Directory structure:
└── evolutionapi-evolution-api/
    ├── README.md
    ├── CHANGELOG.md
    ├── docker-compose.dev.yaml
    ├── docker-compose.yaml
    ├── Dockerfile
    ├── LICENSE
    ├── local_install.sh
    ├── package.json
    ├── runWithProvider.js
    ├── tsconfig.json
    ├── tsup.config.ts
    ├── .dockerignore
    ├── .env.example
    ├── .eslintignore
    ├── .eslintrc.js
    ├── .prettierrc.js
    ├── Docker/
    │   ├── minio/
    │   │   └── docker-compose.yaml
    │   ├── mysql/
    │   │   └── docker-compose.yaml
    │   ├── postgres/
    │   │   └── docker-compose.yaml
    │   ├── rabbitmq/
    │   │   └── docker-compose.yaml
    │   ├── redis/
    │   │   └── docker-compose.yaml
    │   ├── scripts/
    │   │   ├── deploy_database.sh
    │   │   ├── env_functions.sh
    │   │   └── generate_database.sh
    │   └── swarm/
    │       └── evolution_api_v2.yaml
    ├── Extras/
    │   └── chatwoot/
    │       ├── configurar_admin.json
    │       ├── criador_de_empresas.json
    │       └── criador_de_inbox.json
    ├── manager/
    │   └── dist/
    │       ├── index.html
    │       └── assets/
    │           ├── index-CFAZX6IV.js
    │           ├── index-DNOCacL_.css
    │           └── images/
    ├── prisma/
    │   ├── mysql-schema.prisma
    │   ├── postgresql-schema.prisma
    │   ├── mysql-migrations/
    │   │   ├── migration_lock.toml
    │   │   ├── 20240809105427_init/
    │   │   │   └── migration.sql
    │   │   ├── 20240813153900_add_unique_index_for_remoted_jid_and_instance_in_contacts/
    │   │   │   └── migration.sql
    │   │   ├── 20240814173138_add_ignore_jids_chatwoot/
    │   │   │   └── migration.sql
    │   │   ├── 20240814214314_integrations_unification/
    │   │   │   └── migration.sql
    │   │   ├── 20240821203259_add_postgres_migrations/
    │   │   │   └── migration.sql
    │   │   ├── 20240824162012_add_type_on_integration_sessions/
    │   │   │   └── migration.sql
    │   │   ├── 20240825131301_change_to_evolution_bot/
    │   │   │   └── migration.sql
    │   │   ├── 20241001172800_add_message_status/
    │   │   │   └── migration.sql
    │   │   └── 20241108101333_fix_message_status_as_string/
    │   │       └── migration.sql
    │   └── postgresql-migrations/
    │       ├── migration_lock.toml
    │       ├── 20240609181238_init/
    │       │   └── migration.sql
    │       ├── 20240610144159_create_column_profile_name_instance/
    │       │   └── migration.sql
    │       ├── 20240611125754_create_columns_whitelabel_chatwoot/
    │       │   └── migration.sql
    │       ├── 20240611202817_create_columns_debounce_time_typebot/
    │       │   └── migration.sql
    │       ├── 20240712144948_add_business_id_column_to_instances/
    │       │   └── migration.sql
    │       ├── 20240712150256_create_templates_table/
    │       │   └── migration.sql
    │       ├── 20240712155950_adjusts_in_templates_table/
    │       │   └── migration.sql
    │       ├── 20240712162206_remove_templates_table/
    │       │   └── migration.sql
    │       ├── 20240712223655_column_fallback_typebot/
    │       │   └── migration.sql
    │       ├── 20240712230631_column_ignore_jids_typebot/
    │       │   └── migration.sql
    │       ├── 20240713184337_add_media_table/
    │       │   └── migration.sql
    │       ├── 20240718121437_add_openai_tables/
    │       │   └── migration.sql
    │       ├── 20240718123923_adjusts_openai_tables/
    │       │   └── migration.sql
    │       ├── 20240722173259_add_name_column_to_openai_creds/
    │       │   └── migration.sql
    │       ├── 20240722173518_add_name_column_to_openai_creds/
    │       │   └── migration.sql
    │       ├── 20240723152648_adjusts_in_column_openai_creds/
    │       │   └── migration.sql
    │       ├── 20240723200254_add_webhookurl_on_message/
    │       │   └── migration.sql
    │       ├── 20240725184147_create_template_table/
    │       │   └── migration.sql
    │       ├── 20240725202651_add_webhook_url_template_table/
    │       │   └── migration.sql
    │       ├── 20240725221646_modify_token_instance_table/
    │       │   └── migration.sql
    │       ├── 20240729115127_modify_trigger_type_openai_typebot_table/
    │       │   └── migration.sql
    │       ├── 20240729180347_modify_typebot_session_status_openai_typebot_table/
    │       │   └── migration.sql
    │       ├── 20240730152156_create_dify_tables/
    │       │   └── migration.sql
    │       ├── 20240801193907_add_column_speech_to_text_openai_setting_table/
    │       │   └── migration.sql
    │       ├── 20240803163908_add_column_description_on_integrations_table/
    │       │   └── migration.sql
    │       ├── 20240808210239_add_column_function_url_openaibot_table/
    │       │   └── migration.sql
    │       ├── 20240811021156_add_chat_name_column/
    │       │   └── migration.sql
    │       ├── 20240811183328_add_unique_index_for_remoted_jid_and_instance_in_contacts/
    │       │   └── migration.sql
    │       ├── 20240813003116_make_label_unique_for_instance/
    │       │   └── migration.sql
    │       ├── 20240814173033_add_ignore_jids_chatwoot/
    │       │   └── migration.sql
    │       ├── 20240814202359_integrations_unification/
    │       │   └── migration.sql
    │       ├── 20240817110155_add_trigger_type_advanced/
    │       │   └── migration.sql
    │       ├── 20240819154941_add_context_to_integration_session/
    │       │   └── migration.sql
    │       ├── 20240821120816_bot_id_integration_session/
    │       │   └── migration.sql
    │       ├── 20240821171327_add_generic_bot_table/
    │       │   └── migration.sql
    │       ├── 20240821194524_add_flowise_table/
    │       │   └── migration.sql
    │       ├── 20240824161333_add_type_on_integration_sessions/
    │       │   └── migration.sql
    │       ├── 20240825130616_change_to_evolution_bot/
    │       │   └── migration.sql
    │       ├── 20240828140837_add_is_on_whatsapp_table/
    │       │   └── migration.sql
    │       ├── 20240828141556_remove_name_column_from_on_whatsapp_table/
    │       │   └── migration.sql
    │       ├── 20240830193533_changed_table_case/
    │       │   └── migration.sql
    │       ├── 20240906202019_add_headers_on_webhook_config/
    │       │   └── migration.sql
    │       ├── 20241001180457_add_message_status/
    │       │   └── migration.sql
    │       ├── 20241006130306_alter_status_on_message_table/
    │       │   └── migration.sql
    │       ├── 20241007164026_add_unread_messages_on_chat_table/
    │       │   └── migration.sql
    │       ├── 20241011085129_create_pusher_table/
    │       │   └── migration.sql
    │       ├── 20241011100803_split_messages_and_time_per_char_integrations/
    │       │   └── migration.sql
    │       ├── 20241017144950_create_index/
    │       │   └── migration.sql
    │       └── 20250116001415_add_wavoip_token_to_settings_table/
    │           └── migration.sql
    ├── public/
    │   └── images/
    ├── src/
    │   ├── main.ts
    │   ├── @types/
    │   │   └── express.d.ts
    │   ├── api/
    │   │   ├── server.module.ts
    │   │   ├── abstract/
    │   │   │   ├── abstract.cache.ts
    │   │   │   ├── abstract.repository.ts
    │   │   │   └── abstract.router.ts
    │   │   ├── controllers/
    │   │   │   ├── call.controller.ts
    │   │   │   ├── chat.controller.ts
    │   │   │   ├── group.controller.ts
    │   │   │   ├── instance.controller.ts
    │   │   │   ├── label.controller.ts
    │   │   │   ├── proxy.controller.ts
    │   │   │   ├── sendMessage.controller.ts
    │   │   │   ├── settings.controller.ts
    │   │   │   └── template.controller.ts
    │   │   ├── dto/
    │   │   │   ├── call.dto.ts
    │   │   │   ├── chat.dto.ts
    │   │   │   ├── chatbot.dto.ts
    │   │   │   ├── group.dto.ts
    │   │   │   ├── instance.dto.ts
    │   │   │   ├── label.dto.ts
    │   │   │   ├── proxy.dto.ts
    │   │   │   ├── sendMessage.dto.ts
    │   │   │   ├── settings.dto.ts
    │   │   │   └── template.dto.ts
    │   │   ├── guards/
    │   │   │   ├── auth.guard.ts
    │   │   │   ├── instance.guard.ts
    │   │   │   └── telemetry.guard.ts
    │   │   ├── integrations/
    │   │   │   ├── integration.dto.ts
    │   │   │   ├── channel/
    │   │   │   │   ├── channel.controller.ts
    │   │   │   │   ├── channel.router.ts
    │   │   │   │   ├── evolution/
    │   │   │   │   │   ├── evolution.channel.service.ts
    │   │   │   │   │   ├── evolution.controller.ts
    │   │   │   │   │   └── evolution.router.ts
    │   │   │   │   ├── meta/
    │   │   │   │   │   ├── meta.controller.ts
    │   │   │   │   │   ├── meta.router.ts
    │   │   │   │   │   └── whatsapp.business.service.ts
    │   │   │   │   └── whatsapp/
    │   │   │   │       ├── baileys.controller.ts
    │   │   │   │       ├── baileys.router.ts
    │   │   │   │       ├── whatsapp.baileys.service.ts
    │   │   │   │       └── voiceCalls/
    │   │   │   │           ├── transport.type.ts
    │   │   │   │           └── useVoiceCallsBaileys.ts
    │   │   │   ├── chatbot/
    │   │   │   │   ├── chatbot.controller.ts
    │   │   │   │   ├── chatbot.router.ts
    │   │   │   │   ├── chatbot.schema.ts
    │   │   │   │   ├── chatwoot/
    │   │   │   │   │   ├── controllers/
    │   │   │   │   │   │   └── chatwoot.controller.ts
    │   │   │   │   │   ├── dto/
    │   │   │   │   │   │   └── chatwoot.dto.ts
    │   │   │   │   │   ├── libs/
    │   │   │   │   │   │   └── postgres.client.ts
    │   │   │   │   │   ├── routes/
    │   │   │   │   │   │   └── chatwoot.router.ts
    │   │   │   │   │   ├── services/
    │   │   │   │   │   │   └── chatwoot.service.ts
    │   │   │   │   │   ├── utils/
    │   │   │   │   │   │   └── chatwoot-import-helper.ts
    │   │   │   │   │   └── validate/
    │   │   │   │   │       └── chatwoot.schema.ts
    │   │   │   │   ├── dify/
    │   │   │   │   │   ├── controllers/
    │   │   │   │   │   │   └── dify.controller.ts
    │   │   │   │   │   ├── dto/
    │   │   │   │   │   │   └── dify.dto.ts
    │   │   │   │   │   ├── routes/
    │   │   │   │   │   │   └── dify.router.ts
    │   │   │   │   │   ├── services/
    │   │   │   │   │   │   └── dify.service.ts
    │   │   │   │   │   └── validate/
    │   │   │   │   │       └── dify.schema.ts
    │   │   │   │   ├── evolutionBot/
    │   │   │   │   │   ├── controllers/
    │   │   │   │   │   │   └── evolutionBot.controller.ts
    │   │   │   │   │   ├── dto/
    │   │   │   │   │   │   └── evolutionBot.dto.ts
    │   │   │   │   │   ├── routes/
    │   │   │   │   │   │   └── evolutionBot.router.ts
    │   │   │   │   │   ├── services/
    │   │   │   │   │   │   └── evolutionBot.service.ts
    │   │   │   │   │   └── validate/
    │   │   │   │   │       └── evolutionBot.schema.ts
    │   │   │   │   ├── flowise/
    │   │   │   │   │   ├── controllers/
    │   │   │   │   │   │   └── flowise.controller.ts
    │   │   │   │   │   ├── dto/
    │   │   │   │   │   │   └── flowise.dto.ts
    │   │   │   │   │   ├── routes/
    │   │   │   │   │   │   └── flowise.router.ts
    │   │   │   │   │   ├── services/
    │   │   │   │   │   │   └── flowise.service.ts
    │   │   │   │   │   └── validate/
    │   │   │   │   │       └── flowise.schema.ts
    │   │   │   │   ├── openai/
    │   │   │   │   │   ├── controllers/
    │   │   │   │   │   │   └── openai.controller.ts
    │   │   │   │   │   ├── dto/
    │   │   │   │   │   │   └── openai.dto.ts
    │   │   │   │   │   ├── routes/
    │   │   │   │   │   │   └── openai.router.ts
    │   │   │   │   │   ├── services/
    │   │   │   │   │   │   └── openai.service.ts
    │   │   │   │   │   └── validate/
    │   │   │   │   │       └── openai.schema.ts
    │   │   │   │   └── typebot/
    │   │   │   │       ├── controllers/
    │   │   │   │       │   └── typebot.controller.ts
    │   │   │   │       ├── dto/
    │   │   │   │       │   └── typebot.dto.ts
    │   │   │   │       ├── routes/
    │   │   │   │       │   └── typebot.router.ts
    │   │   │   │       ├── services/
    │   │   │   │       │   └── typebot.service.ts
    │   │   │   │       └── validate/
    │   │   │   │           └── typebot.schema.ts
    │   │   │   ├── event/
    │   │   │   │   ├── event.controller.ts
    │   │   │   │   ├── event.dto.ts
    │   │   │   │   ├── event.manager.ts
    │   │   │   │   ├── event.router.ts
    │   │   │   │   ├── event.schema.ts
    │   │   │   │   ├── pusher/
    │   │   │   │   │   ├── pusher.controller.ts
    │   │   │   │   │   ├── pusher.router.ts
    │   │   │   │   │   └── pusher.schema.ts
    │   │   │   │   ├── rabbitmq/
    │   │   │   │   │   ├── rabbitmq.controller.ts
    │   │   │   │   │   └── rabbitmq.router.ts
    │   │   │   │   ├── sqs/
    │   │   │   │   │   ├── sqs.controller.ts
    │   │   │   │   │   └── sqs.router.ts
    │   │   │   │   ├── webhook/
    │   │   │   │   │   ├── webhook.controller.ts
    │   │   │   │   │   ├── webhook.router.ts
    │   │   │   │   │   └── webhook.schema.ts
    │   │   │   │   └── websocket/
    │   │   │   │       ├── websocket.controller.ts
    │   │   │   │       └── websocket.router.ts
    │   │   │   └── storage/
    │   │   │       ├── storage.router.ts
    │   │   │       └── s3/
    │   │   │           ├── controllers/
    │   │   │           │   └── s3.controller.ts
    │   │   │           ├── dto/
    │   │   │           │   └── media.dto.ts
    │   │   │           ├── libs/
    │   │   │           │   └── minio.server.ts
    │   │   │           ├── routes/
    │   │   │           │   └── s3.router.ts
    │   │   │           ├── services/
    │   │   │           │   └── s3.service.ts
    │   │   │           └── validate/
    │   │   │               └── s3.schema.ts
    │   │   ├── provider/
    │   │   │   └── sessions.ts
    │   │   ├── repository/
    │   │   │   └── repository.service.ts
    │   │   ├── routes/
    │   │   │   ├── call.router.ts
    │   │   │   ├── chat.router.ts
    │   │   │   ├── group.router.ts
    │   │   │   ├── index.router.ts
    │   │   │   ├── instance.router.ts
    │   │   │   ├── label.router.ts
    │   │   │   ├── proxy.router.ts
    │   │   │   ├── sendMessage.router.ts
    │   │   │   ├── settings.router.ts
    │   │   │   ├── template.router.ts
    │   │   │   └── view.router.ts
    │   │   ├── services/
    │   │   │   ├── auth.service.ts
    │   │   │   ├── cache.service.ts
    │   │   │   ├── channel.service.ts
    │   │   │   ├── monitor.service.ts
    │   │   │   ├── proxy.service.ts
    │   │   │   ├── settings.service.ts
    │   │   │   └── template.service.ts
    │   │   └── types/
    │   │       └── wa.types.ts
    │   ├── cache/
    │   │   ├── cacheengine.ts
    │   │   ├── localcache.ts
    │   │   ├── rediscache.client.ts
    │   │   └── rediscache.ts
    │   ├── config/
    │   │   ├── env.config.ts
    │   │   ├── error.config.ts
    │   │   ├── event.config.ts
    │   │   ├── logger.config.ts
    │   │   └── path.config.ts
    │   ├── exceptions/
    │   │   ├── 400.exception.ts
    │   │   ├── 401.exception.ts
    │   │   ├── 403.exception.ts
    │   │   ├── 404.exception.ts
    │   │   ├── 500.exception.ts
    │   │   └── index.ts
    │   ├── utils/
    │   │   ├── advancedOperatorsSearch.ts
    │   │   ├── createJid.ts
    │   │   ├── findBotByTrigger.ts
    │   │   ├── getConversationMessage.ts
    │   │   ├── i18n.ts
    │   │   ├── instrumentSentry.ts
    │   │   ├── makeProxyAgent.ts
    │   │   ├── onWhatsappCache.ts
    │   │   ├── renderStatus.ts
    │   │   ├── sendTelemetry.ts
    │   │   ├── server-up.ts
    │   │   ├── use-multi-file-auth-state-prisma.ts
    │   │   ├── use-multi-file-auth-state-provider-files.ts
    │   │   ├── use-multi-file-auth-state-redis-db.ts
    │   │   └── translations/
    │   │       ├── en.json
    │   │       ├── es.json
    │   │       └── pt-BR.json
    │   └── validate/
    │       ├── chat.schema.ts
    │       ├── group.schema.ts
    │       ├── instance.schema.ts
    │       ├── label.schema.ts
    │       ├── message.schema.ts
    │       ├── proxy.schema.ts
    │       ├── settings.schema.ts
    │       ├── template.schema.ts
    │       └── validate.schema.ts
    └── .github/
        ├── ISSUE_TEMPLATE/
        │   ├── -en--bug-report.yaml
        │   ├── -en--feature-request.yaml
        │   ├── -pt--reportar-bug.yaml
        │   └── -pt--solicitar-recurso.yaml
        └── workflows/
            ├── check_code_quality.yml
            ├── publish_docker_image.yml
            ├── publish_docker_image_homolog.yml
            └── publish_docker_image_latest.yml

================================================
FILE: README.md
================================================
<h1 align="center">Evolution Api</h1>

<div align="center">

[![Whatsapp Group](https://img.shields.io/badge/Group-WhatsApp-%2322BC18)](https://evolution-api.com/whatsapp)
[![Discord Community](https://img.shields.io/badge/Discord-Community-blue)](https://evolution-api.com/discord)
[![Postman Collection](https://img.shields.io/badge/Postman-Collection-orange)](https://evolution-api.com/postman) 
[![Documentation](https://img.shields.io/badge/Documentation-Official-green)](https://doc.evolution-api.com)
[![License](https://img.shields.io/badge/license-Apache--2.0-blue)](./LICENSE)
[![Support](https://img.shields.io/badge/Donation-picpay-green)](https://app.picpay.com/user/davidsongomes1998)
[![Sponsors](https://img.shields.io/badge/Github-sponsor-orange)](https://github.com/sponsors/EvolutionAPI)

</div>
  
<div align="center"><img src="./public/images/cover.png"></div>

## Evolution API

Evolution API began as a WhatsApp controller API based on [CodeChat](https://github.com/code-chat-br/whatsapp-api), which in turn implemented the [Baileys](https://github.com/WhiskeySockets/Baileys) library. While originally focused on WhatsApp, Evolution API has grown into a comprehensive platform supporting multiple messaging services and integrations. We continue to acknowledge CodeChat for laying the groundwork.

Today, Evolution API is not limited to WhatsApp. It integrates with various platforms such as Typebot, Chatwoot, Dify, and OpenAI, offering a broad array of functionalities beyond messaging. Evolution API supports both the Baileys-based WhatsApp API and the official WhatsApp Business API, with upcoming support for Instagram and Messenger.

## Looking for a Lightweight Version?
For those who need a more streamlined and performance-optimized version, check out [Evolution API Lite](https://github.com/EvolutionAPI/evolution-api-lite). It's designed specifically for microservices, focusing solely on connectivity without integrations or audio conversion features. Ideal for environments that prioritize simplicity and efficiency.

## Types of Connections

Evolution API supports multiple types of connections to WhatsApp, enabling flexible and powerful integration options:

- *WhatsApp API - Baileys*:
  - A free API based on WhatsApp Web, leveraging the [Baileys library](https://github.com/WhiskeySockets/Baileys).
  - This connection type allows control over WhatsApp Web functionalities through a RESTful API, suitable for multi-service chats, service bots, and other WhatsApp-integrated systems.
  - Note: This method relies on the web version of WhatsApp and may have limitations compared to official APIs.

- *WhatsApp Cloud API*:
  - The official API provided by Meta (formerly Facebook).
  - This connection type offers a robust and reliable solution designed for businesses needing higher volumes of messaging and better integration support.
  - The Cloud API supports features such as end-to-end encryption, advanced analytics, and more comprehensive customer service tools.
  - To use this API, you must comply with Meta's policies and potentially pay for usage based on message volume and other factors.

## Integrations

Evolution API supports various integrations to enhance its functionality. Below is a list of available integrations and their uses:

- [Typebot](https://typebot.io/):
  - Build conversational bots using Typebot, integrated directly into Evolution with trigger management.

- [Chatwoot](https://www.chatwoot.com/):
  - Direct integration with Chatwoot for handling customer service for your business.

- [RabbitMQ](https://www.rabbitmq.com/):
  - Receive events from the Evolution API via RabbitMQ.

- [Amazon SQS](https://aws.amazon.com/pt/sqs/):
  - Receive events from the Evolution API via Amazon SQS.

- [Socket.io](https://socket.io/):
  - Receive events from the Evolution API via WebSocket.

- [Dify](https://dify.ai/):
  - Integrate your Evolution API directly with Dify AI for seamless trigger management and multiple agents.

- [OpenAI](https://openai.com/):
  - Integrate your Evolution API with OpenAI for AI capabilities, including audio-to-text conversion, available across all Evolution integrations.

- Amazon S3 / Minio:
  - Store media files received in [Amazon S3](https://aws.amazon.com/pt/s3/) or [Minio](https://min.io/).

## Telemetry Notice

To continuously improve our services, we have implemented telemetry that collects data on the routes used, the most accessed routes, and the version of the API in use. We would like to assure you that no sensitive or personal data is collected during this process. The telemetry helps us identify improvements and provide a better experience for users.

## Evolution Support Premium

Join our Evolution Pro community for expert support and a weekly call to answer questions. Visit the link below to learn more and subscribe:

[Click here to learn more](https://evolution-api.com/suporte-pro)

# Donate to the project.

#### Github Sponsors

https://github.com/sponsors/EvolutionAPI

# Content Creator Partners

We are proud to collaborate with the following content creators who have contributed valuable insights and tutorials about Evolution API:

- [Promovaweb](https://www.youtube.com/@promovaweb)
- [Comunidade ZDG](https://www.youtube.com/@ComunidadeZDG)
- [Francis MNO](https://www.youtube.com/@FrancisMNO)
- [Pablo Cabral](https://youtube.com/@pablocabral)
- [XPop Digital](https://www.youtube.com/@xpopdigital)
- [Costar Wagner Dev](https://www.youtube.com/@costarwagnerdev)
- [Dante Testa](https://youtube.com/@dantetesta_)
- [Rubén Salazar](https://youtube.com/channel/UCnYGZIE2riiLqaN9sI6riig)
- [OrionDesign](youtube.com/OrionDesign_Oficial)
- [IMPA 365](youtube.com/@impa365_ofc)
- [Comunidade Hub Connect](https://youtube.com/@comunidadehubconnect)
- [dSantana Automações](https://www.youtube.com/channel/UCG7DjUmAxtYyURlOGAIryNQ?view_as=subscriber)
- [Edison Martins](https://www.youtube.com/@edisonmartinsmkt)
- [Astra Online](https://www.youtube.com/@astraonlineweb)
- [MKT Seven Automações](https://www.youtube.com/@sevenautomacoes)
- [Vamos automatizar](https://www.youtube.com/vamosautomatizar)

## License

Evolution API is licensed under the Apache License 2.0, with the following additional conditions:

1. **LOGO and copyright information**: In the process of using Evolution API's frontend components, you may not remove or modify the LOGO or copyright information in the Evolution API console or applications. This restriction is inapplicable to uses of Evolution API that do not involve its frontend components.

2. **Usage Notification Requirement**: If Evolution API is used as part of any project, including closed-source systems (e.g., proprietary software), the user is required to display a clear notification within the system that Evolution API is being utilized. This notification should be visible to system administrators and accessible from the system's documentation or settings page. Failure to comply with this requirement may result in the necessity for a commercial license, as determined by the producer.

Please contact contato@atendai.com to inquire about licensing matters.

Apart from the specific conditions mentioned above, all other rights and restrictions follow the Apache License 2.0. Detailed information about the Apache License 2.0 can be found at [http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0).

© 2024 Evolution API


================================================
FILE: CHANGELOG.md
================================================
# 2.2.3 (2025-02-03 11:52)

### Fixed

* Fix cache in local file system
* Update Baileys Version

# 2.2.2 (2025-01-31 06:55)

### Features

* Added prefix key to queue name in RabbitMQ

### Fixed

* Update Baileys Version

# 2.2.1 (2025-01-22 14:37)

### Features

* Retry system for send webhooks
* Message filtering to support timestamp range queries
* Chats filtering to support timestamp range queries

### Fixed

* Correction of webhook global
* Fixed send audio with whatsapp cloud api
* Refactor on fetch chats
* Refactor on Evolution Channel

# 2.2.0 (2024-10-18 10:00)

### Features

* Fake Call function
* Send List with Baileys
* Send Buttons with Baileys
* Added unreadMessages to chats
* Pusher event integration
* Add support for splitMessages and timePerChar in Integrations
* Audio Converter via API
* Send PTV messages with Baileys

### Fixed

* Fixed prefilledVariables in startTypebot
* Fix duplicate file upload
* Mark as read from me and groups
* Fetch chats query
* Ads messages in chatwoot
* Add indexes to improve performance in Evolution
* Add logical or permanent message deletion based on env config
* Add support for fetching multiple instances by key
* Update instance.controller.ts to filter by instanceName
* Receive template button reply message

# 2.1.2 (2024-10-06 10:09)

### Features

* Sync lost messages on chatwoot
* Set the maximum number of listeners that can be registered for events
* Now is possible send medias with form-data

### Fixed

* Fetch status message
* Adjusts in migrations
* Update pushName in chatwoot
* Validate message before sending chatwoot
* Adds the message status to the return of the "prepareMessage" function
* Fixed openai setting when send a message with chatwoot
* Fix buildkey function in hSet and hDelete
* Fix mexico number
* Update baileys version
* Update in Baileys version that fixes timeout when updating profile picture
* Adjusts for fix timeout error on send status message
* Chatwoot verbose logs
* Adjusts on prisma connections
* License terms updated
* Fixed send message to group without no cache (local or redis)
* Fixed startTypebot with startSession = true
* Fixed issue of always creating a new label when saving chatwoot
* Fixed getBase64FromMediaMessage with convertToMp4
* Fixed bug when send message when don't have mentionsEveryOne on payload
* Does not search message without chatwoot Message Id for reply
* Fixed bot fallback not working on integrations

# 2.1.1 (2024-09-22 10:31)

### Features

* Define a global proxy to be used if the instance does not have one
* Save is on whatsapp on the database
* Add headers to the instance's webhook registration
* Debounce message break is now "\n" instead of white space
* Single view messages are now supported in chatwoot
* Chatbots can now send any type of media

### Fixed

* Validate if cache exists before accessing it
* Missing autoCreate chatwoot in instance create
* Fixed bugs in the frontend, on the event screens
* Fixed use chatwoot with evolution channel
* Fix chatwoot reply quote with Cloud API
* Use exchange name from .env on RabbitMQ
* Fixed chatwoot screen
* It is now possible to send images via the Evolution Channel
* Removed "version" from docker-compose as it is obsolete (https://dev.to/ajeetraina/do-we-still-use-version-in-compose-3inp)
* Fixed typebot ignoreJids being used only from default settings
* Fixed Chatwoot inbox creation on save
* Changed axios timeout for manager requests for 30s
* Update in Baileys version that fixes timeout when updating profile picture
* Fixed issue when sending links in markdown by chatbots like Dify
* Fixed issue with chatbots not respecting settings

# 2.1.0 (2024-08-26 15:33)

### Features

* Improved layout manager
* Translation in manager: English, Portuguese, Spanish and French
* Evolution Bot Integration
* Option to disable chatwoot bot contact with CHATWOOT_BOT_CONTACT
* Added flowise integration
* Added evolution channel on instance create
* Change in license to Apache-2.0
* Mark All in events

### Fixed

* Refactor integrations structure for modular system
* Fixed dify agent integration
* Update Baileys Version
* Fixed proxy config in manager
* Fixed send messages in groups
* S3 saving media sent from me
* Fixed duplication bot when use startTypebot

### Break Changes

* Payloads for events changed (create Instance and set events). Check postman to understand

# 2.0.10 (2024-08-16 16:23)

### Features

* OpenAI send images when markdown
* Dify send images when markdown
* Sentry implemented

### Fixed

* Fix on get profilePicture
* Added S3_REGION on minio settings

# 2.0.9 (2024-08-15 12:31)

### Features

* Added ignoreJids in chatwoot settings
* Dify now identifies images
* Openai now identifies images

### Fixed

* Path mapping & deps fix & bundler changed to tsup
* Improve database scripts to retrieve the provider from env file
* Update contacts database with unique index
* Save chat name
* Correction of media as attachments in chatwoot when using a Meta API Instance and not Baileys
* Update Baileys version 6.7.6
* Deprecate buttons and list in new Baileys version
* Changed labels to be unique on the same instance
* Remove instance from redis even if using database
* Unified integration session system so they don't overlap
* Temporary fix for pictureUrl bug in groups
* Fix on migrations

# 2.0.9-rc (2024-08-09 18:00)

### Features

* Added general session button in typebot, dify and openai in manager
* Added compatibility with mysql through prisma

### Fixed

* Import contacts with image in chatwoot
* Fix conversationId when is dify agent
* Fixed loading of selects in the manager
* Add restart button to sessions screen
* Adjustments to docker files
* StopBotFromMe working with chatwoot

# 2.0.8-rc (2024-08-08 20:23)

### Features

* Variables passed to the input in dify
* OwnerJid passed to typebot
* Function for openai assistant added

### Fixed

* Adjusts in telemetry

# 2.0.7-rc (2024-08-03 14:04)

### Fixed

* BusinessId added on create instances in manager
* Adjusts in restart instance
* Resolve issue with connecting to instance
* Session is now individual per instance and remoteJid
* Credentials verify on manager login
* Added description column on typebot, dify and openai
* Fixed dify agent integration

# 2.0.6-rc (2024-08-02 19:23)

### Features

* Get models for OpenAI

### Fixed

* fetchInstances with clientName parameter
* fixed update typebot, openai and dify

# 2.0.5-rc (2024-08-01 18:01)

### Features

* Speech to Text with Openai

### Fixed

* ClientName on infos
* Instance screen scroll bar in manager

# 2.0.4-rc (2024-07-30 14:13)

### Features

* New manager v2.0
* Dify integration

### Fixed

* Update Baileys Version
* Adjusts for new manager
* Corrected openai trigger validation
* Corrected typebot trigger validation

# 2.0.3-beta (2024-07-29 09:03)

### Features

* Webhook url by submitted template to send status updates
* Sending template approval status webhook

### Fixed

* Equations and adjustments for the new manager
* Adjust TriggerType for OpenAI and Typebot integrations
* Fixed Typebot start call with active session

# 2.0.2-beta (2024-07-18 21:33)

### Feature

* Open AI implemented

### Fixed

* Fixed the function of saving or not saving data in the database
* Resolve not find name
* Removed DEL_TEMP_INSTANCES as it is not being used
* Fixed global exchange name
* Add apiKey and serverUrl to prefilledVariables in typebot service
* Correction in start typebot, if it doesn't exist, create it

# 2.0.1-beta (2024-07-17 17:01)

### Fixed

* Resolved issue with Chatwoot not receiving messages sent by Typebot

# 2.0.0-beta (2024-07-14 17:00)

### Feature

* Added prisma orm, connection to postgres and mysql
* Added chatwoot integration activation
* Added typebot integration activation
* Now you can register several typebots with triggers
* Media sent to typebot now goes as a template string, example: imageMessage|MESSAGE_ID
* Organization configuration and logo in chatwoot bot contact
* Added debounce time for typebot messages
* Tagging in chatwoot contact by instance
* Add support for managing WhatsApp templates via official API
* Fixes and implementation of regex and fallback in typebot
* Ignore jids configuration added to typebot (will be used for both groups and contacts)
* Minio and S3 integration
* When S3 integration enabled, the media sent to typebot now goes as a template string, example: imageMessage|MEDIA_URL

### Fixed

* Removed excessive verbose logs
* Optimization in instance registration
* Now in typebot we wait until the terminal block to accept the user's message, if it arrives before the block is sent, it is ignored
* Correction of audio sending, now we can speed it up and have the audio wireframe
* Reply with media message on Chatwoot
* improvements in sending status and groups
* Correction in response returns from buttons, lists and templates
* EvolutionAPI/Baileys implemented

### Break changes

* jwt authentication removed
* Connection to mongodb removed
* Standardized all request bodies to use camelCase
* Change in webhook information from owner to instanceId
* Changed the .env file configuration, removed the yml version and added .env to the repository root
* Removed the mobile type connection with Baileys
* Simplified payloads and endpoints
* Improved Typebot
  - Now you can register several typebots
  - Start configuration by trigger or for all
  - Session search by typebot or remoteJid
  - KeepOpen configuration (keeps the session even when the bot ends, to run once per contact)
  - StopBotFromMe configuration, allows me to stop the bot if I send a chat message.
* Changed the way the goal webhook is configured

# 1.8.2 (2024-07-03 13:50)

### Fixed

* Corretion in globall rabbitmq queue name
* Improvement in the use of mongodb database for credentials
* Fixed base64 in webhook for documentWithCaption
* Fixed Generate pairing code

# 1.8.1 (2024-06-08 21:32)

### Feature

* New method of saving sessions to a file using worker, made in partnership with [codechat](https://github.com/code-chat-br/whatsapp-api)

### Fixed

* Correction of variables breaking lines in typebot

### Fixed

* Correction of variables breaking lines in typebot

# 1.8.0 (2024-05-27 16:10)

### Feature

* Now in the manager, when logging in with the client's apikey, the listing only shows the instance corresponding to the provided apikey (only with MongoDB)
* New global mode for rabbitmq events
* Build in docker for linux/amd64, linux/arm64 platforms

### Fixed

* Correction in message formatting when generated by AI as markdown in typebot
* Security fix in fetch instance with client key when not connected to mongodb

# 1.7.5 (2024-05-21 08:50)

### Fixed

* Add merge_brazil_contacts function to solve nine digit in brazilian numbers
* Optimize ChatwootService method for updating contact
* Fix swagger auth
* Update aws sdk v3
* Fix getOpenConversationByContact and init queries error
* Method to mark chat as unread
* Added environment variable to manually select the WhatsApp web version for the baileys lib (optional)

# 1.7.4 (2024-04-28 09:46)

### Fixed

* Adjusts in proxy on fetchAgent
* Recovering messages lost with redis cache
* Log when init redis cache service
* Recovering messages lost with redis cache
* Chatwoot inbox name
* Update Baileys version

# 1.7.3 (2024-04-18 12:07)

### Fixed

* Revert fix audio encoding
* Recovering messages lost with redis cache
* Adjusts in redis for save instances
* Adjusts in proxy
* Revert pull request #523
* Added instance name on logs
* Added support for Spanish
* Fix error: invalid operator. The allowed operators for identifier are equal_to,not_equal_to in chatwoot

# 1.7.2 (2024-04-12 17:31)

### Feature

* Mobile connection via sms (test)

### Fixed

* Adjusts in redis
* Send global event in websocket
* Adjusts in proxy
* Fix audio encoding
* Fix conversation read on chatwoot version 3.7
* Fix when receiving/sending messages from whatsapp desktop with ephemeral messages enabled
* Changed returned sessions on typebot status change
* Reorganization of files and folders

# 1.7.1 (2024-04-03 10:19)

### Fixed

* Correction when sending files with captions on Whatsapp Business
* Correction in receiving messages with response on WhatsApp Business
* Correction when sending a reaction to a message on WhatsApp Business
* Correction of receiving reactions on WhatsApp business
* Removed mandatory description of rows from sendList
* Feature to collect message type in typebot

# 1.7.0 (2024-03-11 18:23)

### Feature

* Added update message endpoint
* Add translate capabilities to QRMessages in CW
* Join in Group by Invite Code
* Read messages from whatsapp in chatwoot
* Add support to use use redis in cacheservice
* Add support for labels
* Command to clearcache from chatwoot inbox
* Whatsapp Cloud API Oficial

### Fixed

* Proxy configuration improvements
* Correction in sending lists
* Adjust in webhook_base64
* Correction in typebot text formatting
* Correction in chatwoot text formatting and render list message
* Only use a axios request to get file mimetype if necessary
* When possible use the original file extension
* When receiving a file from whatsapp, use the original filename in chatwoot if possible
* Remove message ids cache in chatwoot to use chatwoot's api itself
* Adjusts the quoted message, now has contextInfo in the message Raw
* Collecting responses with text or numbers in Typebot
* Added sendList endpoint to swagger documentation
* Implemented a function to synchronize message deletions on WhatsApp, automatically reflecting in Chatwoot.
* Improvement on numbers validation
* Fix polls in message sending
* Sending status message
* Message 'connection successfully' spamming
* Invalidate the conversation cache if reopen_conversation is false and the conversation was resolved
* Fix looping when deleting a message in chatwoot
* When receiving a file from whatsapp, use the original filename in chatwoot if possible
* Correction in the sendList Function
* Implement contact upsert in messaging-history.set
* Improve proxy error handling
* Refactor fetching participants for group in WhatsApp service
* Fixed problem where the typebot final keyword did not work
* Typebot's wait now pauses the flow and composing is defined by the delay_message parameter in set typebot
* Composing over 20s now loops until finished

# 1.6.1 (2023-12-22 11:43)

### Fixed

* Fixed Lid Messages
* Fixed sending variables to typebot
* Fixed sending variables from typebot
* Correction sending s3/minio media to chatwoot and typebot
* Fixed the problem with typebot closing at the end of the flow, now this is optional with the TYPEBOT_KEEP_OPEN variable
* Fixed chatwoot Bold, Italic and Underline formatting using Regex
* Added the sign_delimiter property to the Chatwoot configuration, allowing you to set a different delimiter for the signature. Default when not defined \n
* Include instance Id field in the instance configuration
* Fixed the pairing code
* Adjusts in typebot
* Fix the problem when disconnecting the instance and connecting again using mongodb
* Options to disable docs and manager
* When deleting a message in whatsapp, delete the message in chatwoot too


# 1.6.0 (2023-12-12 17:24)

### Feature

* Added AWS SQS Integration
* Added support for new typebot API
* Added endpoint sendPresence
* New Instance Manager
* Added auto_create to the chatwoot set to create the inbox automatically or not
* Added reply, delete and message reaction in chatwoot v3.3.1

### Fixed

* Adjusts in proxy
* Adjusts in start session for Typebot
* Added mimetype field when sending media
* Ajusts in validations to messages.upsert
* Fixed messages not received: error handling when updating contact in chatwoot
* Fix workaround to manage param data as an array in mongodb
* Removed await from webhook when sending a message
* Update typebot.service.ts - element.underline change ~ for *
* Removed api restart on receiving an error
* Fixes in mongodb and chatwoot
* Adjusted return from queries in mongodb
* Added restart instance when update profile picture
* Correction of chatwoot functioning with admin flows
* Fixed problem that did not generate qrcode with the chatwoot_conversation_pending option enabled
* Fixed issue where CSAT opened a new ticket when reopen_conversation was disabled
* Fixed issue sending contact to Chatwoot via iOS

### Integrations

* Chatwoot: v3.3.1
* Typebot: v2.20.0

# 1.5.4 (2023-10-09 20:43)

### Fixed

* Baileys logger typing issue resolved
* Solved problem with duplicate messages in chatwoot

# 1.5.3 (2023-10-06 18:55)

### Feature

* Swagger documentation
* Added base 64 sending option via webhook

### Fixed

* Remove rabbitmq queues when delete instances
* Improvement in restart instance to completely redo the connection
* Update node version: v20
* Correction of messages sent by the api and typebot not appearing in chatwoot
* Adjustment to start typebot, added startSession parameter
* Chatwoot now receives messages sent via api and typebot
* Fixed problem with starting with an input in typebot
* Added check to ensure variables are not empty before executing foreach in start typebot

# 1.5.2 (2023-09-28 17:56)

### Fixed

* Fix chatwootSchema in chatwoot model to store reopen_conversation and conversation_pending options
* Problem resolved when sending files from minio to typebot
* Improvement in the "startTypebot" method to create persistent session when triggered
* New manager for Evo 1.5.2 - Set Typebot update
* Resolved problems when reading/querying instances

# 1.5.1 (2023-09-17 13:50)

### Feature

* Added listening_from_me option in Set Typebot
* Added variables options in Start Typebot
* Added webhooks for typebot events
* Added ChamaAI integration
* Added webhook to send errors
* Added support for messaging with ads on chatwoot

### Fixed

* Fix looping connection messages in chatwoot
* Improved performance of fetch instances

# 1.5.0 (2023-08-18 12:47)

### Feature

* New instance manager in /manager route
* Added extra files for chatwoot and appsmith
* Added Get Last Message and Archive for Chat
* Added env var QRCODE_COLOR
* Added websocket to send events
* Added rabbitmq to send events
* Added Typebot integration
* Added proxy endpoint
* Added send and date_time in webhook data

### Fixed

* Solved problem when disconnecting from the instance the instance was deleted
* Encoded spaces in chatwoot webhook
* Adjustment in the saving of contacts, saving the information of the number and Jid
* Update Dockerfile
* If you pass empty events in create instance and set webhook it is understood as all
* Fixed issue that did not output base64 averages
* Messages sent by the api now arrive in chatwoot

### Integrations

* Chatwoot: v2.18.0 - v3.0.0
* Typebot: v2.16.0
* Manager Evolution API

# 1.4.8 (2023-07-27 10:27)

### Fixed

* Fixed error return bug

# 1.4.7 (2023-07-27 08:47)

### Fixed

* Fixed error return bug
* Fixed problem of getting message when deleting message in chatwoot
* Change in error return pattern

# 1.4.6 (2023-07-26 17:54)

### Fixed

* Fixed bug of creating new inbox by chatwoot
* When conversation reopens is pending when conversation pending is true
* Added docker-compose file with dockerhub image

# 1.4.5 (2023-07-26 09:32)

### Fixed

* Fixed problems in localization template in chatwoot
* Fix mids going duplicated in chatwoot

# 1.4.4 (2023-07-25 15:24)

### Fixed

* Fixed chatwoot line wrap issue
* Solved receive location in chatwoot
* When requesting the pairing code, it also brings the qr code
* Option reopen_conversation in chatwoot endpoint
* Option conversation_pending in chatwoot endpoint

# 1.4.3 (2023-07-25 10:51)

### Fixed

* Adjusts in settings with options always_online, read_messages and read_status
* Fixed send webhook for event CALL
* Create instance with settings

# 1.4.2 (2023-07-24 20:52)

### Fixed

* Fixed validation is set settings
* Adjusts in group validations
* Ajusts in sticker message to chatwoot

# 1.4.1 (2023-07-24 18:28)

### Fixed

* Fixed reconnect with pairing code or qrcode
* Fixed problem in createJid

# 1.4.0 (2023-07-24 17:03)

### Features

* Added connection functionality via pairing code
* Added fetch profile endpoint in chat controller
* Created settings controller
* Added reject call and send text message when receiving a call
* Added setting to ignore group messages
* Added connection with pairing code in chatwoot with command /init:{NUMBER}
* Added encoding option in endpoint sendWhatsAppAudio

### Fixed

* Added link preview option in send text message
* Fixed problem with fileSha256 appearing when sending a sticker in chatwoot
* Fixed issue where it was not possible to open a conversation when sent at first by me on my cell phone in chatwoot
* Now it only updates the contact name if it is the same as the phone number in chatwoot
* Now accepts all chatwoot inbox templates
* Command to create new instances set to /new_instance:{NAME}:{NUMBER}
* Fix in chatwoot set, sign msg can now be disabled

### Integrations

* Chatwoot: v2.18.0 - v3.0.0 (Beta)

# 1.3.2 (2023-07-21 17:19)

### Fixed

* Fix in update settings that needed to restart after updated
* Correction in the use of the api with mongodb
* Adjustments to search endpoint for contacts, chats, messages and Status messages
* Now when deleting the instance, the data referring to it in mongodb is also deleted
* It is now validated if the instance name contains uppercase and special characters
* For compatibility reasons, container mode has been removed
* Added docker-compose files example

### Integrations

* Chatwoot: v2.18.0

# 1.3.1 (2023-07-20 07:48)

### Fixed

* Adjust in create store files

### Integrations

* Chatwoot: v2.18.0

# 1.3.0 (2023-07-19 11:33)

### Features

* Added messages.delete event
* Added restart instance endpoint
* Created automation for creating instances in the chatwoot bot with the command '#inbox_whatsapp:{INSTANCE_NAME}
* Change Baileys version to: 6.4.0
* Send contact in chatwoot
* Send contact array in chatwoot
* Added apiKey in webhook and serverUrl in fetchInstance if EXPOSE_IN_FETCH_INSTANCES: true
* Translation set to default (english) in chatwoot

### Fixed

* Fixed error to send message in large groups
* Docker files adjusted
* Fixed in the postman collection the webhookByEvent parameter by webhook_by_events
* Added validations in create instance
* Removed link preview endpoint, now it's done automatically from sending conventional text
* Added group membership validation before sending message to groups
* Adjusts in docker files
* Adjusts in returns in endpoints chatwoot and webhook
* Fixed ghost mentions in send text message
* Fixed bug that saved contacts from groups came without number in chatwoot
* Fixed problem to receive csat in chatwoot
* Fixed require fileName for document only in base64 for send media message
* Bug fix when sending mobile message change contact name to number in chatwoot
* Bug fix when connecting whatsapp does not send confirmation message
* Fixed quoted message with id or message directly
* Adjust in validation for mexican and argentine numbers
* Adjust in create store files

### Integrations

* Chatwoot: v2.18.0

# 1.2.2 (2023-07-15 09:36)

### Fixed

* Tweak in route "/" with version info
* Adjusts chatwoot version

### Integrations

* Chatwoot: v2.18.0

# 1.2.1 (2023-07-14 19:04)

### Fixed

* Adjusts in docker files
* Save picture url groups in chatwoot

# 1.2.0 (2023-07-14 15:28)

### Features

* Native integration with chatwoot
* Added returning or non-returning participants option in fetchAllGroups
* Added group integration to chatwoot
* Added automation on create instance to chatwoot
* Added verbose logs and format chatwoot service

### Fixed

* Adjusts in docker-compose files
* Adjusts in number validation for AR and MX numbers
* Adjusts in env files, removed save old_messages
* Fix when sending a message to a group I don't belong returns a bad request
* Fits the format on return from the fetchAllGroups endpoint
* Adjust in send document with caption from chatwoot
* Fixed message with undefind in chatwoot
* Changed message in path /
* Test duplicate message media in groups chatwoot
* Optimize send message from group with mentions
* Fixed name of the profile status in fetchInstances
* Fixed error 500 when logout in instance with status = close

# 1.1.5 (2023-07-12 07:17)

### Fixed

* Adjusts in temp folder
* Return with event send_message

# 1.1.4 (2023-07-08 11:01)

### Features

* Route to send status broadcast
* Added verbose logs
* Insert allContacts in payload of endpoint sendStatus

### Fixed

* Adjusted set in webhook to go empty when enabled false
* Adjust in store files
* Fixed the problem when do not save contacts when receive messages
* Changed owner of the jid for instanceName
* Create .env for installation in docker

# 1.1.3 (2023-07-06 11:43)

### Features

* Added configuration for Baileys log level in env
* Added audio to mp4 converter in optionally get Base64 From MediaMessage
* Added organization name in vcard
* Added email in vcard
* Added url in vcard
* Added verbose logs

### Fixed

* Added timestamp internally in urls to avoid caching
* Correction in decryption of poll votes
* Change in the way the api sent and saved the sent messages, now it goes in the messages.upsert event
* Fixed cash when sending stickers via url
* Improved how Redis works for instances
* Fixed problem when disconnecting the instance it removes the instance
* Fixed problem sending ack when preview is done by me
* Adjust in store files

# 1.1.2 (2023-06-28 13:43)

### Fixed

* Fixed baileys version in package.json
* Fixed problem that did not validate if the token passed in create instance already existed
* Fixed problem that does not delete instance files in server mode

# 1.1.1 (2023-06-28 10:27)

### Features

* Added group invitation sending
* Added webhook configuration per event in the individual instance registration

### Fixed

* Adjust dockerfile variables

# 1.1.0 (2023-06-21 11:17)

### Features

* Improved fetch instances endpoint, now it also fetch other instances even if they are not connected
* Added conversion of audios for sending recorded audio, now it is possible to send mp3 audios and not just ogg
* Route to fetch all groups that the connection is part of
* Route to fetch all privacy settings
* Route to update the privacy settings
* Route to update group subject
* Route to update group description
* Route to accept invite code
* Added configuration of events by webhook of instances
* Now the api key can be exposed in fetch instances if the EXPOSE_IN_FETCH_INSTANCES variable is set to true
* Added option to generate qrcode as soon as the instance is created
* The created instance token can now also be optionally defined manually in the creation endpoint
* Route to send Sticker

### Fixed

* Adjust dockerfile variables
* tweaks in docker-compose to pass variables
* Adjust the route getProfileBusiness to fetchProfileBusiness
* fix error after logout and try to get status or to connect again
* fix sending narrated audio on whatsapp android and ios
* fixed the problem of not disabling the global webhook by the variable
* Adjustment in the recording of temporary files and periodic cleaning
* Fix for container mode also work only with files
* Remove recording of old messages on sync

# 1.0.9 (2023-06-10)

### Fixed

* Adjust dockerfile variables

# 1.0.8 (2023-06-09)

### Features

* Added Docker compose file
* Added ChangeLog file

# 1.0.7 (2023-06-08)

### Features

* Ghost mention
* Mention in reply
* Profile photo change
* Profile name change
* Profile status change
* Sending a poll
* Creation of LinkPreview if message contains URL
* New webhooks system, which can be separated into a url per event
* Sending the local webhook url as destination in the webhook data for webhook redirection
* Startup modes, server or container
* Server Mode works normally as everyone is used to
* Container mode made to use one instance per container, when starting the application an instance is already created and the qrcode is generated and it starts sending webhook without having to call it manually, it only allows one instance at a time.



================================================
FILE: docker-compose.dev.yaml
================================================
services:
  api:
    container_name: evolution_api
    image: evolution/api:local
    build: .
    restart: always
    ports:
      - 8080:8080
    volumes:
      - evolution_instances:/evolution/instances
    networks:
      - evolution-net
    env_file:
      - .env
    expose:
      - 8080

volumes:
  evolution_instances:


networks:
  evolution-net:
    name: evolution-net
    driver: bridge



================================================
FILE: docker-compose.yaml
================================================
services:
  api:
    container_name: evolution_api
    image: atendai/evolution-api:homolog
    restart: always
    depends_on:
      - redis
      - postgres
    ports:
      - 8080:8080
    volumes:
      - evolution_instances:/evolution/instances
    networks:
      - evolution-net
    env_file:
      - .env
    expose:
      - 8080

  redis:
    image: redis:latest
    networks:
      - evolution-net
    container_name: redis
    command: >
      redis-server --port 6379 --appendonly yes
    volumes:
      - evolution_redis:/data
    ports:
      - 6379:6379

  postgres:
    container_name: postgres
    image: postgres:15
    networks:
      - evolution-net
    command: ["postgres", "-c", "max_connections=1000", "-c", "listen_addresses=*"]
    restart: always
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=evolution
      - POSTGRES_HOST_AUTH_METHOD=trust
    volumes:
      - postgres_data:/var/lib/postgresql/data
    expose:
      - 5432

volumes:
  evolution_instances:
  evolution_redis:
  postgres_data:


networks:
  evolution-net:
    name: evolution-net
    driver: bridge



================================================
FILE: Dockerfile
================================================
FROM node:20-alpine AS builder

RUN apk update && \
    apk add git ffmpeg wget curl bash openssl

LABEL version="2.2.3" description="Api to control whatsapp features through http requests." 
LABEL maintainer="Davidson Gomes" git="https://github.com/DavidsonGomes"
LABEL contact="contato@atendai.com"

WORKDIR /evolution

COPY ./package.json ./tsconfig.json ./

RUN npm install

COPY ./src ./src
COPY ./public ./public
COPY ./prisma ./prisma
COPY ./manager ./manager
COPY ./.env.example ./.env
COPY ./runWithProvider.js ./
COPY ./tsup.config.ts ./

COPY ./Docker ./Docker

RUN chmod +x ./Docker/scripts/* && dos2unix ./Docker/scripts/*

RUN ./Docker/scripts/generate_database.sh

RUN npm run build

FROM node:20-alpine AS final

RUN apk update && \
    apk add tzdata ffmpeg bash openssl

ENV TZ=America/Sao_Paulo

WORKDIR /evolution

COPY --from=builder /evolution/package.json ./package.json
COPY --from=builder /evolution/package-lock.json ./package-lock.json

COPY --from=builder /evolution/node_modules ./node_modules
COPY --from=builder /evolution/dist ./dist
COPY --from=builder /evolution/prisma ./prisma
COPY --from=builder /evolution/manager ./manager
COPY --from=builder /evolution/public ./public
COPY --from=builder /evolution/.env ./.env
COPY --from=builder /evolution/Docker ./Docker
COPY --from=builder /evolution/runWithProvider.js ./runWithProvider.js
COPY --from=builder /evolution/tsup.config.ts ./tsup.config.ts

ENV DOCKER_ENV=true

EXPOSE 8080

ENTRYPOINT ["/bin/bash", "-c", ". ./Docker/scripts/deploy_database.sh && npm run start:prod" ]


================================================
FILE: LICENSE
================================================
# Evolution API License

Evolution API is licensed under the Apache License 2.0, with the following additional conditions:

1. Evolution API may be utilized commercially, including as a backend service for other applications or as an application development platform for enterprises. Should the conditions below be met, a commercial license must be obtained from the producer:

a. LOGO and copyright information: In the process of using Evolution API's frontend components, you may not remove or modify the LOGO or copyright information in the Evolution API console or applications. This restriction is inapplicable to uses of Evolution API that do not involve its frontend components.

b. Usage Notification Requirement: If Evolution API is used as part of any project, including closed-source systems (e.g., proprietary software), the user is required to display a clear notification within the system that Evolution API is being utilized. This notification should be visible to system administrators and accessible from the system's documentation or settings page. Failure to comply with this requirement may result in the necessity for a commercial license, as determined by the producer.

Please contact contato@atendai.com to inquire about licensing matters.

2. As a contributor, you should agree that:

a. The producer can adjust the open-source agreement to be more strict or relaxed as deemed necessary.
b. Your contributed code may be used for commercial purposes, including but not limited to its cloud business operations.

Apart from the specific conditions mentioned above, all other rights and restrictions follow the Apache License 2.0. Detailed information about the Apache License 2.0 can be found at http://www.apache.org/licenses/LICENSE-2.0.

© 2024 Evolution API




================================================
FILE: local_install.sh
================================================
#!/bin/bash

# Definir cores para melhor legibilidade
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Função para log
log() {
    echo -e "${GREEN}[INFO]${NC} $1"
}
log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}
log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Verificar se está rodando como root
if [ "$(id -u)" = "0" ]; then
    log_error "Este script não deve ser executado como root"
    exit 1
fi

# Verificar sistema operacional
OS="$(uname -s)"
case "${OS}" in
    Linux*)     
        if [ ! -x "$(command -v curl)" ]; then
            log_warning "Curl não está instalado. Tentando instalar..."
            if [ -x "$(command -v apt-get)" ]; then
                sudo apt-get update && sudo apt-get install -y curl
            elif [ -x "$(command -v yum)" ]; then
                sudo yum install -y curl
            else
                log_error "Não foi possível instalar curl automaticamente. Por favor, instale manualmente."
                exit 1
            fi
        fi
        ;;
    Darwin*)    
        if [ ! -x "$(command -v curl)" ]; then
            log_error "Curl não está instalado. Por favor, instale o Xcode Command Line Tools."
            exit 1
        fi
        ;;
    *)          
        log_error "Sistema operacional não suportado: ${OS}"
        exit 1
        ;;
esac

# Verificar conexão com a internet antes de prosseguir
if ! ping -c 1 8.8.8.8 &> /dev/null; then
    log_error "Sem conexão com a internet. Por favor, verifique sua conexão."
    exit 1
fi

# Adicionar verificação de espaço em disco
REQUIRED_SPACE=1000000 # 1GB em KB
AVAILABLE_SPACE=$(df -k . | awk 'NR==2 {print $4}')
if [ $AVAILABLE_SPACE -lt $REQUIRED_SPACE ]; then
    log_error "Espaço em disco insuficiente. Necessário pelo menos 1GB livre."
    exit 1
fi

# Adicionar tratamento de erro para comandos npm
npm_install_with_retry() {
    local max_attempts=3
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        log "Tentativa $attempt de $max_attempts para npm install"
        if npm install; then
            return 0
        fi
        attempt=$((attempt + 1))
        [ $attempt -le $max_attempts ] && log_warning "Falha na instalação. Tentando novamente em 5 segundos..." && sleep 5
    done
    
    log_error "Falha ao executar npm install após $max_attempts tentativas"
    return 1
}

# Adicionar timeout para comandos
execute_with_timeout() {
    timeout 300 $@ || log_error "Comando excedeu o tempo limite de 5 minutos: $@"
}

# Verificar se o NVM já está instalado
if [ -d "$HOME/.nvm" ]; then
    log "NVM já está instalado."
else
    log "Instalando NVM..."
    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
fi

# Carregar o NVM no ambiente atual
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

# Verificar se a versão do Node.js já está instalada
if command -v node >/dev/null 2>&1 && [ "$(node -v)" = "v20.10.0" ]; then
    log "Node.js v20.10.0 já está instalado."
else
    log "Instalando Node.js v20.10.0..."
    nvm install v20.10.0
fi

nvm use v20.10.0

# Verificar as versões instaladas
log "Verificando as versões instaladas:"
log "Node.js: $(node -v)"
log "npm: $(npm -v)"

# Instala dependências do projeto
log "Instalando dependências do projeto..."
rm -rf node_modules
npm install

# Deploy do banco de dados
log "Deploy do banco de dados..."
npm run db:generate
npm run db:deploy

# Iniciar o projeto
log "Iniciando o projeto..."
if [ "$1" = "-dev" ]; then
    npm run dev:server
else
    npm run build
    npm run start:prod
fi

log "Instalação concluída com sucesso!"

# Criar arquivo de log
LOGFILE="./installation_log_$(date +%Y%m%d_%H%M%S).log"
exec 1> >(tee -a "$LOGFILE")
exec 2>&1

# Adicionar trap para limpeza em caso de interrupção
cleanup() {
    log "Limpando recursos temporários..."
    # Adicione comandos de limpeza aqui
}
trap cleanup EXIT



================================================
FILE: package.json
================================================
{
  "name": "evolution-api",
  "version": "2.2.3",
  "description": "Rest api for communication with WhatsApp",
  "main": "./dist/main.js",
  "type": "commonjs",
  "scripts": {
    "build": "tsc --noEmit && tsup",
    "start": "tsnd -r tsconfig-paths/register --files --transpile-only ./src/main.ts",
    "start:prod": "node dist/main",
    "dev:server": "tsnd -r tsconfig-paths/register --files --transpile-only --respawn --ignore-watch node_modules ./src/main.ts",
    "test": "tsnd -r tsconfig-paths/register --files --transpile-only --respawn --ignore-watch node_modules ./test/all.test.ts",
    "lint": "eslint --fix --ext .ts src",
    "lint:check": "eslint --ext .ts src",
    "db:generate": "node runWithProvider.js \"npx prisma generate --schema ./prisma/DATABASE_PROVIDER-schema.prisma\"",
    "db:deploy": "node runWithProvider.js \"rm -rf ./prisma/migrations && cp -r ./prisma/DATABASE_PROVIDER-migrations ./prisma/migrations && npx prisma migrate deploy --schema ./prisma/DATABASE_PROVIDER-schema.prisma\"",
    "db:deploy:win": "node runWithProvider.js \"xcopy /E /I prisma\\DATABASE_PROVIDER-migrations prisma\\migrations && npx prisma migrate deploy --schema prisma\\DATABASE_PROVIDER-schema.prisma\"",
    "db:studio": "node runWithProvider.js \"npx prisma studio --schema ./prisma/DATABASE_PROVIDER-schema.prisma\"",
    "db:migrate:dev": "node runWithProvider.js \"rm -rf ./prisma/migrations && cp -r ./prisma/DATABASE_PROVIDER-migrations ./prisma/migrations && npx prisma migrate dev --schema ./prisma/DATABASE_PROVIDER-schema.prisma && cp -r ./prisma/migrations/* ./prisma/DATABASE_PROVIDER-migrations\"",
    "db:migrate:dev:win": "node runWithProvider.js \"xcopy /E /I prisma\\DATABASE_PROVIDER-migrations prisma\\migrations && npx prisma migrate dev --schema prisma\\DATABASE_PROVIDER-schema.prisma\""
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/EvolutionAPI/evolution-api.git"
  },
  "keywords": [
    "chat",
    "communication",
    "message",
    "send message",
    "whatsapp",
    "js-whatsapp",
    "whatsapp-api",
    "whatsapp-web",
    "whatsapp",
    "whatsapp-chat",
    "whatsapp-group",
    "automation",
    "multi-device",
    "bot"
  ],
  "author": {
    "name": "Davidson Gomes",
    "email": "contato@atendai.com"
  },
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/EvolutionAPI/evolution-api/issues"
  },
  "homepage": "https://github.com/EvolutionAPI/evolution-api#readme",
  "dependencies": {
    "@adiwajshing/keyed-db": "^0.2.4",
    "@aws-sdk/client-sqs": "^3.723.0",
    "@ffmpeg-installer/ffmpeg": "^1.1.0",
    "@figuro/chatwoot-sdk": "^1.1.16",
    "@hapi/boom": "^10.0.1",
    "@paralleldrive/cuid2": "^2.2.2",
    "@prisma/client": "^6.1.0",
    "@sentry/node": "^8.47.0",
    "amqplib": "^0.10.5",
    "axios": "^1.7.9",
    "baileys": "github:EvolutionAPI/Baileys",
    "class-validator": "^0.14.1",
    "compression": "^1.7.5",
    "cors": "^2.8.5",
    "dayjs": "^1.11.13",
    "dotenv": "^16.4.7",
    "eventemitter2": "^6.4.9",
    "express": "^4.21.2",
    "express-async-errors": "^3.1.1",
    "fluent-ffmpeg": "^2.1.3",
    "form-data": "^4.0.1",
    "https-proxy-agent": "^7.0.6",
    "i18next": "^23.7.19",
    "jimp": "^0.16.13",
    "json-schema": "^0.4.0",
    "jsonschema": "^1.4.1",
    "link-preview-js": "^3.0.13",
    "long": "^5.2.3",
    "mediainfo.js": "^0.3.4",
    "mime": "^4.0.0",
    "mime-types": "^2.1.35",
    "minio": "^8.0.3",
    "multer": "^1.4.5-lts.1",
    "node-cache": "^5.1.2",
    "node-cron": "^3.0.3",
    "openai": "^4.77.3",
    "pg": "^8.13.1",
    "pino": "^8.11.0",
    "prisma": "^6.1.0",
    "pusher": "^5.2.0",
    "qrcode": "^1.5.4",
    "qrcode-terminal": "^0.12.0",
    "redis": "^4.7.0",
    "sharp": "^0.32.6",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "tsup": "^8.3.5"
  },
  "devDependencies": {
    "@types/compression": "^1.7.5",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.18",
    "@types/json-schema": "^7.0.15",
    "@types/mime": "^4.0.0",
    "@types/mime-types": "^2.1.4",
    "@types/node": "^22.10.5",
    "@types/node-cron": "^3.0.11",
    "@types/qrcode": "^1.5.5",
    "@types/qrcode-terminal": "^0.12.2",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.45.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-simple-import-sort": "^10.0.0",
    "prettier": "^3.4.2",
    "ts-node-dev": "^2.0.0",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.2"
  }
}



================================================
FILE: runWithProvider.js
================================================
const dotenv = require('dotenv');
const { execSync } = require('child_process');
const { existsSync } = require('fs');

dotenv.config();

const { DATABASE_PROVIDER } = process.env;
const databaseProviderDefault = DATABASE_PROVIDER ?? 'postgresql';

if (!DATABASE_PROVIDER) {
  console.warn(`DATABASE_PROVIDER is not set in the .env file, using default: ${databaseProviderDefault}`);
}

let command = process.argv
  .slice(2)
  .join(' ')
  .replace(/DATABASE_PROVIDER/g, databaseProviderDefault);

if (command.includes('rmdir') && existsSync('prisma\\migrations')) {
  try {
    execSync('rmdir /S /Q prisma\\migrations', { stdio: 'inherit' });
  } catch (error) {
    console.error(`Error removing directory: prisma\\migrations`);
    process.exit(1);
  }
} else if (command.includes('rmdir')) {
  console.warn(`Directory 'prisma\\migrations' does not exist, skipping removal.`);
}

try {
  execSync(command, { stdio: 'inherit' });
} catch (error) {
  console.error(`Error executing command: ${command}`);
  process.exit(1);
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "declaration": true,
    "target": "es2020",
    "module": "CommonJS",
    "rootDir": "./",
    "resolveJsonModule": true,
    "removeComments": true,
    "outDir": "./dist",
    "noEmitOnError": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": false,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "incremental": true,
    "noImplicitAny": false,
    "baseUrl": ".",
    "paths": {
      "@api/*": ["./src/api/*"],
      "@cache/*": ["./src/cache/*"],
      "@config/*": ["./src/config/*"],
      "@exceptions": ["./src/exceptions"],
      "@libs/*": ["./src/libs/*"],
      "@utils/*": ["./src/utils/*"],
      "@validate/*": ["./src/validate/*"]
    },
    "moduleResolution": "Node"
  },
  "exclude": ["node_modules", "./test", "./dist", "./prisma"],
  "include": [
    "src/**/*",
    "src/**/*.json"
  ]
}


================================================
FILE: tsup.config.ts
================================================
import { cpSync } from 'node:fs';

import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src'],
  outDir: 'dist',
  splitting: false,
  sourcemap: true,
  clean: true,
  minify: true,
  format: ['cjs', 'esm'],
  onSuccess: async () => {
    cpSync('src/utils/translations', 'dist/translations', { recursive: true });
  },
  loader: {
    '.json': 'file',
  },
});



================================================
FILE: .dockerignore
================================================
.git
*Dockerfile*
*docker-compose*
node_modules
dist


================================================
FILE: .env.example
================================================
SERVER_TYPE=http
SERVER_PORT=8080
# Server URL - Set your application url
SERVER_URL=http://localhost:8080

SENTRY_DSN=

# Cors - * for all or set separate by commas -  ex.: 'yourdomain1.com, yourdomain2.com'
CORS_ORIGIN=*
CORS_METHODS=GET,POST,PUT,DELETE
CORS_CREDENTIALS=true

# Determine the logs to be displayed
LOG_LEVEL=ERROR,WARN,DEBUG,INFO,LOG,VERBOSE,DARK,WEBHOOKS,WEBSOCKET
LOG_COLOR=true
# Log Baileys - "fatal" | "error" | "warn" | "info" | "debug" | "trace"
LOG_BAILEYS=error

# Set the maximum number of listeners that can be registered for an event
EVENT_EMITTER_MAX_LISTENERS=50

# Determine how long the instance should be deleted from memory in case of no connection.
# Default time: 5 minutes
# If you don't even want an expiration, enter the value false
DEL_INSTANCE=false

# Provider: postgresql | mysql
DATABASE_PROVIDER=postgresql
DATABASE_CONNECTION_URI='postgresql://user:pass@postgres:5432/evolution?schema=public'
# Client name for the database connection
# It is used to separate an API installation from another that uses the same database.
DATABASE_CONNECTION_CLIENT_NAME=evolution_exchange

# Choose the data you want to save in the application's database
DATABASE_SAVE_DATA_INSTANCE=true
DATABASE_SAVE_DATA_NEW_MESSAGE=true
DATABASE_SAVE_MESSAGE_UPDATE=true
DATABASE_SAVE_DATA_CONTACTS=true
DATABASE_SAVE_DATA_CHATS=true
DATABASE_SAVE_DATA_LABELS=true
DATABASE_SAVE_DATA_HISTORIC=true
DATABASE_SAVE_IS_ON_WHATSAPP=true
DATABASE_SAVE_IS_ON_WHATSAPP_DAYS=7
DATABASE_DELETE_MESSAGE=true

# RabbitMQ - Environment variables
RABBITMQ_ENABLED=false
RABBITMQ_URI=amqp://localhost
RABBITMQ_EXCHANGE_NAME=evolution
# Global events - By enabling this variable, events from all instances are sent in the same event queue.
RABBITMQ_GLOBAL_ENABLED=false
# Prefix key to queue name
RABBITMQ_PREFIX_KEY=evolution
# Choose the events you want to send to RabbitMQ
RABBITMQ_EVENTS_APPLICATION_STARTUP=false
RABBITMQ_EVENTS_INSTANCE_CREATE=false
RABBITMQ_EVENTS_INSTANCE_DELETE=false
RABBITMQ_EVENTS_QRCODE_UPDATED=false
RABBITMQ_EVENTS_MESSAGES_SET=false
RABBITMQ_EVENTS_MESSAGES_UPSERT=false
RABBITMQ_EVENTS_MESSAGES_EDITED=false
RABBITMQ_EVENTS_MESSAGES_UPDATE=false
RABBITMQ_EVENTS_MESSAGES_DELETE=false
RABBITMQ_EVENTS_SEND_MESSAGE=false
RABBITMQ_EVENTS_CONTACTS_SET=false
RABBITMQ_EVENTS_CONTACTS_UPSERT=false
RABBITMQ_EVENTS_CONTACTS_UPDATE=false
RABBITMQ_EVENTS_PRESENCE_UPDATE=false
RABBITMQ_EVENTS_CHATS_SET=false
RABBITMQ_EVENTS_CHATS_UPSERT=false
RABBITMQ_EVENTS_CHATS_UPDATE=false
RABBITMQ_EVENTS_CHATS_DELETE=false
RABBITMQ_EVENTS_GROUPS_UPSERT=false
RABBITMQ_EVENTS_GROUP_UPDATE=false
RABBITMQ_EVENTS_GROUP_PARTICIPANTS_UPDATE=false
RABBITMQ_EVENTS_CONNECTION_UPDATE=false
RABBITMQ_EVENTS_REMOVE_INSTANCE=false
RABBITMQ_EVENTS_LOGOUT_INSTANCE=false
RABBITMQ_EVENTS_CALL=false
RABBITMQ_EVENTS_TYPEBOT_START=false
RABBITMQ_EVENTS_TYPEBOT_CHANGE_STATUS=false

# SQS - Environment variables
SQS_ENABLED=false
SQS_ACCESS_KEY_ID=
SQS_SECRET_ACCESS_KEY=
SQS_ACCOUNT_ID=
SQS_REGION=

# Websocket - Environment variables
WEBSOCKET_ENABLED=false
WEBSOCKET_GLOBAL_EVENTS=false

# Pusher - Environment variables
PUSHER_ENABLED=false
PUSHER_GLOBAL_ENABLED=false
PUSHER_GLOBAL_APP_ID=
PUSHER_GLOBAL_KEY=
PUSHER_GLOBAL_SECRET=
PUSHER_GLOBAL_CLUSTER=
PUSHER_GLOBAL_USE_TLS=true
# Choose the events you want to send to Pusher
PUSHER_EVENTS_APPLICATION_STARTUP=true
PUSHER_EVENTS_QRCODE_UPDATED=true
PUSHER_EVENTS_MESSAGES_SET=true
PUSHER_EVENTS_MESSAGES_UPSERT=true
PUSHER_EVENTS_MESSAGES_EDITED=true
PUSHER_EVENTS_MESSAGES_UPDATE=true
PUSHER_EVENTS_MESSAGES_DELETE=true
PUSHER_EVENTS_SEND_MESSAGE=true
PUSHER_EVENTS_CONTACTS_SET=true
PUSHER_EVENTS_CONTACTS_UPSERT=true
PUSHER_EVENTS_CONTACTS_UPDATE=true
PUSHER_EVENTS_PRESENCE_UPDATE=true
PUSHER_EVENTS_CHATS_SET=true
PUSHER_EVENTS_CHATS_UPSERT=true
PUSHER_EVENTS_CHATS_UPDATE=true
PUSHER_EVENTS_CHATS_DELETE=true
PUSHER_EVENTS_GROUPS_UPSERT=true
PUSHER_EVENTS_GROUPS_UPDATE=true
PUSHER_EVENTS_GROUP_PARTICIPANTS_UPDATE=true
PUSHER_EVENTS_CONNECTION_UPDATE=true
PUSHER_EVENTS_LABELS_EDIT=true
PUSHER_EVENTS_LABELS_ASSOCIATION=true
PUSHER_EVENTS_CALL=true
PUSHER_EVENTS_TYPEBOT_START=false
PUSHER_EVENTS_TYPEBOT_CHANGE_STATUS=false

# WhatsApp Business API - Environment variables
# Token used to validate the webhook on the Facebook APP
WA_BUSINESS_TOKEN_WEBHOOK=evolution
WA_BUSINESS_URL=https://graph.facebook.com
WA_BUSINESS_VERSION=v20.0
WA_BUSINESS_LANGUAGE=en_US

# Global Webhook Settings
# Each instance's Webhook URL and events will be requested at the time it is created
WEBHOOK_GLOBAL_ENABLED=false
# Define a global webhook that will listen for enabled events from all instances
WEBHOOK_GLOBAL_URL=''
# With this option activated, you work with a url per webhook event, respecting the global url and the name of each event
WEBHOOK_GLOBAL_WEBHOOK_BY_EVENTS=false
# Set the events you want to hear
WEBHOOK_EVENTS_APPLICATION_STARTUP=false
WEBHOOK_EVENTS_QRCODE_UPDATED=true
WEBHOOK_EVENTS_MESSAGES_SET=true
WEBHOOK_EVENTS_MESSAGES_UPSERT=true
WEBHOOK_EVENTS_MESSAGES_EDITED=true
WEBHOOK_EVENTS_MESSAGES_UPDATE=true
WEBHOOK_EVENTS_MESSAGES_DELETE=true
WEBHOOK_EVENTS_SEND_MESSAGE=true
WEBHOOK_EVENTS_CONTACTS_SET=true
WEBHOOK_EVENTS_CONTACTS_UPSERT=true
WEBHOOK_EVENTS_CONTACTS_UPDATE=true
WEBHOOK_EVENTS_PRESENCE_UPDATE=true
WEBHOOK_EVENTS_CHATS_SET=true
WEBHOOK_EVENTS_CHATS_UPSERT=true
WEBHOOK_EVENTS_CHATS_UPDATE=true
WEBHOOK_EVENTS_CHATS_DELETE=true
WEBHOOK_EVENTS_GROUPS_UPSERT=true
WEBHOOK_EVENTS_GROUPS_UPDATE=true
WEBHOOK_EVENTS_GROUP_PARTICIPANTS_UPDATE=true
WEBHOOK_EVENTS_CONNECTION_UPDATE=true
WEBHOOK_EVENTS_REMOVE_INSTANCE=false
WEBHOOK_EVENTS_LOGOUT_INSTANCE=false
WEBHOOK_EVENTS_LABELS_EDIT=true
WEBHOOK_EVENTS_LABELS_ASSOCIATION=true
WEBHOOK_EVENTS_CALL=true
# This events is used with Typebot
WEBHOOK_EVENTS_TYPEBOT_START=false
WEBHOOK_EVENTS_TYPEBOT_CHANGE_STATUS=false
# This event is used to send errors
WEBHOOK_EVENTS_ERRORS=false
WEBHOOK_EVENTS_ERRORS_WEBHOOK=

# Name that will be displayed on smartphone connection
CONFIG_SESSION_PHONE_CLIENT=Evolution API
# Browser Name = Chrome | Firefox | Edge | Opera | Safari
CONFIG_SESSION_PHONE_NAME=Chrome

# Whatsapp Web version for baileys channel
# https://web.whatsapp.com/check-update?version=0&platform=web
CONFIG_SESSION_PHONE_VERSION=2.3000.1015901307

# Set qrcode display limit
QRCODE_LIMIT=30
# Color of the QRCode on base64
QRCODE_COLOR='#175197'

# Typebot - Environment variables
TYPEBOT_ENABLED=false
# old | latest
TYPEBOT_API_VERSION=latest

# Chatwoot - Environment variables
CHATWOOT_ENABLED=false
# If you leave this option as false, when deleting the message for everyone on WhatsApp, it will not be deleted on Chatwoot.
CHATWOOT_MESSAGE_READ=true
# If you leave this option as true, when sending a message in Chatwoot, the client's last message will be marked as read on WhatsApp.
CHATWOOT_MESSAGE_DELETE=true
# If you leave this option as true, a contact will be created on Chatwoot to provide the QR Code and update messages about the instance.
CHATWOOT_BOT_CONTACT=true
# This db connection is used to import messages from whatsapp to chatwoot database
CHATWOOT_IMPORT_DATABASE_CONNECTION_URI=postgresql://user:passwprd@host:5432/chatwoot?sslmode=disable
CHATWOOT_IMPORT_PLACEHOLDER_MEDIA_MESSAGE=true

# OpenAI - Environment variables
OPENAI_ENABLED=false

# Dify - Environment variables
DIFY_ENABLED=false

# Cache - Environment variables
# Redis Cache enabled
CACHE_REDIS_ENABLED=true
CACHE_REDIS_URI=redis://localhost:6379/6
CACHE_REDIS_TTL=604800
# Prefix serves to differentiate data from one installation to another that are using the same redis
CACHE_REDIS_PREFIX_KEY=evolution
# Enabling this variable will save the connection information in Redis and not in the database.
CACHE_REDIS_SAVE_INSTANCES=false
# Local Cache enabled
CACHE_LOCAL_ENABLED=false

# Amazon S3 - Environment variables
S3_ENABLED=false
S3_ACCESS_KEY=
S3_SECRET_KEY=
S3_BUCKET=evolution
S3_PORT=443
S3_ENDPOINT=s3.domain.com
S3_REGION=eu-west-3
S3_USE_SSL=true

# AMAZON S3 - Environment variables
# S3_ENABLED=true
# S3_BUCKET=bucket_name
# S3_ACCESS_KEY=access_key_id
# S3_SECRET_KEY=secret_access_key
# S3_ENDPOINT=s3.amazonaws.com # region: s3.eu-west-3.amazonaws.com
# S3_REGION=eu-west-3

# MINIO Use SSL - Environment variables
# S3_ENABLED=true
# S3_ACCESS_KEY=access_key_id
# S3_SECRET_KEY=secret_access_key
# S3_BUCKET=bucket_name
# S3_PORT=443
# S3_ENDPOINT=s3.domain.com
# S3_USE_SSL=true
# S3_REGION=eu-south

# Evolution Audio Converter - Environment variables - https://github.com/EvolutionAPI/evolution-audio-converter
# API_AUDIO_CONVERTER=http://localhost:4040/process-audio
# API_AUDIO_CONVERTER_KEY=429683C4C977415CAAFCCE10F7D57E11

# Define a global apikey to access all instances.
# OBS: This key must be inserted in the request header to create an instance.
AUTHENTICATION_API_KEY=429683C4C977415CAAFCCE10F7D57E11
# If you leave this option as true, the instances will be exposed in the fetch instances endpoint.
AUTHENTICATION_EXPOSE_IN_FETCH_INSTANCES=true
LANGUAGE=en

# Define a global proxy to be used if the instance does not have one
# PROXY_HOST=
# PROXY_PORT=80
# PROXY_PROTOCOL=http
# PROXY_USERNAME=
# PROXY_PASSWORD=


================================================
FILE: .eslintignore
================================================
/node-modules
/dist


================================================
FILE: .eslintrc.js
================================================
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
    warnOnUnsupportedTypeScriptVersion: false,
    EXPERIMENTAL_useSourceOfProjectReferenceRedirect: true,
  },
  plugins: ['@typescript-eslint', 'simple-import-sort', 'import'],
  extends: ['eslint:recommended', 'plugin:@typescript-eslint/recommended', 'plugin:prettier/recommended'],
  globals: {
    Atomics: 'readonly',
    SharedArrayBuffer: 'readonly',
  },
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/no-empty-function': 'off',
    '@typescript-eslint/no-non-null-assertion': 'off',
    '@typescript-eslint/no-unused-vars': 'error',
    'import/first': 'error',
    'import/no-duplicates': 'error',
    'simple-import-sort/imports': 'error',
    'simple-import-sort/exports': 'error',
    '@typescript-eslint/ban-types': [
      'error',
      {
        extendDefaults: true,
        types: {
          '{}': false,
          Object: false,
        },
      },
    ],
    'prettier/prettier': ['error', { endOfLine: 'auto' }],
  },
};



================================================
FILE: .prettierrc.js
================================================
module.exports = {
  semi: true,
  trailingComma: 'all',
  singleQuote: true,
  printWidth: 120,
  arrowParens: 'always',
  tabWidth: 2,
  useTabs: false,
  bracketSameLine: false,
  bracketSpacing: true,
  parser: 'typescript'
}


================================================
FILE: Docker/minio/docker-compose.yaml
================================================
version: '3.3'

services:
  minio:
    container_name: minio
    image: quay.io/minio/minio
    networks:
      - evolution-net
    command: server /data --console-address ":9001"
    restart: always
    ports:
      - 5432:5432
    environment:
      - MINIO_ROOT_USER=USER
      - MINIO_ROOT_PASSWORD=PASSWORD
      - MINIO_BROWSER_REDIRECT_URL=http:/localhost:9001
      - MINIO_SERVER_URL=http://localhost:9000
    volumes:
      - minio_data:/data
    expose:
      - 9000
      - 9001

volumes:
  minio_data:


networks:
  evolution-net:
    name: evolution-net
    driver: bridge



================================================
FILE: Docker/mysql/docker-compose.yaml
================================================
version: '3.3'

services:
  mysql:
    container_name: mysql
    image: percona/percona-server:8.0
    networks:
      - evolution-net
    restart: always
    ports:
      - 3306:3306
    environment:
      - MYSQL_ROOT_PASSWORD=root
      - TZ=America/Bahia
    volumes:
      - mysql_data:/var/lib/mysql
    expose:
      - 3306

volumes:
  mysql_data:


networks:
  evolution-net:
    name: evolution-net
    driver: bridge



================================================
FILE: Docker/postgres/docker-compose.yaml
================================================
version: '3.3'

services:
  postgres:
    container_name: postgres
    image: postgres:15
    networks:
      - evolution-net
    command: ["postgres", "-c", "max_connections=1000"]
    restart: always
    ports:
      - 5432:5432
    environment:
      - POSTGRES_PASSWORD=PASSWORD
    volumes:
      - postgres_data:/var/lib/postgresql/data
    expose:
      - 5432

  pgadmin:
    image: dpage/pgadmin4:latest
    networks:
      - evolution-net
    environment:
      - PGADMIN_DEFAULT_EMAIL=EMAIL
      - PGADMIN_DEFAULT_PASSWORD=PASSWORD  
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    ports:
      - 4000:80
    links:
      - postgres

volumes:
  postgres_data:
  pgadmin_data:


networks:
  evolution-net:
    name: evolution-net
    driver: bridge



================================================
FILE: Docker/rabbitmq/docker-compose.yaml
================================================
version: '3.3'

services:
  rabbitmq:
    container_name: rabbitmq
    image: rabbitmq:management
    environment:
      - RABBITMQ_ERLANG_COOKIE=33H2CdkzF5WrnJ4ud6nkUdRTKXvbCHeFjvVL71p
      - RABBITMQ_DEFAULT_VHOST=default
      - RABBITMQ_DEFAULT_USER=USER
      - RABBITMQ_DEFAULT_PASS=PASSWORD
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq/
    ports:
      - 5672:5672
      - 15672:15672

volumes:
  rabbitmq_data:


networks:
  evolution-net:
    name: evolution-net
    driver: bridge



================================================
FILE: Docker/redis/docker-compose.yaml
================================================
version: '3.3'

services:
  redis:
    image: redis:latest
    networks:
      - evolution-net
    container_name: redis
    command: >
      redis-server --port 6379 --appendonly yes
    volumes:
      - evolution_redis:/data
    ports:
      - 6379:6379

volumes:
  evolution_redis:


networks:
  evolution-net:
    name: evolution-net
    driver: bridge



================================================
FILE: Docker/scripts/deploy_database.sh
================================================
#!/bin/bash

source ./Docker/scripts/env_functions.sh

if [ "$DOCKER_ENV" != "true" ]; then
    export_env_vars
fi

if [[ "$DATABASE_PROVIDER" == "postgresql" || "$DATABASE_PROVIDER" == "mysql" ]]; then
    export DATABASE_URL
    echo "Deploying migrations for $DATABASE_PROVIDER"
    echo "Database URL: $DATABASE_URL"
    # rm -rf ./prisma/migrations
    # cp -r ./prisma/$DATABASE_PROVIDER-migrations ./prisma/migrations
    npm run db:deploy
    if [ $? -ne 0 ]; then
        echo "Migration failed"
        exit 1
    else
        echo "Migration succeeded"
    fi
    npm run db:generate
    if [ $? -ne 0 ]; then
        echo "Prisma generate failed"
        exit 1
    else
        echo "Prisma generate succeeded"
    fi
else
    echo "Error: Database provider $DATABASE_PROVIDER invalid."
    exit 1
fi



================================================
FILE: Docker/scripts/env_functions.sh
================================================
export_env_vars() {
    if [ -f .env ]; then
        while IFS='=' read -r key value; do
            if [[ -z "$key" || "$key" =~ ^\s*# || -z "$value" ]]; then
                continue
            fi

            key=$(echo "$key" | tr -d '[:space:]')
            value=$(echo "$value" | tr -d '[:space:]')
            value=$(echo "$value" | tr -d "'" | tr -d "\"")

            export "$key=$value"
        done < .env
    else
        echo ".env file not found"
        exit 1
    fi
}



================================================
FILE: Docker/scripts/generate_database.sh
================================================
#!/bin/bash

source ./Docker/scripts/env_functions.sh

if [ "$DOCKER_ENV" != "true" ]; then
    export_env_vars
fi

if [[ "$DATABASE_PROVIDER" == "postgresql" || "$DATABASE_PROVIDER" == "mysql" ]]; then
    export DATABASE_URL
    echo "Generating database for $DATABASE_PROVIDER"
    echo "Database URL: $DATABASE_URL"
    npm run db:generate
    if [ $? -ne 0 ]; then
        echo "Prisma generate failed"
        exit 1
    else
        echo "Prisma generate succeeded"
    fi
else
    echo "Error: Database provider $DATABASE_PROVIDER invalid."
    exit 1
fi



================================================
FILE: Docker/swarm/evolution_api_v2.yaml
================================================
version: "3.7"

services:
  evolution_v2:
    image: atendai/evolution-api:v2.1.2
    volumes:
      - evolution_instances:/evolution/instances
    networks:
      - network_public
    environment:
      - SERVER_URL=https://evo2.site.com
      - DEL_INSTANCE=false
      - DATABASE_PROVIDER=postgresql
      - DATABASE_CONNECTION_URI=postgresql://postgres:SENHA@postgres:5432/evolution
      - DATABASE_SAVE_DATA_INSTANCE=true
      - DATABASE_SAVE_DATA_NEW_MESSAGE=true
      - DATABASE_SAVE_MESSAGE_UPDATE=true
      - DATABASE_SAVE_DATA_CONTACTS=true
      - DATABASE_SAVE_DATA_CHATS=true
      - DATABASE_SAVE_DATA_LABELS=true
      - DATABASE_SAVE_DATA_HISTORIC=true
      - DATABASE_CONNECTION_CLIENT_NAME=evolution_v2
      - RABBITMQ_ENABLED=false
      - RABBITMQ_URI=amqp://admin:admin@rabbitmq:5672/default
      - RABBITMQ_EXCHANGE_NAME=evolution_v2
      - RABBITMQ_GLOBAL_ENABLED=false
      - RABBITMQ_EVENTS_APPLICATION_STARTUP=false
      - RABBITMQ_EVENTS_INSTANCE_CREATE=false
      - RABBITMQ_EVENTS_INSTANCE_DELETE=false
      - RABBITMQ_EVENTS_QRCODE_UPDATED=false
      - RABBITMQ_EVENTS_MESSAGES_SET=false
      - RABBITMQ_EVENTS_MESSAGES_UPSERT=true
      - RABBITMQ_EVENTS_MESSAGES_EDITED=false
      - RABBITMQ_EVENTS_MESSAGES_UPDATE=false
      - RABBITMQ_EVENTS_MESSAGES_DELETE=false
      - RABBITMQ_EVENTS_SEND_MESSAGE=false
      - RABBITMQ_EVENTS_CONTACTS_SET=false
      - RABBITMQ_EVENTS_CONTACTS_UPSERT=false
      - RABBITMQ_EVENTS_CONTACTS_UPDATE=false
      - RABBITMQ_EVENTS_PRESENCE_UPDATE=false
      - RABBITMQ_EVENTS_CHATS_SET=false
      - RABBITMQ_EVENTS_CHATS_UPSERT=false
      - RABBITMQ_EVENTS_CHATS_UPDATE=false
      - RABBITMQ_EVENTS_CHATS_DELETE=false
      - RABBITMQ_EVENTS_GROUPS_UPSERT=false
      - RABBITMQ_EVENTS_GROUP_UPDATE=false
      - RABBITMQ_EVENTS_GROUP_PARTICIPANTS_UPDATE=false
      - RABBITMQ_EVENTS_CONNECTION_UPDATE=true
      - RABBITMQ_EVENTS_CALL=false
      - RABBITMQ_EVENTS_TYPEBOT_START=false
      - RABBITMQ_EVENTS_TYPEBOT_CHANGE_STATUS=false
      - SQS_ENABLED=false
      - SQS_ACCESS_KEY_ID=
      - SQS_SECRET_ACCESS_KEY=
      - SQS_ACCOUNT_ID=
      - SQS_REGION=
      - WEBSOCKET_ENABLED=false
      - WEBSOCKET_GLOBAL_EVENTS=false
      - WA_BUSINESS_TOKEN_WEBHOOK=evolution
      - WA_BUSINESS_URL=https://graph.facebook.com
      - WA_BUSINESS_VERSION=v20.0
      - WA_BUSINESS_LANGUAGE=pt_BR
      - WEBHOOK_GLOBAL_URL=''
      - WEBHOOK_GLOBAL_ENABLED=false
      - WEBHOOK_GLOBAL_WEBHOOK_BY_EVENTS=false
      - WEBHOOK_EVENTS_APPLICATION_STARTUP=false
      - WEBHOOK_EVENTS_QRCODE_UPDATED=true
      - WEBHOOK_EVENTS_MESSAGES_SET=true
      - WEBHOOK_EVENTS_MESSAGES_UPSERT=true
      - WEBHOOK_EVENTS_MESSAGES_EDITED=true
      - WEBHOOK_EVENTS_MESSAGES_UPDATE=true
      - WEBHOOK_EVENTS_MESSAGES_DELETE=true
      - WEBHOOK_EVENTS_SEND_MESSAGE=true
      - WEBHOOK_EVENTS_CONTACTS_SET=true
      - WEBHOOK_EVENTS_CONTACTS_UPSERT=true
      - WEBHOOK_EVENTS_CONTACTS_UPDATE=true
      - WEBHOOK_EVENTS_PRESENCE_UPDATE=true
      - WEBHOOK_EVENTS_CHATS_SET=true
      - WEBHOOK_EVENTS_CHATS_UPSERT=true
      - WEBHOOK_EVENTS_CHATS_UPDATE=true
      - WEBHOOK_EVENTS_CHATS_DELETE=true
      - WEBHOOK_EVENTS_GROUPS_UPSERT=true
      - WEBHOOK_EVENTS_GROUPS_UPDATE=true
      - WEBHOOK_EVENTS_GROUP_PARTICIPANTS_UPDATE=true
      - WEBHOOK_EVENTS_CONNECTION_UPDATE=true
      - WEBHOOK_EVENTS_LABELS_EDIT=true
      - WEBHOOK_EVENTS_LABELS_ASSOCIATION=true
      - WEBHOOK_EVENTS_CALL=true
      - WEBHOOK_EVENTS_TYPEBOT_START=false
      - WEBHOOK_EVENTS_TYPEBOT_CHANGE_STATUS=false
      - WEBHOOK_EVENTS_ERRORS=false
      - WEBHOOK_EVENTS_ERRORS_WEBHOOK=
      - CONFIG_SESSION_PHONE_CLIENT=Evolution API V2
      - CONFIG_SESSION_PHONE_NAME=Chrome
      - CONFIG_SESSION_PHONE_VERSION=2.3000.1015901307
      - QRCODE_LIMIT=30
      - OPENAI_ENABLED=true
      - DIFY_ENABLED=true
      - TYPEBOT_ENABLED=true
      - TYPEBOT_API_VERSION=latest
      - CHATWOOT_ENABLED=true
      - CHATWOOT_MESSAGE_READ=true
      - CHATWOOT_MESSAGE_DELETE=true
      - CHATWOOT_IMPORT_DATABASE_CONNECTION_URI=postgresql://postgres:PASSWORD@postgres:5432/chatwoot?sslmode=disable
      - CHATWOOT_IMPORT_PLACEHOLDER_MEDIA_MESSAGE=true
      - CACHE_REDIS_ENABLED=true
      - CACHE_REDIS_URI=redis://evo_redis:6379/1
      - CACHE_REDIS_PREFIX_KEY=evolution_v2
      - CACHE_REDIS_SAVE_INSTANCES=false
      - CACHE_LOCAL_ENABLED=false
      - S3_ENABLED=true
      - S3_ACCESS_KEY=
      - S3_SECRET_KEY=
      - S3_BUCKET=evolution
      - S3_PORT=443
      - S3_ENDPOINT=files.site.com
      - S3_USE_SSL=true
      - AUTHENTICATION_API_KEY=429683C4C977415CAAFCCE10F7D57E11
      - AUTHENTICATION_EXPOSE_IN_FETCH_INSTANCES=true
      - LANGUAGE=en
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.hostname == evolution-manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.evolution_v2.rule=Host(`evo2.site.com`)
        - traefik.http.routers.evolution_v2.entrypoints=websecure
        - traefik.http.routers.evolution_v2.tls.certresolver=letsencryptresolver
        - traefik.http.routers.evolution_v2.priority=1
        - traefik.http.routers.evolution_v2.service=evolution_v2
        - traefik.http.services.evolution_v2.loadbalancer.server.port=8080
        - traefik.http.services.evolution_v2.loadbalancer.passHostHeader=true

volumes:
  evolution_instances:
    external: true
    name: evolution_v2_data

networks:
  network_public:
    external: true
    name: network_public



================================================
FILE: Extras/chatwoot/configurar_admin.json
================================================
{
  "name": "[Evolution] Configurar Admin",
  "nodes": [
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "api_access_token",
              "value": "CHATWOOT_ADMIN_USER_TOKEN"
            },
            {
              "name": "chatwoot_url",
              "value": "https://CHATWOOT_URL"
            },
            {
              "name": "n8n_url",
              "value": "https://N8N_URL"
            },
            {
              "name": "organization",
              "value": "ORGANIZATION_NAME"
            },
            {
              "name": "logo",
              "value": "ORGANIZATION_LOGO"
            }
          ]
        },
        "options": {}
      },
      "id": "7a89a538-2cae-4032-8896-09627c07bc68",
      "name": "Info Base",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        620,
        480
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/api/v1/accounts/1/contacts/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json[\"api_access_token\"] }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"inbox_id\": {{ $('Cria Inbox Start').item.json[\"id\"] }},\n    \"name\": \"Bot {{ $('Info Base').item.json[\"organization\"] }}\",\n    \"phone_number\": \"+123456\",\n    \"avatar_url\": \"{{ $('Info Base').item.json[\"logo\"] }}\"\n}",
        "options": {}
      },
      "id": "12a39df3-6b95-4f83-a0bc-50b25adaca7f",
      "name": "Cria Contato Bot",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        1020,
        480
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/api/v1/accounts/1/inboxes/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json[\"api_access_token\"] }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"name\": \"Start {{ $('Info Base').item.json[\"organization\"] }}\",\n    \"channel\": {\n        \"type\": \"api\",\n        \"website_url\": \"\"\n    }\n}",
        "options": {}
      },
      "id": "bed7c54d-e232-4fe4-9584-0515e9679868",
      "name": "Cria Inbox Start",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        820,
        480
      ]
    },
    {
      "parameters": {},
      "id": "36ada769-a757-4193-989b-0cc4ea504b80",
      "name": "When clicking \"Execute Workflow\"",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        420,
        480
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/api/v1/accounts/1/automation_rules/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json[\"api_access_token\"] }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"name\": \"Create Company Chatwoot\",\n    \"description\": \"Create Company Chatwoot\",\n    \"event_name\": \"message_created\",\n    \"active\": true,\n    \"actions\": \n    [\n        {\n            \"action_name\": \"send_webhook_event\",\n            \"action_params\": [\"{{ $('Info Base').item.json[\"n8n_url\"] }}/webhook/criadorchatwoot\"]\n        }\n    ],\n    \"conditions\": \n    [\n        {\n            \"attribute_key\": \"content\",\n            \"filter_operator\": \"contains\",\n            \"query_operator\": \"and\",\n            \"values\": [\"Tema Criador de Empresa:\"]\n        },\n        {\n            \"attribute_key\": \"phone_number\",\n            \"filter_operator\": \"equal_to\",\n            \"values\": [\"+123456\"]\n        }\n    ]\n}",
        "options": {}
      },
      "id": "f5bbb285-71a8-4c58-a4d7-e56002d697f0",
      "name": "Cria Automação Empresas",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        1220,
        480
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/api/v1/accounts/1/automation_rules/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json[\"api_access_token\"] }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"name\": \"Create Inbox {{ $('Info Base').item.json[\"organization\"] }}\",\n    \"description\": \"Create Inbox {{ $('Info Base').item.json[\"organization\"] }}\",\n    \"event_name\": \"message_created\",\n    \"active\": true,\n    \"actions\": \n    [\n        {\n            \"action_name\": \"send_webhook_event\",\n            \"action_params\": [\"{{ $('Info Base').item.json[\"n8n_url\"] }}/webhook/inbox_whatsapp?utoken={{ $('Info Base').item.json[\"api_access_token\"] }}&organization={{ $('Info Base').item.json[\"organization\"] }}\"]\n        }\n    ],\n    \"conditions\": \n    [\n        {\n            \"attribute_key\": \"content\",\n            \"filter_operator\": \"contains\",\n            \"query_operator\": \"and\",\n            \"values\": [\"start:\"]\n        },\n       \n         {\n            \"attribute_key\": \"phone_number\",\n            \"filter_operator\": \"equal_to\",\n            \"query_operator\": \"or\",\n            \"values\": [\"+123456\"]\n        },\n\n\n        {\n            \"attribute_key\": \"content\",\n            \"filter_operator\": \"contains\",\n            \"query_operator\": \"and\",\n            \"values\": [\"new_instance:\"]\n        },\n        {\n            \"attribute_key\": \"phone_number\",\n            \"filter_operator\": \"equal_to\",\n            \"values\": [\"+123456\"]\n        }\n    ]\n}",
        "options": {}
      },
      "id": "a36bebdc-a318-40a2-8532-c7f476f8adb7",
      "name": "Cria Automação Inboxes",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        1420,
        480
      ]
    },
    {
      "parameters": {
        "content": "## Workflow Para Configurar admin\n**Aqui você prepara o Chatwoot Principal com um usuário (Superadmin) que poderá criar empresas e caixas de entrada**\n**Instruções**\n**No node Info Base, configure as variáveis de seu Chatwoot e N8N**\n**Obs: A variável api_access_token é o token do usuário que irá poder criar as empresas**",
        "width": 894.6435495898575
      },
      "id": "db66e867-e9f4-452d-b521-725eeac652c8",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        420,
        280
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Info Base": {
      "main": [
        [
          {
            "node": "Cria Inbox Start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cria Contato Bot": {
      "main": [
        [
          {
            "node": "Cria Automação Empresas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cria Inbox Start": {
      "main": [
        [
          {
            "node": "Cria Contato Bot",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking \"Execute Workflow\"": {
      "main": [
        [
          {
            "node": "Info Base",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cria Automação Empresas": {
      "main": [
        [
          {
            "node": "Cria Automação Inboxes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "78f155dc-7809-4bfc-9282-63f49b07fc4d",
  "id": "BSATyGpGWLR4ZwNm",
  "meta": {
    "instanceId": "4ff16e963c7f5197d7e99e6239192860914312fea0ce2a9a7fd14d74a0a0e906"
  },
  "tags": []
}


================================================
FILE: Extras/chatwoot/criador_de_empresas.json
================================================
{
  "name": "[Evolution] Criador de Empresas",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "criadorchatwoot",
        "options": {}
      },
      "id": "5a47c10a-e43c-4fa5-baad-4b6cc511bfcd",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        1420,
        860
      ],
      "webhookId": "6fe428e3-1752-453c-9358-abf18b793387"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/platform/api/v1/accounts",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json[\"api_access_token\"] }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "name",
              "value": "={{ $json.name_company }}"
            },
            {
              "name": "locale",
              "value": "pt_BR"
            }
          ]
        },
        "options": {}
      },
      "id": "8295c119-3a96-424e-9386-43d75f6816f5",
      "name": "Cria Conta",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        2020,
        860
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/platform/api/v1/users",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json[\"api_access_token\"] }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "name",
              "value": "={{ $('Info Base').item.json.name_admin }}"
            },
            {
              "name": "email",
              "value": "={{ $('Info Base').item.json[\"email\"] }}"
            },
            {
              "name": "password",
              "value": "={{ $('Info Base').item.json[\"password\"] }}"
            }
          ]
        },
        "options": {}
      },
      "id": "4fe5007a-3a6b-490a-a446-e45cc168189f",
      "name": "Cria Usuario",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        2220,
        860
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/platform/api/v1/accounts/{{ $node[\"Cria Conta\"].json[\"id\"] }}/account_users",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json[\"api_access_token\"] }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ $node[\"Cria Usuario\"].json[\"id\"] }}"
            },
            {
              "name": "role",
              "value": "administrator"
            }
          ]
        },
        "options": {}
      },
      "id": "848c55e2-5678-4291-9602-c94d994da95b",
      "name": "Add Usuario a Conta",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        2420,
        860
      ]
    },
    {
      "parameters": {
        "fromEmail": "={{ $('Info Base').item.json[\"from_email\"] }}",
        "toEmail": "={{ $('LimpaDados').item.json.email }}",
        "subject": "=Bem vindo à {{ $('Info Base').item.json[\"organization\"] }}",
        "text": "=Olá seja bem vindo:\n\nAbaixo segue seus dados de acesso:\n\nURL: {{ $('Info Base').item.json[\"chatwoot_url\"] }}\n\nuser: {{ $('LimpaDados').item.json[\"email\"] }}\n\nSenha: {{ $('LimpaDados').item.json[\"password\"] }}",
        "options": {}
      },
      "id": "27f3b24f-1cf2-4d0d-a354-ecba066059f6",
      "name": "Send Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2,
      "position": [
        3220,
        860
      ],
      "credentials": {
        "smtp": {
          "id": "6BxluEUV8zrXKoVG",
          "name": "[Dgcode] SMTP"
        }
      }
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "api_access_token",
              "value": "CHATWOOT_PLATFORM_TOKEN"
            },
            {
              "name": "chatwoot_url",
              "value": "https://CHATWOOT_URL"
            },
            {
              "name": "n8n_url",
              "value": "https://N8N_URL"
            },
            {
              "name": "organization",
              "value": "ORGANIZATION_NAME"
            },
            {
              "name": "logo",
              "value": "ORGANIZATION_LOGO"
            },
            {
              "name": "from_email",
              "value": "FROM_EMAIL"
            },
            {
              "name": "name",
              "value": "={{ $json.name_company }}"
            },
            {
              "name": "email",
              "value": "={{ $json.email }}"
            },
            {
              "name": "password",
              "value": "={{ $json.password }}"
            },
            {
              "name": "name_company",
              "value": "={{ $json.name_company }}"
            }
          ]
        },
        "options": {}
      },
      "id": "38b4069d-e51e-4db7-933f-941b1be6d124",
      "name": "Info Base",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        1820,
        860
      ]
    },
    {
      "parameters": {
        "keepOnlySet": true,
        "values": {
          "string": [
            {
              "name": "name_admin",
              "value": "={{$node[\"Webhook\"].json[\"body\"][\"messages\"][0][\"content\"].match(/Nome Usuario Administrador: ([^\\n]+)/)[1];}}"
            },
            {
              "name": "name_company",
              "value": "={{$node[\"Webhook\"].json[\"body\"][\"messages\"][0][\"content\"].match(/Nome da Empresa: ([^\\n]+)/)[1];}}"
            },
            {
              "name": "email",
              "value": "={{$node[\"Webhook\"].json[\"body\"][\"messages\"][0][\"content\"].match(/Email: ([^\\s]+)/)[1];}}"
            },
            {
              "name": "password",
              "value": "={{$node[\"Webhook\"].json[\"body\"][\"messages\"][0][\"content\"].match(/Senha: ([^\\s]+)/)[1];}}"
            }
          ]
        },
        "options": {}
      },
      "id": "28e29e73-aadc-49ca-bd6d-b57ee0160a21",
      "name": "LimpaDados",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        1620,
        860
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/api/v1/accounts/{{ $('Add Usuario a Conta').item.json.account_id }}/contacts/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Cria Usuario').item.json.access_token }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"inbox_id\": {{ $('Cria Inbox Start').item.json[\"id\"] }},\n    \"name\": \"Bot {{ $('Info Base').item.json[\"organization\"] }}\",\n    \"phone_number\": \"+123456\",\n    \"avatar_url\": \"{{ $('Info Base').item.json[\"logo\"] }}\"\n}",
        "options": {}
      },
      "id": "bb671443-bdb4-4f56-99af-f0baef246a3e",
      "name": "Cria Contato Bot",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        2820,
        860
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/api/v1/accounts/{{ $('Add Usuario a Conta').item.json.account_id }}/automation_rules/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Cria Usuario').item.json.access_token }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"name\": \"Create Inbox {{ $('Info Base').item.json[\"organization\"] }}\",\n    \"description\": \"Create Inbox {{ $('Info Base').item.json[\"organization\"] }}\",\n    \"event_name\": \"message_created\",\n    \"active\": true,\n    \"actions\": \n    [\n        {\n            \"action_name\": \"send_webhook_event\",\n            \"action_params\": [\"{{ $('Info Base').item.json[\"n8n_url\"] }}/webhook/inbox_whatsapp?utoken={{ $('Cria Usuario').item.json.access_token }}&organization={{ $('Info Base').item.json[\"organization\"] }}\"]\n        }\n    ],\n    \"conditions\": \n    [\n        {\n            \"attribute_key\": \"content\",\n            \"filter_operator\": \"contains\",\n            \"query_operator\": \"and\",\n            \"values\": [\"start:\"]\n        },\n        {\n            \"attribute_key\": \"phone_number\",\n            \"filter_operator\": \"equal_to\",\n            \"query_operator\": \"or\",\n            \"values\": [\"+123456\"]\n        },\n        {\n            \"attribute_key\": \"content\",\n            \"filter_operator\": \"contains\",\n            \"query_operator\": \"and\",\n            \"values\": [\"new_instance:\"]\n        },\n        {\n            \"attribute_key\": \"phone_number\",\n            \"filter_operator\": \"equal_to\",\n            \"values\": [\"+123456\"]\n        }\n    ]\n}",
        "options": {}
      },
      "id": "e016a2af-b212-4e00-a3ff-8cd03530aa06",
      "name": "Cria Automação",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        3020,
        860
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Info Base').item.json[\"chatwoot_url\"] }}/api/v1/accounts/{{ $json.account_id }}/inboxes/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Cria Usuario').item.json.access_token }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"name\": \"Start {{ $('Info Base').item.json[\"organization\"] }}\",\n    \"channel\": {\n        \"type\": \"api\",\n        \"website_url\": \"\"\n    }\n}",
        "options": {}
      },
      "id": "d3c42148-8920-4c98-a874-eb7113f2dd22",
      "name": "Cria Inbox Start",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        2620,
        860
      ]
    },
    {
      "parameters": {
        "content": "## Workflow Criador de Empresas\n**Cria Contas (Empresas) e Usuários através de tema**\n**Instruções**\n**No node Info Base, configure as variáveis de seu Chatwoot e N8N**\n**Obs: A variável api_access_token é o token PlatformApp encontrado no acesso ao Super Admin**\n**Tema para criar novas empresa:**\n\nTema Criador de Empresa:\n\nNome Usuario Administrador: Joao Linhares\nNome da Empresa: Oficina Linhates\nEmail: machineteste24@gmail.com\nSenha: Mfcd62!!",
        "height": 304.02684563758396,
        "width": 1129.7777777777778
      },
      "id": "d07516c0-4c8e-43ab-ba86-c8d063b09be5",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1420,
        520
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "LimpaDados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cria Conta": {
      "main": [
        [
          {
            "node": "Cria Usuario",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cria Usuario": {
      "main": [
        [
          {
            "node": "Add Usuario a Conta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Usuario a Conta": {
      "main": [
        [
          {
            "node": "Cria Inbox Start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Info Base": {
      "main": [
        [
          {
            "node": "Cria Conta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LimpaDados": {
      "main": [
        [
          {
            "node": "Info Base",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cria Contato Bot": {
      "main": [
        [
          {
            "node": "Cria Automação",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cria Automação": {
      "main": [
        [
          {
            "node": "Send Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cria Inbox Start": {
      "main": [
        [
          {
            "node": "Cria Contato Bot",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {},
  "versionId": "3ffd6d3f-6966-4de4-af8f-1fda464bc1b8",
  "id": "79R6qQDtfyCwgYjJ",
  "meta": {
    "instanceId": "4ff16e963c7f5197d7e99e6239192860914312fea0ce2a9a7fd14d74a0a0e906"
  },
  "tags": []
}


================================================
FILE: Extras/chatwoot/criador_de_inbox.json
================================================
{
  "name": "criador_de_inbox_evo_v2.0",
  "nodes": [
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.evolution_url }}/instance/create",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "apikey",
              "value": "={{ $json.global_api_key }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "instanceName",
              "value": "={{ $json.instanceName }}"
            },
            {
              "name": "qrcode",
              "value": "={{ $json.qrcode }}"
            },
            {
              "name": "chatwootAccountId",
              "value": "={{ $json.chatwootAccountId }}"
            },
            {
              "name": "chatwootToken",
              "value": "={{ $json.chatwootToken }}"
            },
            {
              "name": "chatwootUrl",
              "value": "={{ $json.chatwootUrl }}"
            },
            {
              "name": "chatwootSignMsg",
              "value": "={{ $json.chatwootSignMsg }}"
            },
            {
              "name": "chatwootReopenConversation",
              "value": "={{ $json.chatwootReopenConversation }}"
            },
            {
              "name": "chatwootConversationPending",
              "value": "={{ $json.chatwootConversationPending }}"
            },
            {
              "name": "rejectCall",
              "value": "={{ $json.rejectCall }}"
            },
            {
              "name": "msgCall",
              "value": "={{ $json.msgCall }}"
            },
            {
              "name": "groupsIgnore",
              "value": "={{ $json.groupsIgnore }}"
            },
            {
              "name": "alwaysOnline",
              "value": "={{ $json.alwaysOnline }}"
            },
            {
              "name": "readMessages",
              "value": "={{ $json.readMessages }}"
            },
            {
              "name": "readStatus",
              "value": "={{ $json.readStatus }}"
            },
            {
              "name": "chatwootImportContacts",
              "value": "={{ $json.chatwootImportContacts }}"
            },
            {
              "name": "chatwootImportMessages",
              "value": "={{ $json.chatwootImportMessages }}"
            },
            {
              "name": "chatwootDaysLimitImportMessages",
              "value": "={{ $json.chatwootDaysLimitImportMessages }}"
            },
            {
              "name": "syncFullHistory",
              "value": "={{ $json.syncFullHistory }}"
            },
            {
              "name": "chatwootMergeBrazilContacts",
              "value": "={{ $json.chatwootMergeBrazilContacts }}"
            },
            {
              "name": "integration",
              "value": "={{ $json.integration }}"
            },
            {
              "name": "chatwootNameInbox",
              "value": "={{ $json.chatwootNameInbox }}"
            },
            {
              "name": "token",
              "value": "={{ $json.token }}"
            }
          ]
        },
        "options": {}
      },
      "id": "7da41431-cc8e-4eb4-9894-7bf413819fe3",
      "name": "Cria Instancia",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        900,
        680
      ]
    },
    {
      "parameters": {
        "url": "={{ $('Info Base').item.json[\"chatwootUrl\"] }}/api/v1/accounts/{{ $('Info Base').item.json[\"chatwootAccountId\"] }}/inboxes/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json.chatwootToken }}"
            }
          ]
        },
        "options": {}
      },
      "id": "d51fbbfe-4579-4fba-949f-c29e0b806feb",
      "name": "Lista Inboxes",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        1120,
        680
      ]
    },
    {
      "parameters": {
        "content": "## Workflow Para Criar Inbox - Evolution 2.0 ou superior\n**Aqui você configura a comunicação entre o chatwoot e a Evolution API para criar novas instâncias a partir do chatwoot**\n**Instruções**\n**No node Info Base, configure as variáveis de seu Chatwoot e Evolution API**",
        "width": 1129.7777777777778
      },
      "id": "7c66af51-b01e-4b76-8a8c-0193e87ec9d5",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        460,
        460
      ]
    },
    {
      "parameters": {
        "keepOnlySet": true,
        "values": {
          "string": [
            {
              "name": "chatwootUrl",
              "value": "https://chatwootUrl - preencha"
            },
            {
              "name": "evolution_url",
              "value": "https://evolution_url - preencha"
            },
            {
              "name": "global_api_key",
              "value": "global_api_key - preencha"
            },
            {
              "name": "organization",
              "value": "={{ $json.query.organization }}"
            },
            {
              "name": "instanceName",
              "value": "={{ $json.body.messages[0].content.split(':')[1] }}-cwId-{{ $json.body.messages[0].account_id }}"
            },
            {
              "name": "chatwootToken",
              "value": "={{ $json.query.utoken }}"
            },
            {
              "name": "msgCall",
              "value": "Não aceitamos chamadas, por favor deixe uma mensagem!"
            },
            {
              "name": "integration",
              "value": "WHATSAPP-BAILEYS"
            },
            {
              "name": "chatwootNameInbox",
              "value": "={{ $json.body.messages[0].content.split(':')[1] }}"
            },
            {
              "name": "chatwootAccountId",
              "value": "={{ $json.body.messages[0].account_id.toString() }}"
            },
            {
              "name": "token",
              "value": "=AfRw{{ Date.now() }}BeH4"
            }
          ],
          "boolean": [
            {
              "name": "qrcode",
              "value": true
            },
            {
              "name": "chatwootSignMsg",
              "value": true
            },
            {
              "name": "chatwootReopenConversation",
              "value": true
            },
            {
              "name": "chatwootConversationPending"
            },
            {
              "name": "rejectCall"
            },
            {
              "name": "groupsIgnore"
            },
            {
              "name": "alwaysOnline",
              "value": true
            },
            {
              "name": "readMessages",
              "value": true
            },
            {
              "name": "readStatus"
            },
            {
              "name": "chatwootImportMessages",
              "value": true
            },
            {
              "name": "chatwootImportContacts",
              "value": true
            },
            {
              "name": "syncFullHistory"
            },
            {
              "name": "chatwootMergeBrazilContacts",
              "value": true
            }
          ],
          "number": [
            {
              "name": "chatwootDaysLimitImportMessages",
              "value": 60
            }
          ]
        },
        "options": {
          "dotNotation": false
        }
      },
      "id": "eaffbc44-3701-4f8d-b923-92061cfb995f",
      "name": "Info Base",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        680,
        680
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.name }}",
              "value2": "=Start {{ $('Info Base').item.json[\"organization\"] }}"
            }
          ]
        }
      },
      "id": "82eb24c8-2269-4622-b012-d6f6ad35c149",
      "name": "é Start Inbox?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1800,
        600
      ]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "b9de1318-ab0b-4529-b30a-2daea64dbcfe",
      "name": "Split In Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 2,
      "position": [
        1560,
        680
      ]
    },
    {
      "parameters": {
        "method": "DELETE",
        "url": "={{ $('Info Base').item.json[\"chatwootUrl\"] }}/api/v1/accounts/{{ $('Info Base').item.json[\"chatwootAccountId\"] }}/inboxes/{{ $json.id }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json.chatwootToken }}"
            }
          ]
        },
        "options": {}
      },
      "id": "db2ad958-7642-41eb-8e9a-e8b1668230d1",
      "name": "Deleta Inbox Start",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        2040,
        480
      ]
    },
    {
      "parameters": {},
      "id": "6d68d3a7-d613-471f-8492-9ec473481521",
      "name": "No Operation, do nothing",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1800,
        780
      ]
    },
    {
      "parameters": {
        "fieldToSplitOut": "payload",
        "options": {}
      },
      "id": "be833e77-b2ae-44c6-b4fc-ad24ffc8ad9a",
      "name": "Ajusta lista",
      "type": "n8n-nodes-base.itemLists",
      "typeVersion": 2.2,
      "position": [
        1340,
        680
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "inbox_whatsapp",
        "options": {}
      },
      "id": "faae80e0-9070-4a0c-83bc-d47643a64653",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        460,
        680
      ],
      "webhookId": "85cb0c27-4223-4339-b7b4-35a16c0a04b8"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.name }}",
              "value2": "={{ $('Webhook').item.json[\"body\"][\"messages\"][0][\"content\"].split(':')[1] }}"
            }
          ]
        }
      },
      "id": "4ea7b74f-bdc5-4619-8e99-1f5d33c7e28e",
      "name": "é_pre-existente?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1980,
        700
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "={{ $('Info Base').item.json[\"chatwootUrl\"] }}/api/v1/accounts/{{ $('Info Base').item.json[\"chatwootAccountId\"] }}/inboxes/{{ $json.id }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_access_token",
              "value": "={{ $('Info Base').item.json.chatwootToken }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n\"channel\": {\n\"webhook_url\": \"{{ $('Info Base').item.json[\"evolution_url\"] }}/chatwoot/webhook/{{ encodeURIComponent($('Info Base').item.json[\"instanceName\"]) }}\"\n}\n}",
        "options": {}
      },
      "id": "74d6db21-d49e-48d6-b1a8-ff8bddca67d1",
      "name": "Update_webhook_url",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        2200,
        700
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Cria Instancia": {
      "main": [
        [
          {
            "node": "Lista Inboxes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lista Inboxes": {
      "main": [
        [
          {
            "node": "Ajusta lista",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Info Base": {
      "main": [
        [
          {
            "node": "Cria Instancia",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "é Start Inbox?": {
      "main": [
        [
          {
            "node": "Deleta Inbox Start",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "é_pre-existente?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split In Batches": {
      "main": [
        [
          {
            "node": "é Start Inbox?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Operation, do nothing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deleta Inbox Start": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ajusta lista": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Info Base",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "é_pre-existente?": {
      "main": [
        [
          {
            "node": "Update_webhook_url",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update_webhook_url": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "68f9fa60-e295-4b74-8cb3-c4723d6cb2b2",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "8ed3edb9203bfe03a4b94f63390235285fbb1c230430fdae73a456b9fae762d5"
  },
  "id": "f6dLbF7I7nrjcDc4",
  "tags": []
}



================================================
FILE: manager/dist/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/assets/images/evolution-logo.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Evolution Manager</title>
    <script type="module" crossorigin src="/assets/index-CFAZX6IV.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-DNOCacL_.css">
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>



================================================
FILE: manager/dist/assets/index-CFAZX6IV.js
================================================
var Ww=e=>{throw TypeError(e)};var qI=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var sm=(e,t,n)=>t.has(e)||Ww("Cannot "+n);var R=(e,t,n)=>(sm(e,t,"read from private field"),n?n.call(e):t.get(e)),Ie=(e,t,n)=>t.has(e)?Ww("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),xe=(e,t,n,r)=>(sm(e,t,"write to private field"),r?r.call(e,n):t.set(e,n),n),Je=(e,t,n)=>(sm(e,t,"access private method"),n);var uf=(e,t,n,r)=>({set _(s){xe(e,t,s,n)},get _(){return R(e,t,r)}});var kse=qI((ao,io)=>{function jE(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in e)){const o=Object.getOwnPropertyDescriptor(r,s);o&&Object.defineProperty(e,s,o.get?o:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function n(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=n(s);fetch(s.href,o)}})();function jb(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var RE={exports:{}},Oh={},PE={exports:{}},ot={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Dd=Symbol.for("react.element"),WI=Symbol.for("react.portal"),GI=Symbol.for("react.fragment"),JI=Symbol.for("react.strict_mode"),QI=Symbol.for("react.profiler"),ZI=Symbol.for("react.provider"),YI=Symbol.for("react.context"),XI=Symbol.for("react.forward_ref"),eD=Symbol.for("react.suspense"),tD=Symbol.for("react.memo"),nD=Symbol.for("react.lazy"),Gw=Symbol.iterator;function rD(e){return e===null||typeof e!="object"?null:(e=Gw&&e[Gw]||e["@@iterator"],typeof e=="function"?e:null)}var ME={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},OE=Object.assign,NE={};function iu(e,t,n){this.props=e,this.context=t,this.refs=NE,this.updater=n||ME}iu.prototype.isReactComponent={};iu.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};iu.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function IE(){}IE.prototype=iu.prototype;function Rb(e,t,n){this.props=e,this.context=t,this.refs=NE,this.updater=n||ME}var Pb=Rb.prototype=new IE;Pb.constructor=Rb;OE(Pb,iu.prototype);Pb.isPureReactComponent=!0;var Jw=Array.isArray,DE=Object.prototype.hasOwnProperty,Mb={current:null},AE={key:!0,ref:!0,__self:!0,__source:!0};function FE(e,t,n){var r,s={},o=null,a=null;if(t!=null)for(r in t.ref!==void 0&&(a=t.ref),t.key!==void 0&&(o=""+t.key),t)DE.call(t,r)&&!AE.hasOwnProperty(r)&&(s[r]=t[r]);var l=arguments.length-2;if(l===1)s.children=n;else if(1<l){for(var c=Array(l),i=0;i<l;i++)c[i]=arguments[i+2];s.children=c}if(e&&e.defaultProps)for(r in l=e.defaultProps,l)s[r]===void 0&&(s[r]=l[r]);return{$$typeof:Dd,type:e,key:o,ref:a,props:s,_owner:Mb.current}}function sD(e,t){return{$$typeof:Dd,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function Ob(e){return typeof e=="object"&&e!==null&&e.$$typeof===Dd}function oD(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var Qw=/\/+/g;function om(e,t){return typeof e=="object"&&e!==null&&e.key!=null?oD(""+e.key):t.toString(36)}function Zf(e,t,n,r,s){var o=typeof e;(o==="undefined"||o==="boolean")&&(e=null);var a=!1;if(e===null)a=!0;else switch(o){case"string":case"number":a=!0;break;case"object":switch(e.$$typeof){case Dd:case WI:a=!0}}if(a)return a=e,s=s(a),e=r===""?"."+om(a,0):r,Jw(s)?(n="",e!=null&&(n=e.replace(Qw,"$&/")+"/"),Zf(s,t,n,"",function(i){return i})):s!=null&&(Ob(s)&&(s=sD(s,n+(!s.key||a&&a.key===s.key?"":(""+s.key).replace(Qw,"$&/")+"/")+e)),t.push(s)),1;if(a=0,r=r===""?".":r+":",Jw(e))for(var l=0;l<e.length;l++){o=e[l];var c=r+om(o,l);a+=Zf(o,t,n,c,s)}else if(c=rD(e),typeof c=="function")for(e=c.call(e),l=0;!(o=e.next()).done;)o=o.value,c=r+om(o,l++),a+=Zf(o,t,n,c,s);else if(o==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return a}function cf(e,t,n){if(e==null)return e;var r=[],s=0;return Zf(e,r,"","",function(o){return t.call(n,o,s++)}),r}function aD(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var qn={current:null},Yf={transition:null},iD={ReactCurrentDispatcher:qn,ReactCurrentBatchConfig:Yf,ReactCurrentOwner:Mb};function LE(){throw Error("act(...) is not supported in production builds of React.")}ot.Children={map:cf,forEach:function(e,t,n){cf(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return cf(e,function(){t++}),t},toArray:function(e){return cf(e,function(t){return t})||[]},only:function(e){if(!Ob(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};ot.Component=iu;ot.Fragment=GI;ot.Profiler=QI;ot.PureComponent=Rb;ot.StrictMode=JI;ot.Suspense=eD;ot.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=iD;ot.act=LE;ot.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=OE({},e.props),s=e.key,o=e.ref,a=e._owner;if(t!=null){if(t.ref!==void 0&&(o=t.ref,a=Mb.current),t.key!==void 0&&(s=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(c in t)DE.call(t,c)&&!AE.hasOwnProperty(c)&&(r[c]=t[c]===void 0&&l!==void 0?l[c]:t[c])}var c=arguments.length-2;if(c===1)r.children=n;else if(1<c){l=Array(c);for(var i=0;i<c;i++)l[i]=arguments[i+2];r.children=l}return{$$typeof:Dd,type:e.type,key:s,ref:o,props:r,_owner:a}};ot.createContext=function(e){return e={$$typeof:YI,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:ZI,_context:e},e.Consumer=e};ot.createElement=FE;ot.createFactory=function(e){var t=FE.bind(null,e);return t.type=e,t};ot.createRef=function(){return{current:null}};ot.forwardRef=function(e){return{$$typeof:XI,render:e}};ot.isValidElement=Ob;ot.lazy=function(e){return{$$typeof:nD,_payload:{_status:-1,_result:e},_init:aD}};ot.memo=function(e,t){return{$$typeof:tD,type:e,compare:t===void 0?null:t}};ot.startTransition=function(e){var t=Yf.transition;Yf.transition={};try{e()}finally{Yf.transition=t}};ot.unstable_act=LE;ot.useCallback=function(e,t){return qn.current.useCallback(e,t)};ot.useContext=function(e){return qn.current.useContext(e)};ot.useDebugValue=function(){};ot.useDeferredValue=function(e){return qn.current.useDeferredValue(e)};ot.useEffect=function(e,t){return qn.current.useEffect(e,t)};ot.useId=function(){return qn.current.useId()};ot.useImperativeHandle=function(e,t,n){return qn.current.useImperativeHandle(e,t,n)};ot.useInsertionEffect=function(e,t){return qn.current.useInsertionEffect(e,t)};ot.useLayoutEffect=function(e,t){return qn.current.useLayoutEffect(e,t)};ot.useMemo=function(e,t){return qn.current.useMemo(e,t)};ot.useReducer=function(e,t,n){return qn.current.useReducer(e,t,n)};ot.useRef=function(e){return qn.current.useRef(e)};ot.useState=function(e){return qn.current.useState(e)};ot.useSyncExternalStore=function(e,t,n){return qn.current.useSyncExternalStore(e,t,n)};ot.useTransition=function(){return qn.current.useTransition()};ot.version="18.3.1";PE.exports=ot;var v=PE.exports;const Te=jb(v),Nh=jE({__proto__:null,default:Te},[v]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var lD=v,uD=Symbol.for("react.element"),cD=Symbol.for("react.fragment"),dD=Object.prototype.hasOwnProperty,fD=lD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,pD={key:!0,ref:!0,__self:!0,__source:!0};function $E(e,t,n){var r,s={},o=null,a=null;n!==void 0&&(o=""+n),t.key!==void 0&&(o=""+t.key),t.ref!==void 0&&(a=t.ref);for(r in t)dD.call(t,r)&&!pD.hasOwnProperty(r)&&(s[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps,t)s[r]===void 0&&(s[r]=t[r]);return{$$typeof:uD,type:e,key:o,ref:a,props:s,_owner:fD.current}}Oh.Fragment=cD;Oh.jsx=$E;Oh.jsxs=$E;RE.exports=Oh;var u=RE.exports,lu=class{constructor(){this.listeners=new Set,this.subscribe=this.subscribe.bind(this)}subscribe(e){return this.listeners.add(e),this.onSubscribe(),()=>{this.listeners.delete(e),this.onUnsubscribe()}}hasListeners(){return this.listeners.size>0}onSubscribe(){}onUnsubscribe(){}},Kl=typeof window>"u"||"Deno"in globalThis;function Or(){}function hD(e,t){return typeof e=="function"?e(t):e}function Tv(e){return typeof e=="number"&&e>=0&&e!==1/0}function BE(e,t){return Math.max(e+(t||0)-Date.now(),0)}function bl(e,t){return typeof e=="function"?e(t):e}function Qr(e,t){return typeof e=="function"?e(t):e}function Zw(e,t){const{type:n="all",exact:r,fetchStatus:s,predicate:o,queryKey:a,stale:l}=e;if(a){if(r){if(t.queryHash!==Nb(a,t.options))return!1}else if(!Dc(t.queryKey,a))return!1}if(n!=="all"){const c=t.isActive();if(n==="active"&&!c||n==="inactive"&&c)return!1}return!(typeof l=="boolean"&&t.isStale()!==l||s&&s!==t.state.fetchStatus||o&&!o(t))}function Yw(e,t){const{exact:n,status:r,predicate:s,mutationKey:o}=e;if(o){if(!t.options.mutationKey)return!1;if(n){if(gi(t.options.mutationKey)!==gi(o))return!1}else if(!Dc(t.options.mutationKey,o))return!1}return!(r&&t.state.status!==r||s&&!s(t))}function Nb(e,t){return((t==null?void 0:t.queryKeyHashFn)||gi)(e)}function gi(e){return JSON.stringify(e,(t,n)=>kv(n)?Object.keys(n).sort().reduce((r,s)=>(r[s]=n[s],r),{}):n)}function Dc(e,t){return e===t?!0:typeof e!=typeof t?!1:e&&t&&typeof e=="object"&&typeof t=="object"?!Object.keys(t).some(n=>!Dc(e[n],t[n])):!1}function zE(e,t){if(e===t)return e;const n=Xw(e)&&Xw(t);if(n||kv(e)&&kv(t)){const r=n?e:Object.keys(e),s=r.length,o=n?t:Object.keys(t),a=o.length,l=n?[]:{};let c=0;for(let i=0;i<a;i++){const d=n?i:o[i];(!n&&r.includes(d)||n)&&e[d]===void 0&&t[d]===void 0?(l[d]=void 0,c++):(l[d]=zE(e[d],t[d]),l[d]===e[d]&&e[d]!==void 0&&c++)}return s===a&&c===s?e:l}return t}function Tp(e,t){if(!t||Object.keys(e).length!==Object.keys(t).length)return!1;for(const n in e)if(e[n]!==t[n])return!1;return!0}function Xw(e){return Array.isArray(e)&&e.length===Object.keys(e).length}function kv(e){if(!eS(e))return!1;const t=e.constructor;if(t===void 0)return!0;const n=t.prototype;return!(!eS(n)||!n.hasOwnProperty("isPrototypeOf")||Object.getPrototypeOf(e)!==Object.prototype)}function eS(e){return Object.prototype.toString.call(e)==="[object Object]"}function gD(e){return new Promise(t=>{setTimeout(t,e)})}function _v(e,t,n){return typeof n.structuralSharing=="function"?n.structuralSharing(e,t):n.structuralSharing!==!1?zE(e,t):t}function mD(e,t,n=0){const r=[...e,t];return n&&r.length>n?r.slice(1):r}function vD(e,t,n=0){const r=[t,...e];return n&&r.length>n?r.slice(0,-1):r}var UE=Symbol();function VE(e,t){return!e.queryFn&&(t!=null&&t.initialPromise)?()=>t.initialPromise:!e.queryFn||e.queryFn===UE?()=>Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)):e.queryFn}var ei,Ko,Ol,yE,yD=(yE=class extends lu{constructor(){super();Ie(this,ei);Ie(this,Ko);Ie(this,Ol);xe(this,Ol,t=>{if(!Kl&&window.addEventListener){const n=()=>t();return window.addEventListener("visibilitychange",n,!1),()=>{window.removeEventListener("visibilitychange",n)}}})}onSubscribe(){R(this,Ko)||this.setEventListener(R(this,Ol))}onUnsubscribe(){var t;this.hasListeners()||((t=R(this,Ko))==null||t.call(this),xe(this,Ko,void 0))}setEventListener(t){var n;xe(this,Ol,t),(n=R(this,Ko))==null||n.call(this),xe(this,Ko,t(r=>{typeof r=="boolean"?this.setFocused(r):this.onFocus()}))}setFocused(t){R(this,ei)!==t&&(xe(this,ei,t),this.onFocus())}onFocus(){const t=this.isFocused();this.listeners.forEach(n=>{n(t)})}isFocused(){var t;return typeof R(this,ei)=="boolean"?R(this,ei):((t=globalThis.document)==null?void 0:t.visibilityState)!=="hidden"}},ei=new WeakMap,Ko=new WeakMap,Ol=new WeakMap,yE),Ib=new yD,Nl,qo,Il,bE,bD=(bE=class extends lu{constructor(){super();Ie(this,Nl,!0);Ie(this,qo);Ie(this,Il);xe(this,Il,t=>{if(!Kl&&window.addEventListener){const n=()=>t(!0),r=()=>t(!1);return window.addEventListener("online",n,!1),window.addEventListener("offline",r,!1),()=>{window.removeEventListener("online",n),window.removeEventListener("offline",r)}}})}onSubscribe(){R(this,qo)||this.setEventListener(R(this,Il))}onUnsubscribe(){var t;this.hasListeners()||((t=R(this,qo))==null||t.call(this),xe(this,qo,void 0))}setEventListener(t){var n;xe(this,Il,t),(n=R(this,qo))==null||n.call(this),xe(this,qo,t(this.setOnline.bind(this)))}setOnline(t){R(this,Nl)!==t&&(xe(this,Nl,t),this.listeners.forEach(r=>{r(t)}))}isOnline(){return R(this,Nl)}},Nl=new WeakMap,qo=new WeakMap,Il=new WeakMap,bE),kp=new bD;function xD(e){return Math.min(1e3*2**e,3e4)}function HE(e){return(e??"online")==="online"?kp.isOnline():!0}var KE=class extends Error{constructor(e){super("CancelledError"),this.revert=e==null?void 0:e.revert,this.silent=e==null?void 0:e.silent}};function am(e){return e instanceof KE}function qE(e){let t=!1,n=0,r=!1,s,o,a;const l=new Promise((b,y)=>{o=b,a=y}),c=b=>{var y;r||(g(new KE(b)),(y=e.abort)==null||y.call(e))},i=()=>{t=!0},d=()=>{t=!1},p=()=>Ib.isFocused()&&(e.networkMode==="always"||kp.isOnline())&&e.canRun(),f=()=>HE(e.networkMode)&&e.canRun(),h=b=>{var y;r||(r=!0,(y=e.onSuccess)==null||y.call(e,b),s==null||s(),o(b))},g=b=>{var y;r||(r=!0,(y=e.onError)==null||y.call(e,b),s==null||s(),a(b))},m=()=>new Promise(b=>{var y;s=w=>{(r||p())&&b(w)},(y=e.onPause)==null||y.call(e)}).then(()=>{var b;s=void 0,r||(b=e.onContinue)==null||b.call(e)}),x=()=>{if(r)return;let b;const y=n===0?e.initialPromise:void 0;try{b=y??e.fn()}catch(w){b=Promise.reject(w)}Promise.resolve(b).then(h).catch(w=>{var T;if(r)return;const S=e.retry??(Kl?0:3),E=e.retryDelay??xD,C=typeof E=="function"?E(n,w):E,k=S===!0||typeof S=="number"&&n<S||typeof S=="function"&&S(n,w);if(t||!k){g(w);return}n++,(T=e.onFail)==null||T.call(e,n,w),gD(C).then(()=>p()?void 0:m()).then(()=>{t?g(w):x()})})};return{promise:l,cancel:c,continue:()=>(s==null||s(),l),cancelRetry:i,continueRetry:d,canStart:f,start:()=>(f()?x():m().then(x),l)}}function wD(){let e=[],t=0,n=f=>{f()},r=f=>{f()},s=f=>setTimeout(f,0);const o=f=>{s=f},a=f=>{let h;t++;try{h=f()}finally{t--,t||i()}return h},l=f=>{t?e.push(f):s(()=>{n(f)})},c=f=>(...h)=>{l(()=>{f(...h)})},i=()=>{const f=e;e=[],f.length&&s(()=>{r(()=>{f.forEach(h=>{n(h)})})})};return{batch:a,batchCalls:c,schedule:l,setNotifyFunction:f=>{n=f},setBatchNotifyFunction:f=>{r=f},setScheduler:o}}var cn=wD(),ti,xE,WE=(xE=class{constructor(){Ie(this,ti)}destroy(){this.clearGcTimeout()}scheduleGc(){this.clearGcTimeout(),Tv(this.gcTime)&&xe(this,ti,setTimeout(()=>{this.optionalRemove()},this.gcTime))}updateGcTime(e){this.gcTime=Math.max(this.gcTime||0,e??(Kl?1/0:5*60*1e3))}clearGcTimeout(){R(this,ti)&&(clearTimeout(R(this,ti)),xe(this,ti,void 0))}},ti=new WeakMap,xE),Dl,Al,Mr,On,Md,ni,Wr,Js,wE,SD=(wE=class extends WE{constructor(t){super();Ie(this,Wr);Ie(this,Dl);Ie(this,Al);Ie(this,Mr);Ie(this,On);Ie(this,Md);Ie(this,ni);xe(this,ni,!1),xe(this,Md,t.defaultOptions),this.setOptions(t.options),this.observers=[],xe(this,Mr,t.cache),this.queryKey=t.queryKey,this.queryHash=t.queryHash,xe(this,Dl,CD(this.options)),this.state=t.state??R(this,Dl),this.scheduleGc()}get meta(){return this.options.meta}get promise(){var t;return(t=R(this,On))==null?void 0:t.promise}setOptions(t){this.options={...R(this,Md),...t},this.updateGcTime(this.options.gcTime)}optionalRemove(){!this.observers.length&&this.state.fetchStatus==="idle"&&R(this,Mr).remove(this)}setData(t,n){const r=_v(this.state.data,t,this.options);return Je(this,Wr,Js).call(this,{data:r,type:"success",dataUpdatedAt:n==null?void 0:n.updatedAt,manual:n==null?void 0:n.manual}),r}setState(t,n){Je(this,Wr,Js).call(this,{type:"setState",state:t,setStateOptions:n})}cancel(t){var r,s;const n=(r=R(this,On))==null?void 0:r.promise;return(s=R(this,On))==null||s.cancel(t),n?n.then(Or).catch(Or):Promise.resolve()}destroy(){super.destroy(),this.cancel({silent:!0})}reset(){this.destroy(),this.setState(R(this,Dl))}isActive(){return this.observers.some(t=>Qr(t.options.enabled,this)!==!1)}isDisabled(){return this.getObserversCount()>0&&!this.isActive()}isStale(){return this.state.isInvalidated?!0:this.getObserversCount()>0?this.observers.some(t=>t.getCurrentResult().isStale):this.state.data===void 0}isStaleByTime(t=0){return this.state.isInvalidated||this.state.data===void 0||!BE(this.state.dataUpdatedAt,t)}onFocus(){var n;const t=this.observers.find(r=>r.shouldFetchOnWindowFocus());t==null||t.refetch({cancelRefetch:!1}),(n=R(this,On))==null||n.continue()}onOnline(){var n;const t=this.observers.find(r=>r.shouldFetchOnReconnect());t==null||t.refetch({cancelRefetch:!1}),(n=R(this,On))==null||n.continue()}addObserver(t){this.observers.includes(t)||(this.observers.push(t),this.clearGcTimeout(),R(this,Mr).notify({type:"observerAdded",query:this,observer:t}))}removeObserver(t){this.observers.includes(t)&&(this.observers=this.observers.filter(n=>n!==t),this.observers.length||(R(this,On)&&(R(this,ni)?R(this,On).cancel({revert:!0}):R(this,On).cancelRetry()),this.scheduleGc()),R(this,Mr).notify({type:"observerRemoved",query:this,observer:t}))}getObserversCount(){return this.observers.length}invalidate(){this.state.isInvalidated||Je(this,Wr,Js).call(this,{type:"invalidate"})}fetch(t,n){var c,i,d;if(this.state.fetchStatus!=="idle"){if(this.state.data!==void 0&&(n!=null&&n.cancelRefetch))this.cancel({silent:!0});else if(R(this,On))return R(this,On).continueRetry(),R(this,On).promise}if(t&&this.setOptions(t),!this.options.queryFn){const p=this.observers.find(f=>f.options.queryFn);p&&this.setOptions(p.options)}const r=new AbortController,s=p=>{Object.defineProperty(p,"signal",{enumerable:!0,get:()=>(xe(this,ni,!0),r.signal)})},o=()=>{const p=VE(this.options,n),f={queryKey:this.queryKey,meta:this.meta};return s(f),xe(this,ni,!1),this.options.persister?this.options.persister(p,f,this):p(f)},a={fetchOptions:n,options:this.options,queryKey:this.queryKey,state:this.state,fetchFn:o};s(a),(c=this.options.behavior)==null||c.onFetch(a,this),xe(this,Al,this.state),(this.state.fetchStatus==="idle"||this.state.fetchMeta!==((i=a.fetchOptions)==null?void 0:i.meta))&&Je(this,Wr,Js).call(this,{type:"fetch",meta:(d=a.fetchOptions)==null?void 0:d.meta});const l=p=>{var f,h,g,m;am(p)&&p.silent||Je(this,Wr,Js).call(this,{type:"error",error:p}),am(p)||((h=(f=R(this,Mr).config).onError)==null||h.call(f,p,this),(m=(g=R(this,Mr).config).onSettled)==null||m.call(g,this.state.data,p,this)),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1};return xe(this,On,qE({initialPromise:n==null?void 0:n.initialPromise,fn:a.fetchFn,abort:r.abort.bind(r),onSuccess:p=>{var f,h,g,m;if(p===void 0){l(new Error(`${this.queryHash} data is undefined`));return}try{this.setData(p)}catch(x){l(x);return}(h=(f=R(this,Mr).config).onSuccess)==null||h.call(f,p,this),(m=(g=R(this,Mr).config).onSettled)==null||m.call(g,p,this.state.error,this),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1},onError:l,onFail:(p,f)=>{Je(this,Wr,Js).call(this,{type:"failed",failureCount:p,error:f})},onPause:()=>{Je(this,Wr,Js).call(this,{type:"pause"})},onContinue:()=>{Je(this,Wr,Js).call(this,{type:"continue"})},retry:a.options.retry,retryDelay:a.options.retryDelay,networkMode:a.options.networkMode,canRun:()=>!0})),R(this,On).start()}},Dl=new WeakMap,Al=new WeakMap,Mr=new WeakMap,On=new WeakMap,Md=new WeakMap,ni=new WeakMap,Wr=new WeakSet,Js=function(t){const n=r=>{switch(t.type){case"failed":return{...r,fetchFailureCount:t.failureCount,fetchFailureReason:t.error};case"pause":return{...r,fetchStatus:"paused"};case"continue":return{...r,fetchStatus:"fetching"};case"fetch":return{...r,...GE(r.data,this.options),fetchMeta:t.meta??null};case"success":return{...r,data:t.data,dataUpdateCount:r.dataUpdateCount+1,dataUpdatedAt:t.dataUpdatedAt??Date.now(),error:null,isInvalidated:!1,status:"success",...!t.manual&&{fetchStatus:"idle",fetchFailureCount:0,fetchFailureReason:null}};case"error":const s=t.error;return am(s)&&s.revert&&R(this,Al)?{...R(this,Al),fetchStatus:"idle"}:{...r,error:s,errorUpdateCount:r.errorUpdateCount+1,errorUpdatedAt:Date.now(),fetchFailureCount:r.fetchFailureCount+1,fetchFailureReason:s,fetchStatus:"idle",status:"error"};case"invalidate":return{...r,isInvalidated:!0};case"setState":return{...r,...t.state}}};this.state=n(this.state),cn.batch(()=>{this.observers.forEach(r=>{r.onQueryUpdate()}),R(this,Mr).notify({query:this,type:"updated",action:t})})},wE);function GE(e,t){return{fetchFailureCount:0,fetchFailureReason:null,fetchStatus:HE(t.networkMode)?"fetching":"paused",...e===void 0&&{error:null,status:"pending"}}}function CD(e){const t=typeof e.initialData=="function"?e.initialData():e.initialData,n=t!==void 0,r=n?typeof e.initialDataUpdatedAt=="function"?e.initialDataUpdatedAt():e.initialDataUpdatedAt:0;return{data:t,dataUpdateCount:0,dataUpdatedAt:n?r??Date.now():0,error:null,errorUpdateCount:0,errorUpdatedAt:0,fetchFailureCount:0,fetchFailureReason:null,fetchMeta:null,isInvalidated:!1,status:n?"success":"pending",fetchStatus:"idle"}}var Ss,SE,ED=(SE=class extends lu{constructor(t={}){super();Ie(this,Ss);this.config=t,xe(this,Ss,new Map)}build(t,n,r){const s=n.queryKey,o=n.queryHash??Nb(s,n);let a=this.get(o);return a||(a=new SD({cache:this,queryKey:s,queryHash:o,options:t.defaultQueryOptions(n),state:r,defaultOptions:t.getQueryDefaults(s)}),this.add(a)),a}add(t){R(this,Ss).has(t.queryHash)||(R(this,Ss).set(t.queryHash,t),this.notify({type:"added",query:t}))}remove(t){const n=R(this,Ss).get(t.queryHash);n&&(t.destroy(),n===t&&R(this,Ss).delete(t.queryHash),this.notify({type:"removed",query:t}))}clear(){cn.batch(()=>{this.getAll().forEach(t=>{this.remove(t)})})}get(t){return R(this,Ss).get(t)}getAll(){return[...R(this,Ss).values()]}find(t){const n={exact:!0,...t};return this.getAll().find(r=>Zw(n,r))}findAll(t={}){const n=this.getAll();return Object.keys(t).length>0?n.filter(r=>Zw(t,r)):n}notify(t){cn.batch(()=>{this.listeners.forEach(n=>{n(t)})})}onFocus(){cn.batch(()=>{this.getAll().forEach(t=>{t.onFocus()})})}onOnline(){cn.batch(()=>{this.getAll().forEach(t=>{t.onOnline()})})}},Ss=new WeakMap,SE),Cs,Ln,ri,Es,Ao,CE,TD=(CE=class extends WE{constructor(t){super();Ie(this,Es);Ie(this,Cs);Ie(this,Ln);Ie(this,ri);this.mutationId=t.mutationId,xe(this,Ln,t.mutationCache),xe(this,Cs,[]),this.state=t.state||JE(),this.setOptions(t.options),this.scheduleGc()}setOptions(t){this.options=t,this.updateGcTime(this.options.gcTime)}get meta(){return this.options.meta}addObserver(t){R(this,Cs).includes(t)||(R(this,Cs).push(t),this.clearGcTimeout(),R(this,Ln).notify({type:"observerAdded",mutation:this,observer:t}))}removeObserver(t){xe(this,Cs,R(this,Cs).filter(n=>n!==t)),this.scheduleGc(),R(this,Ln).notify({type:"observerRemoved",mutation:this,observer:t})}optionalRemove(){R(this,Cs).length||(this.state.status==="pending"?this.scheduleGc():R(this,Ln).remove(this))}continue(){var t;return((t=R(this,ri))==null?void 0:t.continue())??this.execute(this.state.variables)}async execute(t){var s,o,a,l,c,i,d,p,f,h,g,m,x,b,y,w,S,E,C,k;xe(this,ri,qE({fn:()=>this.options.mutationFn?this.options.mutationFn(t):Promise.reject(new Error("No mutationFn found")),onFail:(T,P)=>{Je(this,Es,Ao).call(this,{type:"failed",failureCount:T,error:P})},onPause:()=>{Je(this,Es,Ao).call(this,{type:"pause"})},onContinue:()=>{Je(this,Es,Ao).call(this,{type:"continue"})},retry:this.options.retry??0,retryDelay:this.options.retryDelay,networkMode:this.options.networkMode,canRun:()=>R(this,Ln).canRun(this)}));const n=this.state.status==="pending",r=!R(this,ri).canStart();try{if(!n){Je(this,Es,Ao).call(this,{type:"pending",variables:t,isPaused:r}),await((o=(s=R(this,Ln).config).onMutate)==null?void 0:o.call(s,t,this));const P=await((l=(a=this.options).onMutate)==null?void 0:l.call(a,t));P!==this.state.context&&Je(this,Es,Ao).call(this,{type:"pending",context:P,variables:t,isPaused:r})}const T=await R(this,ri).start();return await((i=(c=R(this,Ln).config).onSuccess)==null?void 0:i.call(c,T,t,this.state.context,this)),await((p=(d=this.options).onSuccess)==null?void 0:p.call(d,T,t,this.state.context)),await((h=(f=R(this,Ln).config).onSettled)==null?void 0:h.call(f,T,null,this.state.variables,this.state.context,this)),await((m=(g=this.options).onSettled)==null?void 0:m.call(g,T,null,t,this.state.context)),Je(this,Es,Ao).call(this,{type:"success",data:T}),T}catch(T){try{throw await((b=(x=R(this,Ln).config).onError)==null?void 0:b.call(x,T,t,this.state.context,this)),await((w=(y=this.options).onError)==null?void 0:w.call(y,T,t,this.state.context)),await((E=(S=R(this,Ln).config).onSettled)==null?void 0:E.call(S,void 0,T,this.state.variables,this.state.context,this)),await((k=(C=this.options).onSettled)==null?void 0:k.call(C,void 0,T,t,this.state.context)),T}finally{Je(this,Es,Ao).call(this,{type:"error",error:T})}}finally{R(this,Ln).runNext(this)}}},Cs=new WeakMap,Ln=new WeakMap,ri=new WeakMap,Es=new WeakSet,Ao=function(t){const n=r=>{switch(t.type){case"failed":return{...r,failureCount:t.failureCount,failureReason:t.error};case"pause":return{...r,isPaused:!0};case"continue":return{...r,isPaused:!1};case"pending":return{...r,context:t.context,data:void 0,failureCount:0,failureReason:null,error:null,isPaused:t.isPaused,status:"pending",variables:t.variables,submittedAt:Date.now()};case"success":return{...r,data:t.data,failureCount:0,failureReason:null,error:null,status:"success",isPaused:!1};case"error":return{...r,data:void 0,error:t.error,failureCount:r.failureCount+1,failureReason:t.error,isPaused:!1,status:"error"}}};this.state=n(this.state),cn.batch(()=>{R(this,Cs).forEach(r=>{r.onMutationUpdate(t)}),R(this,Ln).notify({mutation:this,type:"updated",action:t})})},CE);function JE(){return{context:void 0,data:void 0,error:null,failureCount:0,failureReason:null,isPaused:!1,status:"idle",variables:void 0,submittedAt:0}}var lr,Od,EE,kD=(EE=class extends lu{constructor(t={}){super();Ie(this,lr);Ie(this,Od);this.config=t,xe(this,lr,new Map),xe(this,Od,Date.now())}build(t,n,r){const s=new TD({mutationCache:this,mutationId:++uf(this,Od)._,options:t.defaultMutationOptions(n),state:r});return this.add(s),s}add(t){const n=df(t),r=R(this,lr).get(n)??[];r.push(t),R(this,lr).set(n,r),this.notify({type:"added",mutation:t})}remove(t){var r;const n=df(t);if(R(this,lr).has(n)){const s=(r=R(this,lr).get(n))==null?void 0:r.filter(o=>o!==t);s&&(s.length===0?R(this,lr).delete(n):R(this,lr).set(n,s))}this.notify({type:"removed",mutation:t})}canRun(t){var r;const n=(r=R(this,lr).get(df(t)))==null?void 0:r.find(s=>s.state.status==="pending");return!n||n===t}runNext(t){var r;const n=(r=R(this,lr).get(df(t)))==null?void 0:r.find(s=>s!==t&&s.state.isPaused);return(n==null?void 0:n.continue())??Promise.resolve()}clear(){cn.batch(()=>{this.getAll().forEach(t=>{this.remove(t)})})}getAll(){return[...R(this,lr).values()].flat()}find(t){const n={exact:!0,...t};return this.getAll().find(r=>Yw(n,r))}findAll(t={}){return this.getAll().filter(n=>Yw(t,n))}notify(t){cn.batch(()=>{this.listeners.forEach(n=>{n(t)})})}resumePausedMutations(){const t=this.getAll().filter(n=>n.state.isPaused);return cn.batch(()=>Promise.all(t.map(n=>n.continue().catch(Or))))}},lr=new WeakMap,Od=new WeakMap,EE);function df(e){var t;return((t=e.options.scope)==null?void 0:t.id)??String(e.mutationId)}function _D(e){return{onFetch:(t,n)=>{const r=async()=>{var g,m,x,b,y;const s=t.options,o=(x=(m=(g=t.fetchOptions)==null?void 0:g.meta)==null?void 0:m.fetchMore)==null?void 0:x.direction,a=((b=t.state.data)==null?void 0:b.pages)||[],l=((y=t.state.data)==null?void 0:y.pageParams)||[],c={pages:[],pageParams:[]};let i=!1;const d=w=>{Object.defineProperty(w,"signal",{enumerable:!0,get:()=>(t.signal.aborted?i=!0:t.signal.addEventListener("abort",()=>{i=!0}),t.signal)})},p=VE(t.options,t.fetchOptions),f=async(w,S,E)=>{if(i)return Promise.reject();if(S==null&&w.pages.length)return Promise.resolve(w);const C={queryKey:t.queryKey,pageParam:S,direction:E?"backward":"forward",meta:t.options.meta};d(C);const k=await p(C),{maxPages:T}=t.options,P=E?vD:mD;return{pages:P(w.pages,k,T),pageParams:P(w.pageParams,S,T)}};let h;if(o&&a.length){const w=o==="backward",S=w?jD:tS,E={pages:a,pageParams:l},C=S(s,E);h=await f(E,C,w)}else{h=await f(c,l[0]??s.initialPageParam);const w=e??a.length;for(let S=1;S<w;S++){const E=tS(s,h);if(E==null)break;h=await f(h,E)}}return h};t.options.persister?t.fetchFn=()=>{var s,o;return(o=(s=t.options).persister)==null?void 0:o.call(s,r,{queryKey:t.queryKey,meta:t.options.meta,signal:t.signal},n)}:t.fetchFn=r}}}function tS(e,{pages:t,pageParams:n}){const r=t.length-1;return t.length>0?e.getNextPageParam(t[r],t,n[r],n):void 0}function jD(e,{pages:t,pageParams:n}){var r;return t.length>0?(r=e.getPreviousPageParam)==null?void 0:r.call(e,t[0],t,n[0],n):void 0}var Ht,Wo,Go,Fl,Ll,Jo,$l,Bl,TE,RD=(TE=class{constructor(e={}){Ie(this,Ht);Ie(this,Wo);Ie(this,Go);Ie(this,Fl);Ie(this,Ll);Ie(this,Jo);Ie(this,$l);Ie(this,Bl);xe(this,Ht,e.queryCache||new ED),xe(this,Wo,e.mutationCache||new kD),xe(this,Go,e.defaultOptions||{}),xe(this,Fl,new Map),xe(this,Ll,new Map),xe(this,Jo,0)}mount(){uf(this,Jo)._++,R(this,Jo)===1&&(xe(this,$l,Ib.subscribe(async e=>{e&&(await this.resumePausedMutations(),R(this,Ht).onFocus())})),xe(this,Bl,kp.subscribe(async e=>{e&&(await this.resumePausedMutations(),R(this,Ht).onOnline())})))}unmount(){var e,t;uf(this,Jo)._--,R(this,Jo)===0&&((e=R(this,$l))==null||e.call(this),xe(this,$l,void 0),(t=R(this,Bl))==null||t.call(this),xe(this,Bl,void 0))}isFetching(e){return R(this,Ht).findAll({...e,fetchStatus:"fetching"}).length}isMutating(e){return R(this,Wo).findAll({...e,status:"pending"}).length}getQueryData(e){var n;const t=this.defaultQueryOptions({queryKey:e});return(n=R(this,Ht).get(t.queryHash))==null?void 0:n.state.data}ensureQueryData(e){const t=this.getQueryData(e.queryKey);if(t===void 0)return this.fetchQuery(e);{const n=this.defaultQueryOptions(e),r=R(this,Ht).build(this,n);return e.revalidateIfStale&&r.isStaleByTime(bl(n.staleTime,r))&&this.prefetchQuery(n),Promise.resolve(t)}}getQueriesData(e){return R(this,Ht).findAll(e).map(({queryKey:t,state:n})=>{const r=n.data;return[t,r]})}setQueryData(e,t,n){const r=this.defaultQueryOptions({queryKey:e}),s=R(this,Ht).get(r.queryHash),o=s==null?void 0:s.state.data,a=hD(t,o);if(a!==void 0)return R(this,Ht).build(this,r).setData(a,{...n,manual:!0})}setQueriesData(e,t,n){return cn.batch(()=>R(this,Ht).findAll(e).map(({queryKey:r})=>[r,this.setQueryData(r,t,n)]))}getQueryState(e){var n;const t=this.defaultQueryOptions({queryKey:e});return(n=R(this,Ht).get(t.queryHash))==null?void 0:n.state}removeQueries(e){const t=R(this,Ht);cn.batch(()=>{t.findAll(e).forEach(n=>{t.remove(n)})})}resetQueries(e,t){const n=R(this,Ht),r={type:"active",...e};return cn.batch(()=>(n.findAll(e).forEach(s=>{s.reset()}),this.refetchQueries(r,t)))}cancelQueries(e={},t={}){const n={revert:!0,...t},r=cn.batch(()=>R(this,Ht).findAll(e).map(s=>s.cancel(n)));return Promise.all(r).then(Or).catch(Or)}invalidateQueries(e={},t={}){return cn.batch(()=>{if(R(this,Ht).findAll(e).forEach(r=>{r.invalidate()}),e.refetchType==="none")return Promise.resolve();const n={...e,type:e.refetchType??e.type??"active"};return this.refetchQueries(n,t)})}refetchQueries(e={},t){const n={...t,cancelRefetch:(t==null?void 0:t.cancelRefetch)??!0},r=cn.batch(()=>R(this,Ht).findAll(e).filter(s=>!s.isDisabled()).map(s=>{let o=s.fetch(void 0,n);return n.throwOnError||(o=o.catch(Or)),s.state.fetchStatus==="paused"?Promise.resolve():o}));return Promise.all(r).then(Or)}fetchQuery(e){const t=this.defaultQueryOptions(e);t.retry===void 0&&(t.retry=!1);const n=R(this,Ht).build(this,t);return n.isStaleByTime(bl(t.staleTime,n))?n.fetch(t):Promise.resolve(n.state.data)}prefetchQuery(e){return this.fetchQuery(e).then(Or).catch(Or)}fetchInfiniteQuery(e){return e.behavior=_D(e.pages),this.fetchQuery(e)}prefetchInfiniteQuery(e){return this.fetchInfiniteQuery(e).then(Or).catch(Or)}resumePausedMutations(){return kp.isOnline()?R(this,Wo).resumePausedMutations():Promise.resolve()}getQueryCache(){return R(this,Ht)}getMutationCache(){return R(this,Wo)}getDefaultOptions(){return R(this,Go)}setDefaultOptions(e){xe(this,Go,e)}setQueryDefaults(e,t){R(this,Fl).set(gi(e),{queryKey:e,defaultOptions:t})}getQueryDefaults(e){const t=[...R(this,Fl).values()];let n={};return t.forEach(r=>{Dc(e,r.queryKey)&&(n={...n,...r.defaultOptions})}),n}setMutationDefaults(e,t){R(this,Ll).set(gi(e),{mutationKey:e,defaultOptions:t})}getMutationDefaults(e){const t=[...R(this,Ll).values()];let n={};return t.forEach(r=>{Dc(e,r.mutationKey)&&(n={...n,...r.defaultOptions})}),n}defaultQueryOptions(e){if(e._defaulted)return e;const t={...R(this,Go).queries,...this.getQueryDefaults(e.queryKey),...e,_defaulted:!0};return t.queryHash||(t.queryHash=Nb(t.queryKey,t)),t.refetchOnReconnect===void 0&&(t.refetchOnReconnect=t.networkMode!=="always"),t.throwOnError===void 0&&(t.throwOnError=!!t.suspense),!t.networkMode&&t.persister&&(t.networkMode="offlineFirst"),t.enabled!==!0&&t.queryFn===UE&&(t.enabled=!1),t}defaultMutationOptions(e){return e!=null&&e._defaulted?e:{...R(this,Go).mutations,...(e==null?void 0:e.mutationKey)&&this.getMutationDefaults(e.mutationKey),...e,_defaulted:!0}}clear(){R(this,Ht).clear(),R(this,Wo).clear()}},Ht=new WeakMap,Wo=new WeakMap,Go=new WeakMap,Fl=new WeakMap,Ll=new WeakMap,Jo=new WeakMap,$l=new WeakMap,Bl=new WeakMap,TE),Qn,at,Nd,$n,si,zl,Ts,Id,Ul,Vl,oi,ai,Qo,Hl,gt,oc,jv,Rv,Pv,Mv,Ov,Nv,Iv,QE,kE,PD=(kE=class extends lu{constructor(t,n){super();Ie(this,gt);Ie(this,Qn);Ie(this,at);Ie(this,Nd);Ie(this,$n);Ie(this,si);Ie(this,zl);Ie(this,Ts);Ie(this,Id);Ie(this,Ul);Ie(this,Vl);Ie(this,oi);Ie(this,ai);Ie(this,Qo);Ie(this,Hl,new Set);this.options=n,xe(this,Qn,t),xe(this,Ts,null),this.bindMethods(),this.setOptions(n)}bindMethods(){this.refetch=this.refetch.bind(this)}onSubscribe(){this.listeners.size===1&&(R(this,at).addObserver(this),nS(R(this,at),this.options)?Je(this,gt,oc).call(this):this.updateResult(),Je(this,gt,Mv).call(this))}onUnsubscribe(){this.hasListeners()||this.destroy()}shouldFetchOnReconnect(){return Dv(R(this,at),this.options,this.options.refetchOnReconnect)}shouldFetchOnWindowFocus(){return Dv(R(this,at),this.options,this.options.refetchOnWindowFocus)}destroy(){this.listeners=new Set,Je(this,gt,Ov).call(this),Je(this,gt,Nv).call(this),R(this,at).removeObserver(this)}setOptions(t,n){const r=this.options,s=R(this,at);if(this.options=R(this,Qn).defaultQueryOptions(t),this.options.enabled!==void 0&&typeof this.options.enabled!="boolean"&&typeof this.options.enabled!="function"&&typeof Qr(this.options.enabled,R(this,at))!="boolean")throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");Je(this,gt,Iv).call(this),R(this,at).setOptions(this.options),r._defaulted&&!Tp(this.options,r)&&R(this,Qn).getQueryCache().notify({type:"observerOptionsUpdated",query:R(this,at),observer:this});const o=this.hasListeners();o&&rS(R(this,at),s,this.options,r)&&Je(this,gt,oc).call(this),this.updateResult(n),o&&(R(this,at)!==s||Qr(this.options.enabled,R(this,at))!==Qr(r.enabled,R(this,at))||bl(this.options.staleTime,R(this,at))!==bl(r.staleTime,R(this,at)))&&Je(this,gt,jv).call(this);const a=Je(this,gt,Rv).call(this);o&&(R(this,at)!==s||Qr(this.options.enabled,R(this,at))!==Qr(r.enabled,R(this,at))||a!==R(this,Qo))&&Je(this,gt,Pv).call(this,a)}getOptimisticResult(t){const n=R(this,Qn).getQueryCache().build(R(this,Qn),t),r=this.createResult(n,t);return OD(this,r)&&(xe(this,$n,r),xe(this,zl,this.options),xe(this,si,R(this,at).state)),r}getCurrentResult(){return R(this,$n)}trackResult(t,n){const r={};return Object.keys(t).forEach(s=>{Object.defineProperty(r,s,{configurable:!1,enumerable:!0,get:()=>(this.trackProp(s),n==null||n(s),t[s])})}),r}trackProp(t){R(this,Hl).add(t)}getCurrentQuery(){return R(this,at)}refetch({...t}={}){return this.fetch({...t})}fetchOptimistic(t){const n=R(this,Qn).defaultQueryOptions(t),r=R(this,Qn).getQueryCache().build(R(this,Qn),n);return r.isFetchingOptimistic=!0,r.fetch().then(()=>this.createResult(r,n))}fetch(t){return Je(this,gt,oc).call(this,{...t,cancelRefetch:t.cancelRefetch??!0}).then(()=>(this.updateResult(),R(this,$n)))}createResult(t,n){var k;const r=R(this,at),s=this.options,o=R(this,$n),a=R(this,si),l=R(this,zl),i=t!==r?t.state:R(this,Nd),{state:d}=t;let p={...d},f=!1,h;if(n._optimisticResults){const T=this.hasListeners(),P=!T&&nS(t,n),N=T&&rS(t,r,n,s);(P||N)&&(p={...p,...GE(d.data,t.options)}),n._optimisticResults==="isRestoring"&&(p.fetchStatus="idle")}let{error:g,errorUpdatedAt:m,status:x}=p;if(n.select&&p.data!==void 0)if(o&&p.data===(a==null?void 0:a.data)&&n.select===R(this,Id))h=R(this,Ul);else try{xe(this,Id,n.select),h=n.select(p.data),h=_v(o==null?void 0:o.data,h,n),xe(this,Ul,h),xe(this,Ts,null)}catch(T){xe(this,Ts,T)}else h=p.data;if(n.placeholderData!==void 0&&h===void 0&&x==="pending"){let T;if(o!=null&&o.isPlaceholderData&&n.placeholderData===(l==null?void 0:l.placeholderData))T=o.data;else if(T=typeof n.placeholderData=="function"?n.placeholderData((k=R(this,Vl))==null?void 0:k.state.data,R(this,Vl)):n.placeholderData,n.select&&T!==void 0)try{T=n.select(T),xe(this,Ts,null)}catch(P){xe(this,Ts,P)}T!==void 0&&(x="success",h=_v(o==null?void 0:o.data,T,n),f=!0)}R(this,Ts)&&(g=R(this,Ts),h=R(this,Ul),m=Date.now(),x="error");const b=p.fetchStatus==="fetching",y=x==="pending",w=x==="error",S=y&&b,E=h!==void 0;return{status:x,fetchStatus:p.fetchStatus,isPending:y,isSuccess:x==="success",isError:w,isInitialLoading:S,isLoading:S,data:h,dataUpdatedAt:p.dataUpdatedAt,error:g,errorUpdatedAt:m,failureCount:p.fetchFailureCount,failureReason:p.fetchFailureReason,errorUpdateCount:p.errorUpdateCount,isFetched:p.dataUpdateCount>0||p.errorUpdateCount>0,isFetchedAfterMount:p.dataUpdateCount>i.dataUpdateCount||p.errorUpdateCount>i.errorUpdateCount,isFetching:b,isRefetching:b&&!y,isLoadingError:w&&!E,isPaused:p.fetchStatus==="paused",isPlaceholderData:f,isRefetchError:w&&E,isStale:Db(t,n),refetch:this.refetch}}updateResult(t){const n=R(this,$n),r=this.createResult(R(this,at),this.options);if(xe(this,si,R(this,at).state),xe(this,zl,this.options),R(this,si).data!==void 0&&xe(this,Vl,R(this,at)),Tp(r,n))return;xe(this,$n,r);const s={},o=()=>{if(!n)return!0;const{notifyOnChangeProps:a}=this.options,l=typeof a=="function"?a():a;if(l==="all"||!l&&!R(this,Hl).size)return!0;const c=new Set(l??R(this,Hl));return this.options.throwOnError&&c.add("error"),Object.keys(R(this,$n)).some(i=>{const d=i;return R(this,$n)[d]!==n[d]&&c.has(d)})};(t==null?void 0:t.listeners)!==!1&&o()&&(s.listeners=!0),Je(this,gt,QE).call(this,{...s,...t})}onQueryUpdate(){this.updateResult(),this.hasListeners()&&Je(this,gt,Mv).call(this)}},Qn=new WeakMap,at=new WeakMap,Nd=new WeakMap,$n=new WeakMap,si=new WeakMap,zl=new WeakMap,Ts=new WeakMap,Id=new WeakMap,Ul=new WeakMap,Vl=new WeakMap,oi=new WeakMap,ai=new WeakMap,Qo=new WeakMap,Hl=new WeakMap,gt=new WeakSet,oc=function(t){Je(this,gt,Iv).call(this);let n=R(this,at).fetch(this.options,t);return t!=null&&t.throwOnError||(n=n.catch(Or)),n},jv=function(){Je(this,gt,Ov).call(this);const t=bl(this.options.staleTime,R(this,at));if(Kl||R(this,$n).isStale||!Tv(t))return;const r=BE(R(this,$n).dataUpdatedAt,t)+1;xe(this,oi,setTimeout(()=>{R(this,$n).isStale||this.updateResult()},r))},Rv=function(){return(typeof this.options.refetchInterval=="function"?this.options.refetchInterval(R(this,at)):this.options.refetchInterval)??!1},Pv=function(t){Je(this,gt,Nv).call(this),xe(this,Qo,t),!(Kl||Qr(this.options.enabled,R(this,at))===!1||!Tv(R(this,Qo))||R(this,Qo)===0)&&xe(this,ai,setInterval(()=>{(this.options.refetchIntervalInBackground||Ib.isFocused())&&Je(this,gt,oc).call(this)},R(this,Qo)))},Mv=function(){Je(this,gt,jv).call(this),Je(this,gt,Pv).call(this,Je(this,gt,Rv).call(this))},Ov=function(){R(this,oi)&&(clearTimeout(R(this,oi)),xe(this,oi,void 0))},Nv=function(){R(this,ai)&&(clearInterval(R(this,ai)),xe(this,ai,void 0))},Iv=function(){const t=R(this,Qn).getQueryCache().build(R(this,Qn),this.options);if(t===R(this,at))return;const n=R(this,at);xe(this,at,t),xe(this,Nd,t.state),this.hasListeners()&&(n==null||n.removeObserver(this),t.addObserver(this))},QE=function(t){cn.batch(()=>{t.listeners&&this.listeners.forEach(n=>{n(R(this,$n))}),R(this,Qn).getQueryCache().notify({query:R(this,at),type:"observerResultsUpdated"})})},kE);function MD(e,t){return Qr(t.enabled,e)!==!1&&e.state.data===void 0&&!(e.state.status==="error"&&t.retryOnMount===!1)}function nS(e,t){return MD(e,t)||e.state.data!==void 0&&Dv(e,t,t.refetchOnMount)}function Dv(e,t,n){if(Qr(t.enabled,e)!==!1){const r=typeof n=="function"?n(e):n;return r==="always"||r!==!1&&Db(e,t)}return!1}function rS(e,t,n,r){return(e!==t||Qr(r.enabled,e)===!1)&&(!n.suspense||e.state.status!=="error")&&Db(e,n)}function Db(e,t){return Qr(t.enabled,e)!==!1&&e.isStaleByTime(bl(t.staleTime,e))}function OD(e,t){return!Tp(e.getCurrentResult(),t)}var Zo,Yo,Zn,to,co,Xf,Av,_E,ND=(_E=class extends lu{constructor(n,r){super();Ie(this,co);Ie(this,Zo);Ie(this,Yo);Ie(this,Zn);Ie(this,to);xe(this,Zo,n),this.setOptions(r),this.bindMethods(),Je(this,co,Xf).call(this)}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(n){var s;const r=this.options;this.options=R(this,Zo).defaultMutationOptions(n),Tp(this.options,r)||R(this,Zo).getMutationCache().notify({type:"observerOptionsUpdated",mutation:R(this,Zn),observer:this}),r!=null&&r.mutationKey&&this.options.mutationKey&&gi(r.mutationKey)!==gi(this.options.mutationKey)?this.reset():((s=R(this,Zn))==null?void 0:s.state.status)==="pending"&&R(this,Zn).setOptions(this.options)}onUnsubscribe(){var n;this.hasListeners()||(n=R(this,Zn))==null||n.removeObserver(this)}onMutationUpdate(n){Je(this,co,Xf).call(this),Je(this,co,Av).call(this,n)}getCurrentResult(){return R(this,Yo)}reset(){var n;(n=R(this,Zn))==null||n.removeObserver(this),xe(this,Zn,void 0),Je(this,co,Xf).call(this),Je(this,co,Av).call(this)}mutate(n,r){var s;return xe(this,to,r),(s=R(this,Zn))==null||s.removeObserver(this),xe(this,Zn,R(this,Zo).getMutationCache().build(R(this,Zo),this.options)),R(this,Zn).addObserver(this),R(this,Zn).execute(n)}},Zo=new WeakMap,Yo=new WeakMap,Zn=new WeakMap,to=new WeakMap,co=new WeakSet,Xf=function(){var r;const n=((r=R(this,Zn))==null?void 0:r.state)??JE();xe(this,Yo,{...n,isPending:n.status==="pending",isSuccess:n.status==="success",isError:n.status==="error",isIdle:n.status==="idle",mutate:this.mutate,reset:this.reset})},Av=function(n){cn.batch(()=>{var r,s,o,a,l,c,i,d;if(R(this,to)&&this.hasListeners()){const p=R(this,Yo).variables,f=R(this,Yo).context;(n==null?void 0:n.type)==="success"?((s=(r=R(this,to)).onSuccess)==null||s.call(r,n.data,p,f),(a=(o=R(this,to)).onSettled)==null||a.call(o,n.data,null,p,f)):(n==null?void 0:n.type)==="error"&&((c=(l=R(this,to)).onError)==null||c.call(l,n.error,p,f),(d=(i=R(this,to)).onSettled)==null||d.call(i,void 0,n.error,p,f))}this.listeners.forEach(p=>{p(R(this,Yo))})})},_E),ZE=v.createContext(void 0),Ab=e=>{const t=v.useContext(ZE);if(!t)throw new Error("No QueryClient set, use QueryClientProvider to set one");return t},ID=({client:e,children:t})=>(v.useEffect(()=>(e.mount(),()=>{e.unmount()}),[e]),u.jsx(ZE.Provider,{value:e,children:t})),YE=v.createContext(!1),DD=()=>v.useContext(YE);YE.Provider;function AD(){let e=!1;return{clearReset:()=>{e=!1},reset:()=>{e=!0},isReset:()=>e}}var FD=v.createContext(AD()),LD=()=>v.useContext(FD);function XE(e,t){return typeof e=="function"?e(...t):!!e}function $D(){}var BD=(e,t)=>{(e.suspense||e.throwOnError)&&(t.isReset()||(e.retryOnMount=!1))},zD=e=>{v.useEffect(()=>{e.clearReset()},[e])},UD=({result:e,errorResetBoundary:t,throwOnError:n,query:r})=>e.isError&&!t.isReset()&&!e.isFetching&&r&&XE(n,[e.error,r]),VD=e=>{e.suspense&&(typeof e.staleTime!="number"&&(e.staleTime=1e3),typeof e.gcTime=="number"&&(e.gcTime=Math.max(e.gcTime,1e3)))},HD=(e,t)=>(e==null?void 0:e.suspense)&&t.isPending,KD=(e,t,n)=>t.fetchOptimistic(e).catch(()=>{n.clearReset()});function qD(e,t,n){var i,d,p,f;const r=Ab(),s=DD(),o=LD(),a=r.defaultQueryOptions(e);(d=(i=r.getDefaultOptions().queries)==null?void 0:i._experimental_beforeQuery)==null||d.call(i,a),a._optimisticResults=s?"isRestoring":"optimistic",VD(a),BD(a,o),zD(o);const[l]=v.useState(()=>new t(r,a)),c=l.getOptimisticResult(a);if(v.useSyncExternalStore(v.useCallback(h=>{const g=s?()=>{}:l.subscribe(cn.batchCalls(h));return l.updateResult(),g},[l,s]),()=>l.getCurrentResult(),()=>l.getCurrentResult()),v.useEffect(()=>{l.setOptions(a,{listeners:!1})},[a,l]),HD(a,c))throw KD(a,l,o);if(UD({result:c,errorResetBoundary:o,throwOnError:a.throwOnError,query:r.getQueryCache().get(a.queryHash)}))throw c.error;return(f=(p=r.getDefaultOptions().queries)==null?void 0:p._experimental_afterQuery)==null||f.call(p,a,c),a.notifyOnChangeProps?c:l.trackResult(c)}function lt(e,t){return qD(e,PD)}function WD(e,t){const n=Ab(),[r]=v.useState(()=>new ND(n,e));v.useEffect(()=>{r.setOptions(e)},[r,e]);const s=v.useSyncExternalStore(v.useCallback(a=>r.subscribe(cn.batchCalls(a)),[r]),()=>r.getCurrentResult(),()=>r.getCurrentResult()),o=v.useCallback((a,l)=>{r.mutate(a,l).catch($D)},[r]);if(s.error&&XE(r.options.throwOnError,[s.error]))throw s.error;return{...s,mutate:o,mutateAsync:s.mutate}}var Fv={},eT={exports:{}},Cr={},tT={exports:{}},nT={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(F,A){var Y=F.length;F.push(A);e:for(;0<Y;){var de=Y-1>>>1,z=F[de];if(0<s(z,A))F[de]=A,F[Y]=z,Y=de;else break e}}function n(F){return F.length===0?null:F[0]}function r(F){if(F.length===0)return null;var A=F[0],Y=F.pop();if(Y!==A){F[0]=Y;e:for(var de=0,z=F.length,se=z>>>1;de<se;){var ne=2*(de+1)-1,ie=F[ne],oe=ne+1,J=F[oe];if(0>s(ie,Y))oe<z&&0>s(J,ie)?(F[de]=J,F[oe]=Y,de=oe):(F[de]=ie,F[ne]=Y,de=ne);else if(oe<z&&0>s(J,Y))F[de]=J,F[oe]=Y,de=oe;else break e}}return A}function s(F,A){var Y=F.sortIndex-A.sortIndex;return Y!==0?Y:F.id-A.id}if(typeof performance=="object"&&typeof performance.now=="function"){var o=performance;e.unstable_now=function(){return o.now()}}else{var a=Date,l=a.now();e.unstable_now=function(){return a.now()-l}}var c=[],i=[],d=1,p=null,f=3,h=!1,g=!1,m=!1,x=typeof setTimeout=="function"?setTimeout:null,b=typeof clearTimeout=="function"?clearTimeout:null,y=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function w(F){for(var A=n(i);A!==null;){if(A.callback===null)r(i);else if(A.startTime<=F)r(i),A.sortIndex=A.expirationTime,t(c,A);else break;A=n(i)}}function S(F){if(m=!1,w(F),!g)if(n(c)!==null)g=!0,ee(E);else{var A=n(i);A!==null&&W(S,A.startTime-F)}}function E(F,A){g=!1,m&&(m=!1,b(T),T=-1),h=!0;var Y=f;try{for(w(A),p=n(c);p!==null&&(!(p.expirationTime>A)||F&&!U());){var de=p.callback;if(typeof de=="function"){p.callback=null,f=p.priorityLevel;var z=de(p.expirationTime<=A);A=e.unstable_now(),typeof z=="function"?p.callback=z:p===n(c)&&r(c),w(A)}else r(c);p=n(c)}if(p!==null)var se=!0;else{var ne=n(i);ne!==null&&W(S,ne.startTime-A),se=!1}return se}finally{p=null,f=Y,h=!1}}var C=!1,k=null,T=-1,P=5,N=-1;function U(){return!(e.unstable_now()-N<P)}function I(){if(k!==null){var F=e.unstable_now();N=F;var A=!0;try{A=k(!0,F)}finally{A?Z():(C=!1,k=null)}}else C=!1}var Z;if(typeof y=="function")Z=function(){y(I)};else if(typeof MessageChannel<"u"){var V=new MessageChannel,Q=V.port2;V.port1.onmessage=I,Z=function(){Q.postMessage(null)}}else Z=function(){x(I,0)};function ee(F){k=F,C||(C=!0,Z())}function W(F,A){T=x(function(){F(e.unstable_now())},A)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(F){F.callback=null},e.unstable_continueExecution=function(){g||h||(g=!0,ee(E))},e.unstable_forceFrameRate=function(F){0>F||125<F?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<F?Math.floor(1e3/F):5},e.unstable_getCurrentPriorityLevel=function(){return f},e.unstable_getFirstCallbackNode=function(){return n(c)},e.unstable_next=function(F){switch(f){case 1:case 2:case 3:var A=3;break;default:A=f}var Y=f;f=A;try{return F()}finally{f=Y}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(F,A){switch(F){case 1:case 2:case 3:case 4:case 5:break;default:F=3}var Y=f;f=F;try{return A()}finally{f=Y}},e.unstable_scheduleCallback=function(F,A,Y){var de=e.unstable_now();switch(typeof Y=="object"&&Y!==null?(Y=Y.delay,Y=typeof Y=="number"&&0<Y?de+Y:de):Y=de,F){case 1:var z=-1;break;case 2:z=250;break;case 5:z=1073741823;break;case 4:z=1e4;break;default:z=5e3}return z=Y+z,F={id:d++,callback:A,priorityLevel:F,startTime:Y,expirationTime:z,sortIndex:-1},Y>de?(F.sortIndex=Y,t(i,F),n(c)===null&&F===n(i)&&(m?(b(T),T=-1):m=!0,W(S,Y-de))):(F.sortIndex=z,t(c,F),g||h||(g=!0,ee(E))),F},e.unstable_shouldYield=U,e.unstable_wrapCallback=function(F){var A=f;return function(){var Y=f;f=A;try{return F.apply(this,arguments)}finally{f=Y}}}})(nT);tT.exports=nT;var GD=tT.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var JD=v,br=GD;function te(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var rT=new Set,Ac={};function Pi(e,t){ql(e,t),ql(e+"Capture",t)}function ql(e,t){for(Ac[e]=t,e=0;e<t.length;e++)rT.add(t[e])}var fo=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Lv=Object.prototype.hasOwnProperty,QD=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,sS={},oS={};function ZD(e){return Lv.call(oS,e)?!0:Lv.call(sS,e)?!1:QD.test(e)?oS[e]=!0:(sS[e]=!0,!1)}function YD(e,t,n,r){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function XD(e,t,n,r){if(t===null||typeof t>"u"||YD(e,t,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function Wn(e,t,n,r,s,o,a){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=o,this.removeEmptyString=a}var Tn={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){Tn[e]=new Wn(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];Tn[t]=new Wn(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){Tn[e]=new Wn(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){Tn[e]=new Wn(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){Tn[e]=new Wn(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){Tn[e]=new Wn(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){Tn[e]=new Wn(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){Tn[e]=new Wn(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){Tn[e]=new Wn(e,5,!1,e.toLowerCase(),null,!1,!1)});var Fb=/[\-:]([a-z])/g;function Lb(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(Fb,Lb);Tn[t]=new Wn(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(Fb,Lb);Tn[t]=new Wn(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(Fb,Lb);Tn[t]=new Wn(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){Tn[e]=new Wn(e,1,!1,e.toLowerCase(),null,!1,!1)});Tn.xlinkHref=new Wn("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){Tn[e]=new Wn(e,1,!1,e.toLowerCase(),null,!0,!0)});function $b(e,t,n,r){var s=Tn.hasOwnProperty(t)?Tn[t]:null;(s!==null?s.type!==0:r||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(XD(t,n,s,r)&&(n=null),r||s===null?ZD(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=n===null?s.type===3?!1:"":n:(t=s.attributeName,r=s.attributeNamespace,n===null?e.removeAttribute(t):(s=s.type,n=s===3||s===4&&n===!0?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}var xo=JD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,ff=Symbol.for("react.element"),rl=Symbol.for("react.portal"),sl=Symbol.for("react.fragment"),Bb=Symbol.for("react.strict_mode"),$v=Symbol.for("react.profiler"),sT=Symbol.for("react.provider"),oT=Symbol.for("react.context"),zb=Symbol.for("react.forward_ref"),Bv=Symbol.for("react.suspense"),zv=Symbol.for("react.suspense_list"),Ub=Symbol.for("react.memo"),$o=Symbol.for("react.lazy"),aT=Symbol.for("react.offscreen"),aS=Symbol.iterator;function Fu(e){return e===null||typeof e!="object"?null:(e=aS&&e[aS]||e["@@iterator"],typeof e=="function"?e:null)}var Bt=Object.assign,im;function ac(e){if(im===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);im=t&&t[1]||""}return`
`+im+e}var lm=!1;function um(e,t){if(!e||lm)return"";lm=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(i){var r=i}Reflect.construct(e,[],t)}else{try{t.call()}catch(i){r=i}e.call(t.prototype)}else{try{throw Error()}catch(i){r=i}e()}}catch(i){if(i&&r&&typeof i.stack=="string"){for(var s=i.stack.split(`
`),o=r.stack.split(`
`),a=s.length-1,l=o.length-1;1<=a&&0<=l&&s[a]!==o[l];)l--;for(;1<=a&&0<=l;a--,l--)if(s[a]!==o[l]){if(a!==1||l!==1)do if(a--,l--,0>l||s[a]!==o[l]){var c=`
`+s[a].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}while(1<=a&&0<=l);break}}}finally{lm=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?ac(e):""}function eA(e){switch(e.tag){case 5:return ac(e.type);case 16:return ac("Lazy");case 13:return ac("Suspense");case 19:return ac("SuspenseList");case 0:case 2:case 15:return e=um(e.type,!1),e;case 11:return e=um(e.type.render,!1),e;case 1:return e=um(e.type,!0),e;default:return""}}function Uv(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case sl:return"Fragment";case rl:return"Portal";case $v:return"Profiler";case Bb:return"StrictMode";case Bv:return"Suspense";case zv:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case oT:return(e.displayName||"Context")+".Consumer";case sT:return(e._context.displayName||"Context")+".Provider";case zb:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case Ub:return t=e.displayName||null,t!==null?t:Uv(e.type)||"Memo";case $o:t=e._payload,e=e._init;try{return Uv(e(t))}catch{}}return null}function tA(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Uv(t);case 8:return t===Bb?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function da(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function iT(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function nA(e){var t=iT(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var s=n.get,o=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(a){r=""+a,o.call(this,a)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(a){r=""+a},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function pf(e){e._valueTracker||(e._valueTracker=nA(e))}function lT(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=iT(e)?e.checked?"true":"false":e.value),e=r,e!==n?(t.setValue(e),!0):!1}function _p(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function Vv(e,t){var n=t.checked;return Bt({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function iS(e,t){var n=t.defaultValue==null?"":t.defaultValue,r=t.checked!=null?t.checked:t.defaultChecked;n=da(t.value!=null?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function uT(e,t){t=t.checked,t!=null&&$b(e,"checked",t,!1)}function Hv(e,t){uT(e,t);var n=da(t.value),r=t.type;if(n!=null)r==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(r==="submit"||r==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?Kv(e,t.type,n):t.hasOwnProperty("defaultValue")&&Kv(e,t.type,da(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function lS(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!(r!=="submit"&&r!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function Kv(e,t,n){(t!=="number"||_p(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var ic=Array.isArray;function xl(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+da(n),t=null,s=0;s<e.length;s++){if(e[s].value===n){e[s].selected=!0,r&&(e[s].defaultSelected=!0);return}t!==null||e[s].disabled||(t=e[s])}t!==null&&(t.selected=!0)}}function qv(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(te(91));return Bt({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function uS(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(te(92));if(ic(n)){if(1<n.length)throw Error(te(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:da(n)}}function cT(e,t){var n=da(t.value),r=da(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),r!=null&&(e.defaultValue=""+r)}function cS(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function dT(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Wv(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?dT(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var hf,fT=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,r,s){MSApp.execUnsafeLocalFunction(function(){return e(t,n,r,s)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(hf=hf||document.createElement("div"),hf.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=hf.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function Fc(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var yc={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},rA=["Webkit","ms","Moz","O"];Object.keys(yc).forEach(function(e){rA.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),yc[t]=yc[e]})});function pT(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||yc.hasOwnProperty(e)&&yc[e]?(""+t).trim():t+"px"}function hT(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var r=n.indexOf("--")===0,s=pT(n,t[n],r);n==="float"&&(n="cssFloat"),r?e.setProperty(n,s):e[n]=s}}var sA=Bt({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Gv(e,t){if(t){if(sA[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(te(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(te(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(te(61))}if(t.style!=null&&typeof t.style!="object")throw Error(te(62))}}function Jv(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Qv=null;function Vb(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var Zv=null,wl=null,Sl=null;function dS(e){if(e=Ld(e)){if(typeof Zv!="function")throw Error(te(280));var t=e.stateNode;t&&(t=Lh(t),Zv(e.stateNode,e.type,t))}}function gT(e){wl?Sl?Sl.push(e):Sl=[e]:wl=e}function mT(){if(wl){var e=wl,t=Sl;if(Sl=wl=null,dS(e),t)for(e=0;e<t.length;e++)dS(t[e])}}function vT(e,t){return e(t)}function yT(){}var cm=!1;function bT(e,t,n){if(cm)return e(t,n);cm=!0;try{return vT(e,t,n)}finally{cm=!1,(wl!==null||Sl!==null)&&(yT(),mT())}}function Lc(e,t){var n=e.stateNode;if(n===null)return null;var r=Lh(n);if(r===null)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(e=e.type,r=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!r;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(te(231,t,typeof n));return n}var Yv=!1;if(fo)try{var Lu={};Object.defineProperty(Lu,"passive",{get:function(){Yv=!0}}),window.addEventListener("test",Lu,Lu),window.removeEventListener("test",Lu,Lu)}catch{Yv=!1}function oA(e,t,n,r,s,o,a,l,c){var i=Array.prototype.slice.call(arguments,3);try{t.apply(n,i)}catch(d){this.onError(d)}}var bc=!1,jp=null,Rp=!1,Xv=null,aA={onError:function(e){bc=!0,jp=e}};function iA(e,t,n,r,s,o,a,l,c){bc=!1,jp=null,oA.apply(aA,arguments)}function lA(e,t,n,r,s,o,a,l,c){if(iA.apply(this,arguments),bc){if(bc){var i=jp;bc=!1,jp=null}else throw Error(te(198));Rp||(Rp=!0,Xv=i)}}function Mi(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function xT(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function fS(e){if(Mi(e)!==e)throw Error(te(188))}function uA(e){var t=e.alternate;if(!t){if(t=Mi(e),t===null)throw Error(te(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(s===null)break;var o=s.alternate;if(o===null){if(r=s.return,r!==null){n=r;continue}break}if(s.child===o.child){for(o=s.child;o;){if(o===n)return fS(s),e;if(o===r)return fS(s),t;o=o.sibling}throw Error(te(188))}if(n.return!==r.return)n=s,r=o;else{for(var a=!1,l=s.child;l;){if(l===n){a=!0,n=s,r=o;break}if(l===r){a=!0,r=s,n=o;break}l=l.sibling}if(!a){for(l=o.child;l;){if(l===n){a=!0,n=o,r=s;break}if(l===r){a=!0,r=o,n=s;break}l=l.sibling}if(!a)throw Error(te(189))}}if(n.alternate!==r)throw Error(te(190))}if(n.tag!==3)throw Error(te(188));return n.stateNode.current===n?e:t}function wT(e){return e=uA(e),e!==null?ST(e):null}function ST(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=ST(e);if(t!==null)return t;e=e.sibling}return null}var CT=br.unstable_scheduleCallback,pS=br.unstable_cancelCallback,cA=br.unstable_shouldYield,dA=br.unstable_requestPaint,Jt=br.unstable_now,fA=br.unstable_getCurrentPriorityLevel,Hb=br.unstable_ImmediatePriority,ET=br.unstable_UserBlockingPriority,Pp=br.unstable_NormalPriority,pA=br.unstable_LowPriority,TT=br.unstable_IdlePriority,Ih=null,Ds=null;function hA(e){if(Ds&&typeof Ds.onCommitFiberRoot=="function")try{Ds.onCommitFiberRoot(Ih,e,void 0,(e.current.flags&128)===128)}catch{}}var ts=Math.clz32?Math.clz32:vA,gA=Math.log,mA=Math.LN2;function vA(e){return e>>>=0,e===0?32:31-(gA(e)/mA|0)|0}var gf=64,mf=4194304;function lc(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function Mp(e,t){var n=e.pendingLanes;if(n===0)return 0;var r=0,s=e.suspendedLanes,o=e.pingedLanes,a=n&268435455;if(a!==0){var l=a&~s;l!==0?r=lc(l):(o&=a,o!==0&&(r=lc(o)))}else a=n&~s,a!==0?r=lc(a):o!==0&&(r=lc(o));if(r===0)return 0;if(t!==0&&t!==r&&!(t&s)&&(s=r&-r,o=t&-t,s>=o||s===16&&(o&4194240)!==0))return t;if(r&4&&(r|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=r;0<t;)n=31-ts(t),s=1<<n,r|=e[n],t&=~s;return r}function yA(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function bA(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,o=e.pendingLanes;0<o;){var a=31-ts(o),l=1<<a,c=s[a];c===-1?(!(l&n)||l&r)&&(s[a]=yA(l,t)):c<=t&&(e.expiredLanes|=l),o&=~l}}function ey(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function kT(){var e=gf;return gf<<=1,!(gf&4194240)&&(gf=64),e}function dm(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Ad(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-ts(t),e[t]=n}function xA(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var s=31-ts(n),o=1<<s;t[s]=0,r[s]=-1,e[s]=-1,n&=~o}}function Kb(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-ts(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}var vt=0;function _T(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var jT,qb,RT,PT,MT,ty=!1,vf=[],ra=null,sa=null,oa=null,$c=new Map,Bc=new Map,zo=[],wA="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function hS(e,t){switch(e){case"focusin":case"focusout":ra=null;break;case"dragenter":case"dragleave":sa=null;break;case"mouseover":case"mouseout":oa=null;break;case"pointerover":case"pointerout":$c.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Bc.delete(t.pointerId)}}function $u(e,t,n,r,s,o){return e===null||e.nativeEvent!==o?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:o,targetContainers:[s]},t!==null&&(t=Ld(t),t!==null&&qb(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,s!==null&&t.indexOf(s)===-1&&t.push(s),e)}function SA(e,t,n,r,s){switch(t){case"focusin":return ra=$u(ra,e,t,n,r,s),!0;case"dragenter":return sa=$u(sa,e,t,n,r,s),!0;case"mouseover":return oa=$u(oa,e,t,n,r,s),!0;case"pointerover":var o=s.pointerId;return $c.set(o,$u($c.get(o)||null,e,t,n,r,s)),!0;case"gotpointercapture":return o=s.pointerId,Bc.set(o,$u(Bc.get(o)||null,e,t,n,r,s)),!0}return!1}function OT(e){var t=Va(e.target);if(t!==null){var n=Mi(t);if(n!==null){if(t=n.tag,t===13){if(t=xT(n),t!==null){e.blockedOn=t,MT(e.priority,function(){RT(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function ep(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=ny(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var r=new n.constructor(n.type,n);Qv=r,n.target.dispatchEvent(r),Qv=null}else return t=Ld(n),t!==null&&qb(t),e.blockedOn=n,!1;t.shift()}return!0}function gS(e,t,n){ep(e)&&n.delete(t)}function CA(){ty=!1,ra!==null&&ep(ra)&&(ra=null),sa!==null&&ep(sa)&&(sa=null),oa!==null&&ep(oa)&&(oa=null),$c.forEach(gS),Bc.forEach(gS)}function Bu(e,t){e.blockedOn===t&&(e.blockedOn=null,ty||(ty=!0,br.unstable_scheduleCallback(br.unstable_NormalPriority,CA)))}function zc(e){function t(s){return Bu(s,e)}if(0<vf.length){Bu(vf[0],e);for(var n=1;n<vf.length;n++){var r=vf[n];r.blockedOn===e&&(r.blockedOn=null)}}for(ra!==null&&Bu(ra,e),sa!==null&&Bu(sa,e),oa!==null&&Bu(oa,e),$c.forEach(t),Bc.forEach(t),n=0;n<zo.length;n++)r=zo[n],r.blockedOn===e&&(r.blockedOn=null);for(;0<zo.length&&(n=zo[0],n.blockedOn===null);)OT(n),n.blockedOn===null&&zo.shift()}var Cl=xo.ReactCurrentBatchConfig,Op=!0;function EA(e,t,n,r){var s=vt,o=Cl.transition;Cl.transition=null;try{vt=1,Wb(e,t,n,r)}finally{vt=s,Cl.transition=o}}function TA(e,t,n,r){var s=vt,o=Cl.transition;Cl.transition=null;try{vt=4,Wb(e,t,n,r)}finally{vt=s,Cl.transition=o}}function Wb(e,t,n,r){if(Op){var s=ny(e,t,n,r);if(s===null)wm(e,t,r,Np,n),hS(e,r);else if(SA(s,e,t,n,r))r.stopPropagation();else if(hS(e,r),t&4&&-1<wA.indexOf(e)){for(;s!==null;){var o=Ld(s);if(o!==null&&jT(o),o=ny(e,t,n,r),o===null&&wm(e,t,r,Np,n),o===s)break;s=o}s!==null&&r.stopPropagation()}else wm(e,t,r,null,n)}}var Np=null;function ny(e,t,n,r){if(Np=null,e=Vb(r),e=Va(e),e!==null)if(t=Mi(e),t===null)e=null;else if(n=t.tag,n===13){if(e=xT(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Np=e,null}function NT(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(fA()){case Hb:return 1;case ET:return 4;case Pp:case pA:return 16;case TT:return 536870912;default:return 16}default:return 16}}var Xo=null,Gb=null,tp=null;function IT(){if(tp)return tp;var e,t=Gb,n=t.length,r,s="value"in Xo?Xo.value:Xo.textContent,o=s.length;for(e=0;e<n&&t[e]===s[e];e++);var a=n-e;for(r=1;r<=a&&t[n-r]===s[o-r];r++);return tp=s.slice(e,1<r?1-r:void 0)}function np(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function yf(){return!0}function mS(){return!1}function Er(e){function t(n,r,s,o,a){this._reactName=n,this._targetInst=s,this.type=r,this.nativeEvent=o,this.target=a,this.currentTarget=null;for(var l in e)e.hasOwnProperty(l)&&(n=e[l],this[l]=n?n(o):o[l]);return this.isDefaultPrevented=(o.defaultPrevented!=null?o.defaultPrevented:o.returnValue===!1)?yf:mS,this.isPropagationStopped=mS,this}return Bt(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=yf)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=yf)},persist:function(){},isPersistent:yf}),t}var uu={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Jb=Er(uu),Fd=Bt({},uu,{view:0,detail:0}),kA=Er(Fd),fm,pm,zu,Dh=Bt({},Fd,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Qb,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==zu&&(zu&&e.type==="mousemove"?(fm=e.screenX-zu.screenX,pm=e.screenY-zu.screenY):pm=fm=0,zu=e),fm)},movementY:function(e){return"movementY"in e?e.movementY:pm}}),vS=Er(Dh),_A=Bt({},Dh,{dataTransfer:0}),jA=Er(_A),RA=Bt({},Fd,{relatedTarget:0}),hm=Er(RA),PA=Bt({},uu,{animationName:0,elapsedTime:0,pseudoElement:0}),MA=Er(PA),OA=Bt({},uu,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),NA=Er(OA),IA=Bt({},uu,{data:0}),yS=Er(IA),DA={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},AA={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},FA={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function LA(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=FA[e])?!!t[e]:!1}function Qb(){return LA}var $A=Bt({},Fd,{key:function(e){if(e.key){var t=DA[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=np(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?AA[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Qb,charCode:function(e){return e.type==="keypress"?np(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?np(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),BA=Er($A),zA=Bt({},Dh,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),bS=Er(zA),UA=Bt({},Fd,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Qb}),VA=Er(UA),HA=Bt({},uu,{propertyName:0,elapsedTime:0,pseudoElement:0}),KA=Er(HA),qA=Bt({},Dh,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),WA=Er(qA),GA=[9,13,27,32],Zb=fo&&"CompositionEvent"in window,xc=null;fo&&"documentMode"in document&&(xc=document.documentMode);var JA=fo&&"TextEvent"in window&&!xc,DT=fo&&(!Zb||xc&&8<xc&&11>=xc),xS=" ",wS=!1;function AT(e,t){switch(e){case"keyup":return GA.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function FT(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var ol=!1;function QA(e,t){switch(e){case"compositionend":return FT(t);case"keypress":return t.which!==32?null:(wS=!0,xS);case"textInput":return e=t.data,e===xS&&wS?null:e;default:return null}}function ZA(e,t){if(ol)return e==="compositionend"||!Zb&&AT(e,t)?(e=IT(),tp=Gb=Xo=null,ol=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return DT&&t.locale!=="ko"?null:t.data;default:return null}}var YA={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function SS(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!YA[e.type]:t==="textarea"}function LT(e,t,n,r){gT(r),t=Ip(t,"onChange"),0<t.length&&(n=new Jb("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var wc=null,Uc=null;function XA(e){JT(e,0)}function Ah(e){var t=ll(e);if(lT(t))return e}function eF(e,t){if(e==="change")return t}var $T=!1;if(fo){var gm;if(fo){var mm="oninput"in document;if(!mm){var CS=document.createElement("div");CS.setAttribute("oninput","return;"),mm=typeof CS.oninput=="function"}gm=mm}else gm=!1;$T=gm&&(!document.documentMode||9<document.documentMode)}function ES(){wc&&(wc.detachEvent("onpropertychange",BT),Uc=wc=null)}function BT(e){if(e.propertyName==="value"&&Ah(Uc)){var t=[];LT(t,Uc,e,Vb(e)),bT(XA,t)}}function tF(e,t,n){e==="focusin"?(ES(),wc=t,Uc=n,wc.attachEvent("onpropertychange",BT)):e==="focusout"&&ES()}function nF(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return Ah(Uc)}function rF(e,t){if(e==="click")return Ah(t)}function sF(e,t){if(e==="input"||e==="change")return Ah(t)}function oF(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var us=typeof Object.is=="function"?Object.is:oF;function Vc(e,t){if(us(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!Lv.call(t,s)||!us(e[s],t[s]))return!1}return!0}function TS(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function kS(e,t){var n=TS(e);e=0;for(var r;n;){if(n.nodeType===3){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=TS(n)}}function zT(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?zT(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function UT(){for(var e=window,t=_p();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=_p(e.document)}return t}function Yb(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function aF(e){var t=UT(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&zT(n.ownerDocument.documentElement,n)){if(r!==null&&Yb(n)){if(t=r.start,e=r.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var s=n.textContent.length,o=Math.min(r.start,s);r=r.end===void 0?o:Math.min(r.end,s),!e.extend&&o>r&&(s=r,r=o,o=s),s=kS(n,o);var a=kS(n,r);s&&a&&(e.rangeCount!==1||e.anchorNode!==s.node||e.anchorOffset!==s.offset||e.focusNode!==a.node||e.focusOffset!==a.offset)&&(t=t.createRange(),t.setStart(s.node,s.offset),e.removeAllRanges(),o>r?(e.addRange(t),e.extend(a.node,a.offset)):(t.setEnd(a.node,a.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var iF=fo&&"documentMode"in document&&11>=document.documentMode,al=null,ry=null,Sc=null,sy=!1;function _S(e,t,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;sy||al==null||al!==_p(r)||(r=al,"selectionStart"in r&&Yb(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Sc&&Vc(Sc,r)||(Sc=r,r=Ip(ry,"onSelect"),0<r.length&&(t=new Jb("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=al)))}function bf(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var il={animationend:bf("Animation","AnimationEnd"),animationiteration:bf("Animation","AnimationIteration"),animationstart:bf("Animation","AnimationStart"),transitionend:bf("Transition","TransitionEnd")},vm={},VT={};fo&&(VT=document.createElement("div").style,"AnimationEvent"in window||(delete il.animationend.animation,delete il.animationiteration.animation,delete il.animationstart.animation),"TransitionEvent"in window||delete il.transitionend.transition);function Fh(e){if(vm[e])return vm[e];if(!il[e])return e;var t=il[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in VT)return vm[e]=t[n];return e}var HT=Fh("animationend"),KT=Fh("animationiteration"),qT=Fh("animationstart"),WT=Fh("transitionend"),GT=new Map,jS="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Ca(e,t){GT.set(e,t),Pi(t,[e])}for(var ym=0;ym<jS.length;ym++){var bm=jS[ym],lF=bm.toLowerCase(),uF=bm[0].toUpperCase()+bm.slice(1);Ca(lF,"on"+uF)}Ca(HT,"onAnimationEnd");Ca(KT,"onAnimationIteration");Ca(qT,"onAnimationStart");Ca("dblclick","onDoubleClick");Ca("focusin","onFocus");Ca("focusout","onBlur");Ca(WT,"onTransitionEnd");ql("onMouseEnter",["mouseout","mouseover"]);ql("onMouseLeave",["mouseout","mouseover"]);ql("onPointerEnter",["pointerout","pointerover"]);ql("onPointerLeave",["pointerout","pointerover"]);Pi("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Pi("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Pi("onBeforeInput",["compositionend","keypress","textInput","paste"]);Pi("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Pi("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Pi("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var uc="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),cF=new Set("cancel close invalid load scroll toggle".split(" ").concat(uc));function RS(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,lA(r,t,void 0,e),e.currentTarget=null}function JT(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var o=void 0;if(t)for(var a=r.length-1;0<=a;a--){var l=r[a],c=l.instance,i=l.currentTarget;if(l=l.listener,c!==o&&s.isPropagationStopped())break e;RS(s,l,i),o=c}else for(a=0;a<r.length;a++){if(l=r[a],c=l.instance,i=l.currentTarget,l=l.listener,c!==o&&s.isPropagationStopped())break e;RS(s,l,i),o=c}}}if(Rp)throw e=Xv,Rp=!1,Xv=null,e}function jt(e,t){var n=t[uy];n===void 0&&(n=t[uy]=new Set);var r=e+"__bubble";n.has(r)||(QT(t,e,2,!1),n.add(r))}function xm(e,t,n){var r=0;t&&(r|=4),QT(n,e,r,t)}var xf="_reactListening"+Math.random().toString(36).slice(2);function Hc(e){if(!e[xf]){e[xf]=!0,rT.forEach(function(n){n!=="selectionchange"&&(cF.has(n)||xm(n,!1,e),xm(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[xf]||(t[xf]=!0,xm("selectionchange",!1,t))}}function QT(e,t,n,r){switch(NT(t)){case 1:var s=EA;break;case 4:s=TA;break;default:s=Wb}n=s.bind(null,t,n,e),s=void 0,!Yv||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(s=!0),r?s!==void 0?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):s!==void 0?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function wm(e,t,n,r,s){var o=r;if(!(t&1)&&!(t&2)&&r!==null)e:for(;;){if(r===null)return;var a=r.tag;if(a===3||a===4){var l=r.stateNode.containerInfo;if(l===s||l.nodeType===8&&l.parentNode===s)break;if(a===4)for(a=r.return;a!==null;){var c=a.tag;if((c===3||c===4)&&(c=a.stateNode.containerInfo,c===s||c.nodeType===8&&c.parentNode===s))return;a=a.return}for(;l!==null;){if(a=Va(l),a===null)return;if(c=a.tag,c===5||c===6){r=o=a;continue e}l=l.parentNode}}r=r.return}bT(function(){var i=o,d=Vb(n),p=[];e:{var f=GT.get(e);if(f!==void 0){var h=Jb,g=e;switch(e){case"keypress":if(np(n)===0)break e;case"keydown":case"keyup":h=BA;break;case"focusin":g="focus",h=hm;break;case"focusout":g="blur",h=hm;break;case"beforeblur":case"afterblur":h=hm;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":h=vS;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":h=jA;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":h=VA;break;case HT:case KT:case qT:h=MA;break;case WT:h=KA;break;case"scroll":h=kA;break;case"wheel":h=WA;break;case"copy":case"cut":case"paste":h=NA;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":h=bS}var m=(t&4)!==0,x=!m&&e==="scroll",b=m?f!==null?f+"Capture":null:f;m=[];for(var y=i,w;y!==null;){w=y;var S=w.stateNode;if(w.tag===5&&S!==null&&(w=S,b!==null&&(S=Lc(y,b),S!=null&&m.push(Kc(y,S,w)))),x)break;y=y.return}0<m.length&&(f=new h(f,g,null,n,d),p.push({event:f,listeners:m}))}}if(!(t&7)){e:{if(f=e==="mouseover"||e==="pointerover",h=e==="mouseout"||e==="pointerout",f&&n!==Qv&&(g=n.relatedTarget||n.fromElement)&&(Va(g)||g[po]))break e;if((h||f)&&(f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window,h?(g=n.relatedTarget||n.toElement,h=i,g=g?Va(g):null,g!==null&&(x=Mi(g),g!==x||g.tag!==5&&g.tag!==6)&&(g=null)):(h=null,g=i),h!==g)){if(m=vS,S="onMouseLeave",b="onMouseEnter",y="mouse",(e==="pointerout"||e==="pointerover")&&(m=bS,S="onPointerLeave",b="onPointerEnter",y="pointer"),x=h==null?f:ll(h),w=g==null?f:ll(g),f=new m(S,y+"leave",h,n,d),f.target=x,f.relatedTarget=w,S=null,Va(d)===i&&(m=new m(b,y+"enter",g,n,d),m.target=w,m.relatedTarget=x,S=m),x=S,h&&g)t:{for(m=h,b=g,y=0,w=m;w;w=Vi(w))y++;for(w=0,S=b;S;S=Vi(S))w++;for(;0<y-w;)m=Vi(m),y--;for(;0<w-y;)b=Vi(b),w--;for(;y--;){if(m===b||b!==null&&m===b.alternate)break t;m=Vi(m),b=Vi(b)}m=null}else m=null;h!==null&&PS(p,f,h,m,!1),g!==null&&x!==null&&PS(p,x,g,m,!0)}}e:{if(f=i?ll(i):window,h=f.nodeName&&f.nodeName.toLowerCase(),h==="select"||h==="input"&&f.type==="file")var E=eF;else if(SS(f))if($T)E=sF;else{E=nF;var C=tF}else(h=f.nodeName)&&h.toLowerCase()==="input"&&(f.type==="checkbox"||f.type==="radio")&&(E=rF);if(E&&(E=E(e,i))){LT(p,E,n,d);break e}C&&C(e,f,i),e==="focusout"&&(C=f._wrapperState)&&C.controlled&&f.type==="number"&&Kv(f,"number",f.value)}switch(C=i?ll(i):window,e){case"focusin":(SS(C)||C.contentEditable==="true")&&(al=C,ry=i,Sc=null);break;case"focusout":Sc=ry=al=null;break;case"mousedown":sy=!0;break;case"contextmenu":case"mouseup":case"dragend":sy=!1,_S(p,n,d);break;case"selectionchange":if(iF)break;case"keydown":case"keyup":_S(p,n,d)}var k;if(Zb)e:{switch(e){case"compositionstart":var T="onCompositionStart";break e;case"compositionend":T="onCompositionEnd";break e;case"compositionupdate":T="onCompositionUpdate";break e}T=void 0}else ol?AT(e,n)&&(T="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(T="onCompositionStart");T&&(DT&&n.locale!=="ko"&&(ol||T!=="onCompositionStart"?T==="onCompositionEnd"&&ol&&(k=IT()):(Xo=d,Gb="value"in Xo?Xo.value:Xo.textContent,ol=!0)),C=Ip(i,T),0<C.length&&(T=new yS(T,e,null,n,d),p.push({event:T,listeners:C}),k?T.data=k:(k=FT(n),k!==null&&(T.data=k)))),(k=JA?QA(e,n):ZA(e,n))&&(i=Ip(i,"onBeforeInput"),0<i.length&&(d=new yS("onBeforeInput","beforeinput",null,n,d),p.push({event:d,listeners:i}),d.data=k))}JT(p,t)})}function Kc(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Ip(e,t){for(var n=t+"Capture",r=[];e!==null;){var s=e,o=s.stateNode;s.tag===5&&o!==null&&(s=o,o=Lc(e,n),o!=null&&r.unshift(Kc(e,o,s)),o=Lc(e,t),o!=null&&r.push(Kc(e,o,s))),e=e.return}return r}function Vi(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function PS(e,t,n,r,s){for(var o=t._reactName,a=[];n!==null&&n!==r;){var l=n,c=l.alternate,i=l.stateNode;if(c!==null&&c===r)break;l.tag===5&&i!==null&&(l=i,s?(c=Lc(n,o),c!=null&&a.unshift(Kc(n,c,l))):s||(c=Lc(n,o),c!=null&&a.push(Kc(n,c,l)))),n=n.return}a.length!==0&&e.push({event:t,listeners:a})}var dF=/\r\n?/g,fF=/\u0000|\uFFFD/g;function MS(e){return(typeof e=="string"?e:""+e).replace(dF,`
`).replace(fF,"")}function wf(e,t,n){if(t=MS(t),MS(e)!==t&&n)throw Error(te(425))}function Dp(){}var oy=null,ay=null;function iy(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var ly=typeof setTimeout=="function"?setTimeout:void 0,pF=typeof clearTimeout=="function"?clearTimeout:void 0,OS=typeof Promise=="function"?Promise:void 0,hF=typeof queueMicrotask=="function"?queueMicrotask:typeof OS<"u"?function(e){return OS.resolve(null).then(e).catch(gF)}:ly;function gF(e){setTimeout(function(){throw e})}function Sm(e,t){var n=t,r=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&s.nodeType===8)if(n=s.data,n==="/$"){if(r===0){e.removeChild(s),zc(t);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=s}while(n);zc(t)}function aa(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function NS(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var cu=Math.random().toString(36).slice(2),ks="__reactFiber$"+cu,qc="__reactProps$"+cu,po="__reactContainer$"+cu,uy="__reactEvents$"+cu,mF="__reactListeners$"+cu,vF="__reactHandles$"+cu;function Va(e){var t=e[ks];if(t)return t;for(var n=e.parentNode;n;){if(t=n[po]||n[ks]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=NS(e);e!==null;){if(n=e[ks])return n;e=NS(e)}return t}e=n,n=e.parentNode}return null}function Ld(e){return e=e[ks]||e[po],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function ll(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(te(33))}function Lh(e){return e[qc]||null}var cy=[],ul=-1;function Ea(e){return{current:e}}function Pt(e){0>ul||(e.current=cy[ul],cy[ul]=null,ul--)}function Et(e,t){ul++,cy[ul]=e.current,e.current=t}var fa={},In=Ea(fa),tr=Ea(!1),mi=fa;function Wl(e,t){var n=e.type.contextTypes;if(!n)return fa;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var s={},o;for(o in n)s[o]=t[o];return r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function nr(e){return e=e.childContextTypes,e!=null}function Ap(){Pt(tr),Pt(In)}function IS(e,t,n){if(In.current!==fa)throw Error(te(168));Et(In,t),Et(tr,n)}function ZT(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var s in r)if(!(s in t))throw Error(te(108,tA(e)||"Unknown",s));return Bt({},n,r)}function Fp(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||fa,mi=In.current,Et(In,e),Et(tr,tr.current),!0}function DS(e,t,n){var r=e.stateNode;if(!r)throw Error(te(169));n?(e=ZT(e,t,mi),r.__reactInternalMemoizedMergedChildContext=e,Pt(tr),Pt(In),Et(In,e)):Pt(tr),Et(tr,n)}var eo=null,$h=!1,Cm=!1;function YT(e){eo===null?eo=[e]:eo.push(e)}function yF(e){$h=!0,YT(e)}function Ta(){if(!Cm&&eo!==null){Cm=!0;var e=0,t=vt;try{var n=eo;for(vt=1;e<n.length;e++){var r=n[e];do r=r(!0);while(r!==null)}eo=null,$h=!1}catch(s){throw eo!==null&&(eo=eo.slice(e+1)),CT(Hb,Ta),s}finally{vt=t,Cm=!1}}return null}var cl=[],dl=0,Lp=null,$p=0,Nr=[],Ir=0,vi=null,ro=1,so="";function $a(e,t){cl[dl++]=$p,cl[dl++]=Lp,Lp=e,$p=t}function XT(e,t,n){Nr[Ir++]=ro,Nr[Ir++]=so,Nr[Ir++]=vi,vi=e;var r=ro;e=so;var s=32-ts(r)-1;r&=~(1<<s),n+=1;var o=32-ts(t)+s;if(30<o){var a=s-s%5;o=(r&(1<<a)-1).toString(32),r>>=a,s-=a,ro=1<<32-ts(t)+s|n<<s|r,so=o+e}else ro=1<<o|n<<s|r,so=e}function Xb(e){e.return!==null&&($a(e,1),XT(e,1,0))}function ex(e){for(;e===Lp;)Lp=cl[--dl],cl[dl]=null,$p=cl[--dl],cl[dl]=null;for(;e===vi;)vi=Nr[--Ir],Nr[Ir]=null,so=Nr[--Ir],Nr[Ir]=null,ro=Nr[--Ir],Nr[Ir]=null}var mr=null,hr=null,Ot=!1,Zr=null;function ek(e,t){var n=Ar(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function AS(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,mr=e,hr=aa(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,mr=e,hr=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=vi!==null?{id:ro,overflow:so}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=Ar(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,mr=e,hr=null,!0):!1;default:return!1}}function dy(e){return(e.mode&1)!==0&&(e.flags&128)===0}function fy(e){if(Ot){var t=hr;if(t){var n=t;if(!AS(e,t)){if(dy(e))throw Error(te(418));t=aa(n.nextSibling);var r=mr;t&&AS(e,t)?ek(r,n):(e.flags=e.flags&-4097|2,Ot=!1,mr=e)}}else{if(dy(e))throw Error(te(418));e.flags=e.flags&-4097|2,Ot=!1,mr=e}}}function FS(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;mr=e}function Sf(e){if(e!==mr)return!1;if(!Ot)return FS(e),Ot=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!iy(e.type,e.memoizedProps)),t&&(t=hr)){if(dy(e))throw tk(),Error(te(418));for(;t;)ek(e,t),t=aa(t.nextSibling)}if(FS(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(te(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){hr=aa(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}hr=null}}else hr=mr?aa(e.stateNode.nextSibling):null;return!0}function tk(){for(var e=hr;e;)e=aa(e.nextSibling)}function Gl(){hr=mr=null,Ot=!1}function tx(e){Zr===null?Zr=[e]:Zr.push(e)}var bF=xo.ReactCurrentBatchConfig;function Uu(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(te(309));var r=n.stateNode}if(!r)throw Error(te(147,e));var s=r,o=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===o?t.ref:(t=function(a){var l=s.refs;a===null?delete l[o]:l[o]=a},t._stringRef=o,t)}if(typeof e!="string")throw Error(te(284));if(!n._owner)throw Error(te(290,e))}return e}function Cf(e,t){throw e=Object.prototype.toString.call(t),Error(te(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function LS(e){var t=e._init;return t(e._payload)}function nk(e){function t(b,y){if(e){var w=b.deletions;w===null?(b.deletions=[y],b.flags|=16):w.push(y)}}function n(b,y){if(!e)return null;for(;y!==null;)t(b,y),y=y.sibling;return null}function r(b,y){for(b=new Map;y!==null;)y.key!==null?b.set(y.key,y):b.set(y.index,y),y=y.sibling;return b}function s(b,y){return b=ca(b,y),b.index=0,b.sibling=null,b}function o(b,y,w){return b.index=w,e?(w=b.alternate,w!==null?(w=w.index,w<y?(b.flags|=2,y):w):(b.flags|=2,y)):(b.flags|=1048576,y)}function a(b){return e&&b.alternate===null&&(b.flags|=2),b}function l(b,y,w,S){return y===null||y.tag!==6?(y=Pm(w,b.mode,S),y.return=b,y):(y=s(y,w),y.return=b,y)}function c(b,y,w,S){var E=w.type;return E===sl?d(b,y,w.props.children,S,w.key):y!==null&&(y.elementType===E||typeof E=="object"&&E!==null&&E.$$typeof===$o&&LS(E)===y.type)?(S=s(y,w.props),S.ref=Uu(b,y,w),S.return=b,S):(S=up(w.type,w.key,w.props,null,b.mode,S),S.ref=Uu(b,y,w),S.return=b,S)}function i(b,y,w,S){return y===null||y.tag!==4||y.stateNode.containerInfo!==w.containerInfo||y.stateNode.implementation!==w.implementation?(y=Mm(w,b.mode,S),y.return=b,y):(y=s(y,w.children||[]),y.return=b,y)}function d(b,y,w,S,E){return y===null||y.tag!==7?(y=li(w,b.mode,S,E),y.return=b,y):(y=s(y,w),y.return=b,y)}function p(b,y,w){if(typeof y=="string"&&y!==""||typeof y=="number")return y=Pm(""+y,b.mode,w),y.return=b,y;if(typeof y=="object"&&y!==null){switch(y.$$typeof){case ff:return w=up(y.type,y.key,y.props,null,b.mode,w),w.ref=Uu(b,null,y),w.return=b,w;case rl:return y=Mm(y,b.mode,w),y.return=b,y;case $o:var S=y._init;return p(b,S(y._payload),w)}if(ic(y)||Fu(y))return y=li(y,b.mode,w,null),y.return=b,y;Cf(b,y)}return null}function f(b,y,w,S){var E=y!==null?y.key:null;if(typeof w=="string"&&w!==""||typeof w=="number")return E!==null?null:l(b,y,""+w,S);if(typeof w=="object"&&w!==null){switch(w.$$typeof){case ff:return w.key===E?c(b,y,w,S):null;case rl:return w.key===E?i(b,y,w,S):null;case $o:return E=w._init,f(b,y,E(w._payload),S)}if(ic(w)||Fu(w))return E!==null?null:d(b,y,w,S,null);Cf(b,w)}return null}function h(b,y,w,S,E){if(typeof S=="string"&&S!==""||typeof S=="number")return b=b.get(w)||null,l(y,b,""+S,E);if(typeof S=="object"&&S!==null){switch(S.$$typeof){case ff:return b=b.get(S.key===null?w:S.key)||null,c(y,b,S,E);case rl:return b=b.get(S.key===null?w:S.key)||null,i(y,b,S,E);case $o:var C=S._init;return h(b,y,w,C(S._payload),E)}if(ic(S)||Fu(S))return b=b.get(w)||null,d(y,b,S,E,null);Cf(y,S)}return null}function g(b,y,w,S){for(var E=null,C=null,k=y,T=y=0,P=null;k!==null&&T<w.length;T++){k.index>T?(P=k,k=null):P=k.sibling;var N=f(b,k,w[T],S);if(N===null){k===null&&(k=P);break}e&&k&&N.alternate===null&&t(b,k),y=o(N,y,T),C===null?E=N:C.sibling=N,C=N,k=P}if(T===w.length)return n(b,k),Ot&&$a(b,T),E;if(k===null){for(;T<w.length;T++)k=p(b,w[T],S),k!==null&&(y=o(k,y,T),C===null?E=k:C.sibling=k,C=k);return Ot&&$a(b,T),E}for(k=r(b,k);T<w.length;T++)P=h(k,b,T,w[T],S),P!==null&&(e&&P.alternate!==null&&k.delete(P.key===null?T:P.key),y=o(P,y,T),C===null?E=P:C.sibling=P,C=P);return e&&k.forEach(function(U){return t(b,U)}),Ot&&$a(b,T),E}function m(b,y,w,S){var E=Fu(w);if(typeof E!="function")throw Error(te(150));if(w=E.call(w),w==null)throw Error(te(151));for(var C=E=null,k=y,T=y=0,P=null,N=w.next();k!==null&&!N.done;T++,N=w.next()){k.index>T?(P=k,k=null):P=k.sibling;var U=f(b,k,N.value,S);if(U===null){k===null&&(k=P);break}e&&k&&U.alternate===null&&t(b,k),y=o(U,y,T),C===null?E=U:C.sibling=U,C=U,k=P}if(N.done)return n(b,k),Ot&&$a(b,T),E;if(k===null){for(;!N.done;T++,N=w.next())N=p(b,N.value,S),N!==null&&(y=o(N,y,T),C===null?E=N:C.sibling=N,C=N);return Ot&&$a(b,T),E}for(k=r(b,k);!N.done;T++,N=w.next())N=h(k,b,T,N.value,S),N!==null&&(e&&N.alternate!==null&&k.delete(N.key===null?T:N.key),y=o(N,y,T),C===null?E=N:C.sibling=N,C=N);return e&&k.forEach(function(I){return t(b,I)}),Ot&&$a(b,T),E}function x(b,y,w,S){if(typeof w=="object"&&w!==null&&w.type===sl&&w.key===null&&(w=w.props.children),typeof w=="object"&&w!==null){switch(w.$$typeof){case ff:e:{for(var E=w.key,C=y;C!==null;){if(C.key===E){if(E=w.type,E===sl){if(C.tag===7){n(b,C.sibling),y=s(C,w.props.children),y.return=b,b=y;break e}}else if(C.elementType===E||typeof E=="object"&&E!==null&&E.$$typeof===$o&&LS(E)===C.type){n(b,C.sibling),y=s(C,w.props),y.ref=Uu(b,C,w),y.return=b,b=y;break e}n(b,C);break}else t(b,C);C=C.sibling}w.type===sl?(y=li(w.props.children,b.mode,S,w.key),y.return=b,b=y):(S=up(w.type,w.key,w.props,null,b.mode,S),S.ref=Uu(b,y,w),S.return=b,b=S)}return a(b);case rl:e:{for(C=w.key;y!==null;){if(y.key===C)if(y.tag===4&&y.stateNode.containerInfo===w.containerInfo&&y.stateNode.implementation===w.implementation){n(b,y.sibling),y=s(y,w.children||[]),y.return=b,b=y;break e}else{n(b,y);break}else t(b,y);y=y.sibling}y=Mm(w,b.mode,S),y.return=b,b=y}return a(b);case $o:return C=w._init,x(b,y,C(w._payload),S)}if(ic(w))return g(b,y,w,S);if(Fu(w))return m(b,y,w,S);Cf(b,w)}return typeof w=="string"&&w!==""||typeof w=="number"?(w=""+w,y!==null&&y.tag===6?(n(b,y.sibling),y=s(y,w),y.return=b,b=y):(n(b,y),y=Pm(w,b.mode,S),y.return=b,b=y),a(b)):n(b,y)}return x}var Jl=nk(!0),rk=nk(!1),Bp=Ea(null),zp=null,fl=null,nx=null;function rx(){nx=fl=zp=null}function sx(e){var t=Bp.current;Pt(Bp),e._currentValue=t}function py(e,t,n){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,r!==null&&(r.childLanes|=t)):r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function El(e,t){zp=e,nx=fl=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(er=!0),e.firstContext=null)}function Br(e){var t=e._currentValue;if(nx!==e)if(e={context:e,memoizedValue:t,next:null},fl===null){if(zp===null)throw Error(te(308));fl=e,zp.dependencies={lanes:0,firstContext:e}}else fl=fl.next=e;return t}var Ha=null;function ox(e){Ha===null?Ha=[e]:Ha.push(e)}function sk(e,t,n,r){var s=t.interleaved;return s===null?(n.next=n,ox(t)):(n.next=s.next,s.next=n),t.interleaved=n,ho(e,r)}function ho(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var Bo=!1;function ax(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function ok(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function lo(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function ia(e,t,n){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,ct&2){var s=r.pending;return s===null?t.next=t:(t.next=s.next,s.next=t),r.pending=t,ho(e,n)}return s=r.interleaved,s===null?(t.next=t,ox(r)):(t.next=s.next,s.next=t),r.interleaved=t,ho(e,n)}function rp(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,Kb(e,n)}}function $S(e,t){var n=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var s=null,o=null;if(n=n.firstBaseUpdate,n!==null){do{var a={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};o===null?s=o=a:o=o.next=a,n=n.next}while(n!==null);o===null?s=o=t:o=o.next=t}else s=o=t;n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:o,shared:r.shared,effects:r.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Up(e,t,n,r){var s=e.updateQueue;Bo=!1;var o=s.firstBaseUpdate,a=s.lastBaseUpdate,l=s.shared.pending;if(l!==null){s.shared.pending=null;var c=l,i=c.next;c.next=null,a===null?o=i:a.next=i,a=c;var d=e.alternate;d!==null&&(d=d.updateQueue,l=d.lastBaseUpdate,l!==a&&(l===null?d.firstBaseUpdate=i:l.next=i,d.lastBaseUpdate=c))}if(o!==null){var p=s.baseState;a=0,d=i=c=null,l=o;do{var f=l.lane,h=l.eventTime;if((r&f)===f){d!==null&&(d=d.next={eventTime:h,lane:0,tag:l.tag,payload:l.payload,callback:l.callback,next:null});e:{var g=e,m=l;switch(f=t,h=n,m.tag){case 1:if(g=m.payload,typeof g=="function"){p=g.call(h,p,f);break e}p=g;break e;case 3:g.flags=g.flags&-65537|128;case 0:if(g=m.payload,f=typeof g=="function"?g.call(h,p,f):g,f==null)break e;p=Bt({},p,f);break e;case 2:Bo=!0}}l.callback!==null&&l.lane!==0&&(e.flags|=64,f=s.effects,f===null?s.effects=[l]:f.push(l))}else h={eventTime:h,lane:f,tag:l.tag,payload:l.payload,callback:l.callback,next:null},d===null?(i=d=h,c=p):d=d.next=h,a|=f;if(l=l.next,l===null){if(l=s.shared.pending,l===null)break;f=l,l=f.next,f.next=null,s.lastBaseUpdate=f,s.shared.pending=null}}while(!0);if(d===null&&(c=p),s.baseState=c,s.firstBaseUpdate=i,s.lastBaseUpdate=d,t=s.shared.interleaved,t!==null){s=t;do a|=s.lane,s=s.next;while(s!==t)}else o===null&&(s.shared.lanes=0);bi|=a,e.lanes=a,e.memoizedState=p}}function BS(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var r=e[t],s=r.callback;if(s!==null){if(r.callback=null,r=n,typeof s!="function")throw Error(te(191,s));s.call(r)}}}var $d={},As=Ea($d),Wc=Ea($d),Gc=Ea($d);function Ka(e){if(e===$d)throw Error(te(174));return e}function ix(e,t){switch(Et(Gc,t),Et(Wc,e),Et(As,$d),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:Wv(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=Wv(t,e)}Pt(As),Et(As,t)}function Ql(){Pt(As),Pt(Wc),Pt(Gc)}function ak(e){Ka(Gc.current);var t=Ka(As.current),n=Wv(t,e.type);t!==n&&(Et(Wc,e),Et(As,n))}function lx(e){Wc.current===e&&(Pt(As),Pt(Wc))}var Ft=Ea(0);function Vp(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Em=[];function ux(){for(var e=0;e<Em.length;e++)Em[e]._workInProgressVersionPrimary=null;Em.length=0}var sp=xo.ReactCurrentDispatcher,Tm=xo.ReactCurrentBatchConfig,yi=0,Lt=null,un=null,mn=null,Hp=!1,Cc=!1,Jc=0,xF=0;function jn(){throw Error(te(321))}function cx(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!us(e[n],t[n]))return!1;return!0}function dx(e,t,n,r,s,o){if(yi=o,Lt=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,sp.current=e===null||e.memoizedState===null?EF:TF,e=n(r,s),Cc){o=0;do{if(Cc=!1,Jc=0,25<=o)throw Error(te(301));o+=1,mn=un=null,t.updateQueue=null,sp.current=kF,e=n(r,s)}while(Cc)}if(sp.current=Kp,t=un!==null&&un.next!==null,yi=0,mn=un=Lt=null,Hp=!1,t)throw Error(te(300));return e}function fx(){var e=Jc!==0;return Jc=0,e}function ws(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return mn===null?Lt.memoizedState=mn=e:mn=mn.next=e,mn}function zr(){if(un===null){var e=Lt.alternate;e=e!==null?e.memoizedState:null}else e=un.next;var t=mn===null?Lt.memoizedState:mn.next;if(t!==null)mn=t,un=e;else{if(e===null)throw Error(te(310));un=e,e={memoizedState:un.memoizedState,baseState:un.baseState,baseQueue:un.baseQueue,queue:un.queue,next:null},mn===null?Lt.memoizedState=mn=e:mn=mn.next=e}return mn}function Qc(e,t){return typeof t=="function"?t(e):t}function km(e){var t=zr(),n=t.queue;if(n===null)throw Error(te(311));n.lastRenderedReducer=e;var r=un,s=r.baseQueue,o=n.pending;if(o!==null){if(s!==null){var a=s.next;s.next=o.next,o.next=a}r.baseQueue=s=o,n.pending=null}if(s!==null){o=s.next,r=r.baseState;var l=a=null,c=null,i=o;do{var d=i.lane;if((yi&d)===d)c!==null&&(c=c.next={lane:0,action:i.action,hasEagerState:i.hasEagerState,eagerState:i.eagerState,next:null}),r=i.hasEagerState?i.eagerState:e(r,i.action);else{var p={lane:d,action:i.action,hasEagerState:i.hasEagerState,eagerState:i.eagerState,next:null};c===null?(l=c=p,a=r):c=c.next=p,Lt.lanes|=d,bi|=d}i=i.next}while(i!==null&&i!==o);c===null?a=r:c.next=l,us(r,t.memoizedState)||(er=!0),t.memoizedState=r,t.baseState=a,t.baseQueue=c,n.lastRenderedState=r}if(e=n.interleaved,e!==null){s=e;do o=s.lane,Lt.lanes|=o,bi|=o,s=s.next;while(s!==e)}else s===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function _m(e){var t=zr(),n=t.queue;if(n===null)throw Error(te(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,o=t.memoizedState;if(s!==null){n.pending=null;var a=s=s.next;do o=e(o,a.action),a=a.next;while(a!==s);us(o,t.memoizedState)||(er=!0),t.memoizedState=o,t.baseQueue===null&&(t.baseState=o),n.lastRenderedState=o}return[o,r]}function ik(){}function lk(e,t){var n=Lt,r=zr(),s=t(),o=!us(r.memoizedState,s);if(o&&(r.memoizedState=s,er=!0),r=r.queue,px(dk.bind(null,n,r,e),[e]),r.getSnapshot!==t||o||mn!==null&&mn.memoizedState.tag&1){if(n.flags|=2048,Zc(9,ck.bind(null,n,r,s,t),void 0,null),vn===null)throw Error(te(349));yi&30||uk(n,t,s)}return s}function uk(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=Lt.updateQueue,t===null?(t={lastEffect:null,stores:null},Lt.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function ck(e,t,n,r){t.value=n,t.getSnapshot=r,fk(t)&&pk(e)}function dk(e,t,n){return n(function(){fk(t)&&pk(e)})}function fk(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!us(e,n)}catch{return!0}}function pk(e){var t=ho(e,1);t!==null&&ns(t,e,1,-1)}function zS(e){var t=ws();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Qc,lastRenderedState:e},t.queue=e,e=e.dispatch=CF.bind(null,Lt,e),[t.memoizedState,e]}function Zc(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},t=Lt.updateQueue,t===null?(t={lastEffect:null,stores:null},Lt.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e)),e}function hk(){return zr().memoizedState}function op(e,t,n,r){var s=ws();Lt.flags|=e,s.memoizedState=Zc(1|t,n,void 0,r===void 0?null:r)}function Bh(e,t,n,r){var s=zr();r=r===void 0?null:r;var o=void 0;if(un!==null){var a=un.memoizedState;if(o=a.destroy,r!==null&&cx(r,a.deps)){s.memoizedState=Zc(t,n,o,r);return}}Lt.flags|=e,s.memoizedState=Zc(1|t,n,o,r)}function US(e,t){return op(8390656,8,e,t)}function px(e,t){return Bh(2048,8,e,t)}function gk(e,t){return Bh(4,2,e,t)}function mk(e,t){return Bh(4,4,e,t)}function vk(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function yk(e,t,n){return n=n!=null?n.concat([e]):null,Bh(4,4,vk.bind(null,t,e),n)}function hx(){}function bk(e,t){var n=zr();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&cx(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function xk(e,t){var n=zr();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&cx(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function wk(e,t,n){return yi&21?(us(n,t)||(n=kT(),Lt.lanes|=n,bi|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,er=!0),e.memoizedState=n)}function wF(e,t){var n=vt;vt=n!==0&&4>n?n:4,e(!0);var r=Tm.transition;Tm.transition={};try{e(!1),t()}finally{vt=n,Tm.transition=r}}function Sk(){return zr().memoizedState}function SF(e,t,n){var r=ua(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ck(e))Ek(t,n);else if(n=sk(e,t,n,r),n!==null){var s=Hn();ns(n,e,r,s),Tk(n,t,r)}}function CF(e,t,n){var r=ua(e),s={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ck(e))Ek(t,s);else{var o=e.alternate;if(e.lanes===0&&(o===null||o.lanes===0)&&(o=t.lastRenderedReducer,o!==null))try{var a=t.lastRenderedState,l=o(a,n);if(s.hasEagerState=!0,s.eagerState=l,us(l,a)){var c=t.interleaved;c===null?(s.next=s,ox(t)):(s.next=c.next,c.next=s),t.interleaved=s;return}}catch{}finally{}n=sk(e,t,s,r),n!==null&&(s=Hn(),ns(n,e,r,s),Tk(n,t,r))}}function Ck(e){var t=e.alternate;return e===Lt||t!==null&&t===Lt}function Ek(e,t){Cc=Hp=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Tk(e,t,n){if(n&4194240){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,Kb(e,n)}}var Kp={readContext:Br,useCallback:jn,useContext:jn,useEffect:jn,useImperativeHandle:jn,useInsertionEffect:jn,useLayoutEffect:jn,useMemo:jn,useReducer:jn,useRef:jn,useState:jn,useDebugValue:jn,useDeferredValue:jn,useTransition:jn,useMutableSource:jn,useSyncExternalStore:jn,useId:jn,unstable_isNewReconciler:!1},EF={readContext:Br,useCallback:function(e,t){return ws().memoizedState=[e,t===void 0?null:t],e},useContext:Br,useEffect:US,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,op(4194308,4,vk.bind(null,t,e),n)},useLayoutEffect:function(e,t){return op(4194308,4,e,t)},useInsertionEffect:function(e,t){return op(4,2,e,t)},useMemo:function(e,t){var n=ws();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=ws();return t=n!==void 0?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=SF.bind(null,Lt,e),[r.memoizedState,e]},useRef:function(e){var t=ws();return e={current:e},t.memoizedState=e},useState:zS,useDebugValue:hx,useDeferredValue:function(e){return ws().memoizedState=e},useTransition:function(){var e=zS(!1),t=e[0];return e=wF.bind(null,e[1]),ws().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=Lt,s=ws();if(Ot){if(n===void 0)throw Error(te(407));n=n()}else{if(n=t(),vn===null)throw Error(te(349));yi&30||uk(r,t,n)}s.memoizedState=n;var o={value:n,getSnapshot:t};return s.queue=o,US(dk.bind(null,r,o,e),[e]),r.flags|=2048,Zc(9,ck.bind(null,r,o,n,t),void 0,null),n},useId:function(){var e=ws(),t=vn.identifierPrefix;if(Ot){var n=so,r=ro;n=(r&~(1<<32-ts(r)-1)).toString(32)+n,t=":"+t+"R"+n,n=Jc++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=xF++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},TF={readContext:Br,useCallback:bk,useContext:Br,useEffect:px,useImperativeHandle:yk,useInsertionEffect:gk,useLayoutEffect:mk,useMemo:xk,useReducer:km,useRef:hk,useState:function(){return km(Qc)},useDebugValue:hx,useDeferredValue:function(e){var t=zr();return wk(t,un.memoizedState,e)},useTransition:function(){var e=km(Qc)[0],t=zr().memoizedState;return[e,t]},useMutableSource:ik,useSyncExternalStore:lk,useId:Sk,unstable_isNewReconciler:!1},kF={readContext:Br,useCallback:bk,useContext:Br,useEffect:px,useImperativeHandle:yk,useInsertionEffect:gk,useLayoutEffect:mk,useMemo:xk,useReducer:_m,useRef:hk,useState:function(){return _m(Qc)},useDebugValue:hx,useDeferredValue:function(e){var t=zr();return un===null?t.memoizedState=e:wk(t,un.memoizedState,e)},useTransition:function(){var e=_m(Qc)[0],t=zr().memoizedState;return[e,t]},useMutableSource:ik,useSyncExternalStore:lk,useId:Sk,unstable_isNewReconciler:!1};function qr(e,t){if(e&&e.defaultProps){t=Bt({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}function hy(e,t,n,r){t=e.memoizedState,n=n(r,t),n=n==null?t:Bt({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var zh={isMounted:function(e){return(e=e._reactInternals)?Mi(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=Hn(),s=ua(e),o=lo(r,s);o.payload=t,n!=null&&(o.callback=n),t=ia(e,o,s),t!==null&&(ns(t,e,s,r),rp(t,e,s))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=Hn(),s=ua(e),o=lo(r,s);o.tag=1,o.payload=t,n!=null&&(o.callback=n),t=ia(e,o,s),t!==null&&(ns(t,e,s,r),rp(t,e,s))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=Hn(),r=ua(e),s=lo(n,r);s.tag=2,t!=null&&(s.callback=t),t=ia(e,s,r),t!==null&&(ns(t,e,r,n),rp(t,e,r))}};function VS(e,t,n,r,s,o,a){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(r,o,a):t.prototype&&t.prototype.isPureReactComponent?!Vc(n,r)||!Vc(s,o):!0}function kk(e,t,n){var r=!1,s=fa,o=t.contextType;return typeof o=="object"&&o!==null?o=Br(o):(s=nr(t)?mi:In.current,r=t.contextTypes,o=(r=r!=null)?Wl(e,s):fa),t=new t(n,o),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=zh,e.stateNode=t,t._reactInternals=e,r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=o),t}function HS(e,t,n,r){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,r),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&zh.enqueueReplaceState(t,t.state,null)}function gy(e,t,n,r){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs={},ax(e);var o=t.contextType;typeof o=="object"&&o!==null?s.context=Br(o):(o=nr(t)?mi:In.current,s.context=Wl(e,o)),s.state=e.memoizedState,o=t.getDerivedStateFromProps,typeof o=="function"&&(hy(e,t,o,n),s.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof s.getSnapshotBeforeUpdate=="function"||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(t=s.state,typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount(),t!==s.state&&zh.enqueueReplaceState(s,s.state,null),Up(e,n,s,r),s.state=e.memoizedState),typeof s.componentDidMount=="function"&&(e.flags|=4194308)}function Zl(e,t){try{var n="",r=t;do n+=eA(r),r=r.return;while(r);var s=n}catch(o){s=`
Error generating stack: `+o.message+`
`+o.stack}return{value:e,source:t,stack:s,digest:null}}function jm(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function my(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var _F=typeof WeakMap=="function"?WeakMap:Map;function _k(e,t,n){n=lo(-1,n),n.tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Wp||(Wp=!0,ky=r),my(e,t)},n}function jk(e,t,n){n=lo(-1,n),n.tag=3;var r=e.type.getDerivedStateFromError;if(typeof r=="function"){var s=t.value;n.payload=function(){return r(s)},n.callback=function(){my(e,t)}}var o=e.stateNode;return o!==null&&typeof o.componentDidCatch=="function"&&(n.callback=function(){my(e,t),typeof r!="function"&&(la===null?la=new Set([this]):la.add(this));var a=t.stack;this.componentDidCatch(t.value,{componentStack:a!==null?a:""})}),n}function KS(e,t,n){var r=e.pingCache;if(r===null){r=e.pingCache=new _F;var s=new Set;r.set(t,s)}else s=r.get(t),s===void 0&&(s=new Set,r.set(t,s));s.has(n)||(s.add(n),e=zF.bind(null,e,t,n),t.then(e,e))}function qS(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function WS(e,t,n,r,s){return e.mode&1?(e.flags|=65536,e.lanes=s,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=lo(-1,1),t.tag=2,ia(n,t,1))),n.lanes|=1),e)}var jF=xo.ReactCurrentOwner,er=!1;function zn(e,t,n,r){t.child=e===null?rk(t,null,n,r):Jl(t,e.child,n,r)}function GS(e,t,n,r,s){n=n.render;var o=t.ref;return El(t,s),r=dx(e,t,n,r,o,s),n=fx(),e!==null&&!er?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,go(e,t,s)):(Ot&&n&&Xb(t),t.flags|=1,zn(e,t,r,s),t.child)}function JS(e,t,n,r,s){if(e===null){var o=n.type;return typeof o=="function"&&!Sx(o)&&o.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=o,Rk(e,t,o,r,s)):(e=up(n.type,null,r,t,t.mode,s),e.ref=t.ref,e.return=t,t.child=e)}if(o=e.child,!(e.lanes&s)){var a=o.memoizedProps;if(n=n.compare,n=n!==null?n:Vc,n(a,r)&&e.ref===t.ref)return go(e,t,s)}return t.flags|=1,e=ca(o,r),e.ref=t.ref,e.return=t,t.child=e}function Rk(e,t,n,r,s){if(e!==null){var o=e.memoizedProps;if(Vc(o,r)&&e.ref===t.ref)if(er=!1,t.pendingProps=r=o,(e.lanes&s)!==0)e.flags&131072&&(er=!0);else return t.lanes=e.lanes,go(e,t,s)}return vy(e,t,n,r,s)}function Pk(e,t,n){var r=t.pendingProps,s=r.children,o=e!==null?e.memoizedState:null;if(r.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Et(hl,cr),cr|=n;else{if(!(n&1073741824))return e=o!==null?o.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Et(hl,cr),cr|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=o!==null?o.baseLanes:n,Et(hl,cr),cr|=r}else o!==null?(r=o.baseLanes|n,t.memoizedState=null):r=n,Et(hl,cr),cr|=r;return zn(e,t,s,n),t.child}function Mk(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function vy(e,t,n,r,s){var o=nr(n)?mi:In.current;return o=Wl(t,o),El(t,s),n=dx(e,t,n,r,o,s),r=fx(),e!==null&&!er?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,go(e,t,s)):(Ot&&r&&Xb(t),t.flags|=1,zn(e,t,n,s),t.child)}function QS(e,t,n,r,s){if(nr(n)){var o=!0;Fp(t)}else o=!1;if(El(t,s),t.stateNode===null)ap(e,t),kk(t,n,r),gy(t,n,r,s),r=!0;else if(e===null){var a=t.stateNode,l=t.memoizedProps;a.props=l;var c=a.context,i=n.contextType;typeof i=="object"&&i!==null?i=Br(i):(i=nr(n)?mi:In.current,i=Wl(t,i));var d=n.getDerivedStateFromProps,p=typeof d=="function"||typeof a.getSnapshotBeforeUpdate=="function";p||typeof a.UNSAFE_componentWillReceiveProps!="function"&&typeof a.componentWillReceiveProps!="function"||(l!==r||c!==i)&&HS(t,a,r,i),Bo=!1;var f=t.memoizedState;a.state=f,Up(t,r,a,s),c=t.memoizedState,l!==r||f!==c||tr.current||Bo?(typeof d=="function"&&(hy(t,n,d,r),c=t.memoizedState),(l=Bo||VS(t,n,l,r,f,c,i))?(p||typeof a.UNSAFE_componentWillMount!="function"&&typeof a.componentWillMount!="function"||(typeof a.componentWillMount=="function"&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount=="function"&&a.UNSAFE_componentWillMount()),typeof a.componentDidMount=="function"&&(t.flags|=4194308)):(typeof a.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=c),a.props=r,a.state=c,a.context=i,r=l):(typeof a.componentDidMount=="function"&&(t.flags|=4194308),r=!1)}else{a=t.stateNode,ok(e,t),l=t.memoizedProps,i=t.type===t.elementType?l:qr(t.type,l),a.props=i,p=t.pendingProps,f=a.context,c=n.contextType,typeof c=="object"&&c!==null?c=Br(c):(c=nr(n)?mi:In.current,c=Wl(t,c));var h=n.getDerivedStateFromProps;(d=typeof h=="function"||typeof a.getSnapshotBeforeUpdate=="function")||typeof a.UNSAFE_componentWillReceiveProps!="function"&&typeof a.componentWillReceiveProps!="function"||(l!==p||f!==c)&&HS(t,a,r,c),Bo=!1,f=t.memoizedState,a.state=f,Up(t,r,a,s);var g=t.memoizedState;l!==p||f!==g||tr.current||Bo?(typeof h=="function"&&(hy(t,n,h,r),g=t.memoizedState),(i=Bo||VS(t,n,i,r,f,g,c)||!1)?(d||typeof a.UNSAFE_componentWillUpdate!="function"&&typeof a.componentWillUpdate!="function"||(typeof a.componentWillUpdate=="function"&&a.componentWillUpdate(r,g,c),typeof a.UNSAFE_componentWillUpdate=="function"&&a.UNSAFE_componentWillUpdate(r,g,c)),typeof a.componentDidUpdate=="function"&&(t.flags|=4),typeof a.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof a.componentDidUpdate!="function"||l===e.memoizedProps&&f===e.memoizedState||(t.flags|=4),typeof a.getSnapshotBeforeUpdate!="function"||l===e.memoizedProps&&f===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=g),a.props=r,a.state=g,a.context=c,r=i):(typeof a.componentDidUpdate!="function"||l===e.memoizedProps&&f===e.memoizedState||(t.flags|=4),typeof a.getSnapshotBeforeUpdate!="function"||l===e.memoizedProps&&f===e.memoizedState||(t.flags|=1024),r=!1)}return yy(e,t,n,r,o,s)}function yy(e,t,n,r,s,o){Mk(e,t);var a=(t.flags&128)!==0;if(!r&&!a)return s&&DS(t,n,!1),go(e,t,o);r=t.stateNode,jF.current=t;var l=a&&typeof n.getDerivedStateFromError!="function"?null:r.render();return t.flags|=1,e!==null&&a?(t.child=Jl(t,e.child,null,o),t.child=Jl(t,null,l,o)):zn(e,t,l,o),t.memoizedState=r.state,s&&DS(t,n,!0),t.child}function Ok(e){var t=e.stateNode;t.pendingContext?IS(e,t.pendingContext,t.pendingContext!==t.context):t.context&&IS(e,t.context,!1),ix(e,t.containerInfo)}function ZS(e,t,n,r,s){return Gl(),tx(s),t.flags|=256,zn(e,t,n,r),t.child}var by={dehydrated:null,treeContext:null,retryLane:0};function xy(e){return{baseLanes:e,cachePool:null,transitions:null}}function Nk(e,t,n){var r=t.pendingProps,s=Ft.current,o=!1,a=(t.flags&128)!==0,l;if((l=a)||(l=e!==null&&e.memoizedState===null?!1:(s&2)!==0),l?(o=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(s|=1),Et(Ft,s&1),e===null)return fy(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(a=r.children,e=r.fallback,o?(r=t.mode,o=t.child,a={mode:"hidden",children:a},!(r&1)&&o!==null?(o.childLanes=0,o.pendingProps=a):o=Hh(a,r,0,null),e=li(e,r,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=xy(n),t.memoizedState=by,e):gx(t,a));if(s=e.memoizedState,s!==null&&(l=s.dehydrated,l!==null))return RF(e,t,a,r,l,s,n);if(o){o=r.fallback,a=t.mode,s=e.child,l=s.sibling;var c={mode:"hidden",children:r.children};return!(a&1)&&t.child!==s?(r=t.child,r.childLanes=0,r.pendingProps=c,t.deletions=null):(r=ca(s,c),r.subtreeFlags=s.subtreeFlags&14680064),l!==null?o=ca(l,o):(o=li(o,a,n,null),o.flags|=2),o.return=t,r.return=t,r.sibling=o,t.child=r,r=o,o=t.child,a=e.child.memoizedState,a=a===null?xy(n):{baseLanes:a.baseLanes|n,cachePool:null,transitions:a.transitions},o.memoizedState=a,o.childLanes=e.childLanes&~n,t.memoizedState=by,r}return o=e.child,e=o.sibling,r=ca(o,{mode:"visible",children:r.children}),!(t.mode&1)&&(r.lanes=n),r.return=t,r.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function gx(e,t){return t=Hh({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function Ef(e,t,n,r){return r!==null&&tx(r),Jl(t,e.child,null,n),e=gx(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function RF(e,t,n,r,s,o,a){if(n)return t.flags&256?(t.flags&=-257,r=jm(Error(te(422))),Ef(e,t,a,r)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(o=r.fallback,s=t.mode,r=Hh({mode:"visible",children:r.children},s,0,null),o=li(o,s,a,null),o.flags|=2,r.return=t,o.return=t,r.sibling=o,t.child=r,t.mode&1&&Jl(t,e.child,null,a),t.child.memoizedState=xy(a),t.memoizedState=by,o);if(!(t.mode&1))return Ef(e,t,a,null);if(s.data==="$!"){if(r=s.nextSibling&&s.nextSibling.dataset,r)var l=r.dgst;return r=l,o=Error(te(419)),r=jm(o,r,void 0),Ef(e,t,a,r)}if(l=(a&e.childLanes)!==0,er||l){if(r=vn,r!==null){switch(a&-a){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}s=s&(r.suspendedLanes|a)?0:s,s!==0&&s!==o.retryLane&&(o.retryLane=s,ho(e,s),ns(r,e,s,-1))}return wx(),r=jm(Error(te(421))),Ef(e,t,a,r)}return s.data==="$?"?(t.flags|=128,t.child=e.child,t=UF.bind(null,e),s._reactRetry=t,null):(e=o.treeContext,hr=aa(s.nextSibling),mr=t,Ot=!0,Zr=null,e!==null&&(Nr[Ir++]=ro,Nr[Ir++]=so,Nr[Ir++]=vi,ro=e.id,so=e.overflow,vi=t),t=gx(t,r.children),t.flags|=4096,t)}function YS(e,t,n){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),py(e.return,t,n)}function Rm(e,t,n,r,s){var o=e.memoizedState;o===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=r,o.tail=n,o.tailMode=s)}function Ik(e,t,n){var r=t.pendingProps,s=r.revealOrder,o=r.tail;if(zn(e,t,r.children,n),r=Ft.current,r&2)r=r&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&YS(e,n,t);else if(e.tag===19)YS(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Et(Ft,r),!(t.mode&1))t.memoizedState=null;else switch(s){case"forwards":for(n=t.child,s=null;n!==null;)e=n.alternate,e!==null&&Vp(e)===null&&(s=n),n=n.sibling;n=s,n===null?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),Rm(t,!1,s,n,o);break;case"backwards":for(n=null,s=t.child,t.child=null;s!==null;){if(e=s.alternate,e!==null&&Vp(e)===null){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}Rm(t,!0,n,null,o);break;case"together":Rm(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function ap(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function go(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),bi|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(te(153));if(t.child!==null){for(e=t.child,n=ca(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=ca(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function PF(e,t,n){switch(t.tag){case 3:Ok(t),Gl();break;case 5:ak(t);break;case 1:nr(t.type)&&Fp(t);break;case 4:ix(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,s=t.memoizedProps.value;Et(Bp,r._currentValue),r._currentValue=s;break;case 13:if(r=t.memoizedState,r!==null)return r.dehydrated!==null?(Et(Ft,Ft.current&1),t.flags|=128,null):n&t.child.childLanes?Nk(e,t,n):(Et(Ft,Ft.current&1),e=go(e,t,n),e!==null?e.sibling:null);Et(Ft,Ft.current&1);break;case 19:if(r=(n&t.childLanes)!==0,e.flags&128){if(r)return Ik(e,t,n);t.flags|=128}if(s=t.memoizedState,s!==null&&(s.rendering=null,s.tail=null,s.lastEffect=null),Et(Ft,Ft.current),r)break;return null;case 22:case 23:return t.lanes=0,Pk(e,t,n)}return go(e,t,n)}var Dk,wy,Ak,Fk;Dk=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};wy=function(){};Ak=function(e,t,n,r){var s=e.memoizedProps;if(s!==r){e=t.stateNode,Ka(As.current);var o=null;switch(n){case"input":s=Vv(e,s),r=Vv(e,r),o=[];break;case"select":s=Bt({},s,{value:void 0}),r=Bt({},r,{value:void 0}),o=[];break;case"textarea":s=qv(e,s),r=qv(e,r),o=[];break;default:typeof s.onClick!="function"&&typeof r.onClick=="function"&&(e.onclick=Dp)}Gv(n,r);var a;n=null;for(i in s)if(!r.hasOwnProperty(i)&&s.hasOwnProperty(i)&&s[i]!=null)if(i==="style"){var l=s[i];for(a in l)l.hasOwnProperty(a)&&(n||(n={}),n[a]="")}else i!=="dangerouslySetInnerHTML"&&i!=="children"&&i!=="suppressContentEditableWarning"&&i!=="suppressHydrationWarning"&&i!=="autoFocus"&&(Ac.hasOwnProperty(i)?o||(o=[]):(o=o||[]).push(i,null));for(i in r){var c=r[i];if(l=s!=null?s[i]:void 0,r.hasOwnProperty(i)&&c!==l&&(c!=null||l!=null))if(i==="style")if(l){for(a in l)!l.hasOwnProperty(a)||c&&c.hasOwnProperty(a)||(n||(n={}),n[a]="");for(a in c)c.hasOwnProperty(a)&&l[a]!==c[a]&&(n||(n={}),n[a]=c[a])}else n||(o||(o=[]),o.push(i,n)),n=c;else i==="dangerouslySetInnerHTML"?(c=c?c.__html:void 0,l=l?l.__html:void 0,c!=null&&l!==c&&(o=o||[]).push(i,c)):i==="children"?typeof c!="string"&&typeof c!="number"||(o=o||[]).push(i,""+c):i!=="suppressContentEditableWarning"&&i!=="suppressHydrationWarning"&&(Ac.hasOwnProperty(i)?(c!=null&&i==="onScroll"&&jt("scroll",e),o||l===c||(o=[])):(o=o||[]).push(i,c))}n&&(o=o||[]).push("style",n);var i=o;(t.updateQueue=i)&&(t.flags|=4)}};Fk=function(e,t,n,r){n!==r&&(t.flags|=4)};function Vu(e,t){if(!Ot)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Rn(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags&14680064,r|=s.flags&14680064,s.return=e,s=s.sibling;else for(s=e.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function MF(e,t,n){var r=t.pendingProps;switch(ex(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Rn(t),null;case 1:return nr(t.type)&&Ap(),Rn(t),null;case 3:return r=t.stateNode,Ql(),Pt(tr),Pt(In),ux(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(e===null||e.child===null)&&(Sf(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,Zr!==null&&(Ry(Zr),Zr=null))),wy(e,t),Rn(t),null;case 5:lx(t);var s=Ka(Gc.current);if(n=t.type,e!==null&&t.stateNode!=null)Ak(e,t,n,r,s),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(t.stateNode===null)throw Error(te(166));return Rn(t),null}if(e=Ka(As.current),Sf(t)){r=t.stateNode,n=t.type;var o=t.memoizedProps;switch(r[ks]=t,r[qc]=o,e=(t.mode&1)!==0,n){case"dialog":jt("cancel",r),jt("close",r);break;case"iframe":case"object":case"embed":jt("load",r);break;case"video":case"audio":for(s=0;s<uc.length;s++)jt(uc[s],r);break;case"source":jt("error",r);break;case"img":case"image":case"link":jt("error",r),jt("load",r);break;case"details":jt("toggle",r);break;case"input":iS(r,o),jt("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!o.multiple},jt("invalid",r);break;case"textarea":uS(r,o),jt("invalid",r)}Gv(n,o),s=null;for(var a in o)if(o.hasOwnProperty(a)){var l=o[a];a==="children"?typeof l=="string"?r.textContent!==l&&(o.suppressHydrationWarning!==!0&&wf(r.textContent,l,e),s=["children",l]):typeof l=="number"&&r.textContent!==""+l&&(o.suppressHydrationWarning!==!0&&wf(r.textContent,l,e),s=["children",""+l]):Ac.hasOwnProperty(a)&&l!=null&&a==="onScroll"&&jt("scroll",r)}switch(n){case"input":pf(r),lS(r,o,!0);break;case"textarea":pf(r),cS(r);break;case"select":case"option":break;default:typeof o.onClick=="function"&&(r.onclick=Dp)}r=s,t.updateQueue=r,r!==null&&(t.flags|=4)}else{a=s.nodeType===9?s:s.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=dT(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=a.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof r.is=="string"?e=a.createElement(n,{is:r.is}):(e=a.createElement(n),n==="select"&&(a=e,r.multiple?a.multiple=!0:r.size&&(a.size=r.size))):e=a.createElementNS(e,n),e[ks]=t,e[qc]=r,Dk(e,t,!1,!1),t.stateNode=e;e:{switch(a=Jv(n,r),n){case"dialog":jt("cancel",e),jt("close",e),s=r;break;case"iframe":case"object":case"embed":jt("load",e),s=r;break;case"video":case"audio":for(s=0;s<uc.length;s++)jt(uc[s],e);s=r;break;case"source":jt("error",e),s=r;break;case"img":case"image":case"link":jt("error",e),jt("load",e),s=r;break;case"details":jt("toggle",e),s=r;break;case"input":iS(e,r),s=Vv(e,r),jt("invalid",e);break;case"option":s=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},s=Bt({},r,{value:void 0}),jt("invalid",e);break;case"textarea":uS(e,r),s=qv(e,r),jt("invalid",e);break;default:s=r}Gv(n,s),l=s;for(o in l)if(l.hasOwnProperty(o)){var c=l[o];o==="style"?hT(e,c):o==="dangerouslySetInnerHTML"?(c=c?c.__html:void 0,c!=null&&fT(e,c)):o==="children"?typeof c=="string"?(n!=="textarea"||c!=="")&&Fc(e,c):typeof c=="number"&&Fc(e,""+c):o!=="suppressContentEditableWarning"&&o!=="suppressHydrationWarning"&&o!=="autoFocus"&&(Ac.hasOwnProperty(o)?c!=null&&o==="onScroll"&&jt("scroll",e):c!=null&&$b(e,o,c,a))}switch(n){case"input":pf(e),lS(e,r,!1);break;case"textarea":pf(e),cS(e);break;case"option":r.value!=null&&e.setAttribute("value",""+da(r.value));break;case"select":e.multiple=!!r.multiple,o=r.value,o!=null?xl(e,!!r.multiple,o,!1):r.defaultValue!=null&&xl(e,!!r.multiple,r.defaultValue,!0);break;default:typeof s.onClick=="function"&&(e.onclick=Dp)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return Rn(t),null;case 6:if(e&&t.stateNode!=null)Fk(e,t,e.memoizedProps,r);else{if(typeof r!="string"&&t.stateNode===null)throw Error(te(166));if(n=Ka(Gc.current),Ka(As.current),Sf(t)){if(r=t.stateNode,n=t.memoizedProps,r[ks]=t,(o=r.nodeValue!==n)&&(e=mr,e!==null))switch(e.tag){case 3:wf(r.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&wf(r.nodeValue,n,(e.mode&1)!==0)}o&&(t.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[ks]=t,t.stateNode=r}return Rn(t),null;case 13:if(Pt(Ft),r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(Ot&&hr!==null&&t.mode&1&&!(t.flags&128))tk(),Gl(),t.flags|=98560,o=!1;else if(o=Sf(t),r!==null&&r.dehydrated!==null){if(e===null){if(!o)throw Error(te(318));if(o=t.memoizedState,o=o!==null?o.dehydrated:null,!o)throw Error(te(317));o[ks]=t}else Gl(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;Rn(t),o=!1}else Zr!==null&&(Ry(Zr),Zr=null),o=!0;if(!o)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(r=r!==null,r!==(e!==null&&e.memoizedState!==null)&&r&&(t.child.flags|=8192,t.mode&1&&(e===null||Ft.current&1?dn===0&&(dn=3):wx())),t.updateQueue!==null&&(t.flags|=4),Rn(t),null);case 4:return Ql(),wy(e,t),e===null&&Hc(t.stateNode.containerInfo),Rn(t),null;case 10:return sx(t.type._context),Rn(t),null;case 17:return nr(t.type)&&Ap(),Rn(t),null;case 19:if(Pt(Ft),o=t.memoizedState,o===null)return Rn(t),null;if(r=(t.flags&128)!==0,a=o.rendering,a===null)if(r)Vu(o,!1);else{if(dn!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(a=Vp(e),a!==null){for(t.flags|=128,Vu(o,!1),r=a.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;n!==null;)o=n,e=r,o.flags&=14680066,a=o.alternate,a===null?(o.childLanes=0,o.lanes=e,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=a.childLanes,o.lanes=a.lanes,o.child=a.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=a.memoizedProps,o.memoizedState=a.memoizedState,o.updateQueue=a.updateQueue,o.type=a.type,e=a.dependencies,o.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Et(Ft,Ft.current&1|2),t.child}e=e.sibling}o.tail!==null&&Jt()>Yl&&(t.flags|=128,r=!0,Vu(o,!1),t.lanes=4194304)}else{if(!r)if(e=Vp(a),e!==null){if(t.flags|=128,r=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),Vu(o,!0),o.tail===null&&o.tailMode==="hidden"&&!a.alternate&&!Ot)return Rn(t),null}else 2*Jt()-o.renderingStartTime>Yl&&n!==1073741824&&(t.flags|=128,r=!0,Vu(o,!1),t.lanes=4194304);o.isBackwards?(a.sibling=t.child,t.child=a):(n=o.last,n!==null?n.sibling=a:t.child=a,o.last=a)}return o.tail!==null?(t=o.tail,o.rendering=t,o.tail=t.sibling,o.renderingStartTime=Jt(),t.sibling=null,n=Ft.current,Et(Ft,r?n&1|2:n&1),t):(Rn(t),null);case 22:case 23:return xx(),r=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==r&&(t.flags|=8192),r&&t.mode&1?cr&1073741824&&(Rn(t),t.subtreeFlags&6&&(t.flags|=8192)):Rn(t),null;case 24:return null;case 25:return null}throw Error(te(156,t.tag))}function OF(e,t){switch(ex(t),t.tag){case 1:return nr(t.type)&&Ap(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return Ql(),Pt(tr),Pt(In),ux(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return lx(t),null;case 13:if(Pt(Ft),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(te(340));Gl()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return Pt(Ft),null;case 4:return Ql(),null;case 10:return sx(t.type._context),null;case 22:case 23:return xx(),null;case 24:return null;default:return null}}var Tf=!1,Nn=!1,NF=typeof WeakSet=="function"?WeakSet:Set,we=null;function pl(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){Kt(e,t,r)}else n.current=null}function Sy(e,t,n){try{n()}catch(r){Kt(e,t,r)}}var XS=!1;function IF(e,t){if(oy=Op,e=UT(),Yb(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var s=r.anchorOffset,o=r.focusNode;r=r.focusOffset;try{n.nodeType,o.nodeType}catch{n=null;break e}var a=0,l=-1,c=-1,i=0,d=0,p=e,f=null;t:for(;;){for(var h;p!==n||s!==0&&p.nodeType!==3||(l=a+s),p!==o||r!==0&&p.nodeType!==3||(c=a+r),p.nodeType===3&&(a+=p.nodeValue.length),(h=p.firstChild)!==null;)f=p,p=h;for(;;){if(p===e)break t;if(f===n&&++i===s&&(l=a),f===o&&++d===r&&(c=a),(h=p.nextSibling)!==null)break;p=f,f=p.parentNode}p=h}n=l===-1||c===-1?null:{start:l,end:c}}else n=null}n=n||{start:0,end:0}}else n=null;for(ay={focusedElem:e,selectionRange:n},Op=!1,we=t;we!==null;)if(t=we,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,we=e;else for(;we!==null;){t=we;try{var g=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(g!==null){var m=g.memoizedProps,x=g.memoizedState,b=t.stateNode,y=b.getSnapshotBeforeUpdate(t.elementType===t.type?m:qr(t.type,m),x);b.__reactInternalSnapshotBeforeUpdate=y}break;case 3:var w=t.stateNode.containerInfo;w.nodeType===1?w.textContent="":w.nodeType===9&&w.documentElement&&w.removeChild(w.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(te(163))}}catch(S){Kt(t,t.return,S)}if(e=t.sibling,e!==null){e.return=t.return,we=e;break}we=t.return}return g=XS,XS=!1,g}function Ec(e,t,n){var r=t.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var s=r=r.next;do{if((s.tag&e)===e){var o=s.destroy;s.destroy=void 0,o!==void 0&&Sy(t,n,o)}s=s.next}while(s!==r)}}function Uh(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function Cy(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function Lk(e){var t=e.alternate;t!==null&&(e.alternate=null,Lk(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[ks],delete t[qc],delete t[uy],delete t[mF],delete t[vF])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function $k(e){return e.tag===5||e.tag===3||e.tag===4}function e0(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||$k(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function Ey(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=Dp));else if(r!==4&&(e=e.child,e!==null))for(Ey(e,t,n),e=e.sibling;e!==null;)Ey(e,t,n),e=e.sibling}function Ty(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(r!==4&&(e=e.child,e!==null))for(Ty(e,t,n),e=e.sibling;e!==null;)Ty(e,t,n),e=e.sibling}var Sn=null,Gr=!1;function Mo(e,t,n){for(n=n.child;n!==null;)Bk(e,t,n),n=n.sibling}function Bk(e,t,n){if(Ds&&typeof Ds.onCommitFiberUnmount=="function")try{Ds.onCommitFiberUnmount(Ih,n)}catch{}switch(n.tag){case 5:Nn||pl(n,t);case 6:var r=Sn,s=Gr;Sn=null,Mo(e,t,n),Sn=r,Gr=s,Sn!==null&&(Gr?(e=Sn,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):Sn.removeChild(n.stateNode));break;case 18:Sn!==null&&(Gr?(e=Sn,n=n.stateNode,e.nodeType===8?Sm(e.parentNode,n):e.nodeType===1&&Sm(e,n),zc(e)):Sm(Sn,n.stateNode));break;case 4:r=Sn,s=Gr,Sn=n.stateNode.containerInfo,Gr=!0,Mo(e,t,n),Sn=r,Gr=s;break;case 0:case 11:case 14:case 15:if(!Nn&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){s=r=r.next;do{var o=s,a=o.destroy;o=o.tag,a!==void 0&&(o&2||o&4)&&Sy(n,t,a),s=s.next}while(s!==r)}Mo(e,t,n);break;case 1:if(!Nn&&(pl(n,t),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(l){Kt(n,t,l)}Mo(e,t,n);break;case 21:Mo(e,t,n);break;case 22:n.mode&1?(Nn=(r=Nn)||n.memoizedState!==null,Mo(e,t,n),Nn=r):Mo(e,t,n);break;default:Mo(e,t,n)}}function t0(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new NF),t.forEach(function(r){var s=VF.bind(null,e,r);n.has(r)||(n.add(r),r.then(s,s))})}}function Kr(e,t){var n=t.deletions;if(n!==null)for(var r=0;r<n.length;r++){var s=n[r];try{var o=e,a=t,l=a;e:for(;l!==null;){switch(l.tag){case 5:Sn=l.stateNode,Gr=!1;break e;case 3:Sn=l.stateNode.containerInfo,Gr=!0;break e;case 4:Sn=l.stateNode.containerInfo,Gr=!0;break e}l=l.return}if(Sn===null)throw Error(te(160));Bk(o,a,s),Sn=null,Gr=!1;var c=s.alternate;c!==null&&(c.return=null),s.return=null}catch(i){Kt(s,t,i)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)zk(t,e),t=t.sibling}function zk(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(Kr(t,e),bs(e),r&4){try{Ec(3,e,e.return),Uh(3,e)}catch(m){Kt(e,e.return,m)}try{Ec(5,e,e.return)}catch(m){Kt(e,e.return,m)}}break;case 1:Kr(t,e),bs(e),r&512&&n!==null&&pl(n,n.return);break;case 5:if(Kr(t,e),bs(e),r&512&&n!==null&&pl(n,n.return),e.flags&32){var s=e.stateNode;try{Fc(s,"")}catch(m){Kt(e,e.return,m)}}if(r&4&&(s=e.stateNode,s!=null)){var o=e.memoizedProps,a=n!==null?n.memoizedProps:o,l=e.type,c=e.updateQueue;if(e.updateQueue=null,c!==null)try{l==="input"&&o.type==="radio"&&o.name!=null&&uT(s,o),Jv(l,a);var i=Jv(l,o);for(a=0;a<c.length;a+=2){var d=c[a],p=c[a+1];d==="style"?hT(s,p):d==="dangerouslySetInnerHTML"?fT(s,p):d==="children"?Fc(s,p):$b(s,d,p,i)}switch(l){case"input":Hv(s,o);break;case"textarea":cT(s,o);break;case"select":var f=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!o.multiple;var h=o.value;h!=null?xl(s,!!o.multiple,h,!1):f!==!!o.multiple&&(o.defaultValue!=null?xl(s,!!o.multiple,o.defaultValue,!0):xl(s,!!o.multiple,o.multiple?[]:"",!1))}s[qc]=o}catch(m){Kt(e,e.return,m)}}break;case 6:if(Kr(t,e),bs(e),r&4){if(e.stateNode===null)throw Error(te(162));s=e.stateNode,o=e.memoizedProps;try{s.nodeValue=o}catch(m){Kt(e,e.return,m)}}break;case 3:if(Kr(t,e),bs(e),r&4&&n!==null&&n.memoizedState.isDehydrated)try{zc(t.containerInfo)}catch(m){Kt(e,e.return,m)}break;case 4:Kr(t,e),bs(e);break;case 13:Kr(t,e),bs(e),s=e.child,s.flags&8192&&(o=s.memoizedState!==null,s.stateNode.isHidden=o,!o||s.alternate!==null&&s.alternate.memoizedState!==null||(yx=Jt())),r&4&&t0(e);break;case 22:if(d=n!==null&&n.memoizedState!==null,e.mode&1?(Nn=(i=Nn)||d,Kr(t,e),Nn=i):Kr(t,e),bs(e),r&8192){if(i=e.memoizedState!==null,(e.stateNode.isHidden=i)&&!d&&e.mode&1)for(we=e,d=e.child;d!==null;){for(p=we=d;we!==null;){switch(f=we,h=f.child,f.tag){case 0:case 11:case 14:case 15:Ec(4,f,f.return);break;case 1:pl(f,f.return);var g=f.stateNode;if(typeof g.componentWillUnmount=="function"){r=f,n=f.return;try{t=r,g.props=t.memoizedProps,g.state=t.memoizedState,g.componentWillUnmount()}catch(m){Kt(r,n,m)}}break;case 5:pl(f,f.return);break;case 22:if(f.memoizedState!==null){r0(p);continue}}h!==null?(h.return=f,we=h):r0(p)}d=d.sibling}e:for(d=null,p=e;;){if(p.tag===5){if(d===null){d=p;try{s=p.stateNode,i?(o=s.style,typeof o.setProperty=="function"?o.setProperty("display","none","important"):o.display="none"):(l=p.stateNode,c=p.memoizedProps.style,a=c!=null&&c.hasOwnProperty("display")?c.display:null,l.style.display=pT("display",a))}catch(m){Kt(e,e.return,m)}}}else if(p.tag===6){if(d===null)try{p.stateNode.nodeValue=i?"":p.memoizedProps}catch(m){Kt(e,e.return,m)}}else if((p.tag!==22&&p.tag!==23||p.memoizedState===null||p===e)&&p.child!==null){p.child.return=p,p=p.child;continue}if(p===e)break e;for(;p.sibling===null;){if(p.return===null||p.return===e)break e;d===p&&(d=null),p=p.return}d===p&&(d=null),p.sibling.return=p.return,p=p.sibling}}break;case 19:Kr(t,e),bs(e),r&4&&t0(e);break;case 21:break;default:Kr(t,e),bs(e)}}function bs(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if($k(n)){var r=n;break e}n=n.return}throw Error(te(160))}switch(r.tag){case 5:var s=r.stateNode;r.flags&32&&(Fc(s,""),r.flags&=-33);var o=e0(e);Ty(e,o,s);break;case 3:case 4:var a=r.stateNode.containerInfo,l=e0(e);Ey(e,l,a);break;default:throw Error(te(161))}}catch(c){Kt(e,e.return,c)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function DF(e,t,n){we=e,Uk(e)}function Uk(e,t,n){for(var r=(e.mode&1)!==0;we!==null;){var s=we,o=s.child;if(s.tag===22&&r){var a=s.memoizedState!==null||Tf;if(!a){var l=s.alternate,c=l!==null&&l.memoizedState!==null||Nn;l=Tf;var i=Nn;if(Tf=a,(Nn=c)&&!i)for(we=s;we!==null;)a=we,c=a.child,a.tag===22&&a.memoizedState!==null?s0(s):c!==null?(c.return=a,we=c):s0(s);for(;o!==null;)we=o,Uk(o),o=o.sibling;we=s,Tf=l,Nn=i}n0(e)}else s.subtreeFlags&8772&&o!==null?(o.return=s,we=o):n0(e)}}function n0(e){for(;we!==null;){var t=we;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:Nn||Uh(5,t);break;case 1:var r=t.stateNode;if(t.flags&4&&!Nn)if(n===null)r.componentDidMount();else{var s=t.elementType===t.type?n.memoizedProps:qr(t.type,n.memoizedProps);r.componentDidUpdate(s,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var o=t.updateQueue;o!==null&&BS(t,o,r);break;case 3:var a=t.updateQueue;if(a!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}BS(t,a,n)}break;case 5:var l=t.stateNode;if(n===null&&t.flags&4){n=l;var c=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":c.autoFocus&&n.focus();break;case"img":c.src&&(n.src=c.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var i=t.alternate;if(i!==null){var d=i.memoizedState;if(d!==null){var p=d.dehydrated;p!==null&&zc(p)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(te(163))}Nn||t.flags&512&&Cy(t)}catch(f){Kt(t,t.return,f)}}if(t===e){we=null;break}if(n=t.sibling,n!==null){n.return=t.return,we=n;break}we=t.return}}function r0(e){for(;we!==null;){var t=we;if(t===e){we=null;break}var n=t.sibling;if(n!==null){n.return=t.return,we=n;break}we=t.return}}function s0(e){for(;we!==null;){var t=we;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{Uh(4,t)}catch(c){Kt(t,n,c)}break;case 1:var r=t.stateNode;if(typeof r.componentDidMount=="function"){var s=t.return;try{r.componentDidMount()}catch(c){Kt(t,s,c)}}var o=t.return;try{Cy(t)}catch(c){Kt(t,o,c)}break;case 5:var a=t.return;try{Cy(t)}catch(c){Kt(t,a,c)}}}catch(c){Kt(t,t.return,c)}if(t===e){we=null;break}var l=t.sibling;if(l!==null){l.return=t.return,we=l;break}we=t.return}}var AF=Math.ceil,qp=xo.ReactCurrentDispatcher,mx=xo.ReactCurrentOwner,Fr=xo.ReactCurrentBatchConfig,ct=0,vn=null,tn=null,En=0,cr=0,hl=Ea(0),dn=0,Yc=null,bi=0,Vh=0,vx=0,Tc=null,Xn=null,yx=0,Yl=1/0,Zs=null,Wp=!1,ky=null,la=null,kf=!1,ea=null,Gp=0,kc=0,_y=null,ip=-1,lp=0;function Hn(){return ct&6?Jt():ip!==-1?ip:ip=Jt()}function ua(e){return e.mode&1?ct&2&&En!==0?En&-En:bF.transition!==null?(lp===0&&(lp=kT()),lp):(e=vt,e!==0||(e=window.event,e=e===void 0?16:NT(e.type)),e):1}function ns(e,t,n,r){if(50<kc)throw kc=0,_y=null,Error(te(185));Ad(e,n,r),(!(ct&2)||e!==vn)&&(e===vn&&(!(ct&2)&&(Vh|=n),dn===4&&Uo(e,En)),rr(e,r),n===1&&ct===0&&!(t.mode&1)&&(Yl=Jt()+500,$h&&Ta()))}function rr(e,t){var n=e.callbackNode;bA(e,t);var r=Mp(e,e===vn?En:0);if(r===0)n!==null&&pS(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(n!=null&&pS(n),t===1)e.tag===0?yF(o0.bind(null,e)):YT(o0.bind(null,e)),hF(function(){!(ct&6)&&Ta()}),n=null;else{switch(_T(r)){case 1:n=Hb;break;case 4:n=ET;break;case 16:n=Pp;break;case 536870912:n=TT;break;default:n=Pp}n=Qk(n,Vk.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function Vk(e,t){if(ip=-1,lp=0,ct&6)throw Error(te(327));var n=e.callbackNode;if(Tl()&&e.callbackNode!==n)return null;var r=Mp(e,e===vn?En:0);if(r===0)return null;if(r&30||r&e.expiredLanes||t)t=Jp(e,r);else{t=r;var s=ct;ct|=2;var o=Kk();(vn!==e||En!==t)&&(Zs=null,Yl=Jt()+500,ii(e,t));do try{$F();break}catch(l){Hk(e,l)}while(!0);rx(),qp.current=o,ct=s,tn!==null?t=0:(vn=null,En=0,t=dn)}if(t!==0){if(t===2&&(s=ey(e),s!==0&&(r=s,t=jy(e,s))),t===1)throw n=Yc,ii(e,0),Uo(e,r),rr(e,Jt()),n;if(t===6)Uo(e,r);else{if(s=e.current.alternate,!(r&30)&&!FF(s)&&(t=Jp(e,r),t===2&&(o=ey(e),o!==0&&(r=o,t=jy(e,o))),t===1))throw n=Yc,ii(e,0),Uo(e,r),rr(e,Jt()),n;switch(e.finishedWork=s,e.finishedLanes=r,t){case 0:case 1:throw Error(te(345));case 2:Ba(e,Xn,Zs);break;case 3:if(Uo(e,r),(r&130023424)===r&&(t=yx+500-Jt(),10<t)){if(Mp(e,0)!==0)break;if(s=e.suspendedLanes,(s&r)!==r){Hn(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=ly(Ba.bind(null,e,Xn,Zs),t);break}Ba(e,Xn,Zs);break;case 4:if(Uo(e,r),(r&4194240)===r)break;for(t=e.eventTimes,s=-1;0<r;){var a=31-ts(r);o=1<<a,a=t[a],a>s&&(s=a),r&=~o}if(r=s,r=Jt()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*AF(r/1960))-r,10<r){e.timeoutHandle=ly(Ba.bind(null,e,Xn,Zs),r);break}Ba(e,Xn,Zs);break;case 5:Ba(e,Xn,Zs);break;default:throw Error(te(329))}}}return rr(e,Jt()),e.callbackNode===n?Vk.bind(null,e):null}function jy(e,t){var n=Tc;return e.current.memoizedState.isDehydrated&&(ii(e,t).flags|=256),e=Jp(e,t),e!==2&&(t=Xn,Xn=n,t!==null&&Ry(t)),e}function Ry(e){Xn===null?Xn=e:Xn.push.apply(Xn,e)}function FF(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var s=n[r],o=s.getSnapshot;s=s.value;try{if(!us(o(),s))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Uo(e,t){for(t&=~vx,t&=~Vh,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-ts(t),r=1<<n;e[n]=-1,t&=~r}}function o0(e){if(ct&6)throw Error(te(327));Tl();var t=Mp(e,0);if(!(t&1))return rr(e,Jt()),null;var n=Jp(e,t);if(e.tag!==0&&n===2){var r=ey(e);r!==0&&(t=r,n=jy(e,r))}if(n===1)throw n=Yc,ii(e,0),Uo(e,t),rr(e,Jt()),n;if(n===6)throw Error(te(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,Ba(e,Xn,Zs),rr(e,Jt()),null}function bx(e,t){var n=ct;ct|=1;try{return e(t)}finally{ct=n,ct===0&&(Yl=Jt()+500,$h&&Ta())}}function xi(e){ea!==null&&ea.tag===0&&!(ct&6)&&Tl();var t=ct;ct|=1;var n=Fr.transition,r=vt;try{if(Fr.transition=null,vt=1,e)return e()}finally{vt=r,Fr.transition=n,ct=t,!(ct&6)&&Ta()}}function xx(){cr=hl.current,Pt(hl)}function ii(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,pF(n)),tn!==null)for(n=tn.return;n!==null;){var r=n;switch(ex(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&Ap();break;case 3:Ql(),Pt(tr),Pt(In),ux();break;case 5:lx(r);break;case 4:Ql();break;case 13:Pt(Ft);break;case 19:Pt(Ft);break;case 10:sx(r.type._context);break;case 22:case 23:xx()}n=n.return}if(vn=e,tn=e=ca(e.current,null),En=cr=t,dn=0,Yc=null,vx=Vh=bi=0,Xn=Tc=null,Ha!==null){for(t=0;t<Ha.length;t++)if(n=Ha[t],r=n.interleaved,r!==null){n.interleaved=null;var s=r.next,o=n.pending;if(o!==null){var a=o.next;o.next=s,r.next=a}n.pending=r}Ha=null}return e}function Hk(e,t){do{var n=tn;try{if(rx(),sp.current=Kp,Hp){for(var r=Lt.memoizedState;r!==null;){var s=r.queue;s!==null&&(s.pending=null),r=r.next}Hp=!1}if(yi=0,mn=un=Lt=null,Cc=!1,Jc=0,mx.current=null,n===null||n.return===null){dn=1,Yc=t,tn=null;break}e:{var o=e,a=n.return,l=n,c=t;if(t=En,l.flags|=32768,c!==null&&typeof c=="object"&&typeof c.then=="function"){var i=c,d=l,p=d.tag;if(!(d.mode&1)&&(p===0||p===11||p===15)){var f=d.alternate;f?(d.updateQueue=f.updateQueue,d.memoizedState=f.memoizedState,d.lanes=f.lanes):(d.updateQueue=null,d.memoizedState=null)}var h=qS(a);if(h!==null){h.flags&=-257,WS(h,a,l,o,t),h.mode&1&&KS(o,i,t),t=h,c=i;var g=t.updateQueue;if(g===null){var m=new Set;m.add(c),t.updateQueue=m}else g.add(c);break e}else{if(!(t&1)){KS(o,i,t),wx();break e}c=Error(te(426))}}else if(Ot&&l.mode&1){var x=qS(a);if(x!==null){!(x.flags&65536)&&(x.flags|=256),WS(x,a,l,o,t),tx(Zl(c,l));break e}}o=c=Zl(c,l),dn!==4&&(dn=2),Tc===null?Tc=[o]:Tc.push(o),o=a;do{switch(o.tag){case 3:o.flags|=65536,t&=-t,o.lanes|=t;var b=_k(o,c,t);$S(o,b);break e;case 1:l=c;var y=o.type,w=o.stateNode;if(!(o.flags&128)&&(typeof y.getDerivedStateFromError=="function"||w!==null&&typeof w.componentDidCatch=="function"&&(la===null||!la.has(w)))){o.flags|=65536,t&=-t,o.lanes|=t;var S=jk(o,l,t);$S(o,S);break e}}o=o.return}while(o!==null)}Wk(n)}catch(E){t=E,tn===n&&n!==null&&(tn=n=n.return);continue}break}while(!0)}function Kk(){var e=qp.current;return qp.current=Kp,e===null?Kp:e}function wx(){(dn===0||dn===3||dn===2)&&(dn=4),vn===null||!(bi&268435455)&&!(Vh&268435455)||Uo(vn,En)}function Jp(e,t){var n=ct;ct|=2;var r=Kk();(vn!==e||En!==t)&&(Zs=null,ii(e,t));do try{LF();break}catch(s){Hk(e,s)}while(!0);if(rx(),ct=n,qp.current=r,tn!==null)throw Error(te(261));return vn=null,En=0,dn}function LF(){for(;tn!==null;)qk(tn)}function $F(){for(;tn!==null&&!cA();)qk(tn)}function qk(e){var t=Jk(e.alternate,e,cr);e.memoizedProps=e.pendingProps,t===null?Wk(e):tn=t,mx.current=null}function Wk(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=OF(n,t),n!==null){n.flags&=32767,tn=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{dn=6,tn=null;return}}else if(n=MF(n,t,cr),n!==null){tn=n;return}if(t=t.sibling,t!==null){tn=t;return}tn=t=e}while(t!==null);dn===0&&(dn=5)}function Ba(e,t,n){var r=vt,s=Fr.transition;try{Fr.transition=null,vt=1,BF(e,t,n,r)}finally{Fr.transition=s,vt=r}return null}function BF(e,t,n,r){do Tl();while(ea!==null);if(ct&6)throw Error(te(327));n=e.finishedWork;var s=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(te(177));e.callbackNode=null,e.callbackPriority=0;var o=n.lanes|n.childLanes;if(xA(e,o),e===vn&&(tn=vn=null,En=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||kf||(kf=!0,Qk(Pp,function(){return Tl(),null})),o=(n.flags&15990)!==0,n.subtreeFlags&15990||o){o=Fr.transition,Fr.transition=null;var a=vt;vt=1;var l=ct;ct|=4,mx.current=null,IF(e,n),zk(n,e),aF(ay),Op=!!oy,ay=oy=null,e.current=n,DF(n),dA(),ct=l,vt=a,Fr.transition=o}else e.current=n;if(kf&&(kf=!1,ea=e,Gp=s),o=e.pendingLanes,o===0&&(la=null),hA(n.stateNode),rr(e,Jt()),t!==null)for(r=e.onRecoverableError,n=0;n<t.length;n++)s=t[n],r(s.value,{componentStack:s.stack,digest:s.digest});if(Wp)throw Wp=!1,e=ky,ky=null,e;return Gp&1&&e.tag!==0&&Tl(),o=e.pendingLanes,o&1?e===_y?kc++:(kc=0,_y=e):kc=0,Ta(),null}function Tl(){if(ea!==null){var e=_T(Gp),t=Fr.transition,n=vt;try{if(Fr.transition=null,vt=16>e?16:e,ea===null)var r=!1;else{if(e=ea,ea=null,Gp=0,ct&6)throw Error(te(331));var s=ct;for(ct|=4,we=e.current;we!==null;){var o=we,a=o.child;if(we.flags&16){var l=o.deletions;if(l!==null){for(var c=0;c<l.length;c++){var i=l[c];for(we=i;we!==null;){var d=we;switch(d.tag){case 0:case 11:case 15:Ec(8,d,o)}var p=d.child;if(p!==null)p.return=d,we=p;else for(;we!==null;){d=we;var f=d.sibling,h=d.return;if(Lk(d),d===i){we=null;break}if(f!==null){f.return=h,we=f;break}we=h}}}var g=o.alternate;if(g!==null){var m=g.child;if(m!==null){g.child=null;do{var x=m.sibling;m.sibling=null,m=x}while(m!==null)}}we=o}}if(o.subtreeFlags&2064&&a!==null)a.return=o,we=a;else e:for(;we!==null;){if(o=we,o.flags&2048)switch(o.tag){case 0:case 11:case 15:Ec(9,o,o.return)}var b=o.sibling;if(b!==null){b.return=o.return,we=b;break e}we=o.return}}var y=e.current;for(we=y;we!==null;){a=we;var w=a.child;if(a.subtreeFlags&2064&&w!==null)w.return=a,we=w;else e:for(a=y;we!==null;){if(l=we,l.flags&2048)try{switch(l.tag){case 0:case 11:case 15:Uh(9,l)}}catch(E){Kt(l,l.return,E)}if(l===a){we=null;break e}var S=l.sibling;if(S!==null){S.return=l.return,we=S;break e}we=l.return}}if(ct=s,Ta(),Ds&&typeof Ds.onPostCommitFiberRoot=="function")try{Ds.onPostCommitFiberRoot(Ih,e)}catch{}r=!0}return r}finally{vt=n,Fr.transition=t}}return!1}function a0(e,t,n){t=Zl(n,t),t=_k(e,t,1),e=ia(e,t,1),t=Hn(),e!==null&&(Ad(e,1,t),rr(e,t))}function Kt(e,t,n){if(e.tag===3)a0(e,e,n);else for(;t!==null;){if(t.tag===3){a0(t,e,n);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(la===null||!la.has(r))){e=Zl(n,e),e=jk(t,e,1),t=ia(t,e,1),e=Hn(),t!==null&&(Ad(t,1,e),rr(t,e));break}}t=t.return}}function zF(e,t,n){var r=e.pingCache;r!==null&&r.delete(t),t=Hn(),e.pingedLanes|=e.suspendedLanes&n,vn===e&&(En&n)===n&&(dn===4||dn===3&&(En&130023424)===En&&500>Jt()-yx?ii(e,0):vx|=n),rr(e,t)}function Gk(e,t){t===0&&(e.mode&1?(t=mf,mf<<=1,!(mf&130023424)&&(mf=4194304)):t=1);var n=Hn();e=ho(e,t),e!==null&&(Ad(e,t,n),rr(e,n))}function UF(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),Gk(e,n)}function VF(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,s=e.memoizedState;s!==null&&(n=s.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(te(314))}r!==null&&r.delete(t),Gk(e,n)}var Jk;Jk=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||tr.current)er=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return er=!1,PF(e,t,n);er=!!(e.flags&131072)}else er=!1,Ot&&t.flags&1048576&&XT(t,$p,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;ap(e,t),e=t.pendingProps;var s=Wl(t,In.current);El(t,n),s=dx(null,t,r,e,s,n);var o=fx();return t.flags|=1,typeof s=="object"&&s!==null&&typeof s.render=="function"&&s.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,nr(r)?(o=!0,Fp(t)):o=!1,t.memoizedState=s.state!==null&&s.state!==void 0?s.state:null,ax(t),s.updater=zh,t.stateNode=s,s._reactInternals=t,gy(t,r,e,n),t=yy(null,t,r,!0,o,n)):(t.tag=0,Ot&&o&&Xb(t),zn(null,t,s,n),t=t.child),t;case 16:r=t.elementType;e:{switch(ap(e,t),e=t.pendingProps,s=r._init,r=s(r._payload),t.type=r,s=t.tag=KF(r),e=qr(r,e),s){case 0:t=vy(null,t,r,e,n);break e;case 1:t=QS(null,t,r,e,n);break e;case 11:t=GS(null,t,r,e,n);break e;case 14:t=JS(null,t,r,qr(r.type,e),n);break e}throw Error(te(306,r,""))}return t;case 0:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:qr(r,s),vy(e,t,r,s,n);case 1:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:qr(r,s),QS(e,t,r,s,n);case 3:e:{if(Ok(t),e===null)throw Error(te(387));r=t.pendingProps,o=t.memoizedState,s=o.element,ok(e,t),Up(t,r,null,n);var a=t.memoizedState;if(r=a.element,o.isDehydrated)if(o={element:r,isDehydrated:!1,cache:a.cache,pendingSuspenseBoundaries:a.pendingSuspenseBoundaries,transitions:a.transitions},t.updateQueue.baseState=o,t.memoizedState=o,t.flags&256){s=Zl(Error(te(423)),t),t=ZS(e,t,r,n,s);break e}else if(r!==s){s=Zl(Error(te(424)),t),t=ZS(e,t,r,n,s);break e}else for(hr=aa(t.stateNode.containerInfo.firstChild),mr=t,Ot=!0,Zr=null,n=rk(t,null,r,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(Gl(),r===s){t=go(e,t,n);break e}zn(e,t,r,n)}t=t.child}return t;case 5:return ak(t),e===null&&fy(t),r=t.type,s=t.pendingProps,o=e!==null?e.memoizedProps:null,a=s.children,iy(r,s)?a=null:o!==null&&iy(r,o)&&(t.flags|=32),Mk(e,t),zn(e,t,a,n),t.child;case 6:return e===null&&fy(t),null;case 13:return Nk(e,t,n);case 4:return ix(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=Jl(t,null,r,n):zn(e,t,r,n),t.child;case 11:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:qr(r,s),GS(e,t,r,s,n);case 7:return zn(e,t,t.pendingProps,n),t.child;case 8:return zn(e,t,t.pendingProps.children,n),t.child;case 12:return zn(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,s=t.pendingProps,o=t.memoizedProps,a=s.value,Et(Bp,r._currentValue),r._currentValue=a,o!==null)if(us(o.value,a)){if(o.children===s.children&&!tr.current){t=go(e,t,n);break e}}else for(o=t.child,o!==null&&(o.return=t);o!==null;){var l=o.dependencies;if(l!==null){a=o.child;for(var c=l.firstContext;c!==null;){if(c.context===r){if(o.tag===1){c=lo(-1,n&-n),c.tag=2;var i=o.updateQueue;if(i!==null){i=i.shared;var d=i.pending;d===null?c.next=c:(c.next=d.next,d.next=c),i.pending=c}}o.lanes|=n,c=o.alternate,c!==null&&(c.lanes|=n),py(o.return,n,t),l.lanes|=n;break}c=c.next}}else if(o.tag===10)a=o.type===t.type?null:o.child;else if(o.tag===18){if(a=o.return,a===null)throw Error(te(341));a.lanes|=n,l=a.alternate,l!==null&&(l.lanes|=n),py(a,n,t),a=o.sibling}else a=o.child;if(a!==null)a.return=o;else for(a=o;a!==null;){if(a===t){a=null;break}if(o=a.sibling,o!==null){o.return=a.return,a=o;break}a=a.return}o=a}zn(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,r=t.pendingProps.children,El(t,n),s=Br(s),r=r(s),t.flags|=1,zn(e,t,r,n),t.child;case 14:return r=t.type,s=qr(r,t.pendingProps),s=qr(r.type,s),JS(e,t,r,s,n);case 15:return Rk(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:qr(r,s),ap(e,t),t.tag=1,nr(r)?(e=!0,Fp(t)):e=!1,El(t,n),kk(t,r,s),gy(t,r,s,n),yy(null,t,r,!0,e,n);case 19:return Ik(e,t,n);case 22:return Pk(e,t,n)}throw Error(te(156,t.tag))};function Qk(e,t){return CT(e,t)}function HF(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ar(e,t,n,r){return new HF(e,t,n,r)}function Sx(e){return e=e.prototype,!(!e||!e.isReactComponent)}function KF(e){if(typeof e=="function")return Sx(e)?1:0;if(e!=null){if(e=e.$$typeof,e===zb)return 11;if(e===Ub)return 14}return 2}function ca(e,t){var n=e.alternate;return n===null?(n=Ar(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function up(e,t,n,r,s,o){var a=2;if(r=e,typeof e=="function")Sx(e)&&(a=1);else if(typeof e=="string")a=5;else e:switch(e){case sl:return li(n.children,s,o,t);case Bb:a=8,s|=8;break;case $v:return e=Ar(12,n,t,s|2),e.elementType=$v,e.lanes=o,e;case Bv:return e=Ar(13,n,t,s),e.elementType=Bv,e.lanes=o,e;case zv:return e=Ar(19,n,t,s),e.elementType=zv,e.lanes=o,e;case aT:return Hh(n,s,o,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case sT:a=10;break e;case oT:a=9;break e;case zb:a=11;break e;case Ub:a=14;break e;case $o:a=16,r=null;break e}throw Error(te(130,e==null?e:typeof e,""))}return t=Ar(a,n,t,s),t.elementType=e,t.type=r,t.lanes=o,t}function li(e,t,n,r){return e=Ar(7,e,r,t),e.lanes=n,e}function Hh(e,t,n,r){return e=Ar(22,e,r,t),e.elementType=aT,e.lanes=n,e.stateNode={isHidden:!1},e}function Pm(e,t,n){return e=Ar(6,e,null,t),e.lanes=n,e}function Mm(e,t,n){return t=Ar(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function qF(e,t,n,r,s){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=dm(0),this.expirationTimes=dm(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=dm(0),this.identifierPrefix=r,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function Cx(e,t,n,r,s,o,a,l,c){return e=new qF(e,t,n,l,c),t===1?(t=1,o===!0&&(t|=8)):t=0,o=Ar(3,null,null,t),e.current=o,o.stateNode=e,o.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},ax(o),e}function WF(e,t,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:rl,key:r==null?null:""+r,children:e,containerInfo:t,implementation:n}}function Zk(e){if(!e)return fa;e=e._reactInternals;e:{if(Mi(e)!==e||e.tag!==1)throw Error(te(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(nr(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(te(171))}if(e.tag===1){var n=e.type;if(nr(n))return ZT(e,n,t)}return t}function Yk(e,t,n,r,s,o,a,l,c){return e=Cx(n,r,!0,e,s,o,a,l,c),e.context=Zk(null),n=e.current,r=Hn(),s=ua(n),o=lo(r,s),o.callback=t??null,ia(n,o,s),e.current.lanes=s,Ad(e,s,r),rr(e,r),e}function Kh(e,t,n,r){var s=t.current,o=Hn(),a=ua(s);return n=Zk(n),t.context===null?t.context=n:t.pendingContext=n,t=lo(o,a),t.payload={element:e},r=r===void 0?null:r,r!==null&&(t.callback=r),e=ia(s,t,a),e!==null&&(ns(e,s,a,o),rp(e,s,a)),a}function Qp(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function i0(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function Ex(e,t){i0(e,t),(e=e.alternate)&&i0(e,t)}function GF(){return null}var Xk=typeof reportError=="function"?reportError:function(e){console.error(e)};function Tx(e){this._internalRoot=e}qh.prototype.render=Tx.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(te(409));Kh(e,t,null,null)};qh.prototype.unmount=Tx.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;xi(function(){Kh(null,e,null,null)}),t[po]=null}};function qh(e){this._internalRoot=e}qh.prototype.unstable_scheduleHydration=function(e){if(e){var t=PT();e={blockedOn:null,target:e,priority:t};for(var n=0;n<zo.length&&t!==0&&t<zo[n].priority;n++);zo.splice(n,0,e),n===0&&OT(e)}};function kx(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function Wh(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function l0(){}function JF(e,t,n,r,s){if(s){if(typeof r=="function"){var o=r;r=function(){var i=Qp(a);o.call(i)}}var a=Yk(t,r,e,0,null,!1,!1,"",l0);return e._reactRootContainer=a,e[po]=a.current,Hc(e.nodeType===8?e.parentNode:e),xi(),a}for(;s=e.lastChild;)e.removeChild(s);if(typeof r=="function"){var l=r;r=function(){var i=Qp(c);l.call(i)}}var c=Cx(e,0,!1,null,null,!1,!1,"",l0);return e._reactRootContainer=c,e[po]=c.current,Hc(e.nodeType===8?e.parentNode:e),xi(function(){Kh(t,c,n,r)}),c}function Gh(e,t,n,r,s){var o=n._reactRootContainer;if(o){var a=o;if(typeof s=="function"){var l=s;s=function(){var c=Qp(a);l.call(c)}}Kh(t,a,e,s)}else a=JF(n,t,e,s,r);return Qp(a)}jT=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=lc(t.pendingLanes);n!==0&&(Kb(t,n|1),rr(t,Jt()),!(ct&6)&&(Yl=Jt()+500,Ta()))}break;case 13:xi(function(){var r=ho(e,1);if(r!==null){var s=Hn();ns(r,e,1,s)}}),Ex(e,1)}};qb=function(e){if(e.tag===13){var t=ho(e,134217728);if(t!==null){var n=Hn();ns(t,e,134217728,n)}Ex(e,134217728)}};RT=function(e){if(e.tag===13){var t=ua(e),n=ho(e,t);if(n!==null){var r=Hn();ns(n,e,t,r)}Ex(e,t)}};PT=function(){return vt};MT=function(e,t){var n=vt;try{return vt=e,t()}finally{vt=n}};Zv=function(e,t,n){switch(t){case"input":if(Hv(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=Lh(r);if(!s)throw Error(te(90));lT(r),Hv(r,s)}}}break;case"textarea":cT(e,n);break;case"select":t=n.value,t!=null&&xl(e,!!n.multiple,t,!1)}};vT=bx;yT=xi;var QF={usingClientEntryPoint:!1,Events:[Ld,ll,Lh,gT,mT,bx]},Hu={findFiberByHostInstance:Va,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},ZF={bundleType:Hu.bundleType,version:Hu.version,rendererPackageName:Hu.rendererPackageName,rendererConfig:Hu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:xo.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=wT(e),e===null?null:e.stateNode},findFiberByHostInstance:Hu.findFiberByHostInstance||GF,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var _f=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!_f.isDisabled&&_f.supportsFiber)try{Ih=_f.inject(ZF),Ds=_f}catch{}}Cr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=QF;Cr.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!kx(t))throw Error(te(200));return WF(e,t,null,n)};Cr.createRoot=function(e,t){if(!kx(e))throw Error(te(299));var n=!1,r="",s=Xk;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onRecoverableError!==void 0&&(s=t.onRecoverableError)),t=Cx(e,1,!1,null,null,n,!1,r,s),e[po]=t.current,Hc(e.nodeType===8?e.parentNode:e),new Tx(t)};Cr.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(te(188)):(e=Object.keys(e).join(","),Error(te(268,e)));return e=wT(t),e=e===null?null:e.stateNode,e};Cr.flushSync=function(e){return xi(e)};Cr.hydrate=function(e,t,n){if(!Wh(t))throw Error(te(200));return Gh(null,e,t,!0,n)};Cr.hydrateRoot=function(e,t,n){if(!kx(e))throw Error(te(405));var r=n!=null&&n.hydratedSources||null,s=!1,o="",a=Xk;if(n!=null&&(n.unstable_strictMode===!0&&(s=!0),n.identifierPrefix!==void 0&&(o=n.identifierPrefix),n.onRecoverableError!==void 0&&(a=n.onRecoverableError)),t=Yk(t,null,e,1,n??null,s,!1,o,a),e[po]=t.current,Hc(e),r)for(e=0;e<r.length;e++)n=r[e],s=n._getVersion,s=s(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s);return new qh(t)};Cr.render=function(e,t,n){if(!Wh(t))throw Error(te(200));return Gh(null,e,t,!1,n)};Cr.unmountComponentAtNode=function(e){if(!Wh(e))throw Error(te(40));return e._reactRootContainer?(xi(function(){Gh(null,null,e,!1,function(){e._reactRootContainer=null,e[po]=null})}),!0):!1};Cr.unstable_batchedUpdates=bx;Cr.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Wh(n))throw Error(te(200));if(e==null||e._reactInternals===void 0)throw Error(te(38));return Gh(e,t,n,!1,r)};Cr.version="18.3.1-next-f1338f8080-20240426";function e_(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e_)}catch(e){console.error(e)}}e_(),eT.exports=Cr;var ka=eT.exports;const t_=jb(ka),YF=jE({__proto__:null,default:t_},[ka]);var u0=ka;Fv.createRoot=u0.createRoot,Fv.hydrateRoot=u0.hydrateRoot;const XF=(...e)=>{console!=null&&console.warn&&(ui(e[0])&&(e[0]=`react-i18next:: ${e[0]}`),console.warn(...e))},c0={},Py=(...e)=>{ui(e[0])&&c0[e[0]]||(ui(e[0])&&(c0[e[0]]=new Date),XF(...e))},n_=(e,t)=>()=>{if(e.isInitialized)t();else{const n=()=>{setTimeout(()=>{e.off("initialized",n)},0),t()};e.on("initialized",n)}},d0=(e,t,n)=>{e.loadNamespaces(t,n_(e,n))},f0=(e,t,n,r)=>{ui(n)&&(n=[n]),n.forEach(s=>{e.options.ns.indexOf(s)<0&&e.options.ns.push(s)}),e.loadLanguages(t,n_(e,r))},e2=(e,t,n={})=>!t.languages||!t.languages.length?(Py("i18n.languages were undefined or empty",t.languages),!0):t.hasLoadedNamespace(e,{lng:n.lng,precheck:(r,s)=>{var o;if(((o=n.bindI18n)==null?void 0:o.indexOf("languageChanging"))>-1&&r.services.backendConnector.backend&&r.isLanguageChangingTo&&!s(r.isLanguageChangingTo,e))return!1}}),ui=e=>typeof e=="string",t2=e=>typeof e=="object"&&e!==null,n2=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,r2={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"©","&#169;":"©","&reg;":"®","&#174;":"®","&hellip;":"…","&#8230;":"…","&#x2F;":"/","&#47;":"/"},s2=e=>r2[e],o2=e=>e.replace(n2,s2);let My={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:o2};const a2=(e={})=>{My={...My,...e}},i2=()=>My;let r_;const l2=e=>{r_=e},u2=()=>r_,c2={type:"3rdParty",init(e){a2(e.options.react),l2(e)}},s_=v.createContext();class d2{constructor(){this.usedNamespaces={}}addUsedNamespaces(t){t.forEach(n=>{var r;(r=this.usedNamespaces)[n]??(r[n]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const f2=(e,t)=>{const n=v.useRef();return v.useEffect(()=>{n.current=e},[e,t]),n.current},o_=(e,t,n,r)=>e.getFixedT(t,n,r),p2=(e,t,n,r)=>v.useCallback(o_(e,t,n,r),[e,t,n,r]),ze=(e,t={})=>{var S,E,C,k;const{i18n:n}=t,{i18n:r,defaultNS:s}=v.useContext(s_)||{},o=n||r||u2();if(o&&!o.reportNamespaces&&(o.reportNamespaces=new d2),!o){Py("You will need to pass in an i18next instance by using initReactI18next");const T=(N,U)=>ui(U)?U:t2(U)&&ui(U.defaultValue)?U.defaultValue:Array.isArray(N)?N[N.length-1]:N,P=[T,{},!1];return P.t=T,P.i18n={},P.ready=!1,P}(S=o.options.react)!=null&&S.wait&&Py("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const a={...i2(),...o.options.react,...t},{useSuspense:l,keyPrefix:c}=a;let i=s||((E=o.options)==null?void 0:E.defaultNS);i=ui(i)?[i]:i||["translation"],(k=(C=o.reportNamespaces).addUsedNamespaces)==null||k.call(C,i);const d=(o.isInitialized||o.initializedStoreOnce)&&i.every(T=>e2(T,o,a)),p=p2(o,t.lng||null,a.nsMode==="fallback"?i:i[0],c),f=()=>p,h=()=>o_(o,t.lng||null,a.nsMode==="fallback"?i:i[0],c),[g,m]=v.useState(f);let x=i.join();t.lng&&(x=`${t.lng}${x}`);const b=f2(x),y=v.useRef(!0);v.useEffect(()=>{const{bindI18n:T,bindI18nStore:P}=a;y.current=!0,!d&&!l&&(t.lng?f0(o,t.lng,i,()=>{y.current&&m(h)}):d0(o,i,()=>{y.current&&m(h)})),d&&b&&b!==x&&y.current&&m(h);const N=()=>{y.current&&m(h)};return T&&(o==null||o.on(T,N)),P&&(o==null||o.store.on(P,N)),()=>{y.current=!1,o&&(T==null||T.split(" ").forEach(U=>o.off(U,N))),P&&o&&P.split(" ").forEach(U=>o.store.off(U,N))}},[o,x]),v.useEffect(()=>{y.current&&d&&m(f)},[o,c,d]);const w=[g,o,d];if(w.t=g,w.i18n=o,w.ready=d,d||!d&&!l)return w;throw new Promise(T=>{t.lng?f0(o,t.lng,i,()=>T()):d0(o,i,()=>T())})};function h2({i18n:e,defaultNS:t,children:n}){const r=v.useMemo(()=>({i18n:e,defaultNS:t}),[e,t]);return v.createElement(s_.Provider,{value:r},n)}/**
 * @remix-run/router v1.18.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function At(){return At=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},At.apply(this,arguments)}var en;(function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"})(en||(en={}));const p0="popstate";function g2(e){e===void 0&&(e={});function t(r,s){let{pathname:o,search:a,hash:l}=r.location;return Xc("",{pathname:o,search:a,hash:l},s.state&&s.state.usr||null,s.state&&s.state.key||"default")}function n(r,s){return typeof s=="string"?s:wi(s)}return v2(t,n,null,e)}function Ze(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function Xl(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}function m2(){return Math.random().toString(36).substr(2,8)}function h0(e,t){return{usr:e.state,key:e.key,idx:t}}function Xc(e,t,n,r){return n===void 0&&(n=null),At({pathname:typeof e=="string"?e:e.pathname,search:"",hash:""},typeof t=="string"?_a(t):t,{state:n,key:t&&t.key||r||m2()})}function wi(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&n!=="?"&&(t+=n.charAt(0)==="?"?n:"?"+n),r&&r!=="#"&&(t+=r.charAt(0)==="#"?r:"#"+r),t}function _a(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function v2(e,t,n,r){r===void 0&&(r={});let{window:s=document.defaultView,v5Compat:o=!1}=r,a=s.history,l=en.Pop,c=null,i=d();i==null&&(i=0,a.replaceState(At({},a.state,{idx:i}),""));function d(){return(a.state||{idx:null}).idx}function p(){l=en.Pop;let x=d(),b=x==null?null:x-i;i=x,c&&c({action:l,location:m.location,delta:b})}function f(x,b){l=en.Push;let y=Xc(m.location,x,b);i=d()+1;let w=h0(y,i),S=m.createHref(y);try{a.pushState(w,"",S)}catch(E){if(E instanceof DOMException&&E.name==="DataCloneError")throw E;s.location.assign(S)}o&&c&&c({action:l,location:m.location,delta:1})}function h(x,b){l=en.Replace;let y=Xc(m.location,x,b);i=d();let w=h0(y,i),S=m.createHref(y);a.replaceState(w,"",S),o&&c&&c({action:l,location:m.location,delta:0})}function g(x){let b=s.location.origin!=="null"?s.location.origin:s.location.href,y=typeof x=="string"?x:wi(x);return y=y.replace(/ $/,"%20"),Ze(b,"No window.location.(origin|href) available to create URL for href: "+y),new URL(y,b)}let m={get action(){return l},get location(){return e(s,a)},listen(x){if(c)throw new Error("A history only accepts one active listener");return s.addEventListener(p0,p),c=x,()=>{s.removeEventListener(p0,p),c=null}},createHref(x){return t(s,x)},createURL:g,encodeLocation(x){let b=g(x);return{pathname:b.pathname,search:b.search,hash:b.hash}},push:f,replace:h,go(x){return a.go(x)}};return m}var Ct;(function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"})(Ct||(Ct={}));const y2=new Set(["lazy","caseSensitive","path","id","index","children"]);function b2(e){return e.index===!0}function ed(e,t,n,r){return n===void 0&&(n=[]),r===void 0&&(r={}),e.map((s,o)=>{let a=[...n,String(o)],l=typeof s.id=="string"?s.id:a.join("-");if(Ze(s.index!==!0||!s.children,"Cannot specify children on an index route"),Ze(!r[l],'Found a route id collision on id "'+l+`".  Route id's must be globally unique within Data Router usages`),b2(s)){let c=At({},s,t(s),{id:l});return r[l]=c,c}else{let c=At({},s,t(s),{id:l,children:void 0});return r[l]=c,s.children&&(c.children=ed(s.children,t,a,r)),c}})}function Ua(e,t,n){return n===void 0&&(n="/"),cp(e,t,n,!1)}function cp(e,t,n,r){let s=typeof t=="string"?_a(t):t,o=du(s.pathname||"/",n);if(o==null)return null;let a=a_(e);w2(a);let l=null;for(let c=0;l==null&&c<a.length;++c){let i=O2(o);l=P2(a[c],i,r)}return l}function x2(e,t){let{route:n,pathname:r,params:s}=e;return{id:n.id,pathname:r,params:s,data:t[n.id],handle:n.handle}}function a_(e,t,n,r){t===void 0&&(t=[]),n===void 0&&(n=[]),r===void 0&&(r="");let s=(o,a,l)=>{let c={relativePath:l===void 0?o.path||"":l,caseSensitive:o.caseSensitive===!0,childrenIndex:a,route:o};c.relativePath.startsWith("/")&&(Ze(c.relativePath.startsWith(r),'Absolute route path "'+c.relativePath+'" nested under path '+('"'+r+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),c.relativePath=c.relativePath.slice(r.length));let i=uo([r,c.relativePath]),d=n.concat(c);o.children&&o.children.length>0&&(Ze(o.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+i+'".')),a_(o.children,t,d,i)),!(o.path==null&&!o.index)&&t.push({path:i,score:j2(i,o.index),routesMeta:d})};return e.forEach((o,a)=>{var l;if(o.path===""||!((l=o.path)!=null&&l.includes("?")))s(o,a);else for(let c of i_(o.path))s(o,a,c)}),t}function i_(e){let t=e.split("/");if(t.length===0)return[];let[n,...r]=t,s=n.endsWith("?"),o=n.replace(/\?$/,"");if(r.length===0)return s?[o,""]:[o];let a=i_(r.join("/")),l=[];return l.push(...a.map(c=>c===""?o:[o,c].join("/"))),s&&l.push(...a),l.map(c=>e.startsWith("/")&&c===""?"/":c)}function w2(e){e.sort((t,n)=>t.score!==n.score?n.score-t.score:R2(t.routesMeta.map(r=>r.childrenIndex),n.routesMeta.map(r=>r.childrenIndex)))}const S2=/^:[\w-]+$/,C2=3,E2=2,T2=1,k2=10,_2=-2,g0=e=>e==="*";function j2(e,t){let n=e.split("/"),r=n.length;return n.some(g0)&&(r+=_2),t&&(r+=E2),n.filter(s=>!g0(s)).reduce((s,o)=>s+(S2.test(o)?C2:o===""?T2:k2),r)}function R2(e,t){return e.length===t.length&&e.slice(0,-1).every((r,s)=>r===t[s])?e[e.length-1]-t[t.length-1]:0}function P2(e,t,n){n===void 0&&(n=!1);let{routesMeta:r}=e,s={},o="/",a=[];for(let l=0;l<r.length;++l){let c=r[l],i=l===r.length-1,d=o==="/"?t:t.slice(o.length)||"/",p=m0({path:c.relativePath,caseSensitive:c.caseSensitive,end:i},d),f=c.route;if(!p&&i&&n&&!r[r.length-1].route.index&&(p=m0({path:c.relativePath,caseSensitive:c.caseSensitive,end:!1},d)),!p)return null;Object.assign(s,p.params),a.push({params:s,pathname:uo([o,p.pathname]),pathnameBase:D2(uo([o,p.pathnameBase])),route:f}),p.pathnameBase!=="/"&&(o=uo([o,p.pathnameBase]))}return a}function m0(e,t){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=M2(e.path,e.caseSensitive,e.end),s=t.match(n);if(!s)return null;let o=s[0],a=o.replace(/(.)\/+$/,"$1"),l=s.slice(1);return{params:r.reduce((i,d,p)=>{let{paramName:f,isOptional:h}=d;if(f==="*"){let m=l[p]||"";a=o.slice(0,o.length-m.length).replace(/(.)\/+$/,"$1")}const g=l[p];return h&&!g?i[f]=void 0:i[f]=(g||"").replace(/%2F/g,"/"),i},{}),pathname:o,pathnameBase:a,pattern:e}}function M2(e,t,n){t===void 0&&(t=!1),n===void 0&&(n=!0),Xl(e==="*"||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were '+('"'+e.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+e.replace(/\*$/,"/*")+'".'));let r=[],s="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(a,l,c)=>(r.push({paramName:l,isOptional:c!=null}),c?"/?([^\\/]+)?":"/([^\\/]+)"));return e.endsWith("*")?(r.push({paramName:"*"}),s+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?s+="\\/*$":e!==""&&e!=="/"&&(s+="(?:(?=\\/|$))"),[new RegExp(s,t?void 0:"i"),r]}function O2(e){try{return e.split("/").map(t=>decodeURIComponent(t).replace(/\//g,"%2F")).join("/")}catch(t){return Xl(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+t+").")),e}}function du(e,t){if(t==="/")return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&r!=="/"?null:e.slice(n)||"/"}function N2(e,t){t===void 0&&(t="/");let{pathname:n,search:r="",hash:s=""}=typeof e=="string"?_a(e):e;return{pathname:n?n.startsWith("/")?n:I2(n,t):t,search:A2(r),hash:F2(s)}}function I2(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(s=>{s===".."?n.length>1&&n.pop():s!=="."&&n.push(s)}),n.length>1?n.join("/"):"/"}function Om(e,t,n,r){return"Cannot include a '"+e+"' character in a manually specified "+("`to."+t+"` field ["+JSON.stringify(r)+"].  Please separate it out to the ")+("`to."+n+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function l_(e){return e.filter((t,n)=>n===0||t.route.path&&t.route.path.length>0)}function Jh(e,t){let n=l_(e);return t?n.map((r,s)=>s===n.length-1?r.pathname:r.pathnameBase):n.map(r=>r.pathnameBase)}function Qh(e,t,n,r){r===void 0&&(r=!1);let s;typeof e=="string"?s=_a(e):(s=At({},e),Ze(!s.pathname||!s.pathname.includes("?"),Om("?","pathname","search",s)),Ze(!s.pathname||!s.pathname.includes("#"),Om("#","pathname","hash",s)),Ze(!s.search||!s.search.includes("#"),Om("#","search","hash",s)));let o=e===""||s.pathname==="",a=o?"/":s.pathname,l;if(a==null)l=n;else{let p=t.length-1;if(!r&&a.startsWith("..")){let f=a.split("/");for(;f[0]==="..";)f.shift(),p-=1;s.pathname=f.join("/")}l=p>=0?t[p]:"/"}let c=N2(s,l),i=a&&a!=="/"&&a.endsWith("/"),d=(o||a===".")&&n.endsWith("/");return!c.pathname.endsWith("/")&&(i||d)&&(c.pathname+="/"),c}const uo=e=>e.join("/").replace(/\/\/+/g,"/"),D2=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),A2=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,F2=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e;class _x{constructor(t,n,r,s){s===void 0&&(s=!1),this.status=t,this.statusText=n||"",this.internal=s,r instanceof Error?(this.data=r.toString(),this.error=r):this.data=r}}function Zh(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}const u_=["post","put","patch","delete"],L2=new Set(u_),$2=["get",...u_],B2=new Set($2),z2=new Set([301,302,303,307,308]),U2=new Set([307,308]),Nm={state:"idle",location:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0},V2={state:"idle",data:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0},Ku={state:"unblocked",proceed:void 0,reset:void 0,location:void 0},jx=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,H2=e=>({hasErrorBoundary:!!e.hasErrorBoundary}),c_="remix-router-transitions";function K2(e){const t=e.window?e.window:typeof window<"u"?window:void 0,n=typeof t<"u"&&typeof t.document<"u"&&typeof t.document.createElement<"u",r=!n;Ze(e.routes.length>0,"You must provide a non-empty routes array to createRouter");let s;if(e.mapRouteProperties)s=e.mapRouteProperties;else if(e.detectErrorBoundary){let M=e.detectErrorBoundary;s=O=>({hasErrorBoundary:M(O)})}else s=H2;let o={},a=ed(e.routes,s,void 0,o),l,c=e.basename||"/",i=e.unstable_dataStrategy||Q2,d=e.unstable_patchRoutesOnMiss,p=At({v7_fetcherPersist:!1,v7_normalizeFormMethod:!1,v7_partialHydration:!1,v7_prependBasename:!1,v7_relativeSplatPath:!1,v7_skipActionErrorRevalidation:!1},e.future),f=null,h=new Set,g=null,m=null,x=null,b=e.hydrationData!=null,y=Ua(a,e.history.location,c),w=null;if(y==null&&!d){let M=Bn(404,{pathname:e.history.location.pathname}),{matches:O,route:L}=k0(a);y=O,w={[L.id]:M}}y&&d&&!e.hydrationData&&rm(y,a,e.history.location.pathname).active&&(y=null);let S;if(!y)S=!1,y=[];else if(y.some(M=>M.route.lazy))S=!1;else if(!y.some(M=>M.route.loader))S=!0;else if(p.v7_partialHydration){let M=e.hydrationData?e.hydrationData.loaderData:null,O=e.hydrationData?e.hydrationData.errors:null,L=H=>H.route.loader?typeof H.route.loader=="function"&&H.route.loader.hydrate===!0?!1:M&&M[H.route.id]!==void 0||O&&O[H.route.id]!==void 0:!0;if(O){let H=y.findIndex(ye=>O[ye.route.id]!==void 0);S=y.slice(0,H+1).every(L)}else S=y.every(L)}else S=e.hydrationData!=null;let E,C={historyAction:e.history.action,location:e.history.location,matches:y,initialized:S,navigation:Nm,restoreScrollPosition:e.hydrationData!=null?!1:null,preventScrollReset:!1,revalidation:"idle",loaderData:e.hydrationData&&e.hydrationData.loaderData||{},actionData:e.hydrationData&&e.hydrationData.actionData||null,errors:e.hydrationData&&e.hydrationData.errors||w,fetchers:new Map,blockers:new Map},k=en.Pop,T=!1,P,N=!1,U=new Map,I=null,Z=!1,V=!1,Q=[],ee=[],W=new Map,F=0,A=-1,Y=new Map,de=new Set,z=new Map,se=new Map,ne=new Set,ie=new Map,oe=new Map,J=new Map,Ce=!1;function Pe(){if(f=e.history.listen(M=>{let{action:O,location:L,delta:H}=M;if(Ce){Ce=!1;return}Xl(oe.size===0||H!=null,"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");let ye=Ro({currentLocation:C.location,nextLocation:L,historyAction:O});if(ye&&H!=null){Ce=!0,e.history.go(H*-1),ms(ye,{state:"blocked",location:L,proceed(){ms(ye,{state:"proceeding",proceed:void 0,reset:void 0,location:L}),e.history.go(H)},reset(){let _e=new Map(C.blockers);_e.set(ye,Ku),me({blockers:_e})}});return}return Wt(O,L)}),n){uL(t,U);let M=()=>cL(t,U);t.addEventListener("pagehide",M),I=()=>t.removeEventListener("pagehide",M)}return C.initialized||Wt(en.Pop,C.location,{initialHydration:!0}),E}function Le(){f&&f(),I&&I(),h.clear(),P&&P.abort(),C.fetchers.forEach((M,O)=>gs(O)),C.blockers.forEach((M,O)=>_n(O))}function Me(M){return h.add(M),()=>h.delete(M)}function me(M,O){O===void 0&&(O={}),C=At({},C,M);let L=[],H=[];p.v7_fetcherPersist&&C.fetchers.forEach((ye,_e)=>{ye.state==="idle"&&(ne.has(_e)?H.push(_e):L.push(_e))}),[...h].forEach(ye=>ye(C,{deletedFetchers:H,unstable_viewTransitionOpts:O.viewTransitionOpts,unstable_flushSync:O.flushSync===!0})),p.v7_fetcherPersist&&(L.forEach(ye=>C.fetchers.delete(ye)),H.forEach(ye=>gs(ye)))}function rt(M,O,L){var H,ye;let{flushSync:_e}=L===void 0?{}:L,$e=C.actionData!=null&&C.navigation.formMethod!=null&&Jr(C.navigation.formMethod)&&C.navigation.state==="loading"&&((H=M.state)==null?void 0:H._isRedirect)!==!0,fe;O.actionData?Object.keys(O.actionData).length>0?fe=O.actionData:fe=null:$e?fe=C.actionData:fe=null;let qe=O.loaderData?E0(C.loaderData,O.loaderData,O.matches||[],O.errors):C.loaderData,Re=C.blockers;Re.size>0&&(Re=new Map(Re),Re.forEach((mt,bt)=>Re.set(bt,Ku)));let Oe=T===!0||C.navigation.formMethod!=null&&Jr(C.navigation.formMethod)&&((ye=M.state)==null?void 0:ye._isRedirect)!==!0;l&&(a=l,l=void 0),Z||k===en.Pop||(k===en.Push?e.history.push(M,M.state):k===en.Replace&&e.history.replace(M,M.state));let yt;if(k===en.Pop){let mt=U.get(C.location.pathname);mt&&mt.has(M.pathname)?yt={currentLocation:C.location,nextLocation:M}:U.has(M.pathname)&&(yt={currentLocation:M,nextLocation:C.location})}else if(N){let mt=U.get(C.location.pathname);mt?mt.add(M.pathname):(mt=new Set([M.pathname]),U.set(C.location.pathname,mt)),yt={currentLocation:C.location,nextLocation:M}}me(At({},O,{actionData:fe,loaderData:qe,historyAction:k,location:M,initialized:!0,navigation:Nm,revalidation:"idle",restoreScrollPosition:Kw(M,O.matches||C.matches),preventScrollReset:Oe,blockers:Re}),{viewTransitionOpts:yt,flushSync:_e===!0}),k=en.Pop,T=!1,N=!1,Z=!1,V=!1,Q=[],ee=[]}async function It(M,O){if(typeof M=="number"){e.history.go(M);return}let L=Oy(C.location,C.matches,c,p.v7_prependBasename,M,p.v7_relativeSplatPath,O==null?void 0:O.fromRouteId,O==null?void 0:O.relative),{path:H,submission:ye,error:_e}=v0(p.v7_normalizeFormMethod,!1,L,O),$e=C.location,fe=Xc(C.location,H,O&&O.state);fe=At({},fe,e.history.encodeLocation(fe));let qe=O&&O.replace!=null?O.replace:void 0,Re=en.Push;qe===!0?Re=en.Replace:qe===!1||ye!=null&&Jr(ye.formMethod)&&ye.formAction===C.location.pathname+C.location.search&&(Re=en.Replace);let Oe=O&&"preventScrollReset"in O?O.preventScrollReset===!0:void 0,yt=(O&&O.unstable_flushSync)===!0,mt=Ro({currentLocation:$e,nextLocation:fe,historyAction:Re});if(mt){ms(mt,{state:"blocked",location:fe,proceed(){ms(mt,{state:"proceeding",proceed:void 0,reset:void 0,location:fe}),It(M,O)},reset(){let bt=new Map(C.blockers);bt.set(mt,Ku),me({blockers:bt})}});return}return await Wt(Re,fe,{submission:ye,pendingError:_e,preventScrollReset:Oe,replace:O&&O.replace,enableViewTransition:O&&O.unstable_viewTransition,flushSync:yt})}function Zt(){if(hn(),me({revalidation:"loading"}),C.navigation.state!=="submitting"){if(C.navigation.state==="idle"){Wt(C.historyAction,C.location,{startUninterruptedRevalidation:!0});return}Wt(k||C.historyAction,C.navigation.location,{overrideNavigation:C.navigation})}}async function Wt(M,O,L){P&&P.abort(),P=null,k=M,Z=(L&&L.startUninterruptedRevalidation)===!0,UI(C.location,C.matches),T=(L&&L.preventScrollReset)===!0,N=(L&&L.enableViewTransition)===!0;let H=l||a,ye=L&&L.overrideNavigation,_e=Ua(H,O,c),$e=(L&&L.flushSync)===!0,fe=rm(_e,H,O.pathname);if(fe.active&&fe.matches&&(_e=fe.matches),!_e){let{error:pt,notFoundMatches:bn,route:Yt}=Iu(O.pathname);rt(O,{matches:bn,loaderData:{},errors:{[Yt.id]:pt}},{flushSync:$e});return}if(C.initialized&&!V&&nL(C.location,O)&&!(L&&L.submission&&Jr(L.submission.formMethod))){rt(O,{matches:_e},{flushSync:$e});return}P=new AbortController;let qe=Hi(e.history,O,P.signal,L&&L.submission),Re;if(L&&L.pendingError)Re=[gl(_e).route.id,{type:Ct.error,error:L.pendingError}];else if(L&&L.submission&&Jr(L.submission.formMethod)){let pt=await an(qe,O,L.submission,_e,fe.active,{replace:L.replace,flushSync:$e});if(pt.shortCircuited)return;if(pt.pendingActionResult){let[bn,Yt]=pt.pendingActionResult;if(fr(Yt)&&Zh(Yt.error)&&Yt.error.status===404){P=null,rt(O,{matches:pt.matches,loaderData:{},errors:{[bn]:Yt.error}});return}}_e=pt.matches||_e,Re=pt.pendingActionResult,ye=Im(O,L.submission),$e=!1,fe.active=!1,qe=Hi(e.history,qe.url,qe.signal)}let{shortCircuited:Oe,matches:yt,loaderData:mt,errors:bt}=await j(qe,O,_e,fe.active,ye,L&&L.submission,L&&L.fetcherSubmission,L&&L.replace,L&&L.initialHydration===!0,$e,Re);Oe||(P=null,rt(O,At({matches:yt||_e},T0(Re),{loaderData:mt,errors:bt})))}async function an(M,O,L,H,ye,_e){_e===void 0&&(_e={}),hn();let $e=iL(O,L);if(me({navigation:$e},{flushSync:_e.flushSync===!0}),ye){let Re=await sf(H,O.pathname,M.signal);if(Re.type==="aborted")return{shortCircuited:!0};if(Re.type==="error"){let{boundaryId:Oe,error:yt}=$i(O.pathname,Re);return{matches:Re.partialMatches,pendingActionResult:[Oe,{type:Ct.error,error:yt}]}}else if(Re.matches)H=Re.matches;else{let{notFoundMatches:Oe,error:yt,route:mt}=Iu(O.pathname);return{matches:Oe,pendingActionResult:[mt.id,{type:Ct.error,error:yt}]}}}let fe,qe=cc(H,O);if(!qe.route.action&&!qe.route.lazy)fe={type:Ct.error,error:Bn(405,{method:M.method,pathname:O.pathname,routeId:qe.route.id})};else if(fe=(await et("action",M,[qe],H))[0],M.signal.aborted)return{shortCircuited:!0};if(Wa(fe)){let Re;return _e&&_e.replace!=null?Re=_e.replace:Re=w0(fe.response.headers.get("Location"),new URL(M.url),c)===C.location.pathname+C.location.search,await Ee(M,fe,{submission:L,replace:Re}),{shortCircuited:!0}}if(qa(fe))throw Bn(400,{type:"defer-action"});if(fr(fe)){let Re=gl(H,qe.route.id);return(_e&&_e.replace)!==!0&&(k=en.Push),{matches:H,pendingActionResult:[Re.route.id,fe]}}return{matches:H,pendingActionResult:[qe.route.id,fe]}}async function j(M,O,L,H,ye,_e,$e,fe,qe,Re,Oe){let yt=ye||Im(O,_e),mt=_e||$e||R0(yt),bt=!Z&&(!p.v7_partialHydration||!qe);if(H){if(bt){let Vt=D(Oe);me(At({navigation:yt},Vt!==void 0?{actionData:Vt}:{}),{flushSync:Re})}let Ge=await sf(L,O.pathname,M.signal);if(Ge.type==="aborted")return{shortCircuited:!0};if(Ge.type==="error"){let{boundaryId:Vt,error:ar}=$i(O.pathname,Ge);return{matches:Ge.partialMatches,loaderData:{},errors:{[Vt]:ar}}}else if(Ge.matches)L=Ge.matches;else{let{error:Vt,notFoundMatches:ar,route:Mt}=Iu(O.pathname);return{matches:ar,loaderData:{},errors:{[Mt.id]:Vt}}}}let pt=l||a,[bn,Yt]=y0(e.history,C,L,mt,O,p.v7_partialHydration&&qe===!0,p.v7_skipActionErrorRevalidation,V,Q,ee,ne,z,de,pt,c,Oe);if(vs(Ge=>!(L&&L.some(Vt=>Vt.route.id===Ge))||bn&&bn.some(Vt=>Vt.route.id===Ge)),A=++F,bn.length===0&&Yt.length===0){let Ge=Ue();return rt(O,At({matches:L,loaderData:{},errors:Oe&&fr(Oe[1])?{[Oe[0]]:Oe[1].error}:null},T0(Oe),Ge?{fetchers:new Map(C.fetchers)}:{}),{flushSync:Re}),{shortCircuited:!0}}if(bt){let Ge={};if(!H){Ge.navigation=yt;let Vt=D(Oe);Vt!==void 0&&(Ge.actionData=Vt)}Yt.length>0&&(Ge.fetchers=B(Yt)),me(Ge,{flushSync:Re})}Yt.forEach(Ge=>{W.has(Ge.key)&&Fn(Ge.key),Ge.controller&&W.set(Ge.key,Ge.controller)});let Au=()=>Yt.forEach(Ge=>Fn(Ge.key));P&&P.signal.addEventListener("abort",Au);let{loaderResults:Po,fetcherResults:Bi}=await kt(C.matches,L,bn,Yt,M);if(M.signal.aborted)return{shortCircuited:!0};P&&P.signal.removeEventListener("abort",Au),Yt.forEach(Ge=>W.delete(Ge.key));let zi=_0([...Po,...Bi]);if(zi){if(zi.idx>=bn.length){let Ge=Yt[zi.idx-bn.length].key;de.add(Ge)}return await Ee(M,zi.result,{replace:fe}),{shortCircuited:!0}}let{loaderData:Ui,errors:ys}=C0(C,L,bn,Po,Oe,Yt,Bi,ie);ie.forEach((Ge,Vt)=>{Ge.subscribe(ar=>{(ar||Ge.done)&&ie.delete(Vt)})}),p.v7_partialHydration&&qe&&C.errors&&Object.entries(C.errors).filter(Ge=>{let[Vt]=Ge;return!bn.some(ar=>ar.route.id===Vt)}).forEach(Ge=>{let[Vt,ar]=Ge;ys=Object.assign(ys||{},{[Vt]:ar})});let of=Ue(),af=St(A),lf=of||af||Yt.length>0;return At({matches:L,loaderData:Ui,errors:ys},lf?{fetchers:new Map(C.fetchers)}:{})}function D(M){if(M&&!fr(M[1]))return{[M[0]]:M[1].data};if(C.actionData)return Object.keys(C.actionData).length===0?null:C.actionData}function B(M){return M.forEach(O=>{let L=C.fetchers.get(O.key),H=qu(void 0,L?L.data:void 0);C.fetchers.set(O.key,H)}),new Map(C.fetchers)}function pe(M,O,L,H){if(r)throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");W.has(M)&&Fn(M);let ye=(H&&H.unstable_flushSync)===!0,_e=l||a,$e=Oy(C.location,C.matches,c,p.v7_prependBasename,L,p.v7_relativeSplatPath,O,H==null?void 0:H.relative),fe=Ua(_e,$e,c),qe=rm(fe,_e,$e);if(qe.active&&qe.matches&&(fe=qe.matches),!fe){gn(M,O,Bn(404,{pathname:$e}),{flushSync:ye});return}let{path:Re,submission:Oe,error:yt}=v0(p.v7_normalizeFormMethod,!0,$e,H);if(yt){gn(M,O,yt,{flushSync:ye});return}let mt=cc(fe,Re);if(T=(H&&H.preventScrollReset)===!0,Oe&&Jr(Oe.formMethod)){le(M,O,Re,mt,fe,qe.active,ye,Oe);return}z.set(M,{routeId:O,path:Re}),ae(M,O,Re,mt,fe,qe.active,ye,Oe)}async function le(M,O,L,H,ye,_e,$e,fe){hn(),z.delete(M);function qe(Mt){if(!Mt.route.action&&!Mt.route.lazy){let Ks=Bn(405,{method:fe.formMethod,pathname:L,routeId:O});return gn(M,O,Ks,{flushSync:$e}),!0}return!1}if(!_e&&qe(H))return;let Re=C.fetchers.get(M);yn(M,lL(fe,Re),{flushSync:$e});let Oe=new AbortController,yt=Hi(e.history,L,Oe.signal,fe);if(_e){let Mt=await sf(ye,L,yt.signal);if(Mt.type==="aborted")return;if(Mt.type==="error"){let{error:Ks}=$i(L,Mt);gn(M,O,Ks,{flushSync:$e});return}else if(Mt.matches){if(ye=Mt.matches,H=cc(ye,L),qe(H))return}else{gn(M,O,Bn(404,{pathname:L}),{flushSync:$e});return}}W.set(M,Oe);let mt=F,pt=(await et("action",yt,[H],ye))[0];if(yt.signal.aborted){W.get(M)===Oe&&W.delete(M);return}if(p.v7_fetcherPersist&&ne.has(M)){if(Wa(pt)||fr(pt)){yn(M,Fo(void 0));return}}else{if(Wa(pt))if(W.delete(M),A>mt){yn(M,Fo(void 0));return}else return de.add(M),yn(M,qu(fe)),Ee(yt,pt,{fetcherSubmission:fe});if(fr(pt)){gn(M,O,pt.error);return}}if(qa(pt))throw Bn(400,{type:"defer-action"});let bn=C.navigation.location||C.location,Yt=Hi(e.history,bn,Oe.signal),Au=l||a,Po=C.navigation.state!=="idle"?Ua(Au,C.navigation.location,c):C.matches;Ze(Po,"Didn't find any matches after fetcher action");let Bi=++F;Y.set(M,Bi);let zi=qu(fe,pt.data);C.fetchers.set(M,zi);let[Ui,ys]=y0(e.history,C,Po,fe,bn,!1,p.v7_skipActionErrorRevalidation,V,Q,ee,ne,z,de,Au,c,[H.route.id,pt]);ys.filter(Mt=>Mt.key!==M).forEach(Mt=>{let Ks=Mt.key,qw=C.fetchers.get(Ks),KI=qu(void 0,qw?qw.data:void 0);C.fetchers.set(Ks,KI),W.has(Ks)&&Fn(Ks),Mt.controller&&W.set(Ks,Mt.controller)}),me({fetchers:new Map(C.fetchers)});let of=()=>ys.forEach(Mt=>Fn(Mt.key));Oe.signal.addEventListener("abort",of);let{loaderResults:af,fetcherResults:lf}=await kt(C.matches,Po,Ui,ys,Yt);if(Oe.signal.aborted)return;Oe.signal.removeEventListener("abort",of),Y.delete(M),W.delete(M),ys.forEach(Mt=>W.delete(Mt.key));let Ge=_0([...af,...lf]);if(Ge){if(Ge.idx>=Ui.length){let Mt=ys[Ge.idx-Ui.length].key;de.add(Mt)}return Ee(Yt,Ge.result)}let{loaderData:Vt,errors:ar}=C0(C,C.matches,Ui,af,void 0,ys,lf,ie);if(C.fetchers.has(M)){let Mt=Fo(pt.data);C.fetchers.set(M,Mt)}St(Bi),C.navigation.state==="loading"&&Bi>A?(Ze(k,"Expected pending action"),P&&P.abort(),rt(C.navigation.location,{matches:Po,loaderData:Vt,errors:ar,fetchers:new Map(C.fetchers)})):(me({errors:ar,loaderData:E0(C.loaderData,Vt,Po,ar),fetchers:new Map(C.fetchers)}),V=!1)}async function ae(M,O,L,H,ye,_e,$e,fe){let qe=C.fetchers.get(M);yn(M,qu(fe,qe?qe.data:void 0),{flushSync:$e});let Re=new AbortController,Oe=Hi(e.history,L,Re.signal);if(_e){let pt=await sf(ye,L,Oe.signal);if(pt.type==="aborted")return;if(pt.type==="error"){let{error:bn}=$i(L,pt);gn(M,O,bn,{flushSync:$e});return}else if(pt.matches)ye=pt.matches,H=cc(ye,L);else{gn(M,O,Bn(404,{pathname:L}),{flushSync:$e});return}}W.set(M,Re);let yt=F,bt=(await et("loader",Oe,[H],ye))[0];if(qa(bt)&&(bt=await g_(bt,Oe.signal,!0)||bt),W.get(M)===Re&&W.delete(M),!Oe.signal.aborted){if(ne.has(M)){yn(M,Fo(void 0));return}if(Wa(bt))if(A>yt){yn(M,Fo(void 0));return}else{de.add(M),await Ee(Oe,bt);return}if(fr(bt)){gn(M,O,bt.error);return}Ze(!qa(bt),"Unhandled fetcher deferred data"),yn(M,Fo(bt.data))}}async function Ee(M,O,L){let{submission:H,fetcherSubmission:ye,replace:_e}=L===void 0?{}:L;O.response.headers.has("X-Remix-Revalidate")&&(V=!0);let $e=O.response.headers.get("Location");Ze($e,"Expected a Location header on the redirect Response"),$e=w0($e,new URL(M.url),c);let fe=Xc(C.location,$e,{_isRedirect:!0});if(n){let bt=!1;if(O.response.headers.has("X-Remix-Reload-Document"))bt=!0;else if(jx.test($e)){const pt=e.history.createURL($e);bt=pt.origin!==t.location.origin||du(pt.pathname,c)==null}if(bt){_e?t.location.replace($e):t.location.assign($e);return}}P=null;let qe=_e===!0?en.Replace:en.Push,{formMethod:Re,formAction:Oe,formEncType:yt}=C.navigation;!H&&!ye&&Re&&Oe&&yt&&(H=R0(C.navigation));let mt=H||ye;if(U2.has(O.response.status)&&mt&&Jr(mt.formMethod))await Wt(qe,fe,{submission:At({},mt,{formAction:$e}),preventScrollReset:T});else{let bt=Im(fe,H);await Wt(qe,fe,{overrideNavigation:bt,fetcherSubmission:ye,preventScrollReset:T})}}async function et(M,O,L,H){try{let ye=await Z2(i,M,O,L,H,o,s);return await Promise.all(ye.map((_e,$e)=>{if(sL(_e)){let fe=_e.result;return{type:Ct.redirect,response:eL(fe,O,L[$e].route.id,H,c,p.v7_relativeSplatPath)}}return X2(_e)}))}catch(ye){return L.map(()=>({type:Ct.error,error:ye}))}}async function kt(M,O,L,H,ye){let[_e,...$e]=await Promise.all([L.length?et("loader",ye,L,O):[],...H.map(fe=>{if(fe.matches&&fe.match&&fe.controller){let qe=Hi(e.history,fe.path,fe.controller.signal);return et("loader",qe,[fe.match],fe.matches).then(Re=>Re[0])}else return Promise.resolve({type:Ct.error,error:Bn(404,{pathname:fe.path})})})]);return await Promise.all([j0(M,L,_e,_e.map(()=>ye.signal),!1,C.loaderData),j0(M,H.map(fe=>fe.match),$e,H.map(fe=>fe.controller?fe.controller.signal:null),!0)]),{loaderResults:_e,fetcherResults:$e}}function hn(){V=!0,Q.push(...vs()),z.forEach((M,O)=>{W.has(O)&&(ee.push(O),Fn(O))})}function yn(M,O,L){L===void 0&&(L={}),C.fetchers.set(M,O),me({fetchers:new Map(C.fetchers)},{flushSync:(L&&L.flushSync)===!0})}function gn(M,O,L,H){H===void 0&&(H={});let ye=gl(C.matches,O);gs(M),me({errors:{[ye.route.id]:L},fetchers:new Map(C.fetchers)},{flushSync:(H&&H.flushSync)===!0})}function jo(M){return p.v7_fetcherPersist&&(se.set(M,(se.get(M)||0)+1),ne.has(M)&&ne.delete(M)),C.fetchers.get(M)||V2}function gs(M){let O=C.fetchers.get(M);W.has(M)&&!(O&&O.state==="loading"&&Y.has(M))&&Fn(M),z.delete(M),Y.delete(M),de.delete(M),ne.delete(M),C.fetchers.delete(M)}function Aa(M){if(p.v7_fetcherPersist){let O=(se.get(M)||0)-1;O<=0?(se.delete(M),ne.add(M)):se.set(M,O)}else gs(M);me({fetchers:new Map(C.fetchers)})}function Fn(M){let O=W.get(M);Ze(O,"Expected fetch controller: "+M),O.abort(),W.delete(M)}function ue(M){for(let O of M){let L=jo(O),H=Fo(L.data);C.fetchers.set(O,H)}}function Ue(){let M=[],O=!1;for(let L of de){let H=C.fetchers.get(L);Ze(H,"Expected fetcher: "+L),H.state==="loading"&&(de.delete(L),M.push(L),O=!0)}return ue(M),O}function St(M){let O=[];for(let[L,H]of Y)if(H<M){let ye=C.fetchers.get(L);Ze(ye,"Expected fetcher: "+L),ye.state==="loading"&&(Fn(L),Y.delete(L),O.push(L))}return ue(O),O.length>0}function dt(M,O){let L=C.blockers.get(M)||Ku;return oe.get(M)!==O&&oe.set(M,O),L}function _n(M){C.blockers.delete(M),oe.delete(M)}function ms(M,O){let L=C.blockers.get(M)||Ku;Ze(L.state==="unblocked"&&O.state==="blocked"||L.state==="blocked"&&O.state==="blocked"||L.state==="blocked"&&O.state==="proceeding"||L.state==="blocked"&&O.state==="unblocked"||L.state==="proceeding"&&O.state==="unblocked","Invalid blocker state transition: "+L.state+" -> "+O.state);let H=new Map(C.blockers);H.set(M,O),me({blockers:H})}function Ro(M){let{currentLocation:O,nextLocation:L,historyAction:H}=M;if(oe.size===0)return;oe.size>1&&Xl(!1,"A router only supports one blocker at a time");let ye=Array.from(oe.entries()),[_e,$e]=ye[ye.length-1],fe=C.blockers.get(_e);if(!(fe&&fe.state==="proceeding")&&$e({currentLocation:O,nextLocation:L,historyAction:H}))return _e}function Iu(M){let O=Bn(404,{pathname:M}),L=l||a,{matches:H,route:ye}=k0(L);return vs(),{notFoundMatches:H,route:ye,error:O}}function $i(M,O){return{boundaryId:gl(O.partialMatches).route.id,error:Bn(400,{type:"route-discovery",pathname:M,message:O.error!=null&&"message"in O.error?O.error:String(O.error)})}}function vs(M){let O=[];return ie.forEach((L,H)=>{(!M||M(H))&&(L.cancel(),O.push(H),ie.delete(H))}),O}function Du(M,O,L){if(g=M,x=O,m=L||null,!b&&C.navigation===Nm){b=!0;let H=Kw(C.location,C.matches);H!=null&&me({restoreScrollPosition:H})}return()=>{g=null,x=null,m=null}}function Hw(M,O){return m&&m(M,O.map(H=>x2(H,C.loaderData)))||M.key}function UI(M,O){if(g&&x){let L=Hw(M,O);g[L]=x()}}function Kw(M,O){if(g){let L=Hw(M,O),H=g[L];if(typeof H=="number")return H}return null}function rm(M,O,L){if(d)if(M){let H=M[M.length-1].route;if(H.path&&(H.path==="*"||H.path.endsWith("/*")))return{active:!0,matches:cp(O,L,c,!0)}}else return{active:!0,matches:cp(O,L,c,!0)||[]};return{active:!1,matches:null}}async function sf(M,O,L){let H=M,ye=H.length>0?H[H.length-1].route:null;for(;;){let _e=l==null,$e=l||a;try{await J2(d,O,H,$e,o,s,J,L)}catch(Oe){return{type:"error",error:Oe,partialMatches:H}}finally{_e&&(a=[...a])}if(L.aborted)return{type:"aborted"};let fe=Ua($e,O,c),qe=!1;if(fe){let Oe=fe[fe.length-1].route;if(Oe.index)return{type:"success",matches:fe};if(Oe.path&&Oe.path.length>0)if(Oe.path==="*")qe=!0;else return{type:"success",matches:fe}}let Re=cp($e,O,c,!0);if(!Re||H.map(Oe=>Oe.route.id).join("-")===Re.map(Oe=>Oe.route.id).join("-"))return{type:"success",matches:qe?fe:null};if(H=Re,ye=H[H.length-1].route,ye.path==="*")return{type:"success",matches:H}}}function VI(M){o={},l=ed(M,s,void 0,o)}function HI(M,O){let L=l==null;f_(M,O,l||a,o,s),L&&(a=[...a],me({}))}return E={get basename(){return c},get future(){return p},get state(){return C},get routes(){return a},get window(){return t},initialize:Pe,subscribe:Me,enableScrollRestoration:Du,navigate:It,fetch:pe,revalidate:Zt,createHref:M=>e.history.createHref(M),encodeLocation:M=>e.history.encodeLocation(M),getFetcher:jo,deleteFetcher:Aa,dispose:Le,getBlocker:dt,deleteBlocker:_n,patchRoutes:HI,_internalFetchControllers:W,_internalActiveDeferreds:ie,_internalSetRoutes:VI},E}function q2(e){return e!=null&&("formData"in e&&e.formData!=null||"body"in e&&e.body!==void 0)}function Oy(e,t,n,r,s,o,a,l){let c,i;if(a){c=[];for(let p of t)if(c.push(p),p.route.id===a){i=p;break}}else c=t,i=t[t.length-1];let d=Qh(s||".",Jh(c,o),du(e.pathname,n)||e.pathname,l==="path");return s==null&&(d.search=e.search,d.hash=e.hash),(s==null||s===""||s===".")&&i&&i.route.index&&!Rx(d.search)&&(d.search=d.search?d.search.replace(/^\?/,"?index&"):"?index"),r&&n!=="/"&&(d.pathname=d.pathname==="/"?n:uo([n,d.pathname])),wi(d)}function v0(e,t,n,r){if(!r||!q2(r))return{path:n};if(r.formMethod&&!aL(r.formMethod))return{path:n,error:Bn(405,{method:r.formMethod})};let s=()=>({path:n,error:Bn(400,{type:"invalid-body"})}),o=r.formMethod||"get",a=e?o.toUpperCase():o.toLowerCase(),l=p_(n);if(r.body!==void 0){if(r.formEncType==="text/plain"){if(!Jr(a))return s();let f=typeof r.body=="string"?r.body:r.body instanceof FormData||r.body instanceof URLSearchParams?Array.from(r.body.entries()).reduce((h,g)=>{let[m,x]=g;return""+h+m+"="+x+`
`},""):String(r.body);return{path:n,submission:{formMethod:a,formAction:l,formEncType:r.formEncType,formData:void 0,json:void 0,text:f}}}else if(r.formEncType==="application/json"){if(!Jr(a))return s();try{let f=typeof r.body=="string"?JSON.parse(r.body):r.body;return{path:n,submission:{formMethod:a,formAction:l,formEncType:r.formEncType,formData:void 0,json:f,text:void 0}}}catch{return s()}}}Ze(typeof FormData=="function","FormData is not available in this environment");let c,i;if(r.formData)c=Ny(r.formData),i=r.formData;else if(r.body instanceof FormData)c=Ny(r.body),i=r.body;else if(r.body instanceof URLSearchParams)c=r.body,i=S0(c);else if(r.body==null)c=new URLSearchParams,i=new FormData;else try{c=new URLSearchParams(r.body),i=S0(c)}catch{return s()}let d={formMethod:a,formAction:l,formEncType:r&&r.formEncType||"application/x-www-form-urlencoded",formData:i,json:void 0,text:void 0};if(Jr(d.formMethod))return{path:n,submission:d};let p=_a(n);return t&&p.search&&Rx(p.search)&&c.append("index",""),p.search="?"+c,{path:wi(p),submission:d}}function W2(e,t){let n=e;if(t){let r=e.findIndex(s=>s.route.id===t);r>=0&&(n=e.slice(0,r))}return n}function y0(e,t,n,r,s,o,a,l,c,i,d,p,f,h,g,m){let x=m?fr(m[1])?m[1].error:m[1].data:void 0,b=e.createURL(t.location),y=e.createURL(s),w=m&&fr(m[1])?m[0]:void 0,S=w?W2(n,w):n,E=m?m[1].statusCode:void 0,C=a&&E&&E>=400,k=S.filter((P,N)=>{let{route:U}=P;if(U.lazy)return!0;if(U.loader==null)return!1;if(o)return typeof U.loader!="function"||U.loader.hydrate?!0:t.loaderData[U.id]===void 0&&(!t.errors||t.errors[U.id]===void 0);if(G2(t.loaderData,t.matches[N],P)||c.some(V=>V===P.route.id))return!0;let I=t.matches[N],Z=P;return b0(P,At({currentUrl:b,currentParams:I.params,nextUrl:y,nextParams:Z.params},r,{actionResult:x,actionStatus:E,defaultShouldRevalidate:C?!1:l||b.pathname+b.search===y.pathname+y.search||b.search!==y.search||d_(I,Z)}))}),T=[];return p.forEach((P,N)=>{if(o||!n.some(Q=>Q.route.id===P.routeId)||d.has(N))return;let U=Ua(h,P.path,g);if(!U){T.push({key:N,routeId:P.routeId,path:P.path,matches:null,match:null,controller:null});return}let I=t.fetchers.get(N),Z=cc(U,P.path),V=!1;f.has(N)?V=!1:i.includes(N)?V=!0:I&&I.state!=="idle"&&I.data===void 0?V=l:V=b0(Z,At({currentUrl:b,currentParams:t.matches[t.matches.length-1].params,nextUrl:y,nextParams:n[n.length-1].params},r,{actionResult:x,actionStatus:E,defaultShouldRevalidate:C?!1:l})),V&&T.push({key:N,routeId:P.routeId,path:P.path,matches:U,match:Z,controller:new AbortController})}),[k,T]}function G2(e,t,n){let r=!t||n.route.id!==t.route.id,s=e[n.route.id]===void 0;return r||s}function d_(e,t){let n=e.route.path;return e.pathname!==t.pathname||n!=null&&n.endsWith("*")&&e.params["*"]!==t.params["*"]}function b0(e,t){if(e.route.shouldRevalidate){let n=e.route.shouldRevalidate(t);if(typeof n=="boolean")return n}return t.defaultShouldRevalidate}async function J2(e,t,n,r,s,o,a,l){let c=[t,...n.map(i=>i.route.id)].join("-");try{let i=a.get(c);i||(i=e({path:t,matches:n,patch:(d,p)=>{l.aborted||f_(d,p,r,s,o)}}),a.set(c,i)),i&&rL(i)&&await i}finally{a.delete(c)}}function f_(e,t,n,r,s){if(e){var o;let a=r[e];Ze(a,"No route found to patch children into: routeId = "+e);let l=ed(t,s,[e,"patch",String(((o=a.children)==null?void 0:o.length)||"0")],r);a.children?a.children.push(...l):a.children=l}else{let a=ed(t,s,["patch",String(n.length||"0")],r);n.push(...a)}}async function x0(e,t,n){if(!e.lazy)return;let r=await e.lazy();if(!e.lazy)return;let s=n[e.id];Ze(s,"No route found in manifest");let o={};for(let a in r){let c=s[a]!==void 0&&a!=="hasErrorBoundary";Xl(!c,'Route "'+s.id+'" has a static property "'+a+'" defined but its lazy function is also returning a value for this property. '+('The lazy route property "'+a+'" will be ignored.')),!c&&!y2.has(a)&&(o[a]=r[a])}Object.assign(s,o),Object.assign(s,At({},t(s),{lazy:void 0}))}function Q2(e){return Promise.all(e.matches.map(t=>t.resolve()))}async function Z2(e,t,n,r,s,o,a,l){let c=r.reduce((p,f)=>p.add(f.route.id),new Set),i=new Set,d=await e({matches:s.map(p=>{let f=c.has(p.route.id);return At({},p,{shouldLoad:f,resolve:g=>(i.add(p.route.id),f?Y2(t,n,p,o,a,g,l):Promise.resolve({type:Ct.data,result:void 0}))})}),request:n,params:s[0].params,context:l});return s.forEach(p=>Ze(i.has(p.route.id),'`match.resolve()` was not called for route id "'+p.route.id+'". You must call `match.resolve()` on every match passed to `dataStrategy` to ensure all routes are properly loaded.')),d.filter((p,f)=>c.has(s[f].route.id))}async function Y2(e,t,n,r,s,o,a){let l,c,i=d=>{let p,f=new Promise((m,x)=>p=x);c=()=>p(),t.signal.addEventListener("abort",c);let h=m=>typeof d!="function"?Promise.reject(new Error("You cannot call the handler for a route which defines a boolean "+('"'+e+'" [routeId: '+n.route.id+"]"))):d({request:t,params:n.params,context:a},...m!==void 0?[m]:[]),g;return o?g=o(m=>h(m)):g=(async()=>{try{return{type:"data",result:await h()}}catch(m){return{type:"error",result:m}}})(),Promise.race([g,f])};try{let d=n.route[e];if(n.route.lazy)if(d){let p,[f]=await Promise.all([i(d).catch(h=>{p=h}),x0(n.route,s,r)]);if(p!==void 0)throw p;l=f}else if(await x0(n.route,s,r),d=n.route[e],d)l=await i(d);else if(e==="action"){let p=new URL(t.url),f=p.pathname+p.search;throw Bn(405,{method:t.method,pathname:f,routeId:n.route.id})}else return{type:Ct.data,result:void 0};else if(d)l=await i(d);else{let p=new URL(t.url),f=p.pathname+p.search;throw Bn(404,{pathname:f})}Ze(l.result!==void 0,"You defined "+(e==="action"?"an action":"a loader")+" for route "+('"'+n.route.id+"\" but didn't return anything from your `"+e+"` ")+"function. Please return a value or `null`.")}catch(d){return{type:Ct.error,result:d}}finally{c&&t.signal.removeEventListener("abort",c)}return l}async function X2(e){let{result:t,type:n,status:r}=e;if(h_(t)){let a;try{let l=t.headers.get("Content-Type");l&&/\bapplication\/json\b/.test(l)?t.body==null?a=null:a=await t.json():a=await t.text()}catch(l){return{type:Ct.error,error:l}}return n===Ct.error?{type:Ct.error,error:new _x(t.status,t.statusText,a),statusCode:t.status,headers:t.headers}:{type:Ct.data,data:a,statusCode:t.status,headers:t.headers}}if(n===Ct.error)return{type:Ct.error,error:t,statusCode:Zh(t)?t.status:r};if(oL(t)){var s,o;return{type:Ct.deferred,deferredData:t,statusCode:(s=t.init)==null?void 0:s.status,headers:((o=t.init)==null?void 0:o.headers)&&new Headers(t.init.headers)}}return{type:Ct.data,data:t,statusCode:r}}function eL(e,t,n,r,s,o){let a=e.headers.get("Location");if(Ze(a,"Redirects returned/thrown from loaders/actions must have a Location header"),!jx.test(a)){let l=r.slice(0,r.findIndex(c=>c.route.id===n)+1);a=Oy(new URL(t.url),l,s,!0,a,o),e.headers.set("Location",a)}return e}function w0(e,t,n){if(jx.test(e)){let r=e,s=r.startsWith("//")?new URL(t.protocol+r):new URL(r),o=du(s.pathname,n)!=null;if(s.origin===t.origin&&o)return s.pathname+s.search+s.hash}return e}function Hi(e,t,n,r){let s=e.createURL(p_(t)).toString(),o={signal:n};if(r&&Jr(r.formMethod)){let{formMethod:a,formEncType:l}=r;o.method=a.toUpperCase(),l==="application/json"?(o.headers=new Headers({"Content-Type":l}),o.body=JSON.stringify(r.json)):l==="text/plain"?o.body=r.text:l==="application/x-www-form-urlencoded"&&r.formData?o.body=Ny(r.formData):o.body=r.formData}return new Request(s,o)}function Ny(e){let t=new URLSearchParams;for(let[n,r]of e.entries())t.append(n,typeof r=="string"?r:r.name);return t}function S0(e){let t=new FormData;for(let[n,r]of e.entries())t.append(n,r);return t}function tL(e,t,n,r,s,o){let a={},l=null,c,i=!1,d={},p=r&&fr(r[1])?r[1].error:void 0;return n.forEach((f,h)=>{let g=t[h].route.id;if(Ze(!Wa(f),"Cannot handle redirect results in processLoaderData"),fr(f)){let m=f.error;p!==void 0&&(m=p,p=void 0),l=l||{};{let x=gl(e,g);l[x.route.id]==null&&(l[x.route.id]=m)}a[g]=void 0,i||(i=!0,c=Zh(f.error)?f.error.status:500),f.headers&&(d[g]=f.headers)}else qa(f)?(s.set(g,f.deferredData),a[g]=f.deferredData.data,f.statusCode!=null&&f.statusCode!==200&&!i&&(c=f.statusCode),f.headers&&(d[g]=f.headers)):(a[g]=f.data,f.statusCode&&f.statusCode!==200&&!i&&(c=f.statusCode),f.headers&&(d[g]=f.headers))}),p!==void 0&&r&&(l={[r[0]]:p},a[r[0]]=void 0),{loaderData:a,errors:l,statusCode:c||200,loaderHeaders:d}}function C0(e,t,n,r,s,o,a,l){let{loaderData:c,errors:i}=tL(t,n,r,s,l);for(let d=0;d<o.length;d++){let{key:p,match:f,controller:h}=o[d];Ze(a!==void 0&&a[d]!==void 0,"Did not find corresponding fetcher result");let g=a[d];if(!(h&&h.signal.aborted))if(fr(g)){let m=gl(e.matches,f==null?void 0:f.route.id);i&&i[m.route.id]||(i=At({},i,{[m.route.id]:g.error})),e.fetchers.delete(p)}else if(Wa(g))Ze(!1,"Unhandled fetcher revalidation redirect");else if(qa(g))Ze(!1,"Unhandled fetcher deferred data");else{let m=Fo(g.data);e.fetchers.set(p,m)}}return{loaderData:c,errors:i}}function E0(e,t,n,r){let s=At({},t);for(let o of n){let a=o.route.id;if(t.hasOwnProperty(a)?t[a]!==void 0&&(s[a]=t[a]):e[a]!==void 0&&o.route.loader&&(s[a]=e[a]),r&&r.hasOwnProperty(a))break}return s}function T0(e){return e?fr(e[1])?{actionData:{}}:{actionData:{[e[0]]:e[1].data}}:{}}function gl(e,t){return(t?e.slice(0,e.findIndex(r=>r.route.id===t)+1):[...e]).reverse().find(r=>r.route.hasErrorBoundary===!0)||e[0]}function k0(e){let t=e.length===1?e[0]:e.find(n=>n.index||!n.path||n.path==="/")||{id:"__shim-error-route__"};return{matches:[{params:{},pathname:"",pathnameBase:"",route:t}],route:t}}function Bn(e,t){let{pathname:n,routeId:r,method:s,type:o,message:a}=t===void 0?{}:t,l="Unknown Server Error",c="Unknown @remix-run/router error";return e===400?(l="Bad Request",o==="route-discovery"?c='Unable to match URL "'+n+'" - the `unstable_patchRoutesOnMiss()` '+(`function threw the following error:
`+a):s&&n&&r?c="You made a "+s+' request to "'+n+'" but '+('did not provide a `loader` for route "'+r+'", ')+"so there is no way to handle the request.":o==="defer-action"?c="defer() is not supported in actions":o==="invalid-body"&&(c="Unable to encode submission body")):e===403?(l="Forbidden",c='Route "'+r+'" does not match URL "'+n+'"'):e===404?(l="Not Found",c='No route matches URL "'+n+'"'):e===405&&(l="Method Not Allowed",s&&n&&r?c="You made a "+s.toUpperCase()+' request to "'+n+'" but '+('did not provide an `action` for route "'+r+'", ')+"so there is no way to handle the request.":s&&(c='Invalid request method "'+s.toUpperCase()+'"')),new _x(e||500,l,new Error(c),!0)}function _0(e){for(let t=e.length-1;t>=0;t--){let n=e[t];if(Wa(n))return{result:n,idx:t}}}function p_(e){let t=typeof e=="string"?_a(e):e;return wi(At({},t,{hash:""}))}function nL(e,t){return e.pathname!==t.pathname||e.search!==t.search?!1:e.hash===""?t.hash!=="":e.hash===t.hash?!0:t.hash!==""}function rL(e){return typeof e=="object"&&e!=null&&"then"in e}function sL(e){return h_(e.result)&&z2.has(e.result.status)}function qa(e){return e.type===Ct.deferred}function fr(e){return e.type===Ct.error}function Wa(e){return(e&&e.type)===Ct.redirect}function oL(e){let t=e;return t&&typeof t=="object"&&typeof t.data=="object"&&typeof t.subscribe=="function"&&typeof t.cancel=="function"&&typeof t.resolveData=="function"}function h_(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.headers=="object"&&typeof e.body<"u"}function aL(e){return B2.has(e.toLowerCase())}function Jr(e){return L2.has(e.toLowerCase())}async function j0(e,t,n,r,s,o){for(let a=0;a<n.length;a++){let l=n[a],c=t[a];if(!c)continue;let i=e.find(p=>p.route.id===c.route.id),d=i!=null&&!d_(i,c)&&(o&&o[c.route.id])!==void 0;if(qa(l)&&(s||d)){let p=r[a];Ze(p,"Expected an AbortSignal for revalidating fetcher deferred result"),await g_(l,p,s).then(f=>{f&&(n[a]=f||n[a])})}}}async function g_(e,t,n){if(n===void 0&&(n=!1),!await e.deferredData.resolveData(t)){if(n)try{return{type:Ct.data,data:e.deferredData.unwrappedData}}catch(s){return{type:Ct.error,error:s}}return{type:Ct.data,data:e.deferredData.data}}}function Rx(e){return new URLSearchParams(e).getAll("index").some(t=>t==="")}function cc(e,t){let n=typeof t=="string"?_a(t).search:t.search;if(e[e.length-1].route.index&&Rx(n||""))return e[e.length-1];let r=l_(e);return r[r.length-1]}function R0(e){let{formMethod:t,formAction:n,formEncType:r,text:s,formData:o,json:a}=e;if(!(!t||!n||!r)){if(s!=null)return{formMethod:t,formAction:n,formEncType:r,formData:void 0,json:void 0,text:s};if(o!=null)return{formMethod:t,formAction:n,formEncType:r,formData:o,json:void 0,text:void 0};if(a!==void 0)return{formMethod:t,formAction:n,formEncType:r,formData:void 0,json:a,text:void 0}}}function Im(e,t){return t?{state:"loading",location:e,formMethod:t.formMethod,formAction:t.formAction,formEncType:t.formEncType,formData:t.formData,json:t.json,text:t.text}:{state:"loading",location:e,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0}}function iL(e,t){return{state:"submitting",location:e,formMethod:t.formMethod,formAction:t.formAction,formEncType:t.formEncType,formData:t.formData,json:t.json,text:t.text}}function qu(e,t){return e?{state:"loading",formMethod:e.formMethod,formAction:e.formAction,formEncType:e.formEncType,formData:e.formData,json:e.json,text:e.text,data:t}:{state:"loading",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data:t}}function lL(e,t){return{state:"submitting",formMethod:e.formMethod,formAction:e.formAction,formEncType:e.formEncType,formData:e.formData,json:e.json,text:e.text,data:t?t.data:void 0}}function Fo(e){return{state:"idle",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data:e}}function uL(e,t){try{let n=e.sessionStorage.getItem(c_);if(n){let r=JSON.parse(n);for(let[s,o]of Object.entries(r||{}))o&&Array.isArray(o)&&t.set(s,new Set(o||[]))}}catch{}}function cL(e,t){if(t.size>0){let n={};for(let[r,s]of t)n[r]=[...s];try{e.sessionStorage.setItem(c_,JSON.stringify(n))}catch(r){Xl(!1,"Failed to save applied view transitions in sessionStorage ("+r+").")}}}/**
 * React Router v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Zp(){return Zp=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Zp.apply(this,arguments)}const Yh=v.createContext(null),m_=v.createContext(null),ja=v.createContext(null),Px=v.createContext(null),wo=v.createContext({outlet:null,matches:[],isDataRoute:!1}),v_=v.createContext(null);function dL(e,t){let{relative:n}=t===void 0?{}:t;fu()||Ze(!1);let{basename:r,navigator:s}=v.useContext(ja),{hash:o,pathname:a,search:l}=b_(e,{relative:n}),c=a;return r!=="/"&&(c=a==="/"?r:uo([r,a])),s.createHref({pathname:c,search:l,hash:o})}function fu(){return v.useContext(Px)!=null}function pu(){return fu()||Ze(!1),v.useContext(Px).location}function y_(e){v.useContext(ja).static||v.useLayoutEffect(e)}function An(){let{isDataRoute:e}=v.useContext(wo);return e?CL():fL()}function fL(){fu()||Ze(!1);let e=v.useContext(Yh),{basename:t,future:n,navigator:r}=v.useContext(ja),{matches:s}=v.useContext(wo),{pathname:o}=pu(),a=JSON.stringify(Jh(s,n.v7_relativeSplatPath)),l=v.useRef(!1);return y_(()=>{l.current=!0}),v.useCallback(function(i,d){if(d===void 0&&(d={}),!l.current)return;if(typeof i=="number"){r.go(i);return}let p=Qh(i,JSON.parse(a),o,d.relative==="path");e==null&&t!=="/"&&(p.pathname=p.pathname==="/"?t:uo([t,p.pathname])),(d.replace?r.replace:r.push)(p,d.state,d)},[t,r,a,o,e])}function So(){let{matches:e}=v.useContext(wo),t=e[e.length-1];return t?t.params:{}}function b_(e,t){let{relative:n}=t===void 0?{}:t,{future:r}=v.useContext(ja),{matches:s}=v.useContext(wo),{pathname:o}=pu(),a=JSON.stringify(Jh(s,r.v7_relativeSplatPath));return v.useMemo(()=>Qh(e,JSON.parse(a),o,n==="path"),[e,a,o,n])}function pL(e,t,n,r){fu()||Ze(!1);let{navigator:s}=v.useContext(ja),{matches:o}=v.useContext(wo),a=o[o.length-1],l=a?a.params:{};a&&a.pathname;let c=a?a.pathnameBase:"/";a&&a.route;let i=pu(),d;d=i;let p=d.pathname||"/",f=p;if(c!=="/"){let m=c.replace(/^\//,"").split("/");f="/"+p.replace(/^\//,"").split("/").slice(m.length).join("/")}let h=Ua(e,{pathname:f});return yL(h&&h.map(m=>Object.assign({},m,{params:Object.assign({},l,m.params),pathname:uo([c,s.encodeLocation?s.encodeLocation(m.pathname).pathname:m.pathname]),pathnameBase:m.pathnameBase==="/"?c:uo([c,s.encodeLocation?s.encodeLocation(m.pathnameBase).pathname:m.pathnameBase])})),o,n,r)}function hL(){let e=SL(),t=Zh(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,s={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return v.createElement(v.Fragment,null,v.createElement("h2",null,"Unexpected Application Error!"),v.createElement("h3",{style:{fontStyle:"italic"}},t),n?v.createElement("pre",{style:s},n):null,null)}const gL=v.createElement(hL,null);class mL extends v.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,n){return n.location!==t.location||n.revalidation!=="idle"&&t.revalidation==="idle"?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:t.error!==void 0?t.error:n.error,location:n.location,revalidation:t.revalidation||n.revalidation}}componentDidCatch(t,n){console.error("React Router caught the following error during render",t,n)}render(){return this.state.error!==void 0?v.createElement(wo.Provider,{value:this.props.routeContext},v.createElement(v_.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function vL(e){let{routeContext:t,match:n,children:r}=e,s=v.useContext(Yh);return s&&s.static&&s.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=n.route.id),v.createElement(wo.Provider,{value:t},r)}function yL(e,t,n,r){var s;if(t===void 0&&(t=[]),n===void 0&&(n=null),r===void 0&&(r=null),e==null){var o;if((o=n)!=null&&o.errors)e=n.matches;else return null}let a=e,l=(s=n)==null?void 0:s.errors;if(l!=null){let d=a.findIndex(p=>p.route.id&&(l==null?void 0:l[p.route.id])!==void 0);d>=0||Ze(!1),a=a.slice(0,Math.min(a.length,d+1))}let c=!1,i=-1;if(n&&r&&r.v7_partialHydration)for(let d=0;d<a.length;d++){let p=a[d];if((p.route.HydrateFallback||p.route.hydrateFallbackElement)&&(i=d),p.route.id){let{loaderData:f,errors:h}=n,g=p.route.loader&&f[p.route.id]===void 0&&(!h||h[p.route.id]===void 0);if(p.route.lazy||g){c=!0,i>=0?a=a.slice(0,i+1):a=[a[0]];break}}}return a.reduceRight((d,p,f)=>{let h,g=!1,m=null,x=null;n&&(h=l&&p.route.id?l[p.route.id]:void 0,m=p.route.errorElement||gL,c&&(i<0&&f===0?(EL("route-fallback"),g=!0,x=null):i===f&&(g=!0,x=p.route.hydrateFallbackElement||null)));let b=t.concat(a.slice(0,f+1)),y=()=>{let w;return h?w=m:g?w=x:p.route.Component?w=v.createElement(p.route.Component,null):p.route.element?w=p.route.element:w=d,v.createElement(vL,{match:p,routeContext:{outlet:d,matches:b,isDataRoute:n!=null},children:w})};return n&&(p.route.ErrorBoundary||p.route.errorElement||f===0)?v.createElement(mL,{location:n.location,revalidation:n.revalidation,component:m,error:h,children:y(),routeContext:{outlet:null,matches:b,isDataRoute:!0}}):y()},null)}var x_=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(x_||{}),Yp=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(Yp||{});function bL(e){let t=v.useContext(Yh);return t||Ze(!1),t}function xL(e){let t=v.useContext(m_);return t||Ze(!1),t}function wL(e){let t=v.useContext(wo);return t||Ze(!1),t}function w_(e){let t=wL(),n=t.matches[t.matches.length-1];return n.route.id||Ze(!1),n.route.id}function SL(){var e;let t=v.useContext(v_),n=xL(Yp.UseRouteError),r=w_(Yp.UseRouteError);return t!==void 0?t:(e=n.errors)==null?void 0:e[r]}function CL(){let{router:e}=bL(x_.UseNavigateStable),t=w_(Yp.UseNavigateStable),n=v.useRef(!1);return y_(()=>{n.current=!0}),v.useCallback(function(s,o){o===void 0&&(o={}),n.current&&(typeof s=="number"?e.navigate(s):e.navigate(s,Zp({fromRouteId:t},o)))},[e,t])}const P0={};function EL(e,t,n){P0[e]||(P0[e]=!0)}function S_(e){let{to:t,replace:n,state:r,relative:s}=e;fu()||Ze(!1);let{future:o,static:a}=v.useContext(ja),{matches:l}=v.useContext(wo),{pathname:c}=pu(),i=An(),d=Qh(t,Jh(l,o.v7_relativeSplatPath),c,s==="path"),p=JSON.stringify(d);return v.useEffect(()=>i(JSON.parse(p),{replace:n,state:r,relative:s}),[i,p,s,n,r]),null}function TL(e){let{basename:t="/",children:n=null,location:r,navigationType:s=en.Pop,navigator:o,static:a=!1,future:l}=e;fu()&&Ze(!1);let c=t.replace(/^\/*/,"/"),i=v.useMemo(()=>({basename:c,navigator:o,static:a,future:Zp({v7_relativeSplatPath:!1},l)}),[c,l,o,a]);typeof r=="string"&&(r=_a(r));let{pathname:d="/",search:p="",hash:f="",state:h=null,key:g="default"}=r,m=v.useMemo(()=>{let x=du(d,c);return x==null?null:{location:{pathname:x,search:p,hash:f,state:h,key:g},navigationType:s}},[c,d,p,f,h,g,s]);return m==null?null:v.createElement(ja.Provider,{value:i},v.createElement(Px.Provider,{children:n,value:m}))}new Promise(()=>{});function kL(e){let t={hasErrorBoundary:e.ErrorBoundary!=null||e.errorElement!=null};return e.Component&&Object.assign(t,{element:v.createElement(e.Component),Component:void 0}),e.HydrateFallback&&Object.assign(t,{hydrateFallbackElement:v.createElement(e.HydrateFallback),HydrateFallback:void 0}),e.ErrorBoundary&&Object.assign(t,{errorElement:v.createElement(e.ErrorBoundary),ErrorBoundary:void 0}),t}/**
 * React Router DOM v6.25.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function td(){return td=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},td.apply(this,arguments)}function _L(e,t){if(e==null)return{};var n={},r=Object.keys(e),s,o;for(o=0;o<r.length;o++)s=r[o],!(t.indexOf(s)>=0)&&(n[s]=e[s]);return n}function jL(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function RL(e,t){return e.button===0&&(!t||t==="_self")&&!jL(e)}const PL=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"],ML="6";try{window.__reactRouterVersion=ML}catch{}function OL(e,t){return K2({basename:void 0,future:td({},void 0,{v7_prependBasename:!0}),history:g2({window:void 0}),hydrationData:NL(),routes:e,mapRouteProperties:kL,unstable_dataStrategy:void 0,unstable_patchRoutesOnMiss:void 0,window:void 0}).initialize()}function NL(){var e;let t=(e=window)==null?void 0:e.__staticRouterHydrationData;return t&&t.errors&&(t=td({},t,{errors:IL(t.errors)})),t}function IL(e){if(!e)return null;let t=Object.entries(e),n={};for(let[r,s]of t)if(s&&s.__type==="RouteErrorResponse")n[r]=new _x(s.status,s.statusText,s.data,s.internal===!0);else if(s&&s.__type==="Error"){if(s.__subType){let o=window[s.__subType];if(typeof o=="function")try{let a=new o(s.message);a.stack="",n[r]=a}catch{}}if(n[r]==null){let o=new Error(s.message);o.stack="",n[r]=o}}else n[r]=s;return n}const DL=v.createContext({isTransitioning:!1}),AL=v.createContext(new Map),FL="startTransition",M0=Nh[FL],LL="flushSync",O0=YF[LL];function $L(e){M0?M0(e):e()}function Wu(e){O0?O0(e):e()}class BL{constructor(){this.status="pending",this.promise=new Promise((t,n)=>{this.resolve=r=>{this.status==="pending"&&(this.status="resolved",t(r))},this.reject=r=>{this.status==="pending"&&(this.status="rejected",n(r))}})}}function zL(e){let{fallbackElement:t,router:n,future:r}=e,[s,o]=v.useState(n.state),[a,l]=v.useState(),[c,i]=v.useState({isTransitioning:!1}),[d,p]=v.useState(),[f,h]=v.useState(),[g,m]=v.useState(),x=v.useRef(new Map),{v7_startTransition:b}=r||{},y=v.useCallback(T=>{b?$L(T):T()},[b]),w=v.useCallback((T,P)=>{let{deletedFetchers:N,unstable_flushSync:U,unstable_viewTransitionOpts:I}=P;N.forEach(V=>x.current.delete(V)),T.fetchers.forEach((V,Q)=>{V.data!==void 0&&x.current.set(Q,V.data)});let Z=n.window==null||n.window.document==null||typeof n.window.document.startViewTransition!="function";if(!I||Z){U?Wu(()=>o(T)):y(()=>o(T));return}if(U){Wu(()=>{f&&(d&&d.resolve(),f.skipTransition()),i({isTransitioning:!0,flushSync:!0,currentLocation:I.currentLocation,nextLocation:I.nextLocation})});let V=n.window.document.startViewTransition(()=>{Wu(()=>o(T))});V.finished.finally(()=>{Wu(()=>{p(void 0),h(void 0),l(void 0),i({isTransitioning:!1})})}),Wu(()=>h(V));return}f?(d&&d.resolve(),f.skipTransition(),m({state:T,currentLocation:I.currentLocation,nextLocation:I.nextLocation})):(l(T),i({isTransitioning:!0,flushSync:!1,currentLocation:I.currentLocation,nextLocation:I.nextLocation}))},[n.window,f,d,x,y]);v.useLayoutEffect(()=>n.subscribe(w),[n,w]),v.useEffect(()=>{c.isTransitioning&&!c.flushSync&&p(new BL)},[c]),v.useEffect(()=>{if(d&&a&&n.window){let T=a,P=d.promise,N=n.window.document.startViewTransition(async()=>{y(()=>o(T)),await P});N.finished.finally(()=>{p(void 0),h(void 0),l(void 0),i({isTransitioning:!1})}),h(N)}},[y,a,d,n.window]),v.useEffect(()=>{d&&a&&s.location.key===a.location.key&&d.resolve()},[d,f,s.location,a]),v.useEffect(()=>{!c.isTransitioning&&g&&(l(g.state),i({isTransitioning:!0,flushSync:!1,currentLocation:g.currentLocation,nextLocation:g.nextLocation}),m(void 0))},[c.isTransitioning,g]),v.useEffect(()=>{},[]);let S=v.useMemo(()=>({createHref:n.createHref,encodeLocation:n.encodeLocation,go:T=>n.navigate(T),push:(T,P,N)=>n.navigate(T,{state:P,preventScrollReset:N==null?void 0:N.preventScrollReset}),replace:(T,P,N)=>n.navigate(T,{replace:!0,state:P,preventScrollReset:N==null?void 0:N.preventScrollReset})}),[n]),E=n.basename||"/",C=v.useMemo(()=>({router:n,navigator:S,static:!1,basename:E}),[n,S,E]),k=v.useMemo(()=>({v7_relativeSplatPath:n.future.v7_relativeSplatPath}),[n.future.v7_relativeSplatPath]);return v.createElement(v.Fragment,null,v.createElement(Yh.Provider,{value:C},v.createElement(m_.Provider,{value:s},v.createElement(AL.Provider,{value:x.current},v.createElement(DL.Provider,{value:c},v.createElement(TL,{basename:E,location:s.location,navigationType:s.historyAction,navigator:S,future:k},s.initialized||n.future.v7_partialHydration?v.createElement(UL,{routes:n.routes,future:n.future,state:s}):t))))),null)}const UL=v.memo(VL);function VL(e){let{routes:t,future:n,state:r}=e;return pL(t,void 0,r,n)}const HL=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",KL=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,nd=v.forwardRef(function(t,n){let{onClick:r,relative:s,reloadDocument:o,replace:a,state:l,target:c,to:i,preventScrollReset:d,unstable_viewTransition:p}=t,f=_L(t,PL),{basename:h}=v.useContext(ja),g,m=!1;if(typeof i=="string"&&KL.test(i)&&(g=i,HL))try{let w=new URL(window.location.href),S=i.startsWith("//")?new URL(w.protocol+i):new URL(i),E=du(S.pathname,h);S.origin===w.origin&&E!=null?i=E+S.search+S.hash:m=!0}catch{}let x=dL(i,{relative:s}),b=qL(i,{replace:a,state:l,target:c,preventScrollReset:d,relative:s,unstable_viewTransition:p});function y(w){r&&r(w),w.defaultPrevented||b(w)}return v.createElement("a",td({},f,{href:g||x,onClick:m||o?r:y,ref:n,target:c}))});var N0;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(N0||(N0={}));var I0;(function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"})(I0||(I0={}));function qL(e,t){let{target:n,replace:r,state:s,preventScrollReset:o,relative:a,unstable_viewTransition:l}=t===void 0?{}:t,c=An(),i=pu(),d=b_(e,{relative:a});return v.useCallback(p=>{if(RL(p,n)){p.preventDefault();let f=r!==void 0?r:wi(i)===wi(d);c(e,{replace:f,state:s,preventScrollReset:o,relative:a,unstable_viewTransition:l})}},[i,c,d,r,s,n,e,o,a,l])}function C_(e){var t,n,r="";if(typeof e=="string"||typeof e=="number")r+=e;else if(typeof e=="object")if(Array.isArray(e)){var s=e.length;for(t=0;t<s;t++)e[t]&&(n=C_(e[t]))&&(r&&(r+=" "),r+=n)}else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}function oo(){for(var e,t,n=0,r="",s=arguments.length;n<s;n++)(e=arguments[n])&&(t=C_(e))&&(r&&(r+=" "),r+=t);return r}const rd=e=>typeof e=="number"&&!isNaN(e),ci=e=>typeof e=="string",gr=e=>typeof e=="function",dp=e=>ci(e)||gr(e)?e:null,Iy=e=>v.isValidElement(e)||ci(e)||gr(e)||rd(e);function WL(e,t,n){n===void 0&&(n=300);const{scrollHeight:r,style:s}=e;requestAnimationFrame(()=>{s.minHeight="initial",s.height=r+"px",s.transition=`all ${n}ms`,requestAnimationFrame(()=>{s.height="0",s.padding="0",s.margin="0",setTimeout(t,n)})})}function Xh(e){let{enter:t,exit:n,appendPosition:r=!1,collapse:s=!0,collapseDuration:o=300}=e;return function(a){let{children:l,position:c,preventExitTransition:i,done:d,nodeRef:p,isIn:f,playToast:h}=a;const g=r?`${t}--${c}`:t,m=r?`${n}--${c}`:n,x=v.useRef(0);return v.useLayoutEffect(()=>{const b=p.current,y=g.split(" "),w=S=>{S.target===p.current&&(h(),b.removeEventListener("animationend",w),b.removeEventListener("animationcancel",w),x.current===0&&S.type!=="animationcancel"&&b.classList.remove(...y))};b.classList.add(...y),b.addEventListener("animationend",w),b.addEventListener("animationcancel",w)},[]),v.useEffect(()=>{const b=p.current,y=()=>{b.removeEventListener("animationend",y),s?WL(b,d,o):d()};f||(i?y():(x.current=1,b.className+=` ${m}`,b.addEventListener("animationend",y)))},[f]),Te.createElement(Te.Fragment,null,l)}}function D0(e,t){return e!=null?{content:e.content,containerId:e.props.containerId,id:e.props.toastId,theme:e.props.theme,type:e.props.type,data:e.props.data||{},isLoading:e.props.isLoading,icon:e.props.icon,status:t}:{}}const Vn=new Map;let sd=[];const Dy=new Set,GL=e=>Dy.forEach(t=>t(e)),E_=()=>Vn.size>0;function T_(e,t){var n;if(t)return!((n=Vn.get(t))==null||!n.isToastActive(e));let r=!1;return Vn.forEach(s=>{s.isToastActive(e)&&(r=!0)}),r}function k_(e,t){Iy(e)&&(E_()||sd.push({content:e,options:t}),Vn.forEach(n=>{n.buildToast(e,t)}))}function A0(e,t){Vn.forEach(n=>{t!=null&&t!=null&&t.containerId?(t==null?void 0:t.containerId)===n.id&&n.toggle(e,t==null?void 0:t.id):n.toggle(e,t==null?void 0:t.id)})}function JL(e){const{subscribe:t,getSnapshot:n,setProps:r}=v.useRef(function(o){const a=o.containerId||1;return{subscribe(l){const c=function(d,p,f){let h=1,g=0,m=[],x=[],b=[],y=p;const w=new Map,S=new Set,E=()=>{b=Array.from(w.values()),S.forEach(T=>T())},C=T=>{x=T==null?[]:x.filter(P=>P!==T),E()},k=T=>{const{toastId:P,onOpen:N,updateId:U,children:I}=T.props,Z=U==null;T.staleId&&w.delete(T.staleId),w.set(P,T),x=[...x,T.props.toastId].filter(V=>V!==T.staleId),E(),f(D0(T,Z?"added":"updated")),Z&&gr(N)&&N(v.isValidElement(I)&&I.props)};return{id:d,props:y,observe:T=>(S.add(T),()=>S.delete(T)),toggle:(T,P)=>{w.forEach(N=>{P!=null&&P!==N.props.toastId||gr(N.toggle)&&N.toggle(T)})},removeToast:C,toasts:w,clearQueue:()=>{g-=m.length,m=[]},buildToast:(T,P)=>{if((z=>{let{containerId:se,toastId:ne,updateId:ie}=z;const oe=se?se!==d:d!==1,J=w.has(ne)&&ie==null;return oe||J})(P))return;const{toastId:N,updateId:U,data:I,staleId:Z,delay:V}=P,Q=()=>{C(N)},ee=U==null;ee&&g++;const W={...y,style:y.toastStyle,key:h++,...Object.fromEntries(Object.entries(P).filter(z=>{let[se,ne]=z;return ne!=null})),toastId:N,updateId:U,data:I,closeToast:Q,isIn:!1,className:dp(P.className||y.toastClassName),bodyClassName:dp(P.bodyClassName||y.bodyClassName),progressClassName:dp(P.progressClassName||y.progressClassName),autoClose:!P.isLoading&&(F=P.autoClose,A=y.autoClose,F===!1||rd(F)&&F>0?F:A),deleteToast(){const z=w.get(N),{onClose:se,children:ne}=z.props;gr(se)&&se(v.isValidElement(ne)&&ne.props),f(D0(z,"removed")),w.delete(N),g--,g<0&&(g=0),m.length>0?k(m.shift()):E()}};var F,A;W.closeButton=y.closeButton,P.closeButton===!1||Iy(P.closeButton)?W.closeButton=P.closeButton:P.closeButton===!0&&(W.closeButton=!Iy(y.closeButton)||y.closeButton);let Y=T;v.isValidElement(T)&&!ci(T.type)?Y=v.cloneElement(T,{closeToast:Q,toastProps:W,data:I}):gr(T)&&(Y=T({closeToast:Q,toastProps:W,data:I}));const de={content:Y,props:W,staleId:Z};y.limit&&y.limit>0&&g>y.limit&&ee?m.push(de):rd(V)?setTimeout(()=>{k(de)},V):k(de)},setProps(T){y=T},setToggle:(T,P)=>{w.get(T).toggle=P},isToastActive:T=>x.some(P=>P===T),getSnapshot:()=>y.newestOnTop?b.reverse():b}}(a,o,GL);Vn.set(a,c);const i=c.observe(l);return sd.forEach(d=>k_(d.content,d.options)),sd=[],()=>{i(),Vn.delete(a)}},setProps(l){var c;(c=Vn.get(a))==null||c.setProps(l)},getSnapshot(){var l;return(l=Vn.get(a))==null?void 0:l.getSnapshot()}}}(e)).current;r(e);const s=v.useSyncExternalStore(t,n,n);return{getToastToRender:function(o){if(!s)return[];const a=new Map;return s.forEach(l=>{const{position:c}=l.props;a.has(c)||a.set(c,[]),a.get(c).push(l)}),Array.from(a,l=>o(l[0],l[1]))},isToastActive:T_,count:s==null?void 0:s.length}}function QL(e){const[t,n]=v.useState(!1),[r,s]=v.useState(!1),o=v.useRef(null),a=v.useRef({start:0,delta:0,removalDistance:0,canCloseOnClick:!0,canDrag:!1,didMove:!1}).current,{autoClose:l,pauseOnHover:c,closeToast:i,onClick:d,closeOnClick:p}=e;var f,h;function g(){n(!0)}function m(){n(!1)}function x(w){const S=o.current;a.canDrag&&S&&(a.didMove=!0,t&&m(),a.delta=e.draggableDirection==="x"?w.clientX-a.start:w.clientY-a.start,a.start!==w.clientX&&(a.canCloseOnClick=!1),S.style.transform=`translate3d(${e.draggableDirection==="x"?`${a.delta}px, var(--y)`:`0, calc(${a.delta}px + var(--y))`},0)`,S.style.opacity=""+(1-Math.abs(a.delta/a.removalDistance)))}function b(){document.removeEventListener("pointermove",x),document.removeEventListener("pointerup",b);const w=o.current;if(a.canDrag&&a.didMove&&w){if(a.canDrag=!1,Math.abs(a.delta)>a.removalDistance)return s(!0),e.closeToast(),void e.collapseAll();w.style.transition="transform 0.2s, opacity 0.2s",w.style.removeProperty("transform"),w.style.removeProperty("opacity")}}(h=Vn.get((f={id:e.toastId,containerId:e.containerId,fn:n}).containerId||1))==null||h.setToggle(f.id,f.fn),v.useEffect(()=>{if(e.pauseOnFocusLoss)return document.hasFocus()||m(),window.addEventListener("focus",g),window.addEventListener("blur",m),()=>{window.removeEventListener("focus",g),window.removeEventListener("blur",m)}},[e.pauseOnFocusLoss]);const y={onPointerDown:function(w){if(e.draggable===!0||e.draggable===w.pointerType){a.didMove=!1,document.addEventListener("pointermove",x),document.addEventListener("pointerup",b);const S=o.current;a.canCloseOnClick=!0,a.canDrag=!0,S.style.transition="none",e.draggableDirection==="x"?(a.start=w.clientX,a.removalDistance=S.offsetWidth*(e.draggablePercent/100)):(a.start=w.clientY,a.removalDistance=S.offsetHeight*(e.draggablePercent===80?1.5*e.draggablePercent:e.draggablePercent)/100)}},onPointerUp:function(w){const{top:S,bottom:E,left:C,right:k}=o.current.getBoundingClientRect();w.nativeEvent.type!=="touchend"&&e.pauseOnHover&&w.clientX>=C&&w.clientX<=k&&w.clientY>=S&&w.clientY<=E?m():g()}};return l&&c&&(y.onMouseEnter=m,e.stacked||(y.onMouseLeave=g)),p&&(y.onClick=w=>{d&&d(w),a.canCloseOnClick&&i()}),{playToast:g,pauseToast:m,isRunning:t,preventExitTransition:r,toastRef:o,eventHandlers:y}}function ZL(e){let{delay:t,isRunning:n,closeToast:r,type:s="default",hide:o,className:a,style:l,controlledProgress:c,progress:i,rtl:d,isIn:p,theme:f}=e;const h=o||c&&i===0,g={...l,animationDuration:`${t}ms`,animationPlayState:n?"running":"paused"};c&&(g.transform=`scaleX(${i})`);const m=oo("Toastify__progress-bar",c?"Toastify__progress-bar--controlled":"Toastify__progress-bar--animated",`Toastify__progress-bar-theme--${f}`,`Toastify__progress-bar--${s}`,{"Toastify__progress-bar--rtl":d}),x=gr(a)?a({rtl:d,type:s,defaultClassName:m}):oo(m,a),b={[c&&i>=1?"onTransitionEnd":"onAnimationEnd"]:c&&i<1?null:()=>{p&&r()}};return Te.createElement("div",{className:"Toastify__progress-bar--wrp","data-hidden":h},Te.createElement("div",{className:`Toastify__progress-bar--bg Toastify__progress-bar-theme--${f} Toastify__progress-bar--${s}`}),Te.createElement("div",{role:"progressbar","aria-hidden":h?"true":"false","aria-label":"notification timer",className:x,style:g,...b}))}let YL=1;const __=()=>""+YL++;function XL(e){return e&&(ci(e.toastId)||rd(e.toastId))?e.toastId:__()}function _c(e,t){return k_(e,t),t.toastId}function Xp(e,t){return{...t,type:t&&t.type||e,toastId:XL(t)}}function jf(e){return(t,n)=>_c(t,Xp(e,n))}function X(e,t){return _c(e,Xp("default",t))}X.loading=(e,t)=>_c(e,Xp("default",{isLoading:!0,autoClose:!1,closeOnClick:!1,closeButton:!1,draggable:!1,...t})),X.promise=function(e,t,n){let r,{pending:s,error:o,success:a}=t;s&&(r=ci(s)?X.loading(s,n):X.loading(s.render,{...n,...s}));const l={isLoading:null,autoClose:null,closeOnClick:null,closeButton:null,draggable:null},c=(d,p,f)=>{if(p==null)return void X.dismiss(r);const h={type:d,...l,...n,data:f},g=ci(p)?{render:p}:p;return r?X.update(r,{...h,...g}):X(g.render,{...h,...g}),f},i=gr(e)?e():e;return i.then(d=>c("success",a,d)).catch(d=>c("error",o,d)),i},X.success=jf("success"),X.info=jf("info"),X.error=jf("error"),X.warning=jf("warning"),X.warn=X.warning,X.dark=(e,t)=>_c(e,Xp("default",{theme:"dark",...t})),X.dismiss=function(e){(function(t){var n;if(E_()){if(t==null||ci(n=t)||rd(n))Vn.forEach(r=>{r.removeToast(t)});else if(t&&("containerId"in t||"id"in t)){const r=Vn.get(t.containerId);r?r.removeToast(t.id):Vn.forEach(s=>{s.removeToast(t.id)})}}else sd=sd.filter(r=>t!=null&&r.options.toastId!==t)})(e)},X.clearWaitingQueue=function(e){e===void 0&&(e={}),Vn.forEach(t=>{!t.props.limit||e.containerId&&t.id!==e.containerId||t.clearQueue()})},X.isActive=T_,X.update=function(e,t){t===void 0&&(t={});const n=((r,s)=>{var o;let{containerId:a}=s;return(o=Vn.get(a||1))==null?void 0:o.toasts.get(r)})(e,t);if(n){const{props:r,content:s}=n,o={delay:100,...r,...t,toastId:t.toastId||e,updateId:__()};o.toastId!==e&&(o.staleId=e);const a=o.render||s;delete o.render,_c(a,o)}},X.done=e=>{X.update(e,{progress:1})},X.onChange=function(e){return Dy.add(e),()=>{Dy.delete(e)}},X.play=e=>A0(!0,e),X.pause=e=>A0(!1,e);const e$=typeof window<"u"?v.useLayoutEffect:v.useEffect,Rf=e=>{let{theme:t,type:n,isLoading:r,...s}=e;return Te.createElement("svg",{viewBox:"0 0 24 24",width:"100%",height:"100%",fill:t==="colored"?"currentColor":`var(--toastify-icon-color-${n})`,...s})},Dm={info:function(e){return Te.createElement(Rf,{...e},Te.createElement("path",{d:"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"}))},warning:function(e){return Te.createElement(Rf,{...e},Te.createElement("path",{d:"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"}))},success:function(e){return Te.createElement(Rf,{...e},Te.createElement("path",{d:"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"}))},error:function(e){return Te.createElement(Rf,{...e},Te.createElement("path",{d:"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"}))},spinner:function(){return Te.createElement("div",{className:"Toastify__spinner"})}},t$=e=>{const{isRunning:t,preventExitTransition:n,toastRef:r,eventHandlers:s,playToast:o}=QL(e),{closeButton:a,children:l,autoClose:c,onClick:i,type:d,hideProgressBar:p,closeToast:f,transition:h,position:g,className:m,style:x,bodyClassName:b,bodyStyle:y,progressClassName:w,progressStyle:S,updateId:E,role:C,progress:k,rtl:T,toastId:P,deleteToast:N,isIn:U,isLoading:I,closeOnClick:Z,theme:V}=e,Q=oo("Toastify__toast",`Toastify__toast-theme--${V}`,`Toastify__toast--${d}`,{"Toastify__toast--rtl":T},{"Toastify__toast--close-on-click":Z}),ee=gr(m)?m({rtl:T,position:g,type:d,defaultClassName:Q}):oo(Q,m),W=function(de){let{theme:z,type:se,isLoading:ne,icon:ie}=de,oe=null;const J={theme:z,type:se};return ie===!1||(gr(ie)?oe=ie({...J,isLoading:ne}):v.isValidElement(ie)?oe=v.cloneElement(ie,J):ne?oe=Dm.spinner():(Ce=>Ce in Dm)(se)&&(oe=Dm[se](J))),oe}(e),F=!!k||!c,A={closeToast:f,type:d,theme:V};let Y=null;return a===!1||(Y=gr(a)?a(A):v.isValidElement(a)?v.cloneElement(a,A):function(de){let{closeToast:z,theme:se,ariaLabel:ne="close"}=de;return Te.createElement("button",{className:`Toastify__close-button Toastify__close-button--${se}`,type:"button",onClick:ie=>{ie.stopPropagation(),z(ie)},"aria-label":ne},Te.createElement("svg",{"aria-hidden":"true",viewBox:"0 0 14 16"},Te.createElement("path",{fillRule:"evenodd",d:"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"})))}(A)),Te.createElement(h,{isIn:U,done:N,position:g,preventExitTransition:n,nodeRef:r,playToast:o},Te.createElement("div",{id:P,onClick:i,"data-in":U,className:ee,...s,style:x,ref:r},Te.createElement("div",{...U&&{role:C},className:gr(b)?b({type:d}):oo("Toastify__toast-body",b),style:y},W!=null&&Te.createElement("div",{className:oo("Toastify__toast-icon",{"Toastify--animate-icon Toastify__zoom-enter":!I})},W),Te.createElement("div",null,l)),Y,Te.createElement(ZL,{...E&&!F?{key:`pb-${E}`}:{},rtl:T,theme:V,delay:c,isRunning:t,isIn:U,closeToast:f,hide:p,type:d,style:S,className:w,controlledProgress:F,progress:k||0})))},eg=function(e,t){return t===void 0&&(t=!1),{enter:`Toastify--animate Toastify__${e}-enter`,exit:`Toastify--animate Toastify__${e}-exit`,appendPosition:t}},n$=Xh(eg("bounce",!0));Xh(eg("slide",!0));Xh(eg("zoom"));Xh(eg("flip"));const r$={position:"top-right",transition:n$,autoClose:5e3,closeButton:!0,pauseOnHover:!0,pauseOnFocusLoss:!0,draggable:"touch",draggablePercent:80,draggableDirection:"x",role:"alert",theme:"light"};function s$(e){let t={...r$,...e};const n=e.stacked,[r,s]=v.useState(!0),o=v.useRef(null),{getToastToRender:a,isToastActive:l,count:c}=JL(t),{className:i,style:d,rtl:p,containerId:f}=t;function h(m){const x=oo("Toastify__toast-container",`Toastify__toast-container--${m}`,{"Toastify__toast-container--rtl":p});return gr(i)?i({position:m,rtl:p,defaultClassName:x}):oo(x,dp(i))}function g(){n&&(s(!0),X.play())}return e$(()=>{if(n){var m;const x=o.current.querySelectorAll('[data-in="true"]'),b=12,y=(m=t.position)==null?void 0:m.includes("top");let w=0,S=0;Array.from(x).reverse().forEach((E,C)=>{const k=E;k.classList.add("Toastify__toast--stacked"),C>0&&(k.dataset.collapsed=`${r}`),k.dataset.pos||(k.dataset.pos=y?"top":"bot");const T=w*(r?.2:1)+(r?0:b*C);k.style.setProperty("--y",`${y?T:-1*T}px`),k.style.setProperty("--g",`${b}`),k.style.setProperty("--s",""+(1-(r?S:0))),w+=k.offsetHeight,S+=.025})}},[r,c,n]),Te.createElement("div",{ref:o,className:"Toastify",id:f,onMouseEnter:()=>{n&&(s(!1),X.pause())},onMouseLeave:g},a((m,x)=>{const b=x.length?{...d}:{...d,pointerEvents:"none"};return Te.createElement("div",{className:h(m),style:b,key:`container-${m}`},x.map(y=>{let{content:w,props:S}=y;return Te.createElement(t$,{...S,stacked:n,collapseAll:g,isIn:l(S.toastId,S.containerId),style:S.style,key:`toast-${S.key}`},w)}))}))}const o$={theme:"system",setTheme:()=>null},j_=v.createContext(o$);function a$({children:e,defaultTheme:t="system",storageKey:n="vite-ui-theme",...r}){const[s,o]=v.useState(()=>localStorage.getItem(n)||t);v.useEffect(()=>{const l=window.document.documentElement;if(l.classList.remove("light","dark"),s==="system"){const c=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light";l.classList.add(c);return}l.classList.add(s)},[s]);const a={theme:s,setTheme:l=>{localStorage.setItem(n,l),o(l)}};return u.jsx(j_.Provider,{...r,value:a,children:e})}const R_=()=>{const e=v.useContext(j_);if(e===void 0)throw new Error("useTheme must be used within a ThemeProvider");return e};let Am=!1;const i$=new RD({defaultOptions:{queries:{staleTime:1e3*60*5,retry(e){return e>=3?(Am===!1&&(Am=!0,X.error("The application is taking longer than expected to load, please try again in a few minutes.",{onClose:()=>{Am=!1}})),!1):!0}}}});var rs=(e=>(e.API_URL="apiUrl",e.TOKEN="token",e.VERSION="version",e.FACEBOOK_APP_ID="facebookAppId",e.FACEBOOK_CONFIG_ID="facebookConfigId",e.FACEBOOK_USER_TOKEN="facebookUserToken",e.CLIENT_NAME="clientName",e))(rs||{});const P_=async e=>{if(e.url){const t=e.url.endsWith("/")?e.url.slice(0,-1):e.url;localStorage.setItem("apiUrl",t)}e.token&&localStorage.setItem("token",e.token),e.version&&localStorage.setItem("version",e.version),e.facebookAppId&&localStorage.setItem("facebookAppId",e.facebookAppId),e.facebookConfigId&&localStorage.setItem("facebookConfigId",e.facebookConfigId),e.facebookUserToken&&localStorage.setItem("facebookUserToken",e.facebookUserToken),e.clientName&&localStorage.setItem("clientName",e.clientName)},M_=()=>{localStorage.removeItem("apiUrl"),localStorage.removeItem("token"),localStorage.removeItem("version"),localStorage.removeItem("facebookAppId"),localStorage.removeItem("facebookConfigId"),localStorage.removeItem("facebookUserToken"),localStorage.removeItem("clientName")},Fs=e=>localStorage.getItem(e),Gt=({children:e})=>{const t=Fs(rs.API_URL),n=Fs(rs.TOKEN),r=Fs(rs.VERSION);return!t||!n||!r?u.jsx(S_,{to:"/manager/login"}):e},l$=({children:e})=>{const t=Fs(rs.API_URL),n=Fs(rs.TOKEN),r=Fs(rs.VERSION);return t&&n&&r?u.jsx(S_,{to:"/"}):e};function O_(e,t){return function(){return e.apply(t,arguments)}}const{toString:u$}=Object.prototype,{getPrototypeOf:Mx}=Object,tg=(e=>t=>{const n=u$.call(t);return e[n]||(e[n]=n.slice(8,-1).toLowerCase())})(Object.create(null)),fs=e=>(e=e.toLowerCase(),t=>tg(t)===e),ng=e=>t=>typeof t===e,{isArray:hu}=Array,od=ng("undefined");function c$(e){return e!==null&&!od(e)&&e.constructor!==null&&!od(e.constructor)&&Lr(e.constructor.isBuffer)&&e.constructor.isBuffer(e)}const N_=fs("ArrayBuffer");function d$(e){let t;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?t=ArrayBuffer.isView(e):t=e&&e.buffer&&N_(e.buffer),t}const f$=ng("string"),Lr=ng("function"),I_=ng("number"),rg=e=>e!==null&&typeof e=="object",p$=e=>e===!0||e===!1,fp=e=>{if(tg(e)!=="object")return!1;const t=Mx(e);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},h$=fs("Date"),g$=fs("File"),m$=fs("Blob"),v$=fs("FileList"),y$=e=>rg(e)&&Lr(e.pipe),b$=e=>{let t;return e&&(typeof FormData=="function"&&e instanceof FormData||Lr(e.append)&&((t=tg(e))==="formdata"||t==="object"&&Lr(e.toString)&&e.toString()==="[object FormData]"))},x$=fs("URLSearchParams"),[w$,S$,C$,E$]=["ReadableStream","Request","Response","Headers"].map(fs),T$=e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function Bd(e,t,{allOwnKeys:n=!1}={}){if(e===null||typeof e>"u")return;let r,s;if(typeof e!="object"&&(e=[e]),hu(e))for(r=0,s=e.length;r<s;r++)t.call(null,e[r],r,e);else{const o=n?Object.getOwnPropertyNames(e):Object.keys(e),a=o.length;let l;for(r=0;r<a;r++)l=o[r],t.call(null,e[l],l,e)}}function D_(e,t){t=t.toLowerCase();const n=Object.keys(e);let r=n.length,s;for(;r-- >0;)if(s=n[r],t===s.toLowerCase())return s;return null}const A_=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:global,F_=e=>!od(e)&&e!==A_;function Ay(){const{caseless:e}=F_(this)&&this||{},t={},n=(r,s)=>{const o=e&&D_(t,s)||s;fp(t[o])&&fp(r)?t[o]=Ay(t[o],r):fp(r)?t[o]=Ay({},r):hu(r)?t[o]=r.slice():t[o]=r};for(let r=0,s=arguments.length;r<s;r++)arguments[r]&&Bd(arguments[r],n);return t}const k$=(e,t,n,{allOwnKeys:r}={})=>(Bd(t,(s,o)=>{n&&Lr(s)?e[o]=O_(s,n):e[o]=s},{allOwnKeys:r}),e),_$=e=>(e.charCodeAt(0)===65279&&(e=e.slice(1)),e),j$=(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},R$=(e,t,n,r)=>{let s,o,a;const l={};if(t=t||{},e==null)return t;do{for(s=Object.getOwnPropertyNames(e),o=s.length;o-- >0;)a=s[o],(!r||r(a,e,t))&&!l[a]&&(t[a]=e[a],l[a]=!0);e=n!==!1&&Mx(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},P$=(e,t,n)=>{e=String(e),(n===void 0||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return r!==-1&&r===n},M$=e=>{if(!e)return null;if(hu(e))return e;let t=e.length;if(!I_(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},O$=(e=>t=>e&&t instanceof e)(typeof Uint8Array<"u"&&Mx(Uint8Array)),N$=(e,t)=>{const r=(e&&e[Symbol.iterator]).call(e);let s;for(;(s=r.next())&&!s.done;){const o=s.value;t.call(e,o[0],o[1])}},I$=(e,t)=>{let n;const r=[];for(;(n=e.exec(t))!==null;)r.push(n);return r},D$=fs("HTMLFormElement"),A$=e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,function(n,r,s){return r.toUpperCase()+s}),F0=(({hasOwnProperty:e})=>(t,n)=>e.call(t,n))(Object.prototype),F$=fs("RegExp"),L_=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};Bd(n,(s,o)=>{let a;(a=t(s,o,e))!==!1&&(r[o]=a||s)}),Object.defineProperties(e,r)},L$=e=>{L_(e,(t,n)=>{if(Lr(e)&&["arguments","caller","callee"].indexOf(n)!==-1)return!1;const r=e[n];if(Lr(r)){if(t.enumerable=!1,"writable"in t){t.writable=!1;return}t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")})}})},$$=(e,t)=>{const n={},r=s=>{s.forEach(o=>{n[o]=!0})};return hu(e)?r(e):r(String(e).split(t)),n},B$=()=>{},z$=(e,t)=>e!=null&&Number.isFinite(e=+e)?e:t,Fm="abcdefghijklmnopqrstuvwxyz",L0="0123456789",$_={DIGIT:L0,ALPHA:Fm,ALPHA_DIGIT:Fm+Fm.toUpperCase()+L0},U$=(e=16,t=$_.ALPHA_DIGIT)=>{let n="";const{length:r}=t;for(;e--;)n+=t[Math.random()*r|0];return n};function V$(e){return!!(e&&Lr(e.append)&&e[Symbol.toStringTag]==="FormData"&&e[Symbol.iterator])}const H$=e=>{const t=new Array(10),n=(r,s)=>{if(rg(r)){if(t.indexOf(r)>=0)return;if(!("toJSON"in r)){t[s]=r;const o=hu(r)?[]:{};return Bd(r,(a,l)=>{const c=n(a,s+1);!od(c)&&(o[l]=c)}),t[s]=void 0,o}}return r};return n(e,0)},K$=fs("AsyncFunction"),q$=e=>e&&(rg(e)||Lr(e))&&Lr(e.then)&&Lr(e.catch),$={isArray:hu,isArrayBuffer:N_,isBuffer:c$,isFormData:b$,isArrayBufferView:d$,isString:f$,isNumber:I_,isBoolean:p$,isObject:rg,isPlainObject:fp,isReadableStream:w$,isRequest:S$,isResponse:C$,isHeaders:E$,isUndefined:od,isDate:h$,isFile:g$,isBlob:m$,isRegExp:F$,isFunction:Lr,isStream:y$,isURLSearchParams:x$,isTypedArray:O$,isFileList:v$,forEach:Bd,merge:Ay,extend:k$,trim:T$,stripBOM:_$,inherits:j$,toFlatObject:R$,kindOf:tg,kindOfTest:fs,endsWith:P$,toArray:M$,forEachEntry:N$,matchAll:I$,isHTMLForm:D$,hasOwnProperty:F0,hasOwnProp:F0,reduceDescriptors:L_,freezeMethods:L$,toObjectSet:$$,toCamelCase:A$,noop:B$,toFiniteNumber:z$,findKey:D_,global:A_,isContextDefined:F_,ALPHABET:$_,generateString:U$,isSpecCompliantForm:V$,toJSONObject:H$,isAsyncFn:K$,isThenable:q$};function He(e,t,n,r,s){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),s&&(this.response=s)}$.inherits(He,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:$.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const B_=He.prototype,z_={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(e=>{z_[e]={value:e}});Object.defineProperties(He,z_);Object.defineProperty(B_,"isAxiosError",{value:!0});He.from=(e,t,n,r,s,o)=>{const a=Object.create(B_);return $.toFlatObject(e,a,function(c){return c!==Error.prototype},l=>l!=="isAxiosError"),He.call(a,e.message,t,n,r,s),a.cause=e,a.name=e.name,o&&Object.assign(a,o),a};const W$=null;function Fy(e){return $.isPlainObject(e)||$.isArray(e)}function U_(e){return $.endsWith(e,"[]")?e.slice(0,-2):e}function $0(e,t,n){return e?e.concat(t).map(function(s,o){return s=U_(s),!n&&o?"["+s+"]":s}).join(n?".":""):t}function G$(e){return $.isArray(e)&&!e.some(Fy)}const J$=$.toFlatObject($,{},null,function(t){return/^is[A-Z]/.test(t)});function sg(e,t,n){if(!$.isObject(e))throw new TypeError("target must be an object");t=t||new FormData,n=$.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,function(m,x){return!$.isUndefined(x[m])});const r=n.metaTokens,s=n.visitor||d,o=n.dots,a=n.indexes,c=(n.Blob||typeof Blob<"u"&&Blob)&&$.isSpecCompliantForm(t);if(!$.isFunction(s))throw new TypeError("visitor must be a function");function i(g){if(g===null)return"";if($.isDate(g))return g.toISOString();if(!c&&$.isBlob(g))throw new He("Blob is not supported. Use a Buffer instead.");return $.isArrayBuffer(g)||$.isTypedArray(g)?c&&typeof Blob=="function"?new Blob([g]):Buffer.from(g):g}function d(g,m,x){let b=g;if(g&&!x&&typeof g=="object"){if($.endsWith(m,"{}"))m=r?m:m.slice(0,-2),g=JSON.stringify(g);else if($.isArray(g)&&G$(g)||($.isFileList(g)||$.endsWith(m,"[]"))&&(b=$.toArray(g)))return m=U_(m),b.forEach(function(w,S){!($.isUndefined(w)||w===null)&&t.append(a===!0?$0([m],S,o):a===null?m:m+"[]",i(w))}),!1}return Fy(g)?!0:(t.append($0(x,m,o),i(g)),!1)}const p=[],f=Object.assign(J$,{defaultVisitor:d,convertValue:i,isVisitable:Fy});function h(g,m){if(!$.isUndefined(g)){if(p.indexOf(g)!==-1)throw Error("Circular reference detected in "+m.join("."));p.push(g),$.forEach(g,function(b,y){(!($.isUndefined(b)||b===null)&&s.call(t,b,$.isString(y)?y.trim():y,m,f))===!0&&h(b,m?m.concat(y):[y])}),p.pop()}}if(!$.isObject(e))throw new TypeError("data must be an object");return h(e),t}function B0(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,function(r){return t[r]})}function Ox(e,t){this._pairs=[],e&&sg(e,this,t)}const V_=Ox.prototype;V_.append=function(t,n){this._pairs.push([t,n])};V_.toString=function(t){const n=t?function(r){return t.call(this,r,B0)}:B0;return this._pairs.map(function(s){return n(s[0])+"="+n(s[1])},"").join("&")};function Q$(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function H_(e,t,n){if(!t)return e;const r=n&&n.encode||Q$,s=n&&n.serialize;let o;if(s?o=s(t,n):o=$.isURLSearchParams(t)?t.toString():new Ox(t,n).toString(r),o){const a=e.indexOf("#");a!==-1&&(e=e.slice(0,a)),e+=(e.indexOf("?")===-1?"?":"&")+o}return e}class z0{constructor(){this.handlers=[]}use(t,n,r){return this.handlers.push({fulfilled:t,rejected:n,synchronous:r?r.synchronous:!1,runWhen:r?r.runWhen:null}),this.handlers.length-1}eject(t){this.handlers[t]&&(this.handlers[t]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(t){$.forEach(this.handlers,function(r){r!==null&&t(r)})}}const K_={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},Z$=typeof URLSearchParams<"u"?URLSearchParams:Ox,Y$=typeof FormData<"u"?FormData:null,X$=typeof Blob<"u"?Blob:null,e4={isBrowser:!0,classes:{URLSearchParams:Z$,FormData:Y$,Blob:X$},protocols:["http","https","file","blob","url","data"]},Nx=typeof window<"u"&&typeof document<"u",t4=(e=>Nx&&["ReactNative","NativeScript","NS"].indexOf(e)<0)(typeof navigator<"u"&&navigator.product),n4=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&typeof self.importScripts=="function",r4=Nx&&window.location.href||"http://localhost",s4=Object.freeze(Object.defineProperty({__proto__:null,hasBrowserEnv:Nx,hasStandardBrowserEnv:t4,hasStandardBrowserWebWorkerEnv:n4,origin:r4},Symbol.toStringTag,{value:"Module"})),ss={...s4,...e4};function o4(e,t){return sg(e,new ss.classes.URLSearchParams,Object.assign({visitor:function(n,r,s,o){return ss.isNode&&$.isBuffer(n)?(this.append(r,n.toString("base64")),!1):o.defaultVisitor.apply(this,arguments)}},t))}function a4(e){return $.matchAll(/\w+|\[(\w*)]/g,e).map(t=>t[0]==="[]"?"":t[1]||t[0])}function i4(e){const t={},n=Object.keys(e);let r;const s=n.length;let o;for(r=0;r<s;r++)o=n[r],t[o]=e[o];return t}function q_(e){function t(n,r,s,o){let a=n[o++];if(a==="__proto__")return!0;const l=Number.isFinite(+a),c=o>=n.length;return a=!a&&$.isArray(s)?s.length:a,c?($.hasOwnProp(s,a)?s[a]=[s[a],r]:s[a]=r,!l):((!s[a]||!$.isObject(s[a]))&&(s[a]=[]),t(n,r,s[a],o)&&$.isArray(s[a])&&(s[a]=i4(s[a])),!l)}if($.isFormData(e)&&$.isFunction(e.entries)){const n={};return $.forEachEntry(e,(r,s)=>{t(a4(r),s,n,0)}),n}return null}function l4(e,t,n){if($.isString(e))try{return(t||JSON.parse)(e),$.trim(e)}catch(r){if(r.name!=="SyntaxError")throw r}return(n||JSON.stringify)(e)}const zd={transitional:K_,adapter:["xhr","http","fetch"],transformRequest:[function(t,n){const r=n.getContentType()||"",s=r.indexOf("application/json")>-1,o=$.isObject(t);if(o&&$.isHTMLForm(t)&&(t=new FormData(t)),$.isFormData(t))return s?JSON.stringify(q_(t)):t;if($.isArrayBuffer(t)||$.isBuffer(t)||$.isStream(t)||$.isFile(t)||$.isBlob(t)||$.isReadableStream(t))return t;if($.isArrayBufferView(t))return t.buffer;if($.isURLSearchParams(t))return n.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),t.toString();let l;if(o){if(r.indexOf("application/x-www-form-urlencoded")>-1)return o4(t,this.formSerializer).toString();if((l=$.isFileList(t))||r.indexOf("multipart/form-data")>-1){const c=this.env&&this.env.FormData;return sg(l?{"files[]":t}:t,c&&new c,this.formSerializer)}}return o||s?(n.setContentType("application/json",!1),l4(t)):t}],transformResponse:[function(t){const n=this.transitional||zd.transitional,r=n&&n.forcedJSONParsing,s=this.responseType==="json";if($.isResponse(t)||$.isReadableStream(t))return t;if(t&&$.isString(t)&&(r&&!this.responseType||s)){const a=!(n&&n.silentJSONParsing)&&s;try{return JSON.parse(t)}catch(l){if(a)throw l.name==="SyntaxError"?He.from(l,He.ERR_BAD_RESPONSE,this,null,this.response):l}}return t}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:ss.classes.FormData,Blob:ss.classes.Blob},validateStatus:function(t){return t>=200&&t<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};$.forEach(["delete","get","head","post","put","patch"],e=>{zd.headers[e]={}});const u4=$.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),c4=e=>{const t={};let n,r,s;return e&&e.split(`
`).forEach(function(a){s=a.indexOf(":"),n=a.substring(0,s).trim().toLowerCase(),r=a.substring(s+1).trim(),!(!n||t[n]&&u4[n])&&(n==="set-cookie"?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)}),t},U0=Symbol("internals");function Gu(e){return e&&String(e).trim().toLowerCase()}function pp(e){return e===!1||e==null?e:$.isArray(e)?e.map(pp):String(e)}function d4(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}const f4=e=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());function Lm(e,t,n,r,s){if($.isFunction(r))return r.call(this,t,n);if(s&&(t=n),!!$.isString(t)){if($.isString(r))return t.indexOf(r)!==-1;if($.isRegExp(r))return r.test(t)}}function p4(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(t,n,r)=>n.toUpperCase()+r)}function h4(e,t){const n=$.toCamelCase(" "+t);["get","set","has"].forEach(r=>{Object.defineProperty(e,r+n,{value:function(s,o,a){return this[r].call(this,t,s,o,a)},configurable:!0})})}let sr=class{constructor(t){t&&this.set(t)}set(t,n,r){const s=this;function o(l,c,i){const d=Gu(c);if(!d)throw new Error("header name must be a non-empty string");const p=$.findKey(s,d);(!p||s[p]===void 0||i===!0||i===void 0&&s[p]!==!1)&&(s[p||c]=pp(l))}const a=(l,c)=>$.forEach(l,(i,d)=>o(i,d,c));if($.isPlainObject(t)||t instanceof this.constructor)a(t,n);else if($.isString(t)&&(t=t.trim())&&!f4(t))a(c4(t),n);else if($.isHeaders(t))for(const[l,c]of t.entries())o(c,l,r);else t!=null&&o(n,t,r);return this}get(t,n){if(t=Gu(t),t){const r=$.findKey(this,t);if(r){const s=this[r];if(!n)return s;if(n===!0)return d4(s);if($.isFunction(n))return n.call(this,s,r);if($.isRegExp(n))return n.exec(s);throw new TypeError("parser must be boolean|regexp|function")}}}has(t,n){if(t=Gu(t),t){const r=$.findKey(this,t);return!!(r&&this[r]!==void 0&&(!n||Lm(this,this[r],r,n)))}return!1}delete(t,n){const r=this;let s=!1;function o(a){if(a=Gu(a),a){const l=$.findKey(r,a);l&&(!n||Lm(r,r[l],l,n))&&(delete r[l],s=!0)}}return $.isArray(t)?t.forEach(o):o(t),s}clear(t){const n=Object.keys(this);let r=n.length,s=!1;for(;r--;){const o=n[r];(!t||Lm(this,this[o],o,t,!0))&&(delete this[o],s=!0)}return s}normalize(t){const n=this,r={};return $.forEach(this,(s,o)=>{const a=$.findKey(r,o);if(a){n[a]=pp(s),delete n[o];return}const l=t?p4(o):String(o).trim();l!==o&&delete n[o],n[l]=pp(s),r[l]=!0}),this}concat(...t){return this.constructor.concat(this,...t)}toJSON(t){const n=Object.create(null);return $.forEach(this,(r,s)=>{r!=null&&r!==!1&&(n[s]=t&&$.isArray(r)?r.join(", "):r)}),n}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([t,n])=>t+": "+n).join(`
`)}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(t){return t instanceof this?t:new this(t)}static concat(t,...n){const r=new this(t);return n.forEach(s=>r.set(s)),r}static accessor(t){const r=(this[U0]=this[U0]={accessors:{}}).accessors,s=this.prototype;function o(a){const l=Gu(a);r[l]||(h4(s,a),r[l]=!0)}return $.isArray(t)?t.forEach(o):o(t),this}};sr.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]);$.reduceDescriptors(sr.prototype,({value:e},t)=>{let n=t[0].toUpperCase()+t.slice(1);return{get:()=>e,set(r){this[n]=r}}});$.freezeMethods(sr);function $m(e,t){const n=this||zd,r=t||n,s=sr.from(r.headers);let o=r.data;return $.forEach(e,function(l){o=l.call(n,o,s.normalize(),t?t.status:void 0)}),s.normalize(),o}function W_(e){return!!(e&&e.__CANCEL__)}function gu(e,t,n){He.call(this,e??"canceled",He.ERR_CANCELED,t,n),this.name="CanceledError"}$.inherits(gu,He,{__CANCEL__:!0});function G_(e,t,n){const r=n.config.validateStatus;!n.status||!r||r(n.status)?e(n):t(new He("Request failed with status code "+n.status,[He.ERR_BAD_REQUEST,He.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n))}function g4(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}function m4(e,t){e=e||10;const n=new Array(e),r=new Array(e);let s=0,o=0,a;return t=t!==void 0?t:1e3,function(c){const i=Date.now(),d=r[o];a||(a=i),n[s]=c,r[s]=i;let p=o,f=0;for(;p!==s;)f+=n[p++],p=p%e;if(s=(s+1)%e,s===o&&(o=(o+1)%e),i-a<t)return;const h=d&&i-d;return h?Math.round(f*1e3/h):void 0}}function v4(e,t){let n=0;const r=1e3/t;let s=null;return function(){const a=this===!0,l=Date.now();if(a||l-n>r)return s&&(clearTimeout(s),s=null),n=l,e.apply(null,arguments);s||(s=setTimeout(()=>(s=null,n=Date.now(),e.apply(null,arguments)),r-(l-n)))}}const eh=(e,t,n=3)=>{let r=0;const s=m4(50,250);return v4(o=>{const a=o.loaded,l=o.lengthComputable?o.total:void 0,c=a-r,i=s(c),d=a<=l;r=a;const p={loaded:a,total:l,progress:l?a/l:void 0,bytes:c,rate:i||void 0,estimated:i&&l&&d?(l-a)/i:void 0,event:o,lengthComputable:l!=null};p[t?"download":"upload"]=!0,e(p)},n)},y4=ss.hasStandardBrowserEnv?function(){const t=/(msie|trident)/i.test(navigator.userAgent),n=document.createElement("a");let r;function s(o){let a=o;return t&&(n.setAttribute("href",a),a=n.href),n.setAttribute("href",a),{href:n.href,protocol:n.protocol?n.protocol.replace(/:$/,""):"",host:n.host,search:n.search?n.search.replace(/^\?/,""):"",hash:n.hash?n.hash.replace(/^#/,""):"",hostname:n.hostname,port:n.port,pathname:n.pathname.charAt(0)==="/"?n.pathname:"/"+n.pathname}}return r=s(window.location.href),function(a){const l=$.isString(a)?s(a):a;return l.protocol===r.protocol&&l.host===r.host}}():function(){return function(){return!0}}(),b4=ss.hasStandardBrowserEnv?{write(e,t,n,r,s,o){const a=[e+"="+encodeURIComponent(t)];$.isNumber(n)&&a.push("expires="+new Date(n).toGMTString()),$.isString(r)&&a.push("path="+r),$.isString(s)&&a.push("domain="+s),o===!0&&a.push("secure"),document.cookie=a.join("; ")},read(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove(e){this.write(e,"",Date.now()-864e5)}}:{write(){},read(){return null},remove(){}};function x4(e){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)}function w4(e,t){return t?e.replace(/\/?\/$/,"")+"/"+t.replace(/^\/+/,""):e}function J_(e,t){return e&&!x4(t)?w4(e,t):t}const V0=e=>e instanceof sr?{...e}:e;function Si(e,t){t=t||{};const n={};function r(i,d,p){return $.isPlainObject(i)&&$.isPlainObject(d)?$.merge.call({caseless:p},i,d):$.isPlainObject(d)?$.merge({},d):$.isArray(d)?d.slice():d}function s(i,d,p){if($.isUndefined(d)){if(!$.isUndefined(i))return r(void 0,i,p)}else return r(i,d,p)}function o(i,d){if(!$.isUndefined(d))return r(void 0,d)}function a(i,d){if($.isUndefined(d)){if(!$.isUndefined(i))return r(void 0,i)}else return r(void 0,d)}function l(i,d,p){if(p in t)return r(i,d);if(p in e)return r(void 0,i)}const c={url:o,method:o,data:o,baseURL:a,transformRequest:a,transformResponse:a,paramsSerializer:a,timeout:a,timeoutMessage:a,withCredentials:a,withXSRFToken:a,adapter:a,responseType:a,xsrfCookieName:a,xsrfHeaderName:a,onUploadProgress:a,onDownloadProgress:a,decompress:a,maxContentLength:a,maxBodyLength:a,beforeRedirect:a,transport:a,httpAgent:a,httpsAgent:a,cancelToken:a,socketPath:a,responseEncoding:a,validateStatus:l,headers:(i,d)=>s(V0(i),V0(d),!0)};return $.forEach(Object.keys(Object.assign({},e,t)),function(d){const p=c[d]||s,f=p(e[d],t[d],d);$.isUndefined(f)&&p!==l||(n[d]=f)}),n}const Q_=e=>{const t=Si({},e);let{data:n,withXSRFToken:r,xsrfHeaderName:s,xsrfCookieName:o,headers:a,auth:l}=t;t.headers=a=sr.from(a),t.url=H_(J_(t.baseURL,t.url),e.params,e.paramsSerializer),l&&a.set("Authorization","Basic "+btoa((l.username||"")+":"+(l.password?unescape(encodeURIComponent(l.password)):"")));let c;if($.isFormData(n)){if(ss.hasStandardBrowserEnv||ss.hasStandardBrowserWebWorkerEnv)a.setContentType(void 0);else if((c=a.getContentType())!==!1){const[i,...d]=c?c.split(";").map(p=>p.trim()).filter(Boolean):[];a.setContentType([i||"multipart/form-data",...d].join("; "))}}if(ss.hasStandardBrowserEnv&&(r&&$.isFunction(r)&&(r=r(t)),r||r!==!1&&y4(t.url))){const i=s&&o&&b4.read(o);i&&a.set(s,i)}return t},S4=typeof XMLHttpRequest<"u",C4=S4&&function(e){return new Promise(function(n,r){const s=Q_(e);let o=s.data;const a=sr.from(s.headers).normalize();let{responseType:l}=s,c;function i(){s.cancelToken&&s.cancelToken.unsubscribe(c),s.signal&&s.signal.removeEventListener("abort",c)}let d=new XMLHttpRequest;d.open(s.method.toUpperCase(),s.url,!0),d.timeout=s.timeout;function p(){if(!d)return;const h=sr.from("getAllResponseHeaders"in d&&d.getAllResponseHeaders()),m={data:!l||l==="text"||l==="json"?d.responseText:d.response,status:d.status,statusText:d.statusText,headers:h,config:e,request:d};G_(function(b){n(b),i()},function(b){r(b),i()},m),d=null}"onloadend"in d?d.onloadend=p:d.onreadystatechange=function(){!d||d.readyState!==4||d.status===0&&!(d.responseURL&&d.responseURL.indexOf("file:")===0)||setTimeout(p)},d.onabort=function(){d&&(r(new He("Request aborted",He.ECONNABORTED,s,d)),d=null)},d.onerror=function(){r(new He("Network Error",He.ERR_NETWORK,s,d)),d=null},d.ontimeout=function(){let g=s.timeout?"timeout of "+s.timeout+"ms exceeded":"timeout exceeded";const m=s.transitional||K_;s.timeoutErrorMessage&&(g=s.timeoutErrorMessage),r(new He(g,m.clarifyTimeoutError?He.ETIMEDOUT:He.ECONNABORTED,s,d)),d=null},o===void 0&&a.setContentType(null),"setRequestHeader"in d&&$.forEach(a.toJSON(),function(g,m){d.setRequestHeader(m,g)}),$.isUndefined(s.withCredentials)||(d.withCredentials=!!s.withCredentials),l&&l!=="json"&&(d.responseType=s.responseType),typeof s.onDownloadProgress=="function"&&d.addEventListener("progress",eh(s.onDownloadProgress,!0)),typeof s.onUploadProgress=="function"&&d.upload&&d.upload.addEventListener("progress",eh(s.onUploadProgress)),(s.cancelToken||s.signal)&&(c=h=>{d&&(r(!h||h.type?new gu(null,e,d):h),d.abort(),d=null)},s.cancelToken&&s.cancelToken.subscribe(c),s.signal&&(s.signal.aborted?c():s.signal.addEventListener("abort",c)));const f=g4(s.url);if(f&&ss.protocols.indexOf(f)===-1){r(new He("Unsupported protocol "+f+":",He.ERR_BAD_REQUEST,e));return}d.send(o||null)})},E4=(e,t)=>{let n=new AbortController,r;const s=function(c){if(!r){r=!0,a();const i=c instanceof Error?c:this.reason;n.abort(i instanceof He?i:new gu(i instanceof Error?i.message:i))}};let o=t&&setTimeout(()=>{s(new He(`timeout ${t} of ms exceeded`,He.ETIMEDOUT))},t);const a=()=>{e&&(o&&clearTimeout(o),o=null,e.forEach(c=>{c&&(c.removeEventListener?c.removeEventListener("abort",s):c.unsubscribe(s))}),e=null)};e.forEach(c=>c&&c.addEventListener&&c.addEventListener("abort",s));const{signal:l}=n;return l.unsubscribe=a,[l,()=>{o&&clearTimeout(o),o=null}]},T4=function*(e,t){let n=e.byteLength;if(!t||n<t){yield e;return}let r=0,s;for(;r<n;)s=r+t,yield e.slice(r,s),r=s},k4=async function*(e,t,n){for await(const r of e)yield*T4(ArrayBuffer.isView(r)?r:await n(String(r)),t)},H0=(e,t,n,r,s)=>{const o=k4(e,t,s);let a=0;return new ReadableStream({type:"bytes",async pull(l){const{done:c,value:i}=await o.next();if(c){l.close(),r();return}let d=i.byteLength;n&&n(a+=d),l.enqueue(new Uint8Array(i))},cancel(l){return r(l),o.return()}},{highWaterMark:2})},K0=(e,t)=>{const n=e!=null;return r=>setTimeout(()=>t({lengthComputable:n,total:e,loaded:r}))},og=typeof fetch=="function"&&typeof Request=="function"&&typeof Response=="function",Z_=og&&typeof ReadableStream=="function",Ly=og&&(typeof TextEncoder=="function"?(e=>t=>e.encode(t))(new TextEncoder):async e=>new Uint8Array(await new Response(e).arrayBuffer())),_4=Z_&&(()=>{let e=!1;const t=new Request(ss.origin,{body:new ReadableStream,method:"POST",get duplex(){return e=!0,"half"}}).headers.has("Content-Type");return e&&!t})(),q0=64*1024,$y=Z_&&!!(()=>{try{return $.isReadableStream(new Response("").body)}catch{}})(),th={stream:$y&&(e=>e.body)};og&&(e=>{["text","arrayBuffer","blob","formData","stream"].forEach(t=>{!th[t]&&(th[t]=$.isFunction(e[t])?n=>n[t]():(n,r)=>{throw new He(`Response type '${t}' is not supported`,He.ERR_NOT_SUPPORT,r)})})})(new Response);const j4=async e=>{if(e==null)return 0;if($.isBlob(e))return e.size;if($.isSpecCompliantForm(e))return(await new Request(e).arrayBuffer()).byteLength;if($.isArrayBufferView(e))return e.byteLength;if($.isURLSearchParams(e)&&(e=e+""),$.isString(e))return(await Ly(e)).byteLength},R4=async(e,t)=>{const n=$.toFiniteNumber(e.getContentLength());return n??j4(t)},P4=og&&(async e=>{let{url:t,method:n,data:r,signal:s,cancelToken:o,timeout:a,onDownloadProgress:l,onUploadProgress:c,responseType:i,headers:d,withCredentials:p="same-origin",fetchOptions:f}=Q_(e);i=i?(i+"").toLowerCase():"text";let[h,g]=s||o||a?E4([s,o],a):[],m,x;const b=()=>{!m&&setTimeout(()=>{h&&h.unsubscribe()}),m=!0};let y;try{if(c&&_4&&n!=="get"&&n!=="head"&&(y=await R4(d,r))!==0){let C=new Request(t,{method:"POST",body:r,duplex:"half"}),k;$.isFormData(r)&&(k=C.headers.get("content-type"))&&d.setContentType(k),C.body&&(r=H0(C.body,q0,K0(y,eh(c)),null,Ly))}$.isString(p)||(p=p?"cors":"omit"),x=new Request(t,{...f,signal:h,method:n.toUpperCase(),headers:d.normalize().toJSON(),body:r,duplex:"half",withCredentials:p});let w=await fetch(x);const S=$y&&(i==="stream"||i==="response");if($y&&(l||S)){const C={};["status","statusText","headers"].forEach(T=>{C[T]=w[T]});const k=$.toFiniteNumber(w.headers.get("content-length"));w=new Response(H0(w.body,q0,l&&K0(k,eh(l,!0)),S&&b,Ly),C)}i=i||"text";let E=await th[$.findKey(th,i)||"text"](w,e);return!S&&b(),g&&g(),await new Promise((C,k)=>{G_(C,k,{data:E,headers:sr.from(w.headers),status:w.status,statusText:w.statusText,config:e,request:x})})}catch(w){throw b(),w&&w.name==="TypeError"&&/fetch/i.test(w.message)?Object.assign(new He("Network Error",He.ERR_NETWORK,e,x),{cause:w.cause||w}):He.from(w,w&&w.code,e,x)}}),By={http:W$,xhr:C4,fetch:P4};$.forEach(By,(e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch{}Object.defineProperty(e,"adapterName",{value:t})}});const W0=e=>`- ${e}`,M4=e=>$.isFunction(e)||e===null||e===!1,Y_={getAdapter:e=>{e=$.isArray(e)?e:[e];const{length:t}=e;let n,r;const s={};for(let o=0;o<t;o++){n=e[o];let a;if(r=n,!M4(n)&&(r=By[(a=String(n)).toLowerCase()],r===void 0))throw new He(`Unknown adapter '${a}'`);if(r)break;s[a||"#"+o]=r}if(!r){const o=Object.entries(s).map(([l,c])=>`adapter ${l} `+(c===!1?"is not supported by the environment":"is not available in the build"));let a=t?o.length>1?`since :
`+o.map(W0).join(`
`):" "+W0(o[0]):"as no adapter specified";throw new He("There is no suitable adapter to dispatch the request "+a,"ERR_NOT_SUPPORT")}return r},adapters:By};function Bm(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new gu(null,e)}function G0(e){return Bm(e),e.headers=sr.from(e.headers),e.data=$m.call(e,e.transformRequest),["post","put","patch"].indexOf(e.method)!==-1&&e.headers.setContentType("application/x-www-form-urlencoded",!1),Y_.getAdapter(e.adapter||zd.adapter)(e).then(function(r){return Bm(e),r.data=$m.call(e,e.transformResponse,r),r.headers=sr.from(r.headers),r},function(r){return W_(r)||(Bm(e),r&&r.response&&(r.response.data=$m.call(e,e.transformResponse,r.response),r.response.headers=sr.from(r.response.headers))),Promise.reject(r)})}const X_="1.7.2",Ix={};["object","boolean","number","function","string","symbol"].forEach((e,t)=>{Ix[e]=function(r){return typeof r===e||"a"+(t<1?"n ":" ")+e}});const J0={};Ix.transitional=function(t,n,r){function s(o,a){return"[Axios v"+X_+"] Transitional option '"+o+"'"+a+(r?". "+r:"")}return(o,a,l)=>{if(t===!1)throw new He(s(a," has been removed"+(n?" in "+n:"")),He.ERR_DEPRECATED);return n&&!J0[a]&&(J0[a]=!0,console.warn(s(a," has been deprecated since v"+n+" and will be removed in the near future"))),t?t(o,a,l):!0}};function O4(e,t,n){if(typeof e!="object")throw new He("options must be an object",He.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let s=r.length;for(;s-- >0;){const o=r[s],a=t[o];if(a){const l=e[o],c=l===void 0||a(l,o,e);if(c!==!0)throw new He("option "+o+" must be "+c,He.ERR_BAD_OPTION_VALUE);continue}if(n!==!0)throw new He("Unknown option "+o,He.ERR_BAD_OPTION)}}const zy={assertOptions:O4,validators:Ix},Oo=zy.validators;let di=class{constructor(t){this.defaults=t,this.interceptors={request:new z0,response:new z0}}async request(t,n){try{return await this._request(t,n)}catch(r){if(r instanceof Error){let s;Error.captureStackTrace?Error.captureStackTrace(s={}):s=new Error;const o=s.stack?s.stack.replace(/^.+\n/,""):"";try{r.stack?o&&!String(r.stack).endsWith(o.replace(/^.+\n.+\n/,""))&&(r.stack+=`
`+o):r.stack=o}catch{}}throw r}}_request(t,n){typeof t=="string"?(n=n||{},n.url=t):n=t||{},n=Si(this.defaults,n);const{transitional:r,paramsSerializer:s,headers:o}=n;r!==void 0&&zy.assertOptions(r,{silentJSONParsing:Oo.transitional(Oo.boolean),forcedJSONParsing:Oo.transitional(Oo.boolean),clarifyTimeoutError:Oo.transitional(Oo.boolean)},!1),s!=null&&($.isFunction(s)?n.paramsSerializer={serialize:s}:zy.assertOptions(s,{encode:Oo.function,serialize:Oo.function},!0)),n.method=(n.method||this.defaults.method||"get").toLowerCase();let a=o&&$.merge(o.common,o[n.method]);o&&$.forEach(["delete","get","head","post","put","patch","common"],g=>{delete o[g]}),n.headers=sr.concat(a,o);const l=[];let c=!0;this.interceptors.request.forEach(function(m){typeof m.runWhen=="function"&&m.runWhen(n)===!1||(c=c&&m.synchronous,l.unshift(m.fulfilled,m.rejected))});const i=[];this.interceptors.response.forEach(function(m){i.push(m.fulfilled,m.rejected)});let d,p=0,f;if(!c){const g=[G0.bind(this),void 0];for(g.unshift.apply(g,l),g.push.apply(g,i),f=g.length,d=Promise.resolve(n);p<f;)d=d.then(g[p++],g[p++]);return d}f=l.length;let h=n;for(p=0;p<f;){const g=l[p++],m=l[p++];try{h=g(h)}catch(x){m.call(this,x);break}}try{d=G0.call(this,h)}catch(g){return Promise.reject(g)}for(p=0,f=i.length;p<f;)d=d.then(i[p++],i[p++]);return d}getUri(t){t=Si(this.defaults,t);const n=J_(t.baseURL,t.url);return H_(n,t.params,t.paramsSerializer)}};$.forEach(["delete","get","head","options"],function(t){di.prototype[t]=function(n,r){return this.request(Si(r||{},{method:t,url:n,data:(r||{}).data}))}});$.forEach(["post","put","patch"],function(t){function n(r){return function(o,a,l){return this.request(Si(l||{},{method:t,headers:r?{"Content-Type":"multipart/form-data"}:{},url:o,data:a}))}}di.prototype[t]=n(),di.prototype[t+"Form"]=n(!0)});let N4=class ej{constructor(t){if(typeof t!="function")throw new TypeError("executor must be a function.");let n;this.promise=new Promise(function(o){n=o});const r=this;this.promise.then(s=>{if(!r._listeners)return;let o=r._listeners.length;for(;o-- >0;)r._listeners[o](s);r._listeners=null}),this.promise.then=s=>{let o;const a=new Promise(l=>{r.subscribe(l),o=l}).then(s);return a.cancel=function(){r.unsubscribe(o)},a},t(function(o,a,l){r.reason||(r.reason=new gu(o,a,l),n(r.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(t){if(this.reason){t(this.reason);return}this._listeners?this._listeners.push(t):this._listeners=[t]}unsubscribe(t){if(!this._listeners)return;const n=this._listeners.indexOf(t);n!==-1&&this._listeners.splice(n,1)}static source(){let t;return{token:new ej(function(s){t=s}),cancel:t}}};function I4(e){return function(n){return e.apply(null,n)}}function D4(e){return $.isObject(e)&&e.isAxiosError===!0}const Uy={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(Uy).forEach(([e,t])=>{Uy[t]=e});function tj(e){const t=new di(e),n=O_(di.prototype.request,t);return $.extend(n,di.prototype,t,{allOwnKeys:!0}),$.extend(n,t,null,{allOwnKeys:!0}),n.create=function(s){return tj(Si(e,s))},n}const zt=tj(zd);zt.Axios=di;zt.CanceledError=gu;zt.CancelToken=N4;zt.isCancel=W_;zt.VERSION=X_;zt.toFormData=sg;zt.AxiosError=He;zt.Cancel=zt.CanceledError;zt.all=function(t){return Promise.all(t)};zt.spread=I4;zt.isAxiosError=D4;zt.mergeConfig=Si;zt.AxiosHeaders=sr;zt.formToJSON=e=>q_($.isHTMLForm(e)?new FormData(e):e);zt.getAdapter=Y_.getAdapter;zt.HttpStatusCode=Uy;zt.default=zt;const{Axios:Mse,AxiosError:Ose,CanceledError:Nse,isCancel:Ise,CancelToken:Dse,VERSION:Ase,all:Fse,Cancel:Lse,isAxiosError:A4,spread:$se,toFormData:Bse,AxiosHeaders:zse,HttpStatusCode:Use,formToJSON:Vse,getAdapter:Hse,mergeConfig:Kse}=zt,F4=e=>["auth","verifyServer",JSON.stringify(e)],nj=async({url:e})=>(await zt.get(`${e}/`)).data,L4=e=>{const{url:t,...n}=e;return lt({...n,queryKey:F4({url:t}),queryFn:()=>nj({url:t}),enabled:!!t})};function $4(e,t){typeof e=="function"?e(t):e!=null&&(e.current=t)}function ag(...e){return t=>e.forEach(n=>$4(n,t))}function it(...e){return v.useCallback(ag(...e),e)}var mo=v.forwardRef((e,t)=>{const{children:n,...r}=e,s=v.Children.toArray(n),o=s.find(z4);if(o){const a=o.props.children,l=s.map(c=>c===o?v.Children.count(a)>1?v.Children.only(null):v.isValidElement(a)?a.props.children:null:c);return u.jsx(Vy,{...r,ref:t,children:v.isValidElement(a)?v.cloneElement(a,void 0,l):null})}return u.jsx(Vy,{...r,ref:t,children:n})});mo.displayName="Slot";var Vy=v.forwardRef((e,t)=>{const{children:n,...r}=e;if(v.isValidElement(n)){const s=V4(n);return v.cloneElement(n,{...U4(r,n.props),ref:t?ag(t,s):s})}return v.Children.count(n)>1?v.Children.only(null):null});Vy.displayName="SlotClone";var B4=({children:e})=>u.jsx(u.Fragment,{children:e});function z4(e){return v.isValidElement(e)&&e.type===B4}function U4(e,t){const n={...t};for(const r in t){const s=e[r],o=t[r];/^on[A-Z]/.test(r)?s&&o?n[r]=(...l)=>{o(...l),s(...l)}:s&&(n[r]=s):r==="style"?n[r]={...s,...o}:r==="className"&&(n[r]=[s,o].filter(Boolean).join(" "))}return{...e,...n}}function V4(e){var r,s;let t=(r=Object.getOwnPropertyDescriptor(e.props,"ref"))==null?void 0:r.get,n=t&&"isReactWarning"in t&&t.isReactWarning;return n?e.ref:(t=(s=Object.getOwnPropertyDescriptor(e,"ref"))==null?void 0:s.get,n=t&&"isReactWarning"in t&&t.isReactWarning,n?e.props.ref:e.props.ref||e.ref)}function rj(e){var t,n,r="";if(typeof e=="string"||typeof e=="number")r+=e;else if(typeof e=="object")if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=rj(e[t]))&&(r&&(r+=" "),r+=n);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}function H4(){for(var e,t,n=0,r="";n<arguments.length;)(e=arguments[n++])&&(t=rj(e))&&(r&&(r+=" "),r+=t);return r}const Q0=e=>typeof e=="boolean"?"".concat(e):e===0?"0":e,Z0=H4,ig=(e,t)=>n=>{var r;if((t==null?void 0:t.variants)==null)return Z0(e,n==null?void 0:n.class,n==null?void 0:n.className);const{variants:s,defaultVariants:o}=t,a=Object.keys(s).map(i=>{const d=n==null?void 0:n[i],p=o==null?void 0:o[i];if(d===null)return null;const f=Q0(d)||Q0(p);return s[i][f]}),l=n&&Object.entries(n).reduce((i,d)=>{let[p,f]=d;return f===void 0||(i[p]=f),i},{}),c=t==null||(r=t.compoundVariants)===null||r===void 0?void 0:r.reduce((i,d)=>{let{class:p,className:f,...h}=d;return Object.entries(h).every(g=>{let[m,x]=g;return Array.isArray(x)?x.includes({...o,...l}[m]):{...o,...l}[m]===x})?[...i,p,f]:i},[]);return Z0(e,a,c,n==null?void 0:n.class,n==null?void 0:n.className)},Dx="-";function K4(e){const t=W4(e),{conflictingClassGroups:n,conflictingClassGroupModifiers:r}=e;function s(a){const l=a.split(Dx);return l[0]===""&&l.length!==1&&l.shift(),sj(l,t)||q4(a)}function o(a,l){const c=n[a]||[];return l&&r[a]?[...c,...r[a]]:c}return{getClassGroupId:s,getConflictingClassGroupIds:o}}function sj(e,t){var a;if(e.length===0)return t.classGroupId;const n=e[0],r=t.nextPart.get(n),s=r?sj(e.slice(1),r):void 0;if(s)return s;if(t.validators.length===0)return;const o=e.join(Dx);return(a=t.validators.find(({validator:l})=>l(o)))==null?void 0:a.classGroupId}const Y0=/^\[(.+)\]$/;function q4(e){if(Y0.test(e)){const t=Y0.exec(e)[1],n=t==null?void 0:t.substring(0,t.indexOf(":"));if(n)return"arbitrary.."+n}}function W4(e){const{theme:t,prefix:n}=e,r={nextPart:new Map,validators:[]};return J4(Object.entries(e.classGroups),n).forEach(([o,a])=>{Hy(a,r,o,t)}),r}function Hy(e,t,n,r){e.forEach(s=>{if(typeof s=="string"){const o=s===""?t:X0(t,s);o.classGroupId=n;return}if(typeof s=="function"){if(G4(s)){Hy(s(r),t,n,r);return}t.validators.push({validator:s,classGroupId:n});return}Object.entries(s).forEach(([o,a])=>{Hy(a,X0(t,o),n,r)})})}function X0(e,t){let n=e;return t.split(Dx).forEach(r=>{n.nextPart.has(r)||n.nextPart.set(r,{nextPart:new Map,validators:[]}),n=n.nextPart.get(r)}),n}function G4(e){return e.isThemeGetter}function J4(e,t){return t?e.map(([n,r])=>{const s=r.map(o=>typeof o=="string"?t+o:typeof o=="object"?Object.fromEntries(Object.entries(o).map(([a,l])=>[t+a,l])):o);return[n,s]}):e}function Q4(e){if(e<1)return{get:()=>{},set:()=>{}};let t=0,n=new Map,r=new Map;function s(o,a){n.set(o,a),t++,t>e&&(t=0,r=n,n=new Map)}return{get(o){let a=n.get(o);if(a!==void 0)return a;if((a=r.get(o))!==void 0)return s(o,a),a},set(o,a){n.has(o)?n.set(o,a):s(o,a)}}}const oj="!";function Z4(e){const{separator:t,experimentalParseClassName:n}=e,r=t.length===1,s=t[0],o=t.length;function a(l){const c=[];let i=0,d=0,p;for(let x=0;x<l.length;x++){let b=l[x];if(i===0){if(b===s&&(r||l.slice(x,x+o)===t)){c.push(l.slice(d,x)),d=x+o;continue}if(b==="/"){p=x;continue}}b==="["?i++:b==="]"&&i--}const f=c.length===0?l:l.substring(d),h=f.startsWith(oj),g=h?f.substring(1):f,m=p&&p>d?p-d:void 0;return{modifiers:c,hasImportantModifier:h,baseClassName:g,maybePostfixModifierPosition:m}}return n?function(c){return n({className:c,parseClassName:a})}:a}function Y4(e){if(e.length<=1)return e;const t=[];let n=[];return e.forEach(r=>{r[0]==="["?(t.push(...n.sort(),r),n=[]):n.push(r)}),t.push(...n.sort()),t}function X4(e){return{cache:Q4(e.cacheSize),parseClassName:Z4(e),...K4(e)}}const e3=/\s+/;function t3(e,t){const{parseClassName:n,getClassGroupId:r,getConflictingClassGroupIds:s}=t,o=new Set;return e.trim().split(e3).map(a=>{const{modifiers:l,hasImportantModifier:c,baseClassName:i,maybePostfixModifierPosition:d}=n(a);let p=!!d,f=r(p?i.substring(0,d):i);if(!f){if(!p)return{isTailwindClass:!1,originalClassName:a};if(f=r(i),!f)return{isTailwindClass:!1,originalClassName:a};p=!1}const h=Y4(l).join(":");return{isTailwindClass:!0,modifierId:c?h+oj:h,classGroupId:f,originalClassName:a,hasPostfixModifier:p}}).reverse().filter(a=>{if(!a.isTailwindClass)return!0;const{modifierId:l,classGroupId:c,hasPostfixModifier:i}=a,d=l+c;return o.has(d)?!1:(o.add(d),s(c,i).forEach(p=>o.add(l+p)),!0)}).reverse().map(a=>a.originalClassName).join(" ")}function n3(){let e=0,t,n,r="";for(;e<arguments.length;)(t=arguments[e++])&&(n=aj(t))&&(r&&(r+=" "),r+=n);return r}function aj(e){if(typeof e=="string")return e;let t,n="";for(let r=0;r<e.length;r++)e[r]&&(t=aj(e[r]))&&(n&&(n+=" "),n+=t);return n}function r3(e,...t){let n,r,s,o=a;function a(c){const i=t.reduce((d,p)=>p(d),e());return n=X4(i),r=n.cache.get,s=n.cache.set,o=l,l(c)}function l(c){const i=r(c);if(i)return i;const d=t3(c,n);return s(c,d),d}return function(){return o(n3.apply(null,arguments))}}function _t(e){const t=n=>n[e]||[];return t.isThemeGetter=!0,t}const ij=/^\[(?:([a-z-]+):)?(.+)\]$/i,s3=/^\d+\/\d+$/,o3=new Set(["px","full","screen"]),a3=/^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,i3=/\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,l3=/^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,u3=/^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,c3=/^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;function qs(e){return Ga(e)||o3.has(e)||s3.test(e)}function No(e){return mu(e,"length",y3)}function Ga(e){return!!e&&!Number.isNaN(Number(e))}function Pf(e){return mu(e,"number",Ga)}function Ju(e){return!!e&&Number.isInteger(Number(e))}function d3(e){return e.endsWith("%")&&Ga(e.slice(0,-1))}function We(e){return ij.test(e)}function Io(e){return a3.test(e)}const f3=new Set(["length","size","percentage"]);function p3(e){return mu(e,f3,lj)}function h3(e){return mu(e,"position",lj)}const g3=new Set(["image","url"]);function m3(e){return mu(e,g3,x3)}function v3(e){return mu(e,"",b3)}function Qu(){return!0}function mu(e,t,n){const r=ij.exec(e);return r?r[1]?typeof t=="string"?r[1]===t:t.has(r[1]):n(r[2]):!1}function y3(e){return i3.test(e)&&!l3.test(e)}function lj(){return!1}function b3(e){return u3.test(e)}function x3(e){return c3.test(e)}function w3(){const e=_t("colors"),t=_t("spacing"),n=_t("blur"),r=_t("brightness"),s=_t("borderColor"),o=_t("borderRadius"),a=_t("borderSpacing"),l=_t("borderWidth"),c=_t("contrast"),i=_t("grayscale"),d=_t("hueRotate"),p=_t("invert"),f=_t("gap"),h=_t("gradientColorStops"),g=_t("gradientColorStopPositions"),m=_t("inset"),x=_t("margin"),b=_t("opacity"),y=_t("padding"),w=_t("saturate"),S=_t("scale"),E=_t("sepia"),C=_t("skew"),k=_t("space"),T=_t("translate"),P=()=>["auto","contain","none"],N=()=>["auto","hidden","clip","visible","scroll"],U=()=>["auto",We,t],I=()=>[We,t],Z=()=>["",qs,No],V=()=>["auto",Ga,We],Q=()=>["bottom","center","left","left-bottom","left-top","right","right-bottom","right-top","top"],ee=()=>["solid","dashed","dotted","double","none"],W=()=>["normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn","hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"],F=()=>["start","end","center","between","around","evenly","stretch"],A=()=>["","0",We],Y=()=>["auto","avoid","all","avoid-page","page","left","right","column"],de=()=>[Ga,Pf],z=()=>[Ga,We];return{cacheSize:500,separator:":",theme:{colors:[Qu],spacing:[qs,No],blur:["none","",Io,We],brightness:de(),borderColor:[e],borderRadius:["none","","full",Io,We],borderSpacing:I(),borderWidth:Z(),contrast:de(),grayscale:A(),hueRotate:z(),invert:A(),gap:I(),gradientColorStops:[e],gradientColorStopPositions:[d3,No],inset:U(),margin:U(),opacity:de(),padding:I(),saturate:de(),scale:de(),sepia:A(),skew:z(),space:I(),translate:I()},classGroups:{aspect:[{aspect:["auto","square","video",We]}],container:["container"],columns:[{columns:[Io]}],"break-after":[{"break-after":Y()}],"break-before":[{"break-before":Y()}],"break-inside":[{"break-inside":["auto","avoid","avoid-page","avoid-column"]}],"box-decoration":[{"box-decoration":["slice","clone"]}],box:[{box:["border","content"]}],display:["block","inline-block","inline","flex","inline-flex","table","inline-table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row-group","table-row","flow-root","grid","inline-grid","contents","list-item","hidden"],float:[{float:["right","left","none","start","end"]}],clear:[{clear:["left","right","both","none","start","end"]}],isolation:["isolate","isolation-auto"],"object-fit":[{object:["contain","cover","fill","none","scale-down"]}],"object-position":[{object:[...Q(),We]}],overflow:[{overflow:N()}],"overflow-x":[{"overflow-x":N()}],"overflow-y":[{"overflow-y":N()}],overscroll:[{overscroll:P()}],"overscroll-x":[{"overscroll-x":P()}],"overscroll-y":[{"overscroll-y":P()}],position:["static","fixed","absolute","relative","sticky"],inset:[{inset:[m]}],"inset-x":[{"inset-x":[m]}],"inset-y":[{"inset-y":[m]}],start:[{start:[m]}],end:[{end:[m]}],top:[{top:[m]}],right:[{right:[m]}],bottom:[{bottom:[m]}],left:[{left:[m]}],visibility:["visible","invisible","collapse"],z:[{z:["auto",Ju,We]}],basis:[{basis:U()}],"flex-direction":[{flex:["row","row-reverse","col","col-reverse"]}],"flex-wrap":[{flex:["wrap","wrap-reverse","nowrap"]}],flex:[{flex:["1","auto","initial","none",We]}],grow:[{grow:A()}],shrink:[{shrink:A()}],order:[{order:["first","last","none",Ju,We]}],"grid-cols":[{"grid-cols":[Qu]}],"col-start-end":[{col:["auto",{span:["full",Ju,We]},We]}],"col-start":[{"col-start":V()}],"col-end":[{"col-end":V()}],"grid-rows":[{"grid-rows":[Qu]}],"row-start-end":[{row:["auto",{span:[Ju,We]},We]}],"row-start":[{"row-start":V()}],"row-end":[{"row-end":V()}],"grid-flow":[{"grid-flow":["row","col","dense","row-dense","col-dense"]}],"auto-cols":[{"auto-cols":["auto","min","max","fr",We]}],"auto-rows":[{"auto-rows":["auto","min","max","fr",We]}],gap:[{gap:[f]}],"gap-x":[{"gap-x":[f]}],"gap-y":[{"gap-y":[f]}],"justify-content":[{justify:["normal",...F()]}],"justify-items":[{"justify-items":["start","end","center","stretch"]}],"justify-self":[{"justify-self":["auto","start","end","center","stretch"]}],"align-content":[{content:["normal",...F(),"baseline"]}],"align-items":[{items:["start","end","center","baseline","stretch"]}],"align-self":[{self:["auto","start","end","center","stretch","baseline"]}],"place-content":[{"place-content":[...F(),"baseline"]}],"place-items":[{"place-items":["start","end","center","baseline","stretch"]}],"place-self":[{"place-self":["auto","start","end","center","stretch"]}],p:[{p:[y]}],px:[{px:[y]}],py:[{py:[y]}],ps:[{ps:[y]}],pe:[{pe:[y]}],pt:[{pt:[y]}],pr:[{pr:[y]}],pb:[{pb:[y]}],pl:[{pl:[y]}],m:[{m:[x]}],mx:[{mx:[x]}],my:[{my:[x]}],ms:[{ms:[x]}],me:[{me:[x]}],mt:[{mt:[x]}],mr:[{mr:[x]}],mb:[{mb:[x]}],ml:[{ml:[x]}],"space-x":[{"space-x":[k]}],"space-x-reverse":["space-x-reverse"],"space-y":[{"space-y":[k]}],"space-y-reverse":["space-y-reverse"],w:[{w:["auto","min","max","fit","svw","lvw","dvw",We,t]}],"min-w":[{"min-w":[We,t,"min","max","fit"]}],"max-w":[{"max-w":[We,t,"none","full","min","max","fit","prose",{screen:[Io]},Io]}],h:[{h:[We,t,"auto","min","max","fit","svh","lvh","dvh"]}],"min-h":[{"min-h":[We,t,"min","max","fit","svh","lvh","dvh"]}],"max-h":[{"max-h":[We,t,"min","max","fit","svh","lvh","dvh"]}],size:[{size:[We,t,"auto","min","max","fit"]}],"font-size":[{text:["base",Io,No]}],"font-smoothing":["antialiased","subpixel-antialiased"],"font-style":["italic","not-italic"],"font-weight":[{font:["thin","extralight","light","normal","medium","semibold","bold","extrabold","black",Pf]}],"font-family":[{font:[Qu]}],"fvn-normal":["normal-nums"],"fvn-ordinal":["ordinal"],"fvn-slashed-zero":["slashed-zero"],"fvn-figure":["lining-nums","oldstyle-nums"],"fvn-spacing":["proportional-nums","tabular-nums"],"fvn-fraction":["diagonal-fractions","stacked-fractons"],tracking:[{tracking:["tighter","tight","normal","wide","wider","widest",We]}],"line-clamp":[{"line-clamp":["none",Ga,Pf]}],leading:[{leading:["none","tight","snug","normal","relaxed","loose",qs,We]}],"list-image":[{"list-image":["none",We]}],"list-style-type":[{list:["none","disc","decimal",We]}],"list-style-position":[{list:["inside","outside"]}],"placeholder-color":[{placeholder:[e]}],"placeholder-opacity":[{"placeholder-opacity":[b]}],"text-alignment":[{text:["left","center","right","justify","start","end"]}],"text-color":[{text:[e]}],"text-opacity":[{"text-opacity":[b]}],"text-decoration":["underline","overline","line-through","no-underline"],"text-decoration-style":[{decoration:[...ee(),"wavy"]}],"text-decoration-thickness":[{decoration:["auto","from-font",qs,No]}],"underline-offset":[{"underline-offset":["auto",qs,We]}],"text-decoration-color":[{decoration:[e]}],"text-transform":["uppercase","lowercase","capitalize","normal-case"],"text-overflow":["truncate","text-ellipsis","text-clip"],"text-wrap":[{text:["wrap","nowrap","balance","pretty"]}],indent:[{indent:I()}],"vertical-align":[{align:["baseline","top","middle","bottom","text-top","text-bottom","sub","super",We]}],whitespace:[{whitespace:["normal","nowrap","pre","pre-line","pre-wrap","break-spaces"]}],break:[{break:["normal","words","all","keep"]}],hyphens:[{hyphens:["none","manual","auto"]}],content:[{content:["none",We]}],"bg-attachment":[{bg:["fixed","local","scroll"]}],"bg-clip":[{"bg-clip":["border","padding","content","text"]}],"bg-opacity":[{"bg-opacity":[b]}],"bg-origin":[{"bg-origin":["border","padding","content"]}],"bg-position":[{bg:[...Q(),h3]}],"bg-repeat":[{bg:["no-repeat",{repeat:["","x","y","round","space"]}]}],"bg-size":[{bg:["auto","cover","contain",p3]}],"bg-image":[{bg:["none",{"gradient-to":["t","tr","r","br","b","bl","l","tl"]},m3]}],"bg-color":[{bg:[e]}],"gradient-from-pos":[{from:[g]}],"gradient-via-pos":[{via:[g]}],"gradient-to-pos":[{to:[g]}],"gradient-from":[{from:[h]}],"gradient-via":[{via:[h]}],"gradient-to":[{to:[h]}],rounded:[{rounded:[o]}],"rounded-s":[{"rounded-s":[o]}],"rounded-e":[{"rounded-e":[o]}],"rounded-t":[{"rounded-t":[o]}],"rounded-r":[{"rounded-r":[o]}],"rounded-b":[{"rounded-b":[o]}],"rounded-l":[{"rounded-l":[o]}],"rounded-ss":[{"rounded-ss":[o]}],"rounded-se":[{"rounded-se":[o]}],"rounded-ee":[{"rounded-ee":[o]}],"rounded-es":[{"rounded-es":[o]}],"rounded-tl":[{"rounded-tl":[o]}],"rounded-tr":[{"rounded-tr":[o]}],"rounded-br":[{"rounded-br":[o]}],"rounded-bl":[{"rounded-bl":[o]}],"border-w":[{border:[l]}],"border-w-x":[{"border-x":[l]}],"border-w-y":[{"border-y":[l]}],"border-w-s":[{"border-s":[l]}],"border-w-e":[{"border-e":[l]}],"border-w-t":[{"border-t":[l]}],"border-w-r":[{"border-r":[l]}],"border-w-b":[{"border-b":[l]}],"border-w-l":[{"border-l":[l]}],"border-opacity":[{"border-opacity":[b]}],"border-style":[{border:[...ee(),"hidden"]}],"divide-x":[{"divide-x":[l]}],"divide-x-reverse":["divide-x-reverse"],"divide-y":[{"divide-y":[l]}],"divide-y-reverse":["divide-y-reverse"],"divide-opacity":[{"divide-opacity":[b]}],"divide-style":[{divide:ee()}],"border-color":[{border:[s]}],"border-color-x":[{"border-x":[s]}],"border-color-y":[{"border-y":[s]}],"border-color-t":[{"border-t":[s]}],"border-color-r":[{"border-r":[s]}],"border-color-b":[{"border-b":[s]}],"border-color-l":[{"border-l":[s]}],"divide-color":[{divide:[s]}],"outline-style":[{outline:["",...ee()]}],"outline-offset":[{"outline-offset":[qs,We]}],"outline-w":[{outline:[qs,No]}],"outline-color":[{outline:[e]}],"ring-w":[{ring:Z()}],"ring-w-inset":["ring-inset"],"ring-color":[{ring:[e]}],"ring-opacity":[{"ring-opacity":[b]}],"ring-offset-w":[{"ring-offset":[qs,No]}],"ring-offset-color":[{"ring-offset":[e]}],shadow:[{shadow:["","inner","none",Io,v3]}],"shadow-color":[{shadow:[Qu]}],opacity:[{opacity:[b]}],"mix-blend":[{"mix-blend":[...W(),"plus-lighter","plus-darker"]}],"bg-blend":[{"bg-blend":W()}],filter:[{filter:["","none"]}],blur:[{blur:[n]}],brightness:[{brightness:[r]}],contrast:[{contrast:[c]}],"drop-shadow":[{"drop-shadow":["","none",Io,We]}],grayscale:[{grayscale:[i]}],"hue-rotate":[{"hue-rotate":[d]}],invert:[{invert:[p]}],saturate:[{saturate:[w]}],sepia:[{sepia:[E]}],"backdrop-filter":[{"backdrop-filter":["","none"]}],"backdrop-blur":[{"backdrop-blur":[n]}],"backdrop-brightness":[{"backdrop-brightness":[r]}],"backdrop-contrast":[{"backdrop-contrast":[c]}],"backdrop-grayscale":[{"backdrop-grayscale":[i]}],"backdrop-hue-rotate":[{"backdrop-hue-rotate":[d]}],"backdrop-invert":[{"backdrop-invert":[p]}],"backdrop-opacity":[{"backdrop-opacity":[b]}],"backdrop-saturate":[{"backdrop-saturate":[w]}],"backdrop-sepia":[{"backdrop-sepia":[E]}],"border-collapse":[{border:["collapse","separate"]}],"border-spacing":[{"border-spacing":[a]}],"border-spacing-x":[{"border-spacing-x":[a]}],"border-spacing-y":[{"border-spacing-y":[a]}],"table-layout":[{table:["auto","fixed"]}],caption:[{caption:["top","bottom"]}],transition:[{transition:["none","all","","colors","opacity","shadow","transform",We]}],duration:[{duration:z()}],ease:[{ease:["linear","in","out","in-out",We]}],delay:[{delay:z()}],animate:[{animate:["none","spin","ping","pulse","bounce",We]}],transform:[{transform:["","gpu","none"]}],scale:[{scale:[S]}],"scale-x":[{"scale-x":[S]}],"scale-y":[{"scale-y":[S]}],rotate:[{rotate:[Ju,We]}],"translate-x":[{"translate-x":[T]}],"translate-y":[{"translate-y":[T]}],"skew-x":[{"skew-x":[C]}],"skew-y":[{"skew-y":[C]}],"transform-origin":[{origin:["center","top","top-right","right","bottom-right","bottom","bottom-left","left","top-left",We]}],accent:[{accent:["auto",e]}],appearance:[{appearance:["none","auto"]}],cursor:[{cursor:["auto","default","pointer","wait","text","move","help","not-allowed","none","context-menu","progress","cell","crosshair","vertical-text","alias","copy","no-drop","grab","grabbing","all-scroll","col-resize","row-resize","n-resize","e-resize","s-resize","w-resize","ne-resize","nw-resize","se-resize","sw-resize","ew-resize","ns-resize","nesw-resize","nwse-resize","zoom-in","zoom-out",We]}],"caret-color":[{caret:[e]}],"pointer-events":[{"pointer-events":["none","auto"]}],resize:[{resize:["none","y","x",""]}],"scroll-behavior":[{scroll:["auto","smooth"]}],"scroll-m":[{"scroll-m":I()}],"scroll-mx":[{"scroll-mx":I()}],"scroll-my":[{"scroll-my":I()}],"scroll-ms":[{"scroll-ms":I()}],"scroll-me":[{"scroll-me":I()}],"scroll-mt":[{"scroll-mt":I()}],"scroll-mr":[{"scroll-mr":I()}],"scroll-mb":[{"scroll-mb":I()}],"scroll-ml":[{"scroll-ml":I()}],"scroll-p":[{"scroll-p":I()}],"scroll-px":[{"scroll-px":I()}],"scroll-py":[{"scroll-py":I()}],"scroll-ps":[{"scroll-ps":I()}],"scroll-pe":[{"scroll-pe":I()}],"scroll-pt":[{"scroll-pt":I()}],"scroll-pr":[{"scroll-pr":I()}],"scroll-pb":[{"scroll-pb":I()}],"scroll-pl":[{"scroll-pl":I()}],"snap-align":[{snap:["start","end","center","align-none"]}],"snap-stop":[{snap:["normal","always"]}],"snap-type":[{snap:["none","x","y","both"]}],"snap-strictness":[{snap:["mandatory","proximity"]}],touch:[{touch:["auto","none","manipulation"]}],"touch-x":[{"touch-pan":["x","left","right"]}],"touch-y":[{"touch-pan":["y","up","down"]}],"touch-pz":["touch-pinch-zoom"],select:[{select:["none","text","all","auto"]}],"will-change":[{"will-change":["auto","scroll","contents","transform",We]}],fill:[{fill:[e,"none"]}],"stroke-w":[{stroke:[qs,No,Pf]}],stroke:[{stroke:[e,"none"]}],sr:["sr-only","not-sr-only"],"forced-color-adjust":[{"forced-color-adjust":["auto","none"]}]},conflictingClassGroups:{overflow:["overflow-x","overflow-y"],overscroll:["overscroll-x","overscroll-y"],inset:["inset-x","inset-y","start","end","top","right","bottom","left"],"inset-x":["right","left"],"inset-y":["top","bottom"],flex:["basis","grow","shrink"],gap:["gap-x","gap-y"],p:["px","py","ps","pe","pt","pr","pb","pl"],px:["pr","pl"],py:["pt","pb"],m:["mx","my","ms","me","mt","mr","mb","ml"],mx:["mr","ml"],my:["mt","mb"],size:["w","h"],"font-size":["leading"],"fvn-normal":["fvn-ordinal","fvn-slashed-zero","fvn-figure","fvn-spacing","fvn-fraction"],"fvn-ordinal":["fvn-normal"],"fvn-slashed-zero":["fvn-normal"],"fvn-figure":["fvn-normal"],"fvn-spacing":["fvn-normal"],"fvn-fraction":["fvn-normal"],"line-clamp":["display","overflow"],rounded:["rounded-s","rounded-e","rounded-t","rounded-r","rounded-b","rounded-l","rounded-ss","rounded-se","rounded-ee","rounded-es","rounded-tl","rounded-tr","rounded-br","rounded-bl"],"rounded-s":["rounded-ss","rounded-es"],"rounded-e":["rounded-se","rounded-ee"],"rounded-t":["rounded-tl","rounded-tr"],"rounded-r":["rounded-tr","rounded-br"],"rounded-b":["rounded-br","rounded-bl"],"rounded-l":["rounded-tl","rounded-bl"],"border-spacing":["border-spacing-x","border-spacing-y"],"border-w":["border-w-s","border-w-e","border-w-t","border-w-r","border-w-b","border-w-l"],"border-w-x":["border-w-r","border-w-l"],"border-w-y":["border-w-t","border-w-b"],"border-color":["border-color-t","border-color-r","border-color-b","border-color-l"],"border-color-x":["border-color-r","border-color-l"],"border-color-y":["border-color-t","border-color-b"],"scroll-m":["scroll-mx","scroll-my","scroll-ms","scroll-me","scroll-mt","scroll-mr","scroll-mb","scroll-ml"],"scroll-mx":["scroll-mr","scroll-ml"],"scroll-my":["scroll-mt","scroll-mb"],"scroll-p":["scroll-px","scroll-py","scroll-ps","scroll-pe","scroll-pt","scroll-pr","scroll-pb","scroll-pl"],"scroll-px":["scroll-pr","scroll-pl"],"scroll-py":["scroll-pt","scroll-pb"],touch:["touch-x","touch-y","touch-pz"],"touch-x":["touch"],"touch-y":["touch"],"touch-pz":["touch"]},conflictingClassGroupModifiers:{"font-size":["leading"]}}}const S3=r3(w3);function ge(...e){return S3(oo(e))}const C3=ig("inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",{variants:{variant:{default:"bg-primary text-primary-foreground hover:bg-primary/90",destructive:"bg-destructive text-destructive-foreground hover:bg-destructive/90",outline:"border border-input bg-background hover:bg-accent hover:text-accent-foreground",secondary:"bg-secondary text-secondary-foreground hover:bg-secondary/80",warning:"bg-amber-600 shadow-sm hover:bg-amber-600/90 data-active:bg-amber-600/90 text-foreground",ghost:"hover:bg-accent hover:text-accent-foreground",link:"text-primary underline-offset-4 hover:underline"},size:{default:"h-10 px-4 py-2",sm:"h-9 rounded-md px-3",lg:"h-11 rounded-md px-8",icon:"h-10 w-10"}},defaultVariants:{variant:"default",size:"default"}}),q=v.forwardRef(({className:e,variant:t,size:n,asChild:r=!1,...s},o)=>{const a=r?mo:"button";return u.jsx(a,{className:ge(C3({variant:t,size:n,className:e})),ref:o,...s})});q.displayName="Button";function Ax(){const{t:e}=ze(),t=Fs(rs.API_URL),{data:n}=L4({url:t}),r=v.useMemo(()=>n==null?void 0:n.clientName,[n]),s=v.useMemo(()=>n==null?void 0:n.version,[n]),o=[{name:"Discord",url:"https://evolution-api.com/discord"},{name:"Postman",url:"https://evolution-api.com/postman"},{name:"GitHub",url:"https://github.com/EvolutionAPI/evolution-api"},{name:"Docs",url:"https://doc.evolution-api.com"}];return u.jsxs("footer",{className:"flex w-full flex-col items-center justify-between p-6 text-xs text-secondary-foreground sm:flex-row",children:[u.jsxs("div",{className:"flex items-center space-x-3 divide-x",children:[r&&r!==""&&u.jsxs("span",{children:[e("footer.clientName"),": ",u.jsx("strong",{children:r})]}),s&&s!==""&&u.jsxs("span",{className:"pl-3",children:[e("footer.version"),": ",u.jsx("strong",{children:s})]})]}),u.jsx("div",{className:"flex gap-2",children:o.map(a=>u.jsx(q,{variant:"link",asChild:!0,size:"sm",className:"text-xs",children:u.jsx("a",{href:a.url,target:"_blank",rel:"noopener noreferrer",children:a.name})},a.url))})]})}/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const E3=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),uj=(...e)=>e.filter((t,n,r)=>!!t&&r.indexOf(t)===n).join(" ");/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var T3={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const k3=v.forwardRef(({color:e="currentColor",size:t=24,strokeWidth:n=2,absoluteStrokeWidth:r,className:s="",children:o,iconNode:a,...l},c)=>v.createElement("svg",{ref:c,...T3,width:t,height:t,stroke:e,strokeWidth:r?Number(n)*24/Number(t):n,className:uj("lucide",s),...l},[...a.map(([i,d])=>v.createElement(i,d)),...Array.isArray(o)?o:[o]]));/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Xe=(e,t)=>{const n=v.forwardRef(({className:r,...s},o)=>v.createElement(k3,{ref:o,iconNode:t,className:uj(`lucide-${E3(e)}`,r),...s}));return n.displayName=`${e}`,n};/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _3=Xe("ArrowUpDown",[["path",{d:"m21 16-4 4-4-4",key:"f6ql7i"}],["path",{d:"M17 20V4",key:"1ejh1v"}],["path",{d:"m3 8 4-4 4 4",key:"11wl7u"}],["path",{d:"M7 4v16",key:"1glfcx"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const j3=Xe("ArrowUp",[["path",{d:"m5 12 7-7 7 7",key:"hav0vg"}],["path",{d:"M12 19V5",key:"x0mq9r"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cj=Xe("Check",[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lg=Xe("ChevronDown",[["path",{d:"m6 9 6 6 6-6",key:"qrunsl"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const R3=Xe("ChevronRight",[["path",{d:"m9 18 6-6-6-6",key:"mthhwq"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const P3=Xe("ChevronUp",[["path",{d:"m18 15-6-6-6 6",key:"153udz"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const M3=Xe("ChevronsUpDown",[["path",{d:"m7 15 5 5 5-5",key:"1hf1tw"}],["path",{d:"m7 9 5-5 5 5",key:"sgt6xg"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const O3=Xe("CircleHelp",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3",key:"1u773s"}],["path",{d:"M12 17h.01",key:"p32p05"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ud=Xe("CircleStop",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["rect",{width:"6",height:"6",x:"9",y:"9",key:"1wrtvo"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const dj=Xe("CircleUser",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["circle",{cx:"12",cy:"10",r:"3",key:"ilqhr7"}],["path",{d:"M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662",key:"154egf"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const N3=Xe("Circle",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Oi=Xe("Cog",[["path",{d:"M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z",key:"sobvz5"}],["path",{d:"M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z",key:"11i496"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M12 22v-2",key:"1osdcq"}],["path",{d:"m17 20.66-1-1.73",key:"eq3orb"}],["path",{d:"M11 10.27 7 3.34",key:"16pf9h"}],["path",{d:"m20.66 17-1.73-1",key:"sg0v6f"}],["path",{d:"m3.34 7 1.73 1",key:"1ulond"}],["path",{d:"M14 12h8",key:"4f43i9"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"m20.66 7-1.73 1",key:"1ow05n"}],["path",{d:"m3.34 17 1.73-1",key:"nuk764"}],["path",{d:"m17 3.34-1 1.73",key:"2wel8s"}],["path",{d:"m11 13.73-4 6.93",key:"794ttg"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const I3=Xe("Copy",[["rect",{width:"14",height:"14",x:"8",y:"8",rx:"2",ry:"2",key:"17jyea"}],["path",{d:"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",key:"zix9uf"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Vd=Xe("Delete",[["path",{d:"M10 5a2 2 0 0 0-1.344.519l-6.328 5.74a1 1 0 0 0 0 1.481l6.328 5.741A2 2 0 0 0 10 19h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2z",key:"1yo7s0"}],["path",{d:"m12 9 6 6",key:"anjzzh"}],["path",{d:"m18 9-6 6",key:"1fp51s"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const D3=Xe("DoorOpen",[["path",{d:"M13 4h3a2 2 0 0 1 2 2v14",key:"hrm0s9"}],["path",{d:"M2 20h3",key:"1gaodv"}],["path",{d:"M13 20h9",key:"s90cdi"}],["path",{d:"M10 12v.01",key:"vx6srw"}],["path",{d:"M13 4.562v16.157a1 1 0 0 1-1.242.97L5 20V5.562a2 2 0 0 1 1.515-1.94l4-1A2 2 0 0 1 13 4.561Z",key:"199qr4"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vu=Xe("Ellipsis",[["circle",{cx:"12",cy:"12",r:"1",key:"41hilf"}],["circle",{cx:"19",cy:"12",r:"1",key:"1wjl8i"}],["circle",{cx:"5",cy:"12",r:"1",key:"1pcz8c"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const A3=Xe("EyeOff",[["path",{d:"M9.88 9.88a3 3 0 1 0 4.24 4.24",key:"1jxqfv"}],["path",{d:"M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68",key:"9wicm4"}],["path",{d:"M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61",key:"1jreej"}],["line",{x1:"2",x2:"22",y1:"2",y2:"22",key:"a6p6uj"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const F3=Xe("Eye",[["path",{d:"M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z",key:"rwhkz3"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const L3=Xe("FileQuestion",[["path",{d:"M12 17h.01",key:"p32p05"}],["path",{d:"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z",key:"1mlx9k"}],["path",{d:"M9.1 9a3 3 0 0 1 5.82 1c0 2-3 3-3 3",key:"mhlwft"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $3=Xe("GripVertical",[["circle",{cx:"9",cy:"12",r:"1",key:"1vctgf"}],["circle",{cx:"9",cy:"5",r:"1",key:"hp0tcf"}],["circle",{cx:"9",cy:"19",r:"1",key:"fkjjf6"}],["circle",{cx:"15",cy:"12",r:"1",key:"1tmaij"}],["circle",{cx:"15",cy:"5",r:"1",key:"19l28e"}],["circle",{cx:"15",cy:"19",r:"1",key:"f4zoj3"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const B3=Xe("IterationCcw",[["path",{d:"M20 10c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8h8",key:"4znkd0"}],["polyline",{points:"16 14 20 18 16 22",key:"11njsm"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const z3=Xe("Languages",[["path",{d:"m5 8 6 6",key:"1wu5hv"}],["path",{d:"m4 14 6-6 2-3",key:"1k1g8d"}],["path",{d:"M2 5h12",key:"or177f"}],["path",{d:"M7 2h1",key:"1t2jsx"}],["path",{d:"m22 22-5-10-5 10",key:"don7ne"}],["path",{d:"M14 18h6",key:"1m8k6r"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const U3=Xe("LayoutDashboard",[["rect",{width:"7",height:"9",x:"3",y:"3",rx:"1",key:"10lvy0"}],["rect",{width:"7",height:"5",x:"14",y:"3",rx:"1",key:"16une8"}],["rect",{width:"7",height:"9",x:"14",y:"12",rx:"1",key:"1hutg5"}],["rect",{width:"7",height:"5",x:"3",y:"16",rx:"1",key:"ldoo1y"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const V3=Xe("LifeBuoy",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m4.93 4.93 4.24 4.24",key:"1ymg45"}],["path",{d:"m14.83 9.17 4.24-4.24",key:"1cb5xl"}],["path",{d:"m14.83 14.83 4.24 4.24",key:"q42g0n"}],["path",{d:"m9.17 14.83-4.24 4.24",key:"bqpfvv"}],["circle",{cx:"12",cy:"12",r:"4",key:"4exip2"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Hd=Xe("ListCollapse",[["path",{d:"m3 10 2.5-2.5L3 5",key:"i6eama"}],["path",{d:"m3 19 2.5-2.5L3 14",key:"w2gmor"}],["path",{d:"M10 6h11",key:"c7qv1k"}],["path",{d:"M10 12h11",key:"6m4ad9"}],["path",{d:"M10 18h11",key:"11hvi2"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const H3=Xe("Lock",[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ug=Xe("MessageCircle",[["path",{d:"M7.9 20A9 9 0 1 0 4 16.1L2 22Z",key:"vv11sd"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const K3=Xe("Moon",[["path",{d:"M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z",key:"a7tn18"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const q3=Xe("Paperclip",[["path",{d:"m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l8.57-8.57A4 4 0 1 1 18 8.84l-8.59 8.57a2 2 0 0 1-2.83-2.83l8.49-8.48",key:"1u3ebp"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Kd=Xe("Pause",[["rect",{x:"14",y:"4",width:"4",height:"16",rx:"1",key:"zuxfzm"}],["rect",{x:"6",y:"4",width:"4",height:"16",rx:"1",key:"1okwgv"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qd=Xe("Play",[["polygon",{points:"6 3 20 12 6 21 6 3",key:"1oa8hb"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ni=Xe("Plus",[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"M12 5v14",key:"s699le"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fj=Xe("RefreshCw",[["path",{d:"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",key:"v9h5vc"}],["path",{d:"M21 3v5h-5",key:"1q7to0"}],["path",{d:"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",key:"3uifl3"}],["path",{d:"M8 16H3v5",key:"1cv678"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Wd=Xe("RotateCcw",[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const W3=Xe("Sparkle",[["path",{d:"M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",key:"4pj2yx"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const G3=Xe("Sun",[["circle",{cx:"12",cy:"12",r:"4",key:"4exip2"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"m4.93 4.93 1.41 1.41",key:"149t6j"}],["path",{d:"m17.66 17.66 1.41 1.41",key:"ptbguv"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"m6.34 17.66-1.41 1.41",key:"1m8zz5"}],["path",{d:"m19.07 4.93-1.41 1.41",key:"1shlcs"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const J3=Xe("UsersRound",[["path",{d:"M18 21a8 8 0 0 0-16 0",key:"3ypg7q"}],["circle",{cx:"10",cy:"8",r:"5",key:"o932ke"}],["path",{d:"M22 20c0-3.37-2-6.5-4-8a5 5 0 0 0-.45-8.3",key:"10s06x"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Q3=Xe("X",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]);/**
 * @license lucide-react v0.408.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const pj=Xe("Zap",[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]]),he=zt.create({timeout:3e4});he.interceptors.request.use(async e=>{const t=Fs(rs.API_URL);if(t&&(e.baseURL=t.toString()),!e.headers.apiKey||e.headers.apiKey===""){const n=Fs(rs.TOKEN);n&&(e.headers.apikey=`${n}`)}return e},e=>Promise.reject(e));const Z3=e=>["instance","fetchInstance",JSON.stringify(e)],Y3=async({instanceId:e})=>{const t=await he.get("/instance/fetchInstances",{params:{instanceId:e}});return Array.isArray(t.data)?t.data[0]:t.data},hj=e=>{const{instanceId:t,...n}=e;return lt({...n,queryKey:Z3({instanceId:t}),queryFn:()=>Y3({instanceId:t}),enabled:!!t})};function Se(e,t,{checkForDefaultPrevented:n=!0}={}){return function(s){if(e==null||e(s),n===!1||!s.defaultPrevented)return t==null?void 0:t(s)}}function X3(e,t){const n=v.createContext(t);function r(o){const{children:a,...l}=o,c=v.useMemo(()=>l,Object.values(l));return u.jsx(n.Provider,{value:c,children:a})}function s(o){const a=v.useContext(n);if(a)return a;if(t!==void 0)return t;throw new Error(`\`${o}\` must be used within \`${e}\``)}return r.displayName=e+"Provider",[r,s]}function Vr(e,t=[]){let n=[];function r(o,a){const l=v.createContext(a),c=n.length;n=[...n,a];function i(p){const{scope:f,children:h,...g}=p,m=(f==null?void 0:f[e][c])||l,x=v.useMemo(()=>g,Object.values(g));return u.jsx(m.Provider,{value:x,children:h})}function d(p,f){const h=(f==null?void 0:f[e][c])||l,g=v.useContext(h);if(g)return g;if(a!==void 0)return a;throw new Error(`\`${p}\` must be used within \`${o}\``)}return i.displayName=o+"Provider",[i,d]}const s=()=>{const o=n.map(a=>v.createContext(a));return function(l){const c=(l==null?void 0:l[e])||o;return v.useMemo(()=>({[`__scope${e}`]:{...l,[e]:c}}),[l,c])}};return s.scopeName=e,[r,eB(s,...t)]}function eB(...e){const t=e[0];if(e.length===1)return t;const n=()=>{const r=e.map(s=>({useScope:s(),scopeName:s.scopeName}));return function(o){const a=r.reduce((l,{useScope:c,scopeName:i})=>{const p=c(o)[`__scope${i}`];return{...l,...p}},{});return v.useMemo(()=>({[`__scope${t.scopeName}`]:a}),[a])}};return n.scopeName=t.scopeName,n}function nn(e){const t=v.useRef(e);return v.useEffect(()=>{t.current=e}),v.useMemo(()=>(...n)=>{var r;return(r=t.current)==null?void 0:r.call(t,...n)},[])}function pa({prop:e,defaultProp:t,onChange:n=()=>{}}){const[r,s]=tB({defaultProp:t,onChange:n}),o=e!==void 0,a=o?e:r,l=nn(n),c=v.useCallback(i=>{if(o){const p=typeof i=="function"?i(e):i;p!==e&&l(p)}else s(i)},[o,e,s,l]);return[a,c]}function tB({defaultProp:e,onChange:t}){const n=v.useState(e),[r]=n,s=v.useRef(r),o=nn(t);return v.useEffect(()=>{s.current!==r&&(o(r),s.current=r)},[r,s,o]),n}var nB=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Ne=nB.reduce((e,t)=>{const n=v.forwardRef((r,s)=>{const{asChild:o,...a}=r,l=o?mo:t;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),u.jsx(l,{...a,ref:s})});return n.displayName=`Primitive.${t}`,{...e,[t]:n}},{});function gj(e,t){e&&ka.flushSync(()=>e.dispatchEvent(t))}function Fx(e){const t=e+"CollectionProvider",[n,r]=Vr(t),[s,o]=n(t,{collectionRef:{current:null},itemMap:new Map}),a=h=>{const{scope:g,children:m}=h,x=Te.useRef(null),b=Te.useRef(new Map).current;return u.jsx(s,{scope:g,itemMap:b,collectionRef:x,children:m})};a.displayName=t;const l=e+"CollectionSlot",c=Te.forwardRef((h,g)=>{const{scope:m,children:x}=h,b=o(l,m),y=it(g,b.collectionRef);return u.jsx(mo,{ref:y,children:x})});c.displayName=l;const i=e+"CollectionItemSlot",d="data-radix-collection-item",p=Te.forwardRef((h,g)=>{const{scope:m,children:x,...b}=h,y=Te.useRef(null),w=it(g,y),S=o(i,m);return Te.useEffect(()=>(S.itemMap.set(y,{ref:y,...b}),()=>void S.itemMap.delete(y))),u.jsx(mo,{[d]:"",ref:w,children:x})});p.displayName=i;function f(h){const g=o(e+"CollectionConsumer",h);return Te.useCallback(()=>{const x=g.collectionRef.current;if(!x)return[];const b=Array.from(x.querySelectorAll(`[${d}]`));return Array.from(g.itemMap.values()).sort((S,E)=>b.indexOf(S.ref.current)-b.indexOf(E.ref.current))},[g.collectionRef,g.itemMap])}return[{Provider:a,Slot:c,ItemSlot:p},f,r]}var rB=v.createContext(void 0);function Gd(e){const t=v.useContext(rB);return e||t||"ltr"}function sB(e,t=globalThis==null?void 0:globalThis.document){const n=nn(e);v.useEffect(()=>{const r=s=>{s.key==="Escape"&&n(s)};return t.addEventListener("keydown",r,{capture:!0}),()=>t.removeEventListener("keydown",r,{capture:!0})},[n,t])}var oB="DismissableLayer",Ky="dismissableLayer.update",aB="dismissableLayer.pointerDownOutside",iB="dismissableLayer.focusOutside",eC,mj=v.createContext({layers:new Set,layersWithOutsidePointerEventsDisabled:new Set,branches:new Set}),cg=v.forwardRef((e,t)=>{const{disableOutsidePointerEvents:n=!1,onEscapeKeyDown:r,onPointerDownOutside:s,onFocusOutside:o,onInteractOutside:a,onDismiss:l,...c}=e,i=v.useContext(mj),[d,p]=v.useState(null),f=(d==null?void 0:d.ownerDocument)??(globalThis==null?void 0:globalThis.document),[,h]=v.useState({}),g=it(t,k=>p(k)),m=Array.from(i.layers),[x]=[...i.layersWithOutsidePointerEventsDisabled].slice(-1),b=m.indexOf(x),y=d?m.indexOf(d):-1,w=i.layersWithOutsidePointerEventsDisabled.size>0,S=y>=b,E=cB(k=>{const T=k.target,P=[...i.branches].some(N=>N.contains(T));!S||P||(s==null||s(k),a==null||a(k),k.defaultPrevented||l==null||l())},f),C=dB(k=>{const T=k.target;[...i.branches].some(N=>N.contains(T))||(o==null||o(k),a==null||a(k),k.defaultPrevented||l==null||l())},f);return sB(k=>{y===i.layers.size-1&&(r==null||r(k),!k.defaultPrevented&&l&&(k.preventDefault(),l()))},f),v.useEffect(()=>{if(d)return n&&(i.layersWithOutsidePointerEventsDisabled.size===0&&(eC=f.body.style.pointerEvents,f.body.style.pointerEvents="none"),i.layersWithOutsidePointerEventsDisabled.add(d)),i.layers.add(d),tC(),()=>{n&&i.layersWithOutsidePointerEventsDisabled.size===1&&(f.body.style.pointerEvents=eC)}},[d,f,n,i]),v.useEffect(()=>()=>{d&&(i.layers.delete(d),i.layersWithOutsidePointerEventsDisabled.delete(d),tC())},[d,i]),v.useEffect(()=>{const k=()=>h({});return document.addEventListener(Ky,k),()=>document.removeEventListener(Ky,k)},[]),u.jsx(Ne.div,{...c,ref:g,style:{pointerEvents:w?S?"auto":"none":void 0,...e.style},onFocusCapture:Se(e.onFocusCapture,C.onFocusCapture),onBlurCapture:Se(e.onBlurCapture,C.onBlurCapture),onPointerDownCapture:Se(e.onPointerDownCapture,E.onPointerDownCapture)})});cg.displayName=oB;var lB="DismissableLayerBranch",uB=v.forwardRef((e,t)=>{const n=v.useContext(mj),r=v.useRef(null),s=it(t,r);return v.useEffect(()=>{const o=r.current;if(o)return n.branches.add(o),()=>{n.branches.delete(o)}},[n.branches]),u.jsx(Ne.div,{...e,ref:s})});uB.displayName=lB;function cB(e,t=globalThis==null?void 0:globalThis.document){const n=nn(e),r=v.useRef(!1),s=v.useRef(()=>{});return v.useEffect(()=>{const o=l=>{if(l.target&&!r.current){let c=function(){vj(aB,n,i,{discrete:!0})};const i={originalEvent:l};l.pointerType==="touch"?(t.removeEventListener("click",s.current),s.current=c,t.addEventListener("click",s.current,{once:!0})):c()}else t.removeEventListener("click",s.current);r.current=!1},a=window.setTimeout(()=>{t.addEventListener("pointerdown",o)},0);return()=>{window.clearTimeout(a),t.removeEventListener("pointerdown",o),t.removeEventListener("click",s.current)}},[t,n]),{onPointerDownCapture:()=>r.current=!0}}function dB(e,t=globalThis==null?void 0:globalThis.document){const n=nn(e),r=v.useRef(!1);return v.useEffect(()=>{const s=o=>{o.target&&!r.current&&vj(iB,n,{originalEvent:o},{discrete:!1})};return t.addEventListener("focusin",s),()=>t.removeEventListener("focusin",s)},[t,n]),{onFocusCapture:()=>r.current=!0,onBlurCapture:()=>r.current=!1}}function tC(){const e=new CustomEvent(Ky);document.dispatchEvent(e)}function vj(e,t,n,{discrete:r}){const s=n.originalEvent.target,o=new CustomEvent(e,{bubbles:!1,cancelable:!0,detail:n});t&&s.addEventListener(e,t,{once:!0}),r?gj(s,o):s.dispatchEvent(o)}var zm=0;function Lx(){v.useEffect(()=>{const e=document.querySelectorAll("[data-radix-focus-guard]");return document.body.insertAdjacentElement("afterbegin",e[0]??nC()),document.body.insertAdjacentElement("beforeend",e[1]??nC()),zm++,()=>{zm===1&&document.querySelectorAll("[data-radix-focus-guard]").forEach(t=>t.remove()),zm--}},[])}function nC(){const e=document.createElement("span");return e.setAttribute("data-radix-focus-guard",""),e.tabIndex=0,e.style.cssText="outline: none; opacity: 0; position: fixed; pointer-events: none",e}var Um="focusScope.autoFocusOnMount",Vm="focusScope.autoFocusOnUnmount",rC={bubbles:!1,cancelable:!0},fB="FocusScope",dg=v.forwardRef((e,t)=>{const{loop:n=!1,trapped:r=!1,onMountAutoFocus:s,onUnmountAutoFocus:o,...a}=e,[l,c]=v.useState(null),i=nn(s),d=nn(o),p=v.useRef(null),f=it(t,m=>c(m)),h=v.useRef({paused:!1,pause(){this.paused=!0},resume(){this.paused=!1}}).current;v.useEffect(()=>{if(r){let m=function(w){if(h.paused||!l)return;const S=w.target;l.contains(S)?p.current=S:Lo(p.current,{select:!0})},x=function(w){if(h.paused||!l)return;const S=w.relatedTarget;S!==null&&(l.contains(S)||Lo(p.current,{select:!0}))},b=function(w){if(document.activeElement===document.body)for(const E of w)E.removedNodes.length>0&&Lo(l)};document.addEventListener("focusin",m),document.addEventListener("focusout",x);const y=new MutationObserver(b);return l&&y.observe(l,{childList:!0,subtree:!0}),()=>{document.removeEventListener("focusin",m),document.removeEventListener("focusout",x),y.disconnect()}}},[r,l,h.paused]),v.useEffect(()=>{if(l){oC.add(h);const m=document.activeElement;if(!l.contains(m)){const b=new CustomEvent(Um,rC);l.addEventListener(Um,i),l.dispatchEvent(b),b.defaultPrevented||(pB(yB(yj(l)),{select:!0}),document.activeElement===m&&Lo(l))}return()=>{l.removeEventListener(Um,i),setTimeout(()=>{const b=new CustomEvent(Vm,rC);l.addEventListener(Vm,d),l.dispatchEvent(b),b.defaultPrevented||Lo(m??document.body,{select:!0}),l.removeEventListener(Vm,d),oC.remove(h)},0)}}},[l,i,d,h]);const g=v.useCallback(m=>{if(!n&&!r||h.paused)return;const x=m.key==="Tab"&&!m.altKey&&!m.ctrlKey&&!m.metaKey,b=document.activeElement;if(x&&b){const y=m.currentTarget,[w,S]=hB(y);w&&S?!m.shiftKey&&b===S?(m.preventDefault(),n&&Lo(w,{select:!0})):m.shiftKey&&b===w&&(m.preventDefault(),n&&Lo(S,{select:!0})):b===y&&m.preventDefault()}},[n,r,h.paused]);return u.jsx(Ne.div,{tabIndex:-1,...a,ref:f,onKeyDown:g})});dg.displayName=fB;function pB(e,{select:t=!1}={}){const n=document.activeElement;for(const r of e)if(Lo(r,{select:t}),document.activeElement!==n)return}function hB(e){const t=yj(e),n=sC(t,e),r=sC(t.reverse(),e);return[n,r]}function yj(e){const t=[],n=document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,{acceptNode:r=>{const s=r.tagName==="INPUT"&&r.type==="hidden";return r.disabled||r.hidden||s?NodeFilter.FILTER_SKIP:r.tabIndex>=0?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP}});for(;n.nextNode();)t.push(n.currentNode);return t}function sC(e,t){for(const n of e)if(!gB(n,{upTo:t}))return n}function gB(e,{upTo:t}){if(getComputedStyle(e).visibility==="hidden")return!0;for(;e;){if(t!==void 0&&e===t)return!1;if(getComputedStyle(e).display==="none")return!0;e=e.parentElement}return!1}function mB(e){return e instanceof HTMLInputElement&&"select"in e}function Lo(e,{select:t=!1}={}){if(e&&e.focus){const n=document.activeElement;e.focus({preventScroll:!0}),e!==n&&mB(e)&&t&&e.select()}}var oC=vB();function vB(){let e=[];return{add(t){const n=e[0];t!==n&&(n==null||n.pause()),e=aC(e,t),e.unshift(t)},remove(t){var n;e=aC(e,t),(n=e[0])==null||n.resume()}}}function aC(e,t){const n=[...e],r=n.indexOf(t);return r!==-1&&n.splice(r,1),n}function yB(e){return e.filter(t=>t.tagName!=="A")}var fn=globalThis!=null&&globalThis.document?v.useLayoutEffect:()=>{},bB=Nh.useId||(()=>{}),xB=0;function os(e){const[t,n]=v.useState(bB());return fn(()=>{n(r=>r??String(xB++))},[e]),t?`radix-${t}`:""}const wB=["top","right","bottom","left"],Ms=Math.min,pr=Math.max,nh=Math.round,Mf=Math.floor,ha=e=>({x:e,y:e}),SB={left:"right",right:"left",bottom:"top",top:"bottom"},CB={start:"end",end:"start"};function qy(e,t,n){return pr(e,Ms(t,n))}function vo(e,t){return typeof e=="function"?e(t):e}function yo(e){return e.split("-")[0]}function yu(e){return e.split("-")[1]}function $x(e){return e==="x"?"y":"x"}function Bx(e){return e==="y"?"height":"width"}function ga(e){return["top","bottom"].includes(yo(e))?"y":"x"}function zx(e){return $x(ga(e))}function EB(e,t,n){n===void 0&&(n=!1);const r=yu(e),s=zx(e),o=Bx(s);let a=s==="x"?r===(n?"end":"start")?"right":"left":r==="start"?"bottom":"top";return t.reference[o]>t.floating[o]&&(a=rh(a)),[a,rh(a)]}function TB(e){const t=rh(e);return[Wy(e),t,Wy(t)]}function Wy(e){return e.replace(/start|end/g,t=>CB[t])}function kB(e,t,n){const r=["left","right"],s=["right","left"],o=["top","bottom"],a=["bottom","top"];switch(e){case"top":case"bottom":return n?t?s:r:t?r:s;case"left":case"right":return t?o:a;default:return[]}}function _B(e,t,n,r){const s=yu(e);let o=kB(yo(e),n==="start",r);return s&&(o=o.map(a=>a+"-"+s),t&&(o=o.concat(o.map(Wy)))),o}function rh(e){return e.replace(/left|right|bottom|top/g,t=>SB[t])}function jB(e){return{top:0,right:0,bottom:0,left:0,...e}}function bj(e){return typeof e!="number"?jB(e):{top:e,right:e,bottom:e,left:e}}function sh(e){const{x:t,y:n,width:r,height:s}=e;return{width:r,height:s,top:n,left:t,right:t+r,bottom:n+s,x:t,y:n}}function iC(e,t,n){let{reference:r,floating:s}=e;const o=ga(t),a=zx(t),l=Bx(a),c=yo(t),i=o==="y",d=r.x+r.width/2-s.width/2,p=r.y+r.height/2-s.height/2,f=r[l]/2-s[l]/2;let h;switch(c){case"top":h={x:d,y:r.y-s.height};break;case"bottom":h={x:d,y:r.y+r.height};break;case"right":h={x:r.x+r.width,y:p};break;case"left":h={x:r.x-s.width,y:p};break;default:h={x:r.x,y:r.y}}switch(yu(t)){case"start":h[a]-=f*(n&&i?-1:1);break;case"end":h[a]+=f*(n&&i?-1:1);break}return h}const RB=async(e,t,n)=>{const{placement:r="bottom",strategy:s="absolute",middleware:o=[],platform:a}=n,l=o.filter(Boolean),c=await(a.isRTL==null?void 0:a.isRTL(t));let i=await a.getElementRects({reference:e,floating:t,strategy:s}),{x:d,y:p}=iC(i,r,c),f=r,h={},g=0;for(let m=0;m<l.length;m++){const{name:x,fn:b}=l[m],{x:y,y:w,data:S,reset:E}=await b({x:d,y:p,initialPlacement:r,placement:f,strategy:s,middlewareData:h,rects:i,platform:a,elements:{reference:e,floating:t}});d=y??d,p=w??p,h={...h,[x]:{...h[x],...S}},E&&g<=50&&(g++,typeof E=="object"&&(E.placement&&(f=E.placement),E.rects&&(i=E.rects===!0?await a.getElementRects({reference:e,floating:t,strategy:s}):E.rects),{x:d,y:p}=iC(i,f,c)),m=-1)}return{x:d,y:p,placement:f,strategy:s,middlewareData:h}};async function ad(e,t){var n;t===void 0&&(t={});const{x:r,y:s,platform:o,rects:a,elements:l,strategy:c}=e,{boundary:i="clippingAncestors",rootBoundary:d="viewport",elementContext:p="floating",altBoundary:f=!1,padding:h=0}=vo(t,e),g=bj(h),x=l[f?p==="floating"?"reference":"floating":p],b=sh(await o.getClippingRect({element:(n=await(o.isElement==null?void 0:o.isElement(x)))==null||n?x:x.contextElement||await(o.getDocumentElement==null?void 0:o.getDocumentElement(l.floating)),boundary:i,rootBoundary:d,strategy:c})),y=p==="floating"?{x:r,y:s,width:a.floating.width,height:a.floating.height}:a.reference,w=await(o.getOffsetParent==null?void 0:o.getOffsetParent(l.floating)),S=await(o.isElement==null?void 0:o.isElement(w))?await(o.getScale==null?void 0:o.getScale(w))||{x:1,y:1}:{x:1,y:1},E=sh(o.convertOffsetParentRelativeRectToViewportRelativeRect?await o.convertOffsetParentRelativeRectToViewportRelativeRect({elements:l,rect:y,offsetParent:w,strategy:c}):y);return{top:(b.top-E.top+g.top)/S.y,bottom:(E.bottom-b.bottom+g.bottom)/S.y,left:(b.left-E.left+g.left)/S.x,right:(E.right-b.right+g.right)/S.x}}const PB=e=>({name:"arrow",options:e,async fn(t){const{x:n,y:r,placement:s,rects:o,platform:a,elements:l,middlewareData:c}=t,{element:i,padding:d=0}=vo(e,t)||{};if(i==null)return{};const p=bj(d),f={x:n,y:r},h=zx(s),g=Bx(h),m=await a.getDimensions(i),x=h==="y",b=x?"top":"left",y=x?"bottom":"right",w=x?"clientHeight":"clientWidth",S=o.reference[g]+o.reference[h]-f[h]-o.floating[g],E=f[h]-o.reference[h],C=await(a.getOffsetParent==null?void 0:a.getOffsetParent(i));let k=C?C[w]:0;(!k||!await(a.isElement==null?void 0:a.isElement(C)))&&(k=l.floating[w]||o.floating[g]);const T=S/2-E/2,P=k/2-m[g]/2-1,N=Ms(p[b],P),U=Ms(p[y],P),I=N,Z=k-m[g]-U,V=k/2-m[g]/2+T,Q=qy(I,V,Z),ee=!c.arrow&&yu(s)!=null&&V!==Q&&o.reference[g]/2-(V<I?N:U)-m[g]/2<0,W=ee?V<I?V-I:V-Z:0;return{[h]:f[h]+W,data:{[h]:Q,centerOffset:V-Q-W,...ee&&{alignmentOffset:W}},reset:ee}}}),MB=function(e){return e===void 0&&(e={}),{name:"flip",options:e,async fn(t){var n,r;const{placement:s,middlewareData:o,rects:a,initialPlacement:l,platform:c,elements:i}=t,{mainAxis:d=!0,crossAxis:p=!0,fallbackPlacements:f,fallbackStrategy:h="bestFit",fallbackAxisSideDirection:g="none",flipAlignment:m=!0,...x}=vo(e,t);if((n=o.arrow)!=null&&n.alignmentOffset)return{};const b=yo(s),y=ga(l),w=yo(l)===l,S=await(c.isRTL==null?void 0:c.isRTL(i.floating)),E=f||(w||!m?[rh(l)]:TB(l)),C=g!=="none";!f&&C&&E.push(..._B(l,m,g,S));const k=[l,...E],T=await ad(t,x),P=[];let N=((r=o.flip)==null?void 0:r.overflows)||[];if(d&&P.push(T[b]),p){const V=EB(s,a,S);P.push(T[V[0]],T[V[1]])}if(N=[...N,{placement:s,overflows:P}],!P.every(V=>V<=0)){var U,I;const V=(((U=o.flip)==null?void 0:U.index)||0)+1,Q=k[V];if(Q)return{data:{index:V,overflows:N},reset:{placement:Q}};let ee=(I=N.filter(W=>W.overflows[0]<=0).sort((W,F)=>W.overflows[1]-F.overflows[1])[0])==null?void 0:I.placement;if(!ee)switch(h){case"bestFit":{var Z;const W=(Z=N.filter(F=>{if(C){const A=ga(F.placement);return A===y||A==="y"}return!0}).map(F=>[F.placement,F.overflows.filter(A=>A>0).reduce((A,Y)=>A+Y,0)]).sort((F,A)=>F[1]-A[1])[0])==null?void 0:Z[0];W&&(ee=W);break}case"initialPlacement":ee=l;break}if(s!==ee)return{reset:{placement:ee}}}return{}}}};function lC(e,t){return{top:e.top-t.height,right:e.right-t.width,bottom:e.bottom-t.height,left:e.left-t.width}}function uC(e){return wB.some(t=>e[t]>=0)}const OB=function(e){return e===void 0&&(e={}),{name:"hide",options:e,async fn(t){const{rects:n}=t,{strategy:r="referenceHidden",...s}=vo(e,t);switch(r){case"referenceHidden":{const o=await ad(t,{...s,elementContext:"reference"}),a=lC(o,n.reference);return{data:{referenceHiddenOffsets:a,referenceHidden:uC(a)}}}case"escaped":{const o=await ad(t,{...s,altBoundary:!0}),a=lC(o,n.floating);return{data:{escapedOffsets:a,escaped:uC(a)}}}default:return{}}}}};async function NB(e,t){const{placement:n,platform:r,elements:s}=e,o=await(r.isRTL==null?void 0:r.isRTL(s.floating)),a=yo(n),l=yu(n),c=ga(n)==="y",i=["left","top"].includes(a)?-1:1,d=o&&c?-1:1,p=vo(t,e);let{mainAxis:f,crossAxis:h,alignmentAxis:g}=typeof p=="number"?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...p};return l&&typeof g=="number"&&(h=l==="end"?g*-1:g),c?{x:h*d,y:f*i}:{x:f*i,y:h*d}}const IB=function(e){return e===void 0&&(e=0),{name:"offset",options:e,async fn(t){var n,r;const{x:s,y:o,placement:a,middlewareData:l}=t,c=await NB(t,e);return a===((n=l.offset)==null?void 0:n.placement)&&(r=l.arrow)!=null&&r.alignmentOffset?{}:{x:s+c.x,y:o+c.y,data:{...c,placement:a}}}}},DB=function(e){return e===void 0&&(e={}),{name:"shift",options:e,async fn(t){const{x:n,y:r,placement:s}=t,{mainAxis:o=!0,crossAxis:a=!1,limiter:l={fn:x=>{let{x:b,y}=x;return{x:b,y}}},...c}=vo(e,t),i={x:n,y:r},d=await ad(t,c),p=ga(yo(s)),f=$x(p);let h=i[f],g=i[p];if(o){const x=f==="y"?"top":"left",b=f==="y"?"bottom":"right",y=h+d[x],w=h-d[b];h=qy(y,h,w)}if(a){const x=p==="y"?"top":"left",b=p==="y"?"bottom":"right",y=g+d[x],w=g-d[b];g=qy(y,g,w)}const m=l.fn({...t,[f]:h,[p]:g});return{...m,data:{x:m.x-n,y:m.y-r}}}}},AB=function(e){return e===void 0&&(e={}),{options:e,fn(t){const{x:n,y:r,placement:s,rects:o,middlewareData:a}=t,{offset:l=0,mainAxis:c=!0,crossAxis:i=!0}=vo(e,t),d={x:n,y:r},p=ga(s),f=$x(p);let h=d[f],g=d[p];const m=vo(l,t),x=typeof m=="number"?{mainAxis:m,crossAxis:0}:{mainAxis:0,crossAxis:0,...m};if(c){const w=f==="y"?"height":"width",S=o.reference[f]-o.floating[w]+x.mainAxis,E=o.reference[f]+o.reference[w]-x.mainAxis;h<S?h=S:h>E&&(h=E)}if(i){var b,y;const w=f==="y"?"width":"height",S=["top","left"].includes(yo(s)),E=o.reference[p]-o.floating[w]+(S&&((b=a.offset)==null?void 0:b[p])||0)+(S?0:x.crossAxis),C=o.reference[p]+o.reference[w]+(S?0:((y=a.offset)==null?void 0:y[p])||0)-(S?x.crossAxis:0);g<E?g=E:g>C&&(g=C)}return{[f]:h,[p]:g}}}},FB=function(e){return e===void 0&&(e={}),{name:"size",options:e,async fn(t){const{placement:n,rects:r,platform:s,elements:o}=t,{apply:a=()=>{},...l}=vo(e,t),c=await ad(t,l),i=yo(n),d=yu(n),p=ga(n)==="y",{width:f,height:h}=r.floating;let g,m;i==="top"||i==="bottom"?(g=i,m=d===(await(s.isRTL==null?void 0:s.isRTL(o.floating))?"start":"end")?"left":"right"):(m=i,g=d==="end"?"top":"bottom");const x=h-c.top-c.bottom,b=f-c.left-c.right,y=Ms(h-c[g],x),w=Ms(f-c[m],b),S=!t.middlewareData.shift;let E=y,C=w;if(p?C=d||S?Ms(w,b):b:E=d||S?Ms(y,x):x,S&&!d){const T=pr(c.left,0),P=pr(c.right,0),N=pr(c.top,0),U=pr(c.bottom,0);p?C=f-2*(T!==0||P!==0?T+P:pr(c.left,c.right)):E=h-2*(N!==0||U!==0?N+U:pr(c.top,c.bottom))}await a({...t,availableWidth:C,availableHeight:E});const k=await s.getDimensions(o.floating);return f!==k.width||h!==k.height?{reset:{rects:!0}}:{}}}};function bu(e){return xj(e)?(e.nodeName||"").toLowerCase():"#document"}function vr(e){var t;return(e==null||(t=e.ownerDocument)==null?void 0:t.defaultView)||window}function Co(e){var t;return(t=(xj(e)?e.ownerDocument:e.document)||window.document)==null?void 0:t.documentElement}function xj(e){return e instanceof Node||e instanceof vr(e).Node}function $s(e){return e instanceof Element||e instanceof vr(e).Element}function Bs(e){return e instanceof HTMLElement||e instanceof vr(e).HTMLElement}function cC(e){return typeof ShadowRoot>"u"?!1:e instanceof ShadowRoot||e instanceof vr(e).ShadowRoot}function Jd(e){const{overflow:t,overflowX:n,overflowY:r,display:s}=cs(e);return/auto|scroll|overlay|hidden|clip/.test(t+r+n)&&!["inline","contents"].includes(s)}function LB(e){return["table","td","th"].includes(bu(e))}function fg(e){return[":popover-open",":modal"].some(t=>{try{return e.matches(t)}catch{return!1}})}function Ux(e){const t=Vx(),n=cs(e);return n.transform!=="none"||n.perspective!=="none"||(n.containerType?n.containerType!=="normal":!1)||!t&&(n.backdropFilter?n.backdropFilter!=="none":!1)||!t&&(n.filter?n.filter!=="none":!1)||["transform","perspective","filter"].some(r=>(n.willChange||"").includes(r))||["paint","layout","strict","content"].some(r=>(n.contain||"").includes(r))}function $B(e){let t=ma(e);for(;Bs(t)&&!eu(t);){if(fg(t))return null;if(Ux(t))return t;t=ma(t)}return null}function Vx(){return typeof CSS>"u"||!CSS.supports?!1:CSS.supports("-webkit-backdrop-filter","none")}function eu(e){return["html","body","#document"].includes(bu(e))}function cs(e){return vr(e).getComputedStyle(e)}function pg(e){return $s(e)?{scrollLeft:e.scrollLeft,scrollTop:e.scrollTop}:{scrollLeft:e.scrollX,scrollTop:e.scrollY}}function ma(e){if(bu(e)==="html")return e;const t=e.assignedSlot||e.parentNode||cC(e)&&e.host||Co(e);return cC(t)?t.host:t}function wj(e){const t=ma(e);return eu(t)?e.ownerDocument?e.ownerDocument.body:e.body:Bs(t)&&Jd(t)?t:wj(t)}function id(e,t,n){var r;t===void 0&&(t=[]),n===void 0&&(n=!0);const s=wj(e),o=s===((r=e.ownerDocument)==null?void 0:r.body),a=vr(s);return o?t.concat(a,a.visualViewport||[],Jd(s)?s:[],a.frameElement&&n?id(a.frameElement):[]):t.concat(s,id(s,[],n))}function Sj(e){const t=cs(e);let n=parseFloat(t.width)||0,r=parseFloat(t.height)||0;const s=Bs(e),o=s?e.offsetWidth:n,a=s?e.offsetHeight:r,l=nh(n)!==o||nh(r)!==a;return l&&(n=o,r=a),{width:n,height:r,$:l}}function Hx(e){return $s(e)?e:e.contextElement}function kl(e){const t=Hx(e);if(!Bs(t))return ha(1);const n=t.getBoundingClientRect(),{width:r,height:s,$:o}=Sj(t);let a=(o?nh(n.width):n.width)/r,l=(o?nh(n.height):n.height)/s;return(!a||!Number.isFinite(a))&&(a=1),(!l||!Number.isFinite(l))&&(l=1),{x:a,y:l}}const BB=ha(0);function Cj(e){const t=vr(e);return!Vx()||!t.visualViewport?BB:{x:t.visualViewport.offsetLeft,y:t.visualViewport.offsetTop}}function zB(e,t,n){return t===void 0&&(t=!1),!n||t&&n!==vr(e)?!1:t}function Ci(e,t,n,r){t===void 0&&(t=!1),n===void 0&&(n=!1);const s=e.getBoundingClientRect(),o=Hx(e);let a=ha(1);t&&(r?$s(r)&&(a=kl(r)):a=kl(e));const l=zB(o,n,r)?Cj(o):ha(0);let c=(s.left+l.x)/a.x,i=(s.top+l.y)/a.y,d=s.width/a.x,p=s.height/a.y;if(o){const f=vr(o),h=r&&$s(r)?vr(r):r;let g=f,m=g.frameElement;for(;m&&r&&h!==g;){const x=kl(m),b=m.getBoundingClientRect(),y=cs(m),w=b.left+(m.clientLeft+parseFloat(y.paddingLeft))*x.x,S=b.top+(m.clientTop+parseFloat(y.paddingTop))*x.y;c*=x.x,i*=x.y,d*=x.x,p*=x.y,c+=w,i+=S,g=vr(m),m=g.frameElement}}return sh({width:d,height:p,x:c,y:i})}function UB(e){let{elements:t,rect:n,offsetParent:r,strategy:s}=e;const o=s==="fixed",a=Co(r),l=t?fg(t.floating):!1;if(r===a||l&&o)return n;let c={scrollLeft:0,scrollTop:0},i=ha(1);const d=ha(0),p=Bs(r);if((p||!p&&!o)&&((bu(r)!=="body"||Jd(a))&&(c=pg(r)),Bs(r))){const f=Ci(r);i=kl(r),d.x=f.x+r.clientLeft,d.y=f.y+r.clientTop}return{width:n.width*i.x,height:n.height*i.y,x:n.x*i.x-c.scrollLeft*i.x+d.x,y:n.y*i.y-c.scrollTop*i.y+d.y}}function VB(e){return Array.from(e.getClientRects())}function Ej(e){return Ci(Co(e)).left+pg(e).scrollLeft}function HB(e){const t=Co(e),n=pg(e),r=e.ownerDocument.body,s=pr(t.scrollWidth,t.clientWidth,r.scrollWidth,r.clientWidth),o=pr(t.scrollHeight,t.clientHeight,r.scrollHeight,r.clientHeight);let a=-n.scrollLeft+Ej(e);const l=-n.scrollTop;return cs(r).direction==="rtl"&&(a+=pr(t.clientWidth,r.clientWidth)-s),{width:s,height:o,x:a,y:l}}function KB(e,t){const n=vr(e),r=Co(e),s=n.visualViewport;let o=r.clientWidth,a=r.clientHeight,l=0,c=0;if(s){o=s.width,a=s.height;const i=Vx();(!i||i&&t==="fixed")&&(l=s.offsetLeft,c=s.offsetTop)}return{width:o,height:a,x:l,y:c}}function qB(e,t){const n=Ci(e,!0,t==="fixed"),r=n.top+e.clientTop,s=n.left+e.clientLeft,o=Bs(e)?kl(e):ha(1),a=e.clientWidth*o.x,l=e.clientHeight*o.y,c=s*o.x,i=r*o.y;return{width:a,height:l,x:c,y:i}}function dC(e,t,n){let r;if(t==="viewport")r=KB(e,n);else if(t==="document")r=HB(Co(e));else if($s(t))r=qB(t,n);else{const s=Cj(e);r={...t,x:t.x-s.x,y:t.y-s.y}}return sh(r)}function Tj(e,t){const n=ma(e);return n===t||!$s(n)||eu(n)?!1:cs(n).position==="fixed"||Tj(n,t)}function WB(e,t){const n=t.get(e);if(n)return n;let r=id(e,[],!1).filter(l=>$s(l)&&bu(l)!=="body"),s=null;const o=cs(e).position==="fixed";let a=o?ma(e):e;for(;$s(a)&&!eu(a);){const l=cs(a),c=Ux(a);!c&&l.position==="fixed"&&(s=null),(o?!c&&!s:!c&&l.position==="static"&&!!s&&["absolute","fixed"].includes(s.position)||Jd(a)&&!c&&Tj(e,a))?r=r.filter(d=>d!==a):s=l,a=ma(a)}return t.set(e,r),r}function GB(e){let{element:t,boundary:n,rootBoundary:r,strategy:s}=e;const a=[...n==="clippingAncestors"?fg(t)?[]:WB(t,this._c):[].concat(n),r],l=a[0],c=a.reduce((i,d)=>{const p=dC(t,d,s);return i.top=pr(p.top,i.top),i.right=Ms(p.right,i.right),i.bottom=Ms(p.bottom,i.bottom),i.left=pr(p.left,i.left),i},dC(t,l,s));return{width:c.right-c.left,height:c.bottom-c.top,x:c.left,y:c.top}}function JB(e){const{width:t,height:n}=Sj(e);return{width:t,height:n}}function QB(e,t,n){const r=Bs(t),s=Co(t),o=n==="fixed",a=Ci(e,!0,o,t);let l={scrollLeft:0,scrollTop:0};const c=ha(0);if(r||!r&&!o)if((bu(t)!=="body"||Jd(s))&&(l=pg(t)),r){const p=Ci(t,!0,o,t);c.x=p.x+t.clientLeft,c.y=p.y+t.clientTop}else s&&(c.x=Ej(s));const i=a.left+l.scrollLeft-c.x,d=a.top+l.scrollTop-c.y;return{x:i,y:d,width:a.width,height:a.height}}function Hm(e){return cs(e).position==="static"}function fC(e,t){return!Bs(e)||cs(e).position==="fixed"?null:t?t(e):e.offsetParent}function kj(e,t){const n=vr(e);if(fg(e))return n;if(!Bs(e)){let s=ma(e);for(;s&&!eu(s);){if($s(s)&&!Hm(s))return s;s=ma(s)}return n}let r=fC(e,t);for(;r&&LB(r)&&Hm(r);)r=fC(r,t);return r&&eu(r)&&Hm(r)&&!Ux(r)?n:r||$B(e)||n}const ZB=async function(e){const t=this.getOffsetParent||kj,n=this.getDimensions,r=await n(e.floating);return{reference:QB(e.reference,await t(e.floating),e.strategy),floating:{x:0,y:0,width:r.width,height:r.height}}};function YB(e){return cs(e).direction==="rtl"}const XB={convertOffsetParentRelativeRectToViewportRelativeRect:UB,getDocumentElement:Co,getClippingRect:GB,getOffsetParent:kj,getElementRects:ZB,getClientRects:VB,getDimensions:JB,getScale:kl,isElement:$s,isRTL:YB};function ez(e,t){let n=null,r;const s=Co(e);function o(){var l;clearTimeout(r),(l=n)==null||l.disconnect(),n=null}function a(l,c){l===void 0&&(l=!1),c===void 0&&(c=1),o();const{left:i,top:d,width:p,height:f}=e.getBoundingClientRect();if(l||t(),!p||!f)return;const h=Mf(d),g=Mf(s.clientWidth-(i+p)),m=Mf(s.clientHeight-(d+f)),x=Mf(i),y={rootMargin:-h+"px "+-g+"px "+-m+"px "+-x+"px",threshold:pr(0,Ms(1,c))||1};let w=!0;function S(E){const C=E[0].intersectionRatio;if(C!==c){if(!w)return a();C?a(!1,C):r=setTimeout(()=>{a(!1,1e-7)},1e3)}w=!1}try{n=new IntersectionObserver(S,{...y,root:s.ownerDocument})}catch{n=new IntersectionObserver(S,y)}n.observe(e)}return a(!0),o}function tz(e,t,n,r){r===void 0&&(r={});const{ancestorScroll:s=!0,ancestorResize:o=!0,elementResize:a=typeof ResizeObserver=="function",layoutShift:l=typeof IntersectionObserver=="function",animationFrame:c=!1}=r,i=Hx(e),d=s||o?[...i?id(i):[],...id(t)]:[];d.forEach(b=>{s&&b.addEventListener("scroll",n,{passive:!0}),o&&b.addEventListener("resize",n)});const p=i&&l?ez(i,n):null;let f=-1,h=null;a&&(h=new ResizeObserver(b=>{let[y]=b;y&&y.target===i&&h&&(h.unobserve(t),cancelAnimationFrame(f),f=requestAnimationFrame(()=>{var w;(w=h)==null||w.observe(t)})),n()}),i&&!c&&h.observe(i),h.observe(t));let g,m=c?Ci(e):null;c&&x();function x(){const b=Ci(e);m&&(b.x!==m.x||b.y!==m.y||b.width!==m.width||b.height!==m.height)&&n(),m=b,g=requestAnimationFrame(x)}return n(),()=>{var b;d.forEach(y=>{s&&y.removeEventListener("scroll",n),o&&y.removeEventListener("resize",n)}),p==null||p(),(b=h)==null||b.disconnect(),h=null,c&&cancelAnimationFrame(g)}}const nz=IB,rz=DB,sz=MB,oz=FB,az=OB,pC=PB,iz=AB,lz=(e,t,n)=>{const r=new Map,s={platform:XB,...n},o={...s.platform,_c:r};return RB(e,t,{...s,platform:o})};var hp=typeof document<"u"?v.useLayoutEffect:v.useEffect;function oh(e,t){if(e===t)return!0;if(typeof e!=typeof t)return!1;if(typeof e=="function"&&e.toString()===t.toString())return!0;let n,r,s;if(e&&t&&typeof e=="object"){if(Array.isArray(e)){if(n=e.length,n!==t.length)return!1;for(r=n;r--!==0;)if(!oh(e[r],t[r]))return!1;return!0}if(s=Object.keys(e),n=s.length,n!==Object.keys(t).length)return!1;for(r=n;r--!==0;)if(!{}.hasOwnProperty.call(t,s[r]))return!1;for(r=n;r--!==0;){const o=s[r];if(!(o==="_owner"&&e.$$typeof)&&!oh(e[o],t[o]))return!1}return!0}return e!==e&&t!==t}function _j(e){return typeof window>"u"?1:(e.ownerDocument.defaultView||window).devicePixelRatio||1}function hC(e,t){const n=_j(e);return Math.round(t*n)/n}function gC(e){const t=v.useRef(e);return hp(()=>{t.current=e}),t}function uz(e){e===void 0&&(e={});const{placement:t="bottom",strategy:n="absolute",middleware:r=[],platform:s,elements:{reference:o,floating:a}={},transform:l=!0,whileElementsMounted:c,open:i}=e,[d,p]=v.useState({x:0,y:0,strategy:n,placement:t,middlewareData:{},isPositioned:!1}),[f,h]=v.useState(r);oh(f,r)||h(r);const[g,m]=v.useState(null),[x,b]=v.useState(null),y=v.useCallback(W=>{W!==C.current&&(C.current=W,m(W))},[]),w=v.useCallback(W=>{W!==k.current&&(k.current=W,b(W))},[]),S=o||g,E=a||x,C=v.useRef(null),k=v.useRef(null),T=v.useRef(d),P=c!=null,N=gC(c),U=gC(s),I=v.useCallback(()=>{if(!C.current||!k.current)return;const W={placement:t,strategy:n,middleware:f};U.current&&(W.platform=U.current),lz(C.current,k.current,W).then(F=>{const A={...F,isPositioned:!0};Z.current&&!oh(T.current,A)&&(T.current=A,ka.flushSync(()=>{p(A)}))})},[f,t,n,U]);hp(()=>{i===!1&&T.current.isPositioned&&(T.current.isPositioned=!1,p(W=>({...W,isPositioned:!1})))},[i]);const Z=v.useRef(!1);hp(()=>(Z.current=!0,()=>{Z.current=!1}),[]),hp(()=>{if(S&&(C.current=S),E&&(k.current=E),S&&E){if(N.current)return N.current(S,E,I);I()}},[S,E,I,N,P]);const V=v.useMemo(()=>({reference:C,floating:k,setReference:y,setFloating:w}),[y,w]),Q=v.useMemo(()=>({reference:S,floating:E}),[S,E]),ee=v.useMemo(()=>{const W={position:n,left:0,top:0};if(!Q.floating)return W;const F=hC(Q.floating,d.x),A=hC(Q.floating,d.y);return l?{...W,transform:"translate("+F+"px, "+A+"px)",..._j(Q.floating)>=1.5&&{willChange:"transform"}}:{position:n,left:F,top:A}},[n,l,Q.floating,d.x,d.y]);return v.useMemo(()=>({...d,update:I,refs:V,elements:Q,floatingStyles:ee}),[d,I,V,Q,ee])}const cz=e=>{function t(n){return{}.hasOwnProperty.call(n,"current")}return{name:"arrow",options:e,fn(n){const{element:r,padding:s}=typeof e=="function"?e(n):e;return r&&t(r)?r.current!=null?pC({element:r.current,padding:s}).fn(n):{}:r?pC({element:r,padding:s}).fn(n):{}}}},dz=(e,t)=>({...nz(e),options:[e,t]}),fz=(e,t)=>({...rz(e),options:[e,t]}),pz=(e,t)=>({...iz(e),options:[e,t]}),hz=(e,t)=>({...sz(e),options:[e,t]}),gz=(e,t)=>({...oz(e),options:[e,t]}),mz=(e,t)=>({...az(e),options:[e,t]}),vz=(e,t)=>({...cz(e),options:[e,t]});var yz="Arrow",jj=v.forwardRef((e,t)=>{const{children:n,width:r=10,height:s=5,...o}=e;return u.jsx(Ne.svg,{...o,ref:t,width:r,height:s,viewBox:"0 0 30 10",preserveAspectRatio:"none",children:e.asChild?n:u.jsx("polygon",{points:"0,0 30,0 15,10"})})});jj.displayName=yz;var bz=jj;function Rj(e){const[t,n]=v.useState(void 0);return fn(()=>{if(e){n({width:e.offsetWidth,height:e.offsetHeight});const r=new ResizeObserver(s=>{if(!Array.isArray(s)||!s.length)return;const o=s[0];let a,l;if("borderBoxSize"in o){const c=o.borderBoxSize,i=Array.isArray(c)?c[0]:c;a=i.inlineSize,l=i.blockSize}else a=e.offsetWidth,l=e.offsetHeight;n({width:a,height:l})});return r.observe(e,{box:"border-box"}),()=>r.unobserve(e)}else n(void 0)},[e]),t}var Kx="Popper",[Pj,hg]=Vr(Kx),[xz,Mj]=Pj(Kx),Oj=e=>{const{__scopePopper:t,children:n}=e,[r,s]=v.useState(null);return u.jsx(xz,{scope:t,anchor:r,onAnchorChange:s,children:n})};Oj.displayName=Kx;var Nj="PopperAnchor",Ij=v.forwardRef((e,t)=>{const{__scopePopper:n,virtualRef:r,...s}=e,o=Mj(Nj,n),a=v.useRef(null),l=it(t,a);return v.useEffect(()=>{o.onAnchorChange((r==null?void 0:r.current)||a.current)}),r?null:u.jsx(Ne.div,{...s,ref:l})});Ij.displayName=Nj;var qx="PopperContent",[wz,Sz]=Pj(qx),Dj=v.forwardRef((e,t)=>{var J,Ce,Pe,Le,Me,me;const{__scopePopper:n,side:r="bottom",sideOffset:s=0,align:o="center",alignOffset:a=0,arrowPadding:l=0,avoidCollisions:c=!0,collisionBoundary:i=[],collisionPadding:d=0,sticky:p="partial",hideWhenDetached:f=!1,updatePositionStrategy:h="optimized",onPlaced:g,...m}=e,x=Mj(qx,n),[b,y]=v.useState(null),w=it(t,rt=>y(rt)),[S,E]=v.useState(null),C=Rj(S),k=(C==null?void 0:C.width)??0,T=(C==null?void 0:C.height)??0,P=r+(o!=="center"?"-"+o:""),N=typeof d=="number"?d:{top:0,right:0,bottom:0,left:0,...d},U=Array.isArray(i)?i:[i],I=U.length>0,Z={padding:N,boundary:U.filter(Ez),altBoundary:I},{refs:V,floatingStyles:Q,placement:ee,isPositioned:W,middlewareData:F}=uz({strategy:"fixed",placement:P,whileElementsMounted:(...rt)=>tz(...rt,{animationFrame:h==="always"}),elements:{reference:x.anchor},middleware:[dz({mainAxis:s+T,alignmentAxis:a}),c&&fz({mainAxis:!0,crossAxis:!1,limiter:p==="partial"?pz():void 0,...Z}),c&&hz({...Z}),gz({...Z,apply:({elements:rt,rects:It,availableWidth:Zt,availableHeight:Wt})=>{const{width:an,height:j}=It.reference,D=rt.floating.style;D.setProperty("--radix-popper-available-width",`${Zt}px`),D.setProperty("--radix-popper-available-height",`${Wt}px`),D.setProperty("--radix-popper-anchor-width",`${an}px`),D.setProperty("--radix-popper-anchor-height",`${j}px`)}}),S&&vz({element:S,padding:l}),Tz({arrowWidth:k,arrowHeight:T}),f&&mz({strategy:"referenceHidden",...Z})]}),[A,Y]=Lj(ee),de=nn(g);fn(()=>{W&&(de==null||de())},[W,de]);const z=(J=F.arrow)==null?void 0:J.x,se=(Ce=F.arrow)==null?void 0:Ce.y,ne=((Pe=F.arrow)==null?void 0:Pe.centerOffset)!==0,[ie,oe]=v.useState();return fn(()=>{b&&oe(window.getComputedStyle(b).zIndex)},[b]),u.jsx("div",{ref:V.setFloating,"data-radix-popper-content-wrapper":"",style:{...Q,transform:W?Q.transform:"translate(0, -200%)",minWidth:"max-content",zIndex:ie,"--radix-popper-transform-origin":[(Le=F.transformOrigin)==null?void 0:Le.x,(Me=F.transformOrigin)==null?void 0:Me.y].join(" "),...((me=F.hide)==null?void 0:me.referenceHidden)&&{visibility:"hidden",pointerEvents:"none"}},dir:e.dir,children:u.jsx(wz,{scope:n,placedSide:A,onArrowChange:E,arrowX:z,arrowY:se,shouldHideArrow:ne,children:u.jsx(Ne.div,{"data-side":A,"data-align":Y,...m,ref:w,style:{...m.style,animation:W?void 0:"none"}})})})});Dj.displayName=qx;var Aj="PopperArrow",Cz={top:"bottom",right:"left",bottom:"top",left:"right"},Fj=v.forwardRef(function(t,n){const{__scopePopper:r,...s}=t,o=Sz(Aj,r),a=Cz[o.placedSide];return u.jsx("span",{ref:o.onArrowChange,style:{position:"absolute",left:o.arrowX,top:o.arrowY,[a]:0,transformOrigin:{top:"",right:"0 0",bottom:"center 0",left:"100% 0"}[o.placedSide],transform:{top:"translateY(100%)",right:"translateY(50%) rotate(90deg) translateX(-50%)",bottom:"rotate(180deg)",left:"translateY(50%) rotate(-90deg) translateX(50%)"}[o.placedSide],visibility:o.shouldHideArrow?"hidden":void 0},children:u.jsx(bz,{...s,ref:n,style:{...s.style,display:"block"}})})});Fj.displayName=Aj;function Ez(e){return e!==null}var Tz=e=>({name:"transformOrigin",options:e,fn(t){var x,b,y;const{placement:n,rects:r,middlewareData:s}=t,a=((x=s.arrow)==null?void 0:x.centerOffset)!==0,l=a?0:e.arrowWidth,c=a?0:e.arrowHeight,[i,d]=Lj(n),p={start:"0%",center:"50%",end:"100%"}[d],f=(((b=s.arrow)==null?void 0:b.x)??0)+l/2,h=(((y=s.arrow)==null?void 0:y.y)??0)+c/2;let g="",m="";return i==="bottom"?(g=a?p:`${f}px`,m=`${-c}px`):i==="top"?(g=a?p:`${f}px`,m=`${r.floating.height+c}px`):i==="right"?(g=`${-c}px`,m=a?p:`${h}px`):i==="left"&&(g=`${r.floating.width+c}px`,m=a?p:`${h}px`),{data:{x:g,y:m}}}});function Lj(e){const[t,n="center"]=e.split("-");return[t,n]}var $j=Oj,Bj=Ij,zj=Dj,Uj=Fj,kz="Portal",gg=v.forwardRef((e,t)=>{var l;const{container:n,...r}=e,[s,o]=v.useState(!1);fn(()=>o(!0),[]);const a=n||s&&((l=globalThis==null?void 0:globalThis.document)==null?void 0:l.body);return a?t_.createPortal(u.jsx(Ne.div,{...r,ref:t}),a):null});gg.displayName=kz;function _z(e,t){return v.useReducer((n,r)=>t[n][r]??n,e)}var or=e=>{const{present:t,children:n}=e,r=jz(t),s=typeof n=="function"?n({present:r.isPresent}):v.Children.only(n),o=it(r.ref,Rz(s));return typeof n=="function"||r.isPresent?v.cloneElement(s,{ref:o}):null};or.displayName="Presence";function jz(e){const[t,n]=v.useState(),r=v.useRef({}),s=v.useRef(e),o=v.useRef("none"),a=e?"mounted":"unmounted",[l,c]=_z(a,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return v.useEffect(()=>{const i=Of(r.current);o.current=l==="mounted"?i:"none"},[l]),fn(()=>{const i=r.current,d=s.current;if(d!==e){const f=o.current,h=Of(i);e?c("MOUNT"):h==="none"||(i==null?void 0:i.display)==="none"?c("UNMOUNT"):c(d&&f!==h?"ANIMATION_OUT":"UNMOUNT"),s.current=e}},[e,c]),fn(()=>{if(t){const i=p=>{const h=Of(r.current).includes(p.animationName);p.target===t&&h&&ka.flushSync(()=>c("ANIMATION_END"))},d=p=>{p.target===t&&(o.current=Of(r.current))};return t.addEventListener("animationstart",d),t.addEventListener("animationcancel",i),t.addEventListener("animationend",i),()=>{t.removeEventListener("animationstart",d),t.removeEventListener("animationcancel",i),t.removeEventListener("animationend",i)}}else c("ANIMATION_END")},[t,c]),{isPresent:["mounted","unmountSuspended"].includes(l),ref:v.useCallback(i=>{i&&(r.current=getComputedStyle(i)),n(i)},[])}}function Of(e){return(e==null?void 0:e.animationName)||"none"}function Rz(e){var r,s;let t=(r=Object.getOwnPropertyDescriptor(e.props,"ref"))==null?void 0:r.get,n=t&&"isReactWarning"in t&&t.isReactWarning;return n?e.ref:(t=(s=Object.getOwnPropertyDescriptor(e,"ref"))==null?void 0:s.get,n=t&&"isReactWarning"in t&&t.isReactWarning,n?e.props.ref:e.props.ref||e.ref)}var Km="rovingFocusGroup.onEntryFocus",Pz={bubbles:!1,cancelable:!0},mg="RovingFocusGroup",[Gy,Vj,Mz]=Fx(mg),[Oz,vg]=Vr(mg,[Mz]),[Nz,Iz]=Oz(mg),Hj=v.forwardRef((e,t)=>u.jsx(Gy.Provider,{scope:e.__scopeRovingFocusGroup,children:u.jsx(Gy.Slot,{scope:e.__scopeRovingFocusGroup,children:u.jsx(Dz,{...e,ref:t})})}));Hj.displayName=mg;var Dz=v.forwardRef((e,t)=>{const{__scopeRovingFocusGroup:n,orientation:r,loop:s=!1,dir:o,currentTabStopId:a,defaultCurrentTabStopId:l,onCurrentTabStopIdChange:c,onEntryFocus:i,preventScrollOnEntryFocus:d=!1,...p}=e,f=v.useRef(null),h=it(t,f),g=Gd(o),[m=null,x]=pa({prop:a,defaultProp:l,onChange:c}),[b,y]=v.useState(!1),w=nn(i),S=Vj(n),E=v.useRef(!1),[C,k]=v.useState(0);return v.useEffect(()=>{const T=f.current;if(T)return T.addEventListener(Km,w),()=>T.removeEventListener(Km,w)},[w]),u.jsx(Nz,{scope:n,orientation:r,dir:g,loop:s,currentTabStopId:m,onItemFocus:v.useCallback(T=>x(T),[x]),onItemShiftTab:v.useCallback(()=>y(!0),[]),onFocusableItemAdd:v.useCallback(()=>k(T=>T+1),[]),onFocusableItemRemove:v.useCallback(()=>k(T=>T-1),[]),children:u.jsx(Ne.div,{tabIndex:b||C===0?-1:0,"data-orientation":r,...p,ref:h,style:{outline:"none",...e.style},onMouseDown:Se(e.onMouseDown,()=>{E.current=!0}),onFocus:Se(e.onFocus,T=>{const P=!E.current;if(T.target===T.currentTarget&&P&&!b){const N=new CustomEvent(Km,Pz);if(T.currentTarget.dispatchEvent(N),!N.defaultPrevented){const U=S().filter(ee=>ee.focusable),I=U.find(ee=>ee.active),Z=U.find(ee=>ee.id===m),Q=[I,Z,...U].filter(Boolean).map(ee=>ee.ref.current);Wj(Q,d)}}E.current=!1}),onBlur:Se(e.onBlur,()=>y(!1))})})}),Kj="RovingFocusGroupItem",qj=v.forwardRef((e,t)=>{const{__scopeRovingFocusGroup:n,focusable:r=!0,active:s=!1,tabStopId:o,...a}=e,l=os(),c=o||l,i=Iz(Kj,n),d=i.currentTabStopId===c,p=Vj(n),{onFocusableItemAdd:f,onFocusableItemRemove:h}=i;return v.useEffect(()=>{if(r)return f(),()=>h()},[r,f,h]),u.jsx(Gy.ItemSlot,{scope:n,id:c,focusable:r,active:s,children:u.jsx(Ne.span,{tabIndex:d?0:-1,"data-orientation":i.orientation,...a,ref:t,onMouseDown:Se(e.onMouseDown,g=>{r?i.onItemFocus(c):g.preventDefault()}),onFocus:Se(e.onFocus,()=>i.onItemFocus(c)),onKeyDown:Se(e.onKeyDown,g=>{if(g.key==="Tab"&&g.shiftKey){i.onItemShiftTab();return}if(g.target!==g.currentTarget)return;const m=Lz(g,i.orientation,i.dir);if(m!==void 0){if(g.metaKey||g.ctrlKey||g.altKey||g.shiftKey)return;g.preventDefault();let b=p().filter(y=>y.focusable).map(y=>y.ref.current);if(m==="last")b.reverse();else if(m==="prev"||m==="next"){m==="prev"&&b.reverse();const y=b.indexOf(g.currentTarget);b=i.loop?$z(b,y+1):b.slice(y+1)}setTimeout(()=>Wj(b))}})})})});qj.displayName=Kj;var Az={ArrowLeft:"prev",ArrowUp:"prev",ArrowRight:"next",ArrowDown:"next",PageUp:"first",Home:"first",PageDown:"last",End:"last"};function Fz(e,t){return t!=="rtl"?e:e==="ArrowLeft"?"ArrowRight":e==="ArrowRight"?"ArrowLeft":e}function Lz(e,t,n){const r=Fz(e.key,n);if(!(t==="vertical"&&["ArrowLeft","ArrowRight"].includes(r))&&!(t==="horizontal"&&["ArrowUp","ArrowDown"].includes(r)))return Az[r]}function Wj(e,t=!1){const n=document.activeElement;for(const r of e)if(r===n||(r.focus({preventScroll:t}),document.activeElement!==n))return}function $z(e,t){return e.map((n,r)=>e[(t+r)%e.length])}var Gj=Hj,Jj=qj,Bz=function(e){if(typeof document>"u")return null;var t=Array.isArray(e)?e[0]:e;return t.ownerDocument.body},Ki=new WeakMap,Nf=new WeakMap,If={},qm=0,Qj=function(e){return e&&(e.host||Qj(e.parentNode))},zz=function(e,t){return t.map(function(n){if(e.contains(n))return n;var r=Qj(n);return r&&e.contains(r)?r:(console.error("aria-hidden",n,"in not contained inside",e,". Doing nothing"),null)}).filter(function(n){return!!n})},Uz=function(e,t,n,r){var s=zz(t,Array.isArray(e)?e:[e]);If[n]||(If[n]=new WeakMap);var o=If[n],a=[],l=new Set,c=new Set(s),i=function(p){!p||l.has(p)||(l.add(p),i(p.parentNode))};s.forEach(i);var d=function(p){!p||c.has(p)||Array.prototype.forEach.call(p.children,function(f){if(l.has(f))d(f);else try{var h=f.getAttribute(r),g=h!==null&&h!=="false",m=(Ki.get(f)||0)+1,x=(o.get(f)||0)+1;Ki.set(f,m),o.set(f,x),a.push(f),m===1&&g&&Nf.set(f,!0),x===1&&f.setAttribute(n,"true"),g||f.setAttribute(r,"true")}catch(b){console.error("aria-hidden: cannot operate on ",f,b)}})};return d(t),l.clear(),qm++,function(){a.forEach(function(p){var f=Ki.get(p)-1,h=o.get(p)-1;Ki.set(p,f),o.set(p,h),f||(Nf.has(p)||p.removeAttribute(r),Nf.delete(p)),h||p.removeAttribute(n)}),qm--,qm||(Ki=new WeakMap,Ki=new WeakMap,Nf=new WeakMap,If={})}},Wx=function(e,t,n){n===void 0&&(n="data-aria-hidden");var r=Array.from(Array.isArray(e)?e:[e]),s=Bz(e);return s?(r.push.apply(r,Array.from(s.querySelectorAll("[aria-live]"))),Uz(r,s,n,"aria-hidden")):function(){return null}},_s=function(){return _s=Object.assign||function(t){for(var n,r=1,s=arguments.length;r<s;r++){n=arguments[r];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t},_s.apply(this,arguments)};function Zj(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n}function Vz(e,t,n){if(n||arguments.length===2)for(var r=0,s=t.length,o;r<s;r++)(o||!(r in t))&&(o||(o=Array.prototype.slice.call(t,0,r)),o[r]=t[r]);return e.concat(o||Array.prototype.slice.call(t))}var gp="right-scroll-bar-position",mp="width-before-scroll-bar",Hz="with-scroll-bars-hidden",Kz="--removed-body-scroll-bar-size";function Wm(e,t){return typeof e=="function"?e(t):e&&(e.current=t),e}function qz(e,t){var n=v.useState(function(){return{value:e,callback:t,facade:{get current(){return n.value},set current(r){var s=n.value;s!==r&&(n.value=r,n.callback(r,s))}}}})[0];return n.callback=t,n.facade}var Wz=typeof window<"u"?v.useLayoutEffect:v.useEffect,mC=new WeakMap;function Gz(e,t){var n=qz(null,function(r){return e.forEach(function(s){return Wm(s,r)})});return Wz(function(){var r=mC.get(n);if(r){var s=new Set(r),o=new Set(e),a=n.current;s.forEach(function(l){o.has(l)||Wm(l,null)}),o.forEach(function(l){s.has(l)||Wm(l,a)})}mC.set(n,e)},[e]),n}function Jz(e){return e}function Qz(e,t){t===void 0&&(t=Jz);var n=[],r=!1,s={read:function(){if(r)throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");return n.length?n[n.length-1]:e},useMedium:function(o){var a=t(o,r);return n.push(a),function(){n=n.filter(function(l){return l!==a})}},assignSyncMedium:function(o){for(r=!0;n.length;){var a=n;n=[],a.forEach(o)}n={push:function(l){return o(l)},filter:function(){return n}}},assignMedium:function(o){r=!0;var a=[];if(n.length){var l=n;n=[],l.forEach(o),a=n}var c=function(){var d=a;a=[],d.forEach(o)},i=function(){return Promise.resolve().then(c)};i(),n={push:function(d){a.push(d),i()},filter:function(d){return a=a.filter(d),n}}}};return s}function Zz(e){e===void 0&&(e={});var t=Qz(null);return t.options=_s({async:!0,ssr:!1},e),t}var Yj=function(e){var t=e.sideCar,n=Zj(e,["sideCar"]);if(!t)throw new Error("Sidecar: please provide `sideCar` property to import the right car");var r=t.read();if(!r)throw new Error("Sidecar medium not found");return v.createElement(r,_s({},n))};Yj.isSideCarExport=!0;function Yz(e,t){return e.useMedium(t),Yj}var Xj=Zz(),Gm=function(){},yg=v.forwardRef(function(e,t){var n=v.useRef(null),r=v.useState({onScrollCapture:Gm,onWheelCapture:Gm,onTouchMoveCapture:Gm}),s=r[0],o=r[1],a=e.forwardProps,l=e.children,c=e.className,i=e.removeScrollBar,d=e.enabled,p=e.shards,f=e.sideCar,h=e.noIsolation,g=e.inert,m=e.allowPinchZoom,x=e.as,b=x===void 0?"div":x,y=e.gapMode,w=Zj(e,["forwardProps","children","className","removeScrollBar","enabled","shards","sideCar","noIsolation","inert","allowPinchZoom","as","gapMode"]),S=f,E=Gz([n,t]),C=_s(_s({},w),s);return v.createElement(v.Fragment,null,d&&v.createElement(S,{sideCar:Xj,removeScrollBar:i,shards:p,noIsolation:h,inert:g,setCallbacks:o,allowPinchZoom:!!m,lockRef:n,gapMode:y}),a?v.cloneElement(v.Children.only(l),_s(_s({},C),{ref:E})):v.createElement(b,_s({},C,{className:c,ref:E}),l))});yg.defaultProps={enabled:!0,removeScrollBar:!0,inert:!1};yg.classNames={fullWidth:mp,zeroRight:gp};var Xz=function(){if(typeof __webpack_nonce__<"u")return __webpack_nonce__};function eU(){if(!document)return null;var e=document.createElement("style");e.type="text/css";var t=Xz();return t&&e.setAttribute("nonce",t),e}function tU(e,t){e.styleSheet?e.styleSheet.cssText=t:e.appendChild(document.createTextNode(t))}function nU(e){var t=document.head||document.getElementsByTagName("head")[0];t.appendChild(e)}var rU=function(){var e=0,t=null;return{add:function(n){e==0&&(t=eU())&&(tU(t,n),nU(t)),e++},remove:function(){e--,!e&&t&&(t.parentNode&&t.parentNode.removeChild(t),t=null)}}},sU=function(){var e=rU();return function(t,n){v.useEffect(function(){return e.add(t),function(){e.remove()}},[t&&n])}},eR=function(){var e=sU(),t=function(n){var r=n.styles,s=n.dynamic;return e(r,s),null};return t},oU={left:0,top:0,right:0,gap:0},Jm=function(e){return parseInt(e||"",10)||0},aU=function(e){var t=window.getComputedStyle(document.body),n=t[e==="padding"?"paddingLeft":"marginLeft"],r=t[e==="padding"?"paddingTop":"marginTop"],s=t[e==="padding"?"paddingRight":"marginRight"];return[Jm(n),Jm(r),Jm(s)]},iU=function(e){if(e===void 0&&(e="margin"),typeof window>"u")return oU;var t=aU(e),n=document.documentElement.clientWidth,r=window.innerWidth;return{left:t[0],top:t[1],right:t[2],gap:Math.max(0,r-n+t[2]-t[0])}},lU=eR(),_l="data-scroll-locked",uU=function(e,t,n,r){var s=e.left,o=e.top,a=e.right,l=e.gap;return n===void 0&&(n="margin"),`
  .`.concat(Hz,` {
   overflow: hidden `).concat(r,`;
   padding-right: `).concat(l,"px ").concat(r,`;
  }
  body[`).concat(_l,`] {
    overflow: hidden `).concat(r,`;
    overscroll-behavior: contain;
    `).concat([t&&"position: relative ".concat(r,";"),n==="margin"&&`
    padding-left: `.concat(s,`px;
    padding-top: `).concat(o,`px;
    padding-right: `).concat(a,`px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(l,"px ").concat(r,`;
    `),n==="padding"&&"padding-right: ".concat(l,"px ").concat(r,";")].filter(Boolean).join(""),`
  }
  
  .`).concat(gp,` {
    right: `).concat(l,"px ").concat(r,`;
  }
  
  .`).concat(mp,` {
    margin-right: `).concat(l,"px ").concat(r,`;
  }
  
  .`).concat(gp," .").concat(gp,` {
    right: 0 `).concat(r,`;
  }
  
  .`).concat(mp," .").concat(mp,` {
    margin-right: 0 `).concat(r,`;
  }
  
  body[`).concat(_l,`] {
    `).concat(Kz,": ").concat(l,`px;
  }
`)},vC=function(){var e=parseInt(document.body.getAttribute(_l)||"0",10);return isFinite(e)?e:0},cU=function(){v.useEffect(function(){return document.body.setAttribute(_l,(vC()+1).toString()),function(){var e=vC()-1;e<=0?document.body.removeAttribute(_l):document.body.setAttribute(_l,e.toString())}},[])},dU=function(e){var t=e.noRelative,n=e.noImportant,r=e.gapMode,s=r===void 0?"margin":r;cU();var o=v.useMemo(function(){return iU(s)},[s]);return v.createElement(lU,{styles:uU(o,!t,s,n?"":"!important")})},Jy=!1;if(typeof window<"u")try{var Df=Object.defineProperty({},"passive",{get:function(){return Jy=!0,!0}});window.addEventListener("test",Df,Df),window.removeEventListener("test",Df,Df)}catch{Jy=!1}var qi=Jy?{passive:!1}:!1,fU=function(e){return e.tagName==="TEXTAREA"},tR=function(e,t){var n=window.getComputedStyle(e);return n[t]!=="hidden"&&!(n.overflowY===n.overflowX&&!fU(e)&&n[t]==="visible")},pU=function(e){return tR(e,"overflowY")},hU=function(e){return tR(e,"overflowX")},yC=function(e,t){var n=t.ownerDocument,r=t;do{typeof ShadowRoot<"u"&&r instanceof ShadowRoot&&(r=r.host);var s=nR(e,r);if(s){var o=rR(e,r),a=o[1],l=o[2];if(a>l)return!0}r=r.parentNode}while(r&&r!==n.body);return!1},gU=function(e){var t=e.scrollTop,n=e.scrollHeight,r=e.clientHeight;return[t,n,r]},mU=function(e){var t=e.scrollLeft,n=e.scrollWidth,r=e.clientWidth;return[t,n,r]},nR=function(e,t){return e==="v"?pU(t):hU(t)},rR=function(e,t){return e==="v"?gU(t):mU(t)},vU=function(e,t){return e==="h"&&t==="rtl"?-1:1},yU=function(e,t,n,r,s){var o=vU(e,window.getComputedStyle(t).direction),a=o*r,l=n.target,c=t.contains(l),i=!1,d=a>0,p=0,f=0;do{var h=rR(e,l),g=h[0],m=h[1],x=h[2],b=m-x-o*g;(g||b)&&nR(e,l)&&(p+=b,f+=g),l instanceof ShadowRoot?l=l.host:l=l.parentNode}while(!c&&l!==document.body||c&&(t.contains(l)||t===l));return(d&&(Math.abs(p)<1||!s)||!d&&(Math.abs(f)<1||!s))&&(i=!0),i},Af=function(e){return"changedTouches"in e?[e.changedTouches[0].clientX,e.changedTouches[0].clientY]:[0,0]},bC=function(e){return[e.deltaX,e.deltaY]},xC=function(e){return e&&"current"in e?e.current:e},bU=function(e,t){return e[0]===t[0]&&e[1]===t[1]},xU=function(e){return`
  .block-interactivity-`.concat(e,` {pointer-events: none;}
  .allow-interactivity-`).concat(e,` {pointer-events: all;}
`)},wU=0,Wi=[];function SU(e){var t=v.useRef([]),n=v.useRef([0,0]),r=v.useRef(),s=v.useState(wU++)[0],o=v.useState(eR)[0],a=v.useRef(e);v.useEffect(function(){a.current=e},[e]),v.useEffect(function(){if(e.inert){document.body.classList.add("block-interactivity-".concat(s));var m=Vz([e.lockRef.current],(e.shards||[]).map(xC),!0).filter(Boolean);return m.forEach(function(x){return x.classList.add("allow-interactivity-".concat(s))}),function(){document.body.classList.remove("block-interactivity-".concat(s)),m.forEach(function(x){return x.classList.remove("allow-interactivity-".concat(s))})}}},[e.inert,e.lockRef.current,e.shards]);var l=v.useCallback(function(m,x){if("touches"in m&&m.touches.length===2)return!a.current.allowPinchZoom;var b=Af(m),y=n.current,w="deltaX"in m?m.deltaX:y[0]-b[0],S="deltaY"in m?m.deltaY:y[1]-b[1],E,C=m.target,k=Math.abs(w)>Math.abs(S)?"h":"v";if("touches"in m&&k==="h"&&C.type==="range")return!1;var T=yC(k,C);if(!T)return!0;if(T?E=k:(E=k==="v"?"h":"v",T=yC(k,C)),!T)return!1;if(!r.current&&"changedTouches"in m&&(w||S)&&(r.current=E),!E)return!0;var P=r.current||E;return yU(P,x,m,P==="h"?w:S,!0)},[]),c=v.useCallback(function(m){var x=m;if(!(!Wi.length||Wi[Wi.length-1]!==o)){var b="deltaY"in x?bC(x):Af(x),y=t.current.filter(function(E){return E.name===x.type&&(E.target===x.target||x.target===E.shadowParent)&&bU(E.delta,b)})[0];if(y&&y.should){x.cancelable&&x.preventDefault();return}if(!y){var w=(a.current.shards||[]).map(xC).filter(Boolean).filter(function(E){return E.contains(x.target)}),S=w.length>0?l(x,w[0]):!a.current.noIsolation;S&&x.cancelable&&x.preventDefault()}}},[]),i=v.useCallback(function(m,x,b,y){var w={name:m,delta:x,target:b,should:y,shadowParent:CU(b)};t.current.push(w),setTimeout(function(){t.current=t.current.filter(function(S){return S!==w})},1)},[]),d=v.useCallback(function(m){n.current=Af(m),r.current=void 0},[]),p=v.useCallback(function(m){i(m.type,bC(m),m.target,l(m,e.lockRef.current))},[]),f=v.useCallback(function(m){i(m.type,Af(m),m.target,l(m,e.lockRef.current))},[]);v.useEffect(function(){return Wi.push(o),e.setCallbacks({onScrollCapture:p,onWheelCapture:p,onTouchMoveCapture:f}),document.addEventListener("wheel",c,qi),document.addEventListener("touchmove",c,qi),document.addEventListener("touchstart",d,qi),function(){Wi=Wi.filter(function(m){return m!==o}),document.removeEventListener("wheel",c,qi),document.removeEventListener("touchmove",c,qi),document.removeEventListener("touchstart",d,qi)}},[]);var h=e.removeScrollBar,g=e.inert;return v.createElement(v.Fragment,null,g?v.createElement(o,{styles:xU(s)}):null,h?v.createElement(dU,{gapMode:e.gapMode}):null)}function CU(e){for(var t=null;e!==null;)e instanceof ShadowRoot&&(t=e.host,e=e.host),e=e.parentNode;return t}const EU=Yz(Xj,SU);var bg=v.forwardRef(function(e,t){return v.createElement(yg,_s({},e,{ref:t,sideCar:EU}))});bg.classNames=yg.classNames;var Qy=["Enter"," "],TU=["ArrowDown","PageUp","Home"],sR=["ArrowUp","PageDown","End"],kU=[...TU,...sR],_U={ltr:[...Qy,"ArrowRight"],rtl:[...Qy,"ArrowLeft"]},jU={ltr:["ArrowLeft"],rtl:["ArrowRight"]},Qd="Menu",[ld,RU,PU]=Fx(Qd),[Ii,oR]=Vr(Qd,[PU,hg,vg]),xg=hg(),aR=vg(),[MU,Di]=Ii(Qd),[OU,Zd]=Ii(Qd),iR=e=>{const{__scopeMenu:t,open:n=!1,children:r,dir:s,onOpenChange:o,modal:a=!0}=e,l=xg(t),[c,i]=v.useState(null),d=v.useRef(!1),p=nn(o),f=Gd(s);return v.useEffect(()=>{const h=()=>{d.current=!0,document.addEventListener("pointerdown",g,{capture:!0,once:!0}),document.addEventListener("pointermove",g,{capture:!0,once:!0})},g=()=>d.current=!1;return document.addEventListener("keydown",h,{capture:!0}),()=>{document.removeEventListener("keydown",h,{capture:!0}),document.removeEventListener("pointerdown",g,{capture:!0}),document.removeEventListener("pointermove",g,{capture:!0})}},[]),u.jsx($j,{...l,children:u.jsx(MU,{scope:t,open:n,onOpenChange:p,content:c,onContentChange:i,children:u.jsx(OU,{scope:t,onClose:v.useCallback(()=>p(!1),[p]),isUsingKeyboardRef:d,dir:f,modal:a,children:r})})})};iR.displayName=Qd;var NU="MenuAnchor",Gx=v.forwardRef((e,t)=>{const{__scopeMenu:n,...r}=e,s=xg(n);return u.jsx(Bj,{...s,...r,ref:t})});Gx.displayName=NU;var Jx="MenuPortal",[IU,lR]=Ii(Jx,{forceMount:void 0}),uR=e=>{const{__scopeMenu:t,forceMount:n,children:r,container:s}=e,o=Di(Jx,t);return u.jsx(IU,{scope:t,forceMount:n,children:u.jsx(or,{present:n||o.open,children:u.jsx(gg,{asChild:!0,container:s,children:r})})})};uR.displayName=Jx;var $r="MenuContent",[DU,Qx]=Ii($r),cR=v.forwardRef((e,t)=>{const n=lR($r,e.__scopeMenu),{forceMount:r=n.forceMount,...s}=e,o=Di($r,e.__scopeMenu),a=Zd($r,e.__scopeMenu);return u.jsx(ld.Provider,{scope:e.__scopeMenu,children:u.jsx(or,{present:r||o.open,children:u.jsx(ld.Slot,{scope:e.__scopeMenu,children:a.modal?u.jsx(AU,{...s,ref:t}):u.jsx(FU,{...s,ref:t})})})})}),AU=v.forwardRef((e,t)=>{const n=Di($r,e.__scopeMenu),r=v.useRef(null),s=it(t,r);return v.useEffect(()=>{const o=r.current;if(o)return Wx(o)},[]),u.jsx(Zx,{...e,ref:s,trapFocus:n.open,disableOutsidePointerEvents:n.open,disableOutsideScroll:!0,onFocusOutside:Se(e.onFocusOutside,o=>o.preventDefault(),{checkForDefaultPrevented:!1}),onDismiss:()=>n.onOpenChange(!1)})}),FU=v.forwardRef((e,t)=>{const n=Di($r,e.__scopeMenu);return u.jsx(Zx,{...e,ref:t,trapFocus:!1,disableOutsidePointerEvents:!1,disableOutsideScroll:!1,onDismiss:()=>n.onOpenChange(!1)})}),Zx=v.forwardRef((e,t)=>{const{__scopeMenu:n,loop:r=!1,trapFocus:s,onOpenAutoFocus:o,onCloseAutoFocus:a,disableOutsidePointerEvents:l,onEntryFocus:c,onEscapeKeyDown:i,onPointerDownOutside:d,onFocusOutside:p,onInteractOutside:f,onDismiss:h,disableOutsideScroll:g,...m}=e,x=Di($r,n),b=Zd($r,n),y=xg(n),w=aR(n),S=RU(n),[E,C]=v.useState(null),k=v.useRef(null),T=it(t,k,x.onContentChange),P=v.useRef(0),N=v.useRef(""),U=v.useRef(0),I=v.useRef(null),Z=v.useRef("right"),V=v.useRef(0),Q=g?bg:v.Fragment,ee=g?{as:mo,allowPinchZoom:!0}:void 0,W=A=>{var J,Ce;const Y=N.current+A,de=S().filter(Pe=>!Pe.disabled),z=document.activeElement,se=(J=de.find(Pe=>Pe.ref.current===z))==null?void 0:J.textValue,ne=de.map(Pe=>Pe.textValue),ie=JU(ne,Y,se),oe=(Ce=de.find(Pe=>Pe.textValue===ie))==null?void 0:Ce.ref.current;(function Pe(Le){N.current=Le,window.clearTimeout(P.current),Le!==""&&(P.current=window.setTimeout(()=>Pe(""),1e3))})(Y),oe&&setTimeout(()=>oe.focus())};v.useEffect(()=>()=>window.clearTimeout(P.current),[]),Lx();const F=v.useCallback(A=>{var de,z;return Z.current===((de=I.current)==null?void 0:de.side)&&ZU(A,(z=I.current)==null?void 0:z.area)},[]);return u.jsx(DU,{scope:n,searchRef:N,onItemEnter:v.useCallback(A=>{F(A)&&A.preventDefault()},[F]),onItemLeave:v.useCallback(A=>{var Y;F(A)||((Y=k.current)==null||Y.focus(),C(null))},[F]),onTriggerLeave:v.useCallback(A=>{F(A)&&A.preventDefault()},[F]),pointerGraceTimerRef:U,onPointerGraceIntentChange:v.useCallback(A=>{I.current=A},[]),children:u.jsx(Q,{...ee,children:u.jsx(dg,{asChild:!0,trapped:s,onMountAutoFocus:Se(o,A=>{var Y;A.preventDefault(),(Y=k.current)==null||Y.focus({preventScroll:!0})}),onUnmountAutoFocus:a,children:u.jsx(cg,{asChild:!0,disableOutsidePointerEvents:l,onEscapeKeyDown:i,onPointerDownOutside:d,onFocusOutside:p,onInteractOutside:f,onDismiss:h,children:u.jsx(Gj,{asChild:!0,...w,dir:b.dir,orientation:"vertical",loop:r,currentTabStopId:E,onCurrentTabStopIdChange:C,onEntryFocus:Se(c,A=>{b.isUsingKeyboardRef.current||A.preventDefault()}),preventScrollOnEntryFocus:!0,children:u.jsx(zj,{role:"menu","aria-orientation":"vertical","data-state":kR(x.open),"data-radix-menu-content":"",dir:b.dir,...y,...m,ref:T,style:{outline:"none",...m.style},onKeyDown:Se(m.onKeyDown,A=>{const de=A.target.closest("[data-radix-menu-content]")===A.currentTarget,z=A.ctrlKey||A.altKey||A.metaKey,se=A.key.length===1;de&&(A.key==="Tab"&&A.preventDefault(),!z&&se&&W(A.key));const ne=k.current;if(A.target!==ne||!kU.includes(A.key))return;A.preventDefault();const oe=S().filter(J=>!J.disabled).map(J=>J.ref.current);sR.includes(A.key)&&oe.reverse(),WU(oe)}),onBlur:Se(e.onBlur,A=>{A.currentTarget.contains(A.target)||(window.clearTimeout(P.current),N.current="")}),onPointerMove:Se(e.onPointerMove,ud(A=>{const Y=A.target,de=V.current!==A.clientX;if(A.currentTarget.contains(Y)&&de){const z=A.clientX>V.current?"right":"left";Z.current=z,V.current=A.clientX}}))})})})})})})});cR.displayName=$r;var LU="MenuGroup",Yx=v.forwardRef((e,t)=>{const{__scopeMenu:n,...r}=e;return u.jsx(Ne.div,{role:"group",...r,ref:t})});Yx.displayName=LU;var $U="MenuLabel",dR=v.forwardRef((e,t)=>{const{__scopeMenu:n,...r}=e;return u.jsx(Ne.div,{...r,ref:t})});dR.displayName=$U;var ah="MenuItem",wC="menu.itemSelect",wg=v.forwardRef((e,t)=>{const{disabled:n=!1,onSelect:r,...s}=e,o=v.useRef(null),a=Zd(ah,e.__scopeMenu),l=Qx(ah,e.__scopeMenu),c=it(t,o),i=v.useRef(!1),d=()=>{const p=o.current;if(!n&&p){const f=new CustomEvent(wC,{bubbles:!0,cancelable:!0});p.addEventListener(wC,h=>r==null?void 0:r(h),{once:!0}),gj(p,f),f.defaultPrevented?i.current=!1:a.onClose()}};return u.jsx(fR,{...s,ref:c,disabled:n,onClick:Se(e.onClick,d),onPointerDown:p=>{var f;(f=e.onPointerDown)==null||f.call(e,p),i.current=!0},onPointerUp:Se(e.onPointerUp,p=>{var f;i.current||(f=p.currentTarget)==null||f.click()}),onKeyDown:Se(e.onKeyDown,p=>{const f=l.searchRef.current!=="";n||f&&p.key===" "||Qy.includes(p.key)&&(p.currentTarget.click(),p.preventDefault())})})});wg.displayName=ah;var fR=v.forwardRef((e,t)=>{const{__scopeMenu:n,disabled:r=!1,textValue:s,...o}=e,a=Qx(ah,n),l=aR(n),c=v.useRef(null),i=it(t,c),[d,p]=v.useState(!1),[f,h]=v.useState("");return v.useEffect(()=>{const g=c.current;g&&h((g.textContent??"").trim())},[o.children]),u.jsx(ld.ItemSlot,{scope:n,disabled:r,textValue:s??f,children:u.jsx(Jj,{asChild:!0,...l,focusable:!r,children:u.jsx(Ne.div,{role:"menuitem","data-highlighted":d?"":void 0,"aria-disabled":r||void 0,"data-disabled":r?"":void 0,...o,ref:i,onPointerMove:Se(e.onPointerMove,ud(g=>{r?a.onItemLeave(g):(a.onItemEnter(g),g.defaultPrevented||g.currentTarget.focus({preventScroll:!0}))})),onPointerLeave:Se(e.onPointerLeave,ud(g=>a.onItemLeave(g))),onFocus:Se(e.onFocus,()=>p(!0)),onBlur:Se(e.onBlur,()=>p(!1))})})})}),BU="MenuCheckboxItem",pR=v.forwardRef((e,t)=>{const{checked:n=!1,onCheckedChange:r,...s}=e;return u.jsx(yR,{scope:e.__scopeMenu,checked:n,children:u.jsx(wg,{role:"menuitemcheckbox","aria-checked":ih(n)?"mixed":n,...s,ref:t,"data-state":ew(n),onSelect:Se(s.onSelect,()=>r==null?void 0:r(ih(n)?!0:!n),{checkForDefaultPrevented:!1})})})});pR.displayName=BU;var hR="MenuRadioGroup",[zU,UU]=Ii(hR,{value:void 0,onValueChange:()=>{}}),gR=v.forwardRef((e,t)=>{const{value:n,onValueChange:r,...s}=e,o=nn(r);return u.jsx(zU,{scope:e.__scopeMenu,value:n,onValueChange:o,children:u.jsx(Yx,{...s,ref:t})})});gR.displayName=hR;var mR="MenuRadioItem",vR=v.forwardRef((e,t)=>{const{value:n,...r}=e,s=UU(mR,e.__scopeMenu),o=n===s.value;return u.jsx(yR,{scope:e.__scopeMenu,checked:o,children:u.jsx(wg,{role:"menuitemradio","aria-checked":o,...r,ref:t,"data-state":ew(o),onSelect:Se(r.onSelect,()=>{var a;return(a=s.onValueChange)==null?void 0:a.call(s,n)},{checkForDefaultPrevented:!1})})})});vR.displayName=mR;var Xx="MenuItemIndicator",[yR,VU]=Ii(Xx,{checked:!1}),bR=v.forwardRef((e,t)=>{const{__scopeMenu:n,forceMount:r,...s}=e,o=VU(Xx,n);return u.jsx(or,{present:r||ih(o.checked)||o.checked===!0,children:u.jsx(Ne.span,{...s,ref:t,"data-state":ew(o.checked)})})});bR.displayName=Xx;var HU="MenuSeparator",xR=v.forwardRef((e,t)=>{const{__scopeMenu:n,...r}=e;return u.jsx(Ne.div,{role:"separator","aria-orientation":"horizontal",...r,ref:t})});xR.displayName=HU;var KU="MenuArrow",wR=v.forwardRef((e,t)=>{const{__scopeMenu:n,...r}=e,s=xg(n);return u.jsx(Uj,{...s,...r,ref:t})});wR.displayName=KU;var qU="MenuSub",[qse,SR]=Ii(qU),dc="MenuSubTrigger",CR=v.forwardRef((e,t)=>{const n=Di(dc,e.__scopeMenu),r=Zd(dc,e.__scopeMenu),s=SR(dc,e.__scopeMenu),o=Qx(dc,e.__scopeMenu),a=v.useRef(null),{pointerGraceTimerRef:l,onPointerGraceIntentChange:c}=o,i={__scopeMenu:e.__scopeMenu},d=v.useCallback(()=>{a.current&&window.clearTimeout(a.current),a.current=null},[]);return v.useEffect(()=>d,[d]),v.useEffect(()=>{const p=l.current;return()=>{window.clearTimeout(p),c(null)}},[l,c]),u.jsx(Gx,{asChild:!0,...i,children:u.jsx(fR,{id:s.triggerId,"aria-haspopup":"menu","aria-expanded":n.open,"aria-controls":s.contentId,"data-state":kR(n.open),...e,ref:ag(t,s.onTriggerChange),onClick:p=>{var f;(f=e.onClick)==null||f.call(e,p),!(e.disabled||p.defaultPrevented)&&(p.currentTarget.focus(),n.open||n.onOpenChange(!0))},onPointerMove:Se(e.onPointerMove,ud(p=>{o.onItemEnter(p),!p.defaultPrevented&&!e.disabled&&!n.open&&!a.current&&(o.onPointerGraceIntentChange(null),a.current=window.setTimeout(()=>{n.onOpenChange(!0),d()},100))})),onPointerLeave:Se(e.onPointerLeave,ud(p=>{var h,g;d();const f=(h=n.content)==null?void 0:h.getBoundingClientRect();if(f){const m=(g=n.content)==null?void 0:g.dataset.side,x=m==="right",b=x?-5:5,y=f[x?"left":"right"],w=f[x?"right":"left"];o.onPointerGraceIntentChange({area:[{x:p.clientX+b,y:p.clientY},{x:y,y:f.top},{x:w,y:f.top},{x:w,y:f.bottom},{x:y,y:f.bottom}],side:m}),window.clearTimeout(l.current),l.current=window.setTimeout(()=>o.onPointerGraceIntentChange(null),300)}else{if(o.onTriggerLeave(p),p.defaultPrevented)return;o.onPointerGraceIntentChange(null)}})),onKeyDown:Se(e.onKeyDown,p=>{var h;const f=o.searchRef.current!=="";e.disabled||f&&p.key===" "||_U[r.dir].includes(p.key)&&(n.onOpenChange(!0),(h=n.content)==null||h.focus(),p.preventDefault())})})})});CR.displayName=dc;var ER="MenuSubContent",TR=v.forwardRef((e,t)=>{const n=lR($r,e.__scopeMenu),{forceMount:r=n.forceMount,...s}=e,o=Di($r,e.__scopeMenu),a=Zd($r,e.__scopeMenu),l=SR(ER,e.__scopeMenu),c=v.useRef(null),i=it(t,c);return u.jsx(ld.Provider,{scope:e.__scopeMenu,children:u.jsx(or,{present:r||o.open,children:u.jsx(ld.Slot,{scope:e.__scopeMenu,children:u.jsx(Zx,{id:l.contentId,"aria-labelledby":l.triggerId,...s,ref:i,align:"start",side:a.dir==="rtl"?"left":"right",disableOutsidePointerEvents:!1,disableOutsideScroll:!1,trapFocus:!1,onOpenAutoFocus:d=>{var p;a.isUsingKeyboardRef.current&&((p=c.current)==null||p.focus()),d.preventDefault()},onCloseAutoFocus:d=>d.preventDefault(),onFocusOutside:Se(e.onFocusOutside,d=>{d.target!==l.trigger&&o.onOpenChange(!1)}),onEscapeKeyDown:Se(e.onEscapeKeyDown,d=>{a.onClose(),d.preventDefault()}),onKeyDown:Se(e.onKeyDown,d=>{var h;const p=d.currentTarget.contains(d.target),f=jU[a.dir].includes(d.key);p&&f&&(o.onOpenChange(!1),(h=l.trigger)==null||h.focus(),d.preventDefault())})})})})})});TR.displayName=ER;function kR(e){return e?"open":"closed"}function ih(e){return e==="indeterminate"}function ew(e){return ih(e)?"indeterminate":e?"checked":"unchecked"}function WU(e){const t=document.activeElement;for(const n of e)if(n===t||(n.focus(),document.activeElement!==t))return}function GU(e,t){return e.map((n,r)=>e[(t+r)%e.length])}function JU(e,t,n){const s=t.length>1&&Array.from(t).every(i=>i===t[0])?t[0]:t,o=n?e.indexOf(n):-1;let a=GU(e,Math.max(o,0));s.length===1&&(a=a.filter(i=>i!==n));const c=a.find(i=>i.toLowerCase().startsWith(s.toLowerCase()));return c!==n?c:void 0}function QU(e,t){const{x:n,y:r}=e;let s=!1;for(let o=0,a=t.length-1;o<t.length;a=o++){const l=t[o].x,c=t[o].y,i=t[a].x,d=t[a].y;c>r!=d>r&&n<(i-l)*(r-c)/(d-c)+l&&(s=!s)}return s}function ZU(e,t){if(!t)return!1;const n={x:e.clientX,y:e.clientY};return QU(n,t)}function ud(e){return t=>t.pointerType==="mouse"?e(t):void 0}var YU=iR,XU=Gx,e5=uR,t5=cR,n5=Yx,r5=dR,s5=wg,o5=pR,a5=gR,i5=vR,l5=bR,u5=xR,c5=wR,d5=CR,f5=TR,tw="DropdownMenu",[p5,Wse]=Vr(tw,[oR]),Gn=oR(),[h5,_R]=p5(tw),nw=e=>{const{__scopeDropdownMenu:t,children:n,dir:r,open:s,defaultOpen:o,onOpenChange:a,modal:l=!0}=e,c=Gn(t),i=v.useRef(null),[d=!1,p]=pa({prop:s,defaultProp:o,onChange:a});return u.jsx(h5,{scope:t,triggerId:os(),triggerRef:i,contentId:os(),open:d,onOpenChange:p,onOpenToggle:v.useCallback(()=>p(f=>!f),[p]),modal:l,children:u.jsx(YU,{...c,open:d,onOpenChange:p,dir:r,modal:l,children:n})})};nw.displayName=tw;var jR="DropdownMenuTrigger",rw=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,disabled:r=!1,...s}=e,o=_R(jR,n),a=Gn(n);return u.jsx(XU,{asChild:!0,...a,children:u.jsx(Ne.button,{type:"button",id:o.triggerId,"aria-haspopup":"menu","aria-expanded":o.open,"aria-controls":o.open?o.contentId:void 0,"data-state":o.open?"open":"closed","data-disabled":r?"":void 0,disabled:r,...s,ref:ag(t,o.triggerRef),onPointerDown:Se(e.onPointerDown,l=>{!r&&l.button===0&&l.ctrlKey===!1&&(o.onOpenToggle(),o.open||l.preventDefault())}),onKeyDown:Se(e.onKeyDown,l=>{r||(["Enter"," "].includes(l.key)&&o.onOpenToggle(),l.key==="ArrowDown"&&o.onOpenChange(!0),["Enter"," ","ArrowDown"].includes(l.key)&&l.preventDefault())})})})});rw.displayName=jR;var g5="DropdownMenuPortal",RR=e=>{const{__scopeDropdownMenu:t,...n}=e,r=Gn(t);return u.jsx(e5,{...r,...n})};RR.displayName=g5;var PR="DropdownMenuContent",MR=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=_R(PR,n),o=Gn(n),a=v.useRef(!1);return u.jsx(t5,{id:s.contentId,"aria-labelledby":s.triggerId,...o,...r,ref:t,onCloseAutoFocus:Se(e.onCloseAutoFocus,l=>{var c;a.current||(c=s.triggerRef.current)==null||c.focus(),a.current=!1,l.preventDefault()}),onInteractOutside:Se(e.onInteractOutside,l=>{const c=l.detail.originalEvent,i=c.button===0&&c.ctrlKey===!0,d=c.button===2||i;(!s.modal||d)&&(a.current=!0)}),style:{...e.style,"--radix-dropdown-menu-content-transform-origin":"var(--radix-popper-transform-origin)","--radix-dropdown-menu-content-available-width":"var(--radix-popper-available-width)","--radix-dropdown-menu-content-available-height":"var(--radix-popper-available-height)","--radix-dropdown-menu-trigger-width":"var(--radix-popper-anchor-width)","--radix-dropdown-menu-trigger-height":"var(--radix-popper-anchor-height)"}})});MR.displayName=PR;var m5="DropdownMenuGroup",v5=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(n5,{...s,...r,ref:t})});v5.displayName=m5;var y5="DropdownMenuLabel",OR=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(r5,{...s,...r,ref:t})});OR.displayName=y5;var b5="DropdownMenuItem",NR=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(s5,{...s,...r,ref:t})});NR.displayName=b5;var x5="DropdownMenuCheckboxItem",IR=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(o5,{...s,...r,ref:t})});IR.displayName=x5;var w5="DropdownMenuRadioGroup",S5=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(a5,{...s,...r,ref:t})});S5.displayName=w5;var C5="DropdownMenuRadioItem",DR=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(i5,{...s,...r,ref:t})});DR.displayName=C5;var E5="DropdownMenuItemIndicator",AR=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(l5,{...s,...r,ref:t})});AR.displayName=E5;var T5="DropdownMenuSeparator",FR=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(u5,{...s,...r,ref:t})});FR.displayName=T5;var k5="DropdownMenuArrow",_5=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(c5,{...s,...r,ref:t})});_5.displayName=k5;var j5="DropdownMenuSubTrigger",LR=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(d5,{...s,...r,ref:t})});LR.displayName=j5;var R5="DropdownMenuSubContent",$R=v.forwardRef((e,t)=>{const{__scopeDropdownMenu:n,...r}=e,s=Gn(n);return u.jsx(f5,{...s,...r,ref:t,style:{...e.style,"--radix-dropdown-menu-content-transform-origin":"var(--radix-popper-transform-origin)","--radix-dropdown-menu-content-available-width":"var(--radix-popper-available-width)","--radix-dropdown-menu-content-available-height":"var(--radix-popper-available-height)","--radix-dropdown-menu-trigger-width":"var(--radix-popper-anchor-width)","--radix-dropdown-menu-trigger-height":"var(--radix-popper-anchor-height)"}})});$R.displayName=R5;var P5=nw,M5=rw,O5=RR,BR=MR,zR=OR,UR=NR,VR=IR,HR=DR,KR=AR,Ra=FR,qR=LR,WR=$R;const Eo=P5,To=M5,N5=v.forwardRef(({className:e,inset:t,children:n,...r},s)=>u.jsxs(qR,{ref:s,className:ge("flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",t&&"pl-8",e),...r,children:[n,u.jsx(R3,{className:"ml-auto h-4 w-4"})]}));N5.displayName=qR.displayName;const I5=v.forwardRef(({className:e,...t},n)=>u.jsx(WR,{ref:n,className:ge("z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",e),...t}));I5.displayName=WR.displayName;const ps=v.forwardRef(({className:e,sideOffset:t=4,...n},r)=>u.jsx(O5,{children:u.jsx(BR,{ref:r,sideOffset:t,className:ge("z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",e),...n})}));ps.displayName=BR.displayName;const ft=v.forwardRef(({className:e,inset:t,...n},r)=>u.jsx(UR,{ref:r,className:ge("relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",t&&"pl-8",e),...n}));ft.displayName=UR.displayName;const GR=v.forwardRef(({className:e,children:t,checked:n,...r},s)=>u.jsxs(VR,{ref:s,className:ge("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",e),checked:n,...r,children:[u.jsx("span",{className:"absolute left-2 flex h-3.5 w-3.5 items-center justify-center",children:u.jsx(KR,{children:u.jsx(cj,{className:"h-4 w-4"})})}),t]}));GR.displayName=VR.displayName;const D5=v.forwardRef(({className:e,children:t,...n},r)=>u.jsxs(HR,{ref:r,className:ge("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",e),...n,children:[u.jsx("span",{className:"absolute left-2 flex h-3.5 w-3.5 items-center justify-center",children:u.jsx(KR,{children:u.jsx(N3,{className:"h-2 w-2 fill-current"})})}),t]}));D5.displayName=HR.displayName;const Ai=v.forwardRef(({className:e,inset:t,...n},r)=>u.jsx(zR,{ref:r,className:ge("px-2 py-1.5 text-sm font-semibold",t&&"pl-8",e),...n}));Ai.displayName=zR.displayName;const Pa=v.forwardRef(({className:e,...t},n)=>u.jsx(Ra,{ref:n,className:ge("-mx-1 my-1 h-px bg-muted",e),...t}));Pa.displayName=Ra.displayName;function A5(){const{t:e,i18n:t}=ze(),n=r=>{t.changeLanguage(r),localStorage.setItem("i18nextLng",r),window.location.reload()};return u.jsxs(Eo,{children:[u.jsx(To,{asChild:!0,children:u.jsxs(q,{variant:"outline",size:"icon",children:[u.jsx(z3,{className:"h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all"}),u.jsx("span",{className:"sr-only",children:e("header.theme.label")})]})}),u.jsxs(ps,{align:"end",children:[u.jsx(ft,{className:t.language==="pt-BR"?"font-bold":"",onClick:()=>n("pt-BR"),children:e("header.language.portuguese")}),u.jsx(ft,{className:t.language==="en-US"?"font-bold":"",onClick:()=>n("en-US"),children:e("header.language.english")}),u.jsx(ft,{className:t.language==="es-ES"?"font-bold":"",onClick:()=>n("es-ES"),children:e("header.language.spanish")}),u.jsx(ft,{className:t.language==="fr-FR"?"font-bold":"",onClick:()=>n("fr-FR"),children:e("header.language.french")})]})]})}function F5(){const{t:e}=ze(),{setTheme:t}=R_();return u.jsxs(Eo,{children:[u.jsx(To,{asChild:!0,children:u.jsxs(q,{variant:"outline",size:"icon",children:[u.jsx(G3,{className:"h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"}),u.jsx(K3,{className:"absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"}),u.jsx("span",{className:"sr-only",children:e("header.theme.label")})]})}),u.jsxs(ps,{align:"end",children:[u.jsx(ft,{onClick:()=>t("light"),children:e("header.theme.light")}),u.jsx(ft,{onClick:()=>t("dark"),children:e("header.theme.dark")}),u.jsx(ft,{onClick:()=>t("system"),children:e("header.theme.system")})]})]})}var sw="Avatar",[L5,Gse]=Vr(sw),[$5,JR]=L5(sw),QR=v.forwardRef((e,t)=>{const{__scopeAvatar:n,...r}=e,[s,o]=v.useState("idle");return u.jsx($5,{scope:n,imageLoadingStatus:s,onImageLoadingStatusChange:o,children:u.jsx(Ne.span,{...r,ref:t})})});QR.displayName=sw;var ZR="AvatarImage",YR=v.forwardRef((e,t)=>{const{__scopeAvatar:n,src:r,onLoadingStatusChange:s=()=>{},...o}=e,a=JR(ZR,n),l=B5(r),c=nn(i=>{s(i),a.onImageLoadingStatusChange(i)});return fn(()=>{l!=="idle"&&c(l)},[l,c]),l==="loaded"?u.jsx(Ne.img,{...o,ref:t,src:r}):null});YR.displayName=ZR;var XR="AvatarFallback",eP=v.forwardRef((e,t)=>{const{__scopeAvatar:n,delayMs:r,...s}=e,o=JR(XR,n),[a,l]=v.useState(r===void 0);return v.useEffect(()=>{if(r!==void 0){const c=window.setTimeout(()=>l(!0),r);return()=>window.clearTimeout(c)}},[r]),a&&o.imageLoadingStatus!=="loaded"?u.jsx(Ne.span,{...s,ref:t}):null});eP.displayName=XR;function B5(e){const[t,n]=v.useState("idle");return fn(()=>{if(!e){n("error");return}let r=!0;const s=new window.Image,o=a=>()=>{r&&n(a)};return n("loading"),s.onload=o("loaded"),s.onerror=o("error"),s.src=e,()=>{r=!1}},[e]),t}var tP=QR,nP=YR,rP=eP;const Sg=v.forwardRef(({className:e,...t},n)=>u.jsx(tP,{ref:n,className:ge("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",e),...t}));Sg.displayName=tP.displayName;const Cg=v.forwardRef(({className:e,...t},n)=>u.jsx(nP,{ref:n,className:ge("aspect-square h-full w-full",e),...t}));Cg.displayName=nP.displayName;const z5=v.forwardRef(({className:e,...t},n)=>u.jsx(rP,{ref:n,className:ge("flex h-full w-full items-center justify-center rounded-full bg-muted",e),...t}));z5.displayName=rP.displayName;var ow="Dialog",[sP,Jse]=Vr(ow),[U5,hs]=sP(ow),oP=e=>{const{__scopeDialog:t,children:n,open:r,defaultOpen:s,onOpenChange:o,modal:a=!0}=e,l=v.useRef(null),c=v.useRef(null),[i=!1,d]=pa({prop:r,defaultProp:s,onChange:o});return u.jsx(U5,{scope:t,triggerRef:l,contentRef:c,contentId:os(),titleId:os(),descriptionId:os(),open:i,onOpenChange:d,onOpenToggle:v.useCallback(()=>d(p=>!p),[d]),modal:a,children:n})};oP.displayName=ow;var aP="DialogTrigger",iP=v.forwardRef((e,t)=>{const{__scopeDialog:n,...r}=e,s=hs(aP,n),o=it(t,s.triggerRef);return u.jsx(Ne.button,{type:"button","aria-haspopup":"dialog","aria-expanded":s.open,"aria-controls":s.contentId,"data-state":lw(s.open),...r,ref:o,onClick:Se(e.onClick,s.onOpenToggle)})});iP.displayName=aP;var aw="DialogPortal",[V5,lP]=sP(aw,{forceMount:void 0}),uP=e=>{const{__scopeDialog:t,forceMount:n,children:r,container:s}=e,o=hs(aw,t);return u.jsx(V5,{scope:t,forceMount:n,children:v.Children.map(r,a=>u.jsx(or,{present:n||o.open,children:u.jsx(gg,{asChild:!0,container:s,children:a})}))})};uP.displayName=aw;var lh="DialogOverlay",cP=v.forwardRef((e,t)=>{const n=lP(lh,e.__scopeDialog),{forceMount:r=n.forceMount,...s}=e,o=hs(lh,e.__scopeDialog);return o.modal?u.jsx(or,{present:r||o.open,children:u.jsx(H5,{...s,ref:t})}):null});cP.displayName=lh;var H5=v.forwardRef((e,t)=>{const{__scopeDialog:n,...r}=e,s=hs(lh,n);return u.jsx(bg,{as:mo,allowPinchZoom:!0,shards:[s.contentRef],children:u.jsx(Ne.div,{"data-state":lw(s.open),...r,ref:t,style:{pointerEvents:"auto",...r.style}})})}),Ei="DialogContent",dP=v.forwardRef((e,t)=>{const n=lP(Ei,e.__scopeDialog),{forceMount:r=n.forceMount,...s}=e,o=hs(Ei,e.__scopeDialog);return u.jsx(or,{present:r||o.open,children:o.modal?u.jsx(K5,{...s,ref:t}):u.jsx(q5,{...s,ref:t})})});dP.displayName=Ei;var K5=v.forwardRef((e,t)=>{const n=hs(Ei,e.__scopeDialog),r=v.useRef(null),s=it(t,n.contentRef,r);return v.useEffect(()=>{const o=r.current;if(o)return Wx(o)},[]),u.jsx(fP,{...e,ref:s,trapFocus:n.open,disableOutsidePointerEvents:!0,onCloseAutoFocus:Se(e.onCloseAutoFocus,o=>{var a;o.preventDefault(),(a=n.triggerRef.current)==null||a.focus()}),onPointerDownOutside:Se(e.onPointerDownOutside,o=>{const a=o.detail.originalEvent,l=a.button===0&&a.ctrlKey===!0;(a.button===2||l)&&o.preventDefault()}),onFocusOutside:Se(e.onFocusOutside,o=>o.preventDefault())})}),q5=v.forwardRef((e,t)=>{const n=hs(Ei,e.__scopeDialog),r=v.useRef(!1),s=v.useRef(!1);return u.jsx(fP,{...e,ref:t,trapFocus:!1,disableOutsidePointerEvents:!1,onCloseAutoFocus:o=>{var a,l;(a=e.onCloseAutoFocus)==null||a.call(e,o),o.defaultPrevented||(r.current||(l=n.triggerRef.current)==null||l.focus(),o.preventDefault()),r.current=!1,s.current=!1},onInteractOutside:o=>{var c,i;(c=e.onInteractOutside)==null||c.call(e,o),o.defaultPrevented||(r.current=!0,o.detail.originalEvent.type==="pointerdown"&&(s.current=!0));const a=o.target;((i=n.triggerRef.current)==null?void 0:i.contains(a))&&o.preventDefault(),o.detail.originalEvent.type==="focusin"&&s.current&&o.preventDefault()}})}),fP=v.forwardRef((e,t)=>{const{__scopeDialog:n,trapFocus:r,onOpenAutoFocus:s,onCloseAutoFocus:o,...a}=e,l=hs(Ei,n),c=v.useRef(null),i=it(t,c);return Lx(),u.jsxs(u.Fragment,{children:[u.jsx(dg,{asChild:!0,loop:!0,trapped:r,onMountAutoFocus:s,onUnmountAutoFocus:o,children:u.jsx(cg,{role:"dialog",id:l.contentId,"aria-describedby":l.descriptionId,"aria-labelledby":l.titleId,"data-state":lw(l.open),...a,ref:i,onDismiss:()=>l.onOpenChange(!1)})}),u.jsxs(u.Fragment,{children:[u.jsx(W5,{titleId:l.titleId}),u.jsx(J5,{contentRef:c,descriptionId:l.descriptionId})]})]})}),iw="DialogTitle",pP=v.forwardRef((e,t)=>{const{__scopeDialog:n,...r}=e,s=hs(iw,n);return u.jsx(Ne.h2,{id:s.titleId,...r,ref:t})});pP.displayName=iw;var hP="DialogDescription",gP=v.forwardRef((e,t)=>{const{__scopeDialog:n,...r}=e,s=hs(hP,n);return u.jsx(Ne.p,{id:s.descriptionId,...r,ref:t})});gP.displayName=hP;var mP="DialogClose",vP=v.forwardRef((e,t)=>{const{__scopeDialog:n,...r}=e,s=hs(mP,n);return u.jsx(Ne.button,{type:"button",...r,ref:t,onClick:Se(e.onClick,()=>s.onOpenChange(!1))})});vP.displayName=mP;function lw(e){return e?"open":"closed"}var yP="DialogTitleWarning",[Qse,bP]=X3(yP,{contentName:Ei,titleName:iw,docsSlug:"dialog"}),W5=({titleId:e})=>{const t=bP(yP),n=`\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;return v.useEffect(()=>{e&&(document.getElementById(e)||console.error(n))},[n,e]),null},G5="DialogDescriptionWarning",J5=({contentRef:e,descriptionId:t})=>{const r=`Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${bP(G5).contentName}}.`;return v.useEffect(()=>{var o;const s=(o=e.current)==null?void 0:o.getAttribute("aria-describedby");t&&s&&(document.getElementById(t)||console.warn(r))},[r,e,t]),null},Q5=oP,Z5=iP,Y5=uP,xP=cP,wP=dP,SP=pP,CP=gP,EP=vP;const Tt=Q5,Nt=Z5,X5=Y5,TP=EP,kP=v.forwardRef(({className:e,...t},n)=>u.jsx(xP,{ref:n,className:ge("fixed inset-0 z-50 bg-background/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",e),...t}));kP.displayName=xP.displayName;const xt=v.forwardRef(({className:e,children:t,closeBtn:n=!0,...r},s)=>u.jsx(X5,{children:u.jsx(kP,{className:"fixed inset-0 grid place-items-center overflow-y-auto",children:u.jsxs(wP,{ref:s,className:ge("relative z-50 grid w-full max-w-lg gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:m-4 sm:rounded-lg md:w-full",e),...r,children:[t,n&&u.jsxs(EP,{className:"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",children:[u.jsx(Q3,{className:"h-4 w-4"}),u.jsx("span",{className:"sr-only",children:"Close"})]})]})})}));xt.displayName=wP.displayName;const wt=({className:e,...t})=>u.jsx("div",{className:ge("flex flex-col space-y-1.5 text-center sm:text-left",e),...t});wt.displayName="DialogHeader";const rn=({className:e,...t})=>u.jsx("div",{className:ge("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",e),...t});rn.displayName="DialogFooter";const Ut=v.forwardRef(({className:e,...t},n)=>u.jsx(SP,{ref:n,className:ge("text-lg font-semibold leading-none tracking-tight",e),...t}));Ut.displayName=SP.displayName;const Fi=v.forwardRef(({className:e,...t},n)=>u.jsx(CP,{ref:n,className:ge("text-sm text-muted-foreground",e),...t}));Fi.displayName=CP.displayName;function _P({instanceId:e}){const[t,n]=v.useState(!1),r=An(),s=()=>{M_(),r("/manager/login")},o=()=>{r("/manager/")},{data:a}=hj({instanceId:e});return u.jsxs("header",{className:"flex items-center justify-between px-4 py-2",children:[u.jsxs(nd,{to:"/manager",onClick:o,className:"flex h-8 items-center gap-4",children:[u.jsx("img",{src:"/assets/images/evolution-logo.png",alt:"Logo",className:"h-full"}),u.jsx("span",{children:"Evolution Manager"})]}),u.jsxs("div",{className:"flex items-center gap-4",children:[e&&u.jsx(Sg,{className:"h-8 w-8",children:u.jsx(Cg,{src:(a==null?void 0:a.profilePicUrl)||"/assets/images/evolution-logo.png",alt:a==null?void 0:a.name})}),u.jsx(A5,{}),u.jsx(F5,{}),u.jsx(q,{onClick:()=>n(!0),variant:"destructive",size:"icon",children:u.jsx(D3,{size:"18"})})]}),t&&u.jsx(Tt,{onOpenChange:n,open:t,children:u.jsxs(xt,{children:[u.jsx(TP,{}),u.jsx(wt,{children:"Deseja realmente sair?"}),u.jsx(rn,{children:u.jsxs("div",{className:"flex items-center gap-4",children:[u.jsx(q,{onClick:()=>n(!1),size:"sm",variant:"outline",children:"Cancelar"}),u.jsx(q,{onClick:s,variant:"destructive",children:"Sair"})]})})]})})]})}const jP=v.createContext(null),nt=()=>{const e=v.useContext(jP);if(!e)throw new Error("useInstance must be used within an InstanceProvider");return e},eV=({children:e})=>{const t=So(),[n,r]=v.useState(null),{data:s,refetch:o}=hj({instanceId:n});return v.useEffect(()=>{t.instanceId?r(t.instanceId):r(null)},[t]),u.jsx(jP.Provider,{value:{instance:s??null,reloadInstance:async()=>{await o()}},children:e})};var uw="Collapsible",[tV,Zse]=Vr(uw),[nV,cw]=tV(uw),RP=v.forwardRef((e,t)=>{const{__scopeCollapsible:n,open:r,defaultOpen:s,disabled:o,onOpenChange:a,...l}=e,[c=!1,i]=pa({prop:r,defaultProp:s,onChange:a});return u.jsx(nV,{scope:n,disabled:o,contentId:os(),open:c,onOpenToggle:v.useCallback(()=>i(d=>!d),[i]),children:u.jsx(Ne.div,{"data-state":fw(c),"data-disabled":o?"":void 0,...l,ref:t})})});RP.displayName=uw;var PP="CollapsibleTrigger",MP=v.forwardRef((e,t)=>{const{__scopeCollapsible:n,...r}=e,s=cw(PP,n);return u.jsx(Ne.button,{type:"button","aria-controls":s.contentId,"aria-expanded":s.open||!1,"data-state":fw(s.open),"data-disabled":s.disabled?"":void 0,disabled:s.disabled,...r,ref:t,onClick:Se(e.onClick,s.onOpenToggle)})});MP.displayName=PP;var dw="CollapsibleContent",OP=v.forwardRef((e,t)=>{const{forceMount:n,...r}=e,s=cw(dw,e.__scopeCollapsible);return u.jsx(or,{present:n||s.open,children:({present:o})=>u.jsx(rV,{...r,ref:t,present:o})})});OP.displayName=dw;var rV=v.forwardRef((e,t)=>{const{__scopeCollapsible:n,present:r,children:s,...o}=e,a=cw(dw,n),[l,c]=v.useState(r),i=v.useRef(null),d=it(t,i),p=v.useRef(0),f=p.current,h=v.useRef(0),g=h.current,m=a.open||l,x=v.useRef(m),b=v.useRef();return v.useEffect(()=>{const y=requestAnimationFrame(()=>x.current=!1);return()=>cancelAnimationFrame(y)},[]),fn(()=>{const y=i.current;if(y){b.current=b.current||{transitionDuration:y.style.transitionDuration,animationName:y.style.animationName},y.style.transitionDuration="0s",y.style.animationName="none";const w=y.getBoundingClientRect();p.current=w.height,h.current=w.width,x.current||(y.style.transitionDuration=b.current.transitionDuration,y.style.animationName=b.current.animationName),c(r)}},[a.open,r]),u.jsx(Ne.div,{"data-state":fw(a.open),"data-disabled":a.disabled?"":void 0,id:a.contentId,hidden:!m,...o,ref:d,style:{"--radix-collapsible-content-height":f?`${f}px`:void 0,"--radix-collapsible-content-width":g?`${g}px`:void 0,...e.style},children:m&&s})});function fw(e){return e?"open":"closed"}var sV=RP;const oV=sV,aV=MP,iV=OP;function lV(){const{t:e}=ze(),t=v.useMemo(()=>[{id:"dashboard",title:e("sidebar.dashboard"),icon:U3,path:"dashboard"},{navLabel:!0,title:e("sidebar.configurations"),icon:Oi,children:[{id:"settings",title:e("sidebar.settings"),path:"settings"},{id:"proxy",title:e("sidebar.proxy"),path:"proxy"}]},{title:e("sidebar.events"),icon:B3,children:[{id:"webhook",title:e("sidebar.webhook"),path:"webhook"},{id:"websocket",title:e("sidebar.websocket"),path:"websocket"},{id:"rabbitmq",title:e("sidebar.rabbitmq"),path:"rabbitmq"},{id:"sqs",title:e("sidebar.sqs"),path:"sqs"}]},{title:e("sidebar.integrations"),icon:pj,children:[{id:"evolutionBot",title:e("sidebar.evolutionBot"),path:"evolutionBot"},{id:"chatwoot",title:e("sidebar.chatwoot"),path:"chatwoot"},{id:"typebot",title:e("sidebar.typebot"),path:"typebot"},{id:"openai",title:e("sidebar.openai"),path:"openai"},{id:"dify",title:e("sidebar.dify"),path:"dify"},{id:"flowise",title:e("sidebar.flowise"),path:"flowise"}]},{id:"documentation",title:e("sidebar.documentation"),icon:L3,link:"https://doc.evolution-api.com",divider:!0},{id:"postman",title:e("sidebar.postman"),icon:O3,link:"https://evolution-api.com/postman"},{id:"discord",title:e("sidebar.discord"),icon:ug,link:"https://evolution-api.com/discord"},{id:"support-premium",title:e("sidebar.supportPremium"),icon:V3,link:"https://evolution-api.com/suporte-pro"}],[e]),n=An(),{pathname:r}=pu(),{instance:s}=nt(),o=l=>{!l||!s||(l.path&&n(`/manager/instance/${s.id}/${l.path}`),l.link&&window.open(l.link,"_blank"))},a=v.useMemo(()=>t.map(l=>{var c;return{...l,children:"children"in l?(c=l.children)==null?void 0:c.map(i=>({...i,isActive:"path"in i?r.includes(i.path):!1})):void 0,isActive:"path"in l&&l.path?r.includes(l.path):!1}}).map(l=>{var c;return{...l,isActive:l.isActive||"children"in l&&((c=l.children)==null?void 0:c.some(i=>i.isActive))}}),[t,r]);return u.jsx("ul",{className:"flex h-full w-full flex-col gap-2 border-r border-border px-2",children:a.map(l=>u.jsx("li",{className:"divider"in l?"mt-auto":void 0,children:l.children?u.jsxs(oV,{defaultOpen:l.isActive,children:[u.jsx(aV,{asChild:!0,children:u.jsxs(q,{className:ge("flex w-full items-center justify-start gap-2"),variant:l.isActive?"secondary":"link",children:[l.icon&&u.jsx(l.icon,{size:"15"}),u.jsx("span",{children:l.title}),u.jsx(lg,{size:"15",className:"ml-auto"})]})}),u.jsx(iV,{children:u.jsx("ul",{className:"my-4 ml-6 flex flex-col gap-2 text-sm",children:l.children.map(c=>u.jsx("li",{children:u.jsx("button",{onClick:()=>o(c),className:ge(c.isActive?"text-foreground":"text-muted-foreground"),children:u.jsx("span",{className:"nav-label",children:c.title})})},c.id))})})]}):u.jsxs(q,{className:ge("relative flex w-full items-center justify-start gap-2",l.isActive&&"pointer-events-none"),variant:l.isActive?"secondary":"link",children:["link"in l&&u.jsx("a",{href:l.link,target:"_blank",rel:"noreferrer",className:"absolute inset-0 h-full w-full"}),"path"in l&&u.jsx(nd,{to:`/manager/instance/${s==null?void 0:s.id}/${l.path}`,className:"absolute inset-0 h-full w-full"}),l.icon&&u.jsx(l.icon,{size:"15"}),u.jsx("span",{children:l.title})]})},l.title))})}function Zy(e,[t,n]){return Math.min(n,Math.max(t,e))}function uV(e,t){return v.useReducer((n,r)=>t[n][r]??n,e)}var pw="ScrollArea",[NP,Yse]=Vr(pw),[cV,Hr]=NP(pw),IP=v.forwardRef((e,t)=>{const{__scopeScrollArea:n,type:r="hover",dir:s,scrollHideDelay:o=600,...a}=e,[l,c]=v.useState(null),[i,d]=v.useState(null),[p,f]=v.useState(null),[h,g]=v.useState(null),[m,x]=v.useState(null),[b,y]=v.useState(0),[w,S]=v.useState(0),[E,C]=v.useState(!1),[k,T]=v.useState(!1),P=it(t,U=>c(U)),N=Gd(s);return u.jsx(cV,{scope:n,type:r,dir:N,scrollHideDelay:o,scrollArea:l,viewport:i,onViewportChange:d,content:p,onContentChange:f,scrollbarX:h,onScrollbarXChange:g,scrollbarXEnabled:E,onScrollbarXEnabledChange:C,scrollbarY:m,onScrollbarYChange:x,scrollbarYEnabled:k,onScrollbarYEnabledChange:T,onCornerWidthChange:y,onCornerHeightChange:S,children:u.jsx(Ne.div,{dir:N,...a,ref:P,style:{position:"relative","--radix-scroll-area-corner-width":b+"px","--radix-scroll-area-corner-height":w+"px",...e.style}})})});IP.displayName=pw;var DP="ScrollAreaViewport",AP=v.forwardRef((e,t)=>{const{__scopeScrollArea:n,children:r,nonce:s,...o}=e,a=Hr(DP,n),l=v.useRef(null),c=it(t,l,a.onViewportChange);return u.jsxs(u.Fragment,{children:[u.jsx("style",{dangerouslySetInnerHTML:{__html:"[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"},nonce:s}),u.jsx(Ne.div,{"data-radix-scroll-area-viewport":"",...o,ref:c,style:{overflowX:a.scrollbarXEnabled?"scroll":"hidden",overflowY:a.scrollbarYEnabled?"scroll":"hidden",...e.style},children:u.jsx("div",{ref:a.onContentChange,style:{minWidth:"100%",display:"table"},children:r})})]})});AP.displayName=DP;var Hs="ScrollAreaScrollbar",hw=v.forwardRef((e,t)=>{const{forceMount:n,...r}=e,s=Hr(Hs,e.__scopeScrollArea),{onScrollbarXEnabledChange:o,onScrollbarYEnabledChange:a}=s,l=e.orientation==="horizontal";return v.useEffect(()=>(l?o(!0):a(!0),()=>{l?o(!1):a(!1)}),[l,o,a]),s.type==="hover"?u.jsx(dV,{...r,ref:t,forceMount:n}):s.type==="scroll"?u.jsx(fV,{...r,ref:t,forceMount:n}):s.type==="auto"?u.jsx(FP,{...r,ref:t,forceMount:n}):s.type==="always"?u.jsx(gw,{...r,ref:t}):null});hw.displayName=Hs;var dV=v.forwardRef((e,t)=>{const{forceMount:n,...r}=e,s=Hr(Hs,e.__scopeScrollArea),[o,a]=v.useState(!1);return v.useEffect(()=>{const l=s.scrollArea;let c=0;if(l){const i=()=>{window.clearTimeout(c),a(!0)},d=()=>{c=window.setTimeout(()=>a(!1),s.scrollHideDelay)};return l.addEventListener("pointerenter",i),l.addEventListener("pointerleave",d),()=>{window.clearTimeout(c),l.removeEventListener("pointerenter",i),l.removeEventListener("pointerleave",d)}}},[s.scrollArea,s.scrollHideDelay]),u.jsx(or,{present:n||o,children:u.jsx(FP,{"data-state":o?"visible":"hidden",...r,ref:t})})}),fV=v.forwardRef((e,t)=>{const{forceMount:n,...r}=e,s=Hr(Hs,e.__scopeScrollArea),o=e.orientation==="horizontal",a=Tg(()=>c("SCROLL_END"),100),[l,c]=uV("hidden",{hidden:{SCROLL:"scrolling"},scrolling:{SCROLL_END:"idle",POINTER_ENTER:"interacting"},interacting:{SCROLL:"interacting",POINTER_LEAVE:"idle"},idle:{HIDE:"hidden",SCROLL:"scrolling",POINTER_ENTER:"interacting"}});return v.useEffect(()=>{if(l==="idle"){const i=window.setTimeout(()=>c("HIDE"),s.scrollHideDelay);return()=>window.clearTimeout(i)}},[l,s.scrollHideDelay,c]),v.useEffect(()=>{const i=s.viewport,d=o?"scrollLeft":"scrollTop";if(i){let p=i[d];const f=()=>{const h=i[d];p!==h&&(c("SCROLL"),a()),p=h};return i.addEventListener("scroll",f),()=>i.removeEventListener("scroll",f)}},[s.viewport,o,c,a]),u.jsx(or,{present:n||l!=="hidden",children:u.jsx(gw,{"data-state":l==="hidden"?"hidden":"visible",...r,ref:t,onPointerEnter:Se(e.onPointerEnter,()=>c("POINTER_ENTER")),onPointerLeave:Se(e.onPointerLeave,()=>c("POINTER_LEAVE"))})})}),FP=v.forwardRef((e,t)=>{const n=Hr(Hs,e.__scopeScrollArea),{forceMount:r,...s}=e,[o,a]=v.useState(!1),l=e.orientation==="horizontal",c=Tg(()=>{if(n.viewport){const i=n.viewport.offsetWidth<n.viewport.scrollWidth,d=n.viewport.offsetHeight<n.viewport.scrollHeight;a(l?i:d)}},10);return tu(n.viewport,c),tu(n.content,c),u.jsx(or,{present:r||o,children:u.jsx(gw,{"data-state":o?"visible":"hidden",...s,ref:t})})}),gw=v.forwardRef((e,t)=>{const{orientation:n="vertical",...r}=e,s=Hr(Hs,e.__scopeScrollArea),o=v.useRef(null),a=v.useRef(0),[l,c]=v.useState({content:0,viewport:0,scrollbar:{size:0,paddingStart:0,paddingEnd:0}}),i=UP(l.viewport,l.content),d={...r,sizes:l,onSizesChange:c,hasThumb:i>0&&i<1,onThumbChange:f=>o.current=f,onThumbPointerUp:()=>a.current=0,onThumbPointerDown:f=>a.current=f};function p(f,h){return yV(f,a.current,l,h)}return n==="horizontal"?u.jsx(pV,{...d,ref:t,onThumbPositionChange:()=>{if(s.viewport&&o.current){const f=s.viewport.scrollLeft,h=SC(f,l,s.dir);o.current.style.transform=`translate3d(${h}px, 0, 0)`}},onWheelScroll:f=>{s.viewport&&(s.viewport.scrollLeft=f)},onDragScroll:f=>{s.viewport&&(s.viewport.scrollLeft=p(f,s.dir))}}):n==="vertical"?u.jsx(hV,{...d,ref:t,onThumbPositionChange:()=>{if(s.viewport&&o.current){const f=s.viewport.scrollTop,h=SC(f,l);o.current.style.transform=`translate3d(0, ${h}px, 0)`}},onWheelScroll:f=>{s.viewport&&(s.viewport.scrollTop=f)},onDragScroll:f=>{s.viewport&&(s.viewport.scrollTop=p(f))}}):null}),pV=v.forwardRef((e,t)=>{const{sizes:n,onSizesChange:r,...s}=e,o=Hr(Hs,e.__scopeScrollArea),[a,l]=v.useState(),c=v.useRef(null),i=it(t,c,o.onScrollbarXChange);return v.useEffect(()=>{c.current&&l(getComputedStyle(c.current))},[c]),u.jsx($P,{"data-orientation":"horizontal",...s,ref:i,sizes:n,style:{bottom:0,left:o.dir==="rtl"?"var(--radix-scroll-area-corner-width)":0,right:o.dir==="ltr"?"var(--radix-scroll-area-corner-width)":0,"--radix-scroll-area-thumb-width":Eg(n)+"px",...e.style},onThumbPointerDown:d=>e.onThumbPointerDown(d.x),onDragScroll:d=>e.onDragScroll(d.x),onWheelScroll:(d,p)=>{if(o.viewport){const f=o.viewport.scrollLeft+d.deltaX;e.onWheelScroll(f),HP(f,p)&&d.preventDefault()}},onResize:()=>{c.current&&o.viewport&&a&&r({content:o.viewport.scrollWidth,viewport:o.viewport.offsetWidth,scrollbar:{size:c.current.clientWidth,paddingStart:ch(a.paddingLeft),paddingEnd:ch(a.paddingRight)}})}})}),hV=v.forwardRef((e,t)=>{const{sizes:n,onSizesChange:r,...s}=e,o=Hr(Hs,e.__scopeScrollArea),[a,l]=v.useState(),c=v.useRef(null),i=it(t,c,o.onScrollbarYChange);return v.useEffect(()=>{c.current&&l(getComputedStyle(c.current))},[c]),u.jsx($P,{"data-orientation":"vertical",...s,ref:i,sizes:n,style:{top:0,right:o.dir==="ltr"?0:void 0,left:o.dir==="rtl"?0:void 0,bottom:"var(--radix-scroll-area-corner-height)","--radix-scroll-area-thumb-height":Eg(n)+"px",...e.style},onThumbPointerDown:d=>e.onThumbPointerDown(d.y),onDragScroll:d=>e.onDragScroll(d.y),onWheelScroll:(d,p)=>{if(o.viewport){const f=o.viewport.scrollTop+d.deltaY;e.onWheelScroll(f),HP(f,p)&&d.preventDefault()}},onResize:()=>{c.current&&o.viewport&&a&&r({content:o.viewport.scrollHeight,viewport:o.viewport.offsetHeight,scrollbar:{size:c.current.clientHeight,paddingStart:ch(a.paddingTop),paddingEnd:ch(a.paddingBottom)}})}})}),[gV,LP]=NP(Hs),$P=v.forwardRef((e,t)=>{const{__scopeScrollArea:n,sizes:r,hasThumb:s,onThumbChange:o,onThumbPointerUp:a,onThumbPointerDown:l,onThumbPositionChange:c,onDragScroll:i,onWheelScroll:d,onResize:p,...f}=e,h=Hr(Hs,n),[g,m]=v.useState(null),x=it(t,P=>m(P)),b=v.useRef(null),y=v.useRef(""),w=h.viewport,S=r.content-r.viewport,E=nn(d),C=nn(c),k=Tg(p,10);function T(P){if(b.current){const N=P.clientX-b.current.left,U=P.clientY-b.current.top;i({x:N,y:U})}}return v.useEffect(()=>{const P=N=>{const U=N.target;(g==null?void 0:g.contains(U))&&E(N,S)};return document.addEventListener("wheel",P,{passive:!1}),()=>document.removeEventListener("wheel",P,{passive:!1})},[w,g,S,E]),v.useEffect(C,[r,C]),tu(g,k),tu(h.content,k),u.jsx(gV,{scope:n,scrollbar:g,hasThumb:s,onThumbChange:nn(o),onThumbPointerUp:nn(a),onThumbPositionChange:C,onThumbPointerDown:nn(l),children:u.jsx(Ne.div,{...f,ref:x,style:{position:"absolute",...f.style},onPointerDown:Se(e.onPointerDown,P=>{P.button===0&&(P.target.setPointerCapture(P.pointerId),b.current=g.getBoundingClientRect(),y.current=document.body.style.webkitUserSelect,document.body.style.webkitUserSelect="none",h.viewport&&(h.viewport.style.scrollBehavior="auto"),T(P))}),onPointerMove:Se(e.onPointerMove,T),onPointerUp:Se(e.onPointerUp,P=>{const N=P.target;N.hasPointerCapture(P.pointerId)&&N.releasePointerCapture(P.pointerId),document.body.style.webkitUserSelect=y.current,h.viewport&&(h.viewport.style.scrollBehavior=""),b.current=null})})})}),uh="ScrollAreaThumb",BP=v.forwardRef((e,t)=>{const{forceMount:n,...r}=e,s=LP(uh,e.__scopeScrollArea);return u.jsx(or,{present:n||s.hasThumb,children:u.jsx(mV,{ref:t,...r})})}),mV=v.forwardRef((e,t)=>{const{__scopeScrollArea:n,style:r,...s}=e,o=Hr(uh,n),a=LP(uh,n),{onThumbPositionChange:l}=a,c=it(t,p=>a.onThumbChange(p)),i=v.useRef(),d=Tg(()=>{i.current&&(i.current(),i.current=void 0)},100);return v.useEffect(()=>{const p=o.viewport;if(p){const f=()=>{if(d(),!i.current){const h=bV(p,l);i.current=h,l()}};return l(),p.addEventListener("scroll",f),()=>p.removeEventListener("scroll",f)}},[o.viewport,d,l]),u.jsx(Ne.div,{"data-state":a.hasThumb?"visible":"hidden",...s,ref:c,style:{width:"var(--radix-scroll-area-thumb-width)",height:"var(--radix-scroll-area-thumb-height)",...r},onPointerDownCapture:Se(e.onPointerDownCapture,p=>{const h=p.target.getBoundingClientRect(),g=p.clientX-h.left,m=p.clientY-h.top;a.onThumbPointerDown({x:g,y:m})}),onPointerUp:Se(e.onPointerUp,a.onThumbPointerUp)})});BP.displayName=uh;var mw="ScrollAreaCorner",zP=v.forwardRef((e,t)=>{const n=Hr(mw,e.__scopeScrollArea),r=!!(n.scrollbarX&&n.scrollbarY);return n.type!=="scroll"&&r?u.jsx(vV,{...e,ref:t}):null});zP.displayName=mw;var vV=v.forwardRef((e,t)=>{const{__scopeScrollArea:n,...r}=e,s=Hr(mw,n),[o,a]=v.useState(0),[l,c]=v.useState(0),i=!!(o&&l);return tu(s.scrollbarX,()=>{var p;const d=((p=s.scrollbarX)==null?void 0:p.offsetHeight)||0;s.onCornerHeightChange(d),c(d)}),tu(s.scrollbarY,()=>{var p;const d=((p=s.scrollbarY)==null?void 0:p.offsetWidth)||0;s.onCornerWidthChange(d),a(d)}),i?u.jsx(Ne.div,{...r,ref:t,style:{width:o,height:l,position:"absolute",right:s.dir==="ltr"?0:void 0,left:s.dir==="rtl"?0:void 0,bottom:0,...e.style}}):null});function ch(e){return e?parseInt(e,10):0}function UP(e,t){const n=e/t;return isNaN(n)?0:n}function Eg(e){const t=UP(e.viewport,e.content),n=e.scrollbar.paddingStart+e.scrollbar.paddingEnd,r=(e.scrollbar.size-n)*t;return Math.max(r,18)}function yV(e,t,n,r="ltr"){const s=Eg(n),o=s/2,a=t||o,l=s-a,c=n.scrollbar.paddingStart+a,i=n.scrollbar.size-n.scrollbar.paddingEnd-l,d=n.content-n.viewport,p=r==="ltr"?[0,d]:[d*-1,0];return VP([c,i],p)(e)}function SC(e,t,n="ltr"){const r=Eg(t),s=t.scrollbar.paddingStart+t.scrollbar.paddingEnd,o=t.scrollbar.size-s,a=t.content-t.viewport,l=o-r,c=n==="ltr"?[0,a]:[a*-1,0],i=Zy(e,c);return VP([0,a],[0,l])(i)}function VP(e,t){return n=>{if(e[0]===e[1]||t[0]===t[1])return t[0];const r=(t[1]-t[0])/(e[1]-e[0]);return t[0]+r*(n-e[0])}}function HP(e,t){return e>0&&e<t}var bV=(e,t=()=>{})=>{let n={left:e.scrollLeft,top:e.scrollTop},r=0;return function s(){const o={left:e.scrollLeft,top:e.scrollTop},a=n.left!==o.left,l=n.top!==o.top;(a||l)&&t(),n=o,r=window.requestAnimationFrame(s)}(),()=>window.cancelAnimationFrame(r)};function Tg(e,t){const n=nn(e),r=v.useRef(0);return v.useEffect(()=>()=>window.clearTimeout(r.current),[]),v.useCallback(()=>{window.clearTimeout(r.current),r.current=window.setTimeout(n,t)},[n,t])}function tu(e,t){const n=nn(t);fn(()=>{let r=0;if(e){const s=new ResizeObserver(()=>{cancelAnimationFrame(r),r=window.requestAnimationFrame(n)});return s.observe(e),()=>{window.cancelAnimationFrame(r),s.unobserve(e)}}},[e,n])}var KP=IP,xV=AP,wV=zP;const Yy=v.forwardRef(({className:e,children:t,...n},r)=>u.jsxs(KP,{ref:r,className:ge("relative overflow-hidden",e),...n,children:[u.jsx(xV,{className:"h-full w-full rounded-[inherit] [&>div[style]]:!block [&>div[style]]:h-full",children:t}),u.jsx(qP,{}),u.jsx(wV,{})]}));Yy.displayName=KP.displayName;const qP=v.forwardRef(({className:e,orientation:t="vertical",...n},r)=>u.jsx(hw,{ref:r,orientation:t,className:ge("flex touch-none select-none transition-colors",t==="vertical"&&"h-full w-2.5 border-l border-l-transparent p-[1px]",t==="horizontal"&&"h-2.5 border-t border-t-transparent p-[1px]",e),...n,children:u.jsx(BP,{className:ge("relative rounded-full bg-border",t==="vertical"&&"flex-1")})}));qP.displayName=hw.displayName;function Xt({children:e}){const{instanceId:t}=So();return u.jsx(eV,{children:u.jsxs("div",{className:"flex h-screen flex-col",children:[u.jsx(_P,{instanceId:t}),u.jsxs("div",{className:"flex min-h-[calc(100vh_-_56px)] flex-1 flex-col md:flex-row",children:[u.jsx(Yy,{className:"mr-2 py-6 md:w-64",children:u.jsx("div",{className:"flex h-full",children:u.jsx(lV,{})})}),u.jsx(Yy,{className:"w-full",children:u.jsxs("div",{className:"flex h-full flex-col",children:[u.jsx("div",{className:"my-6 flex flex-1 flex-col gap-2 pl-2 pr-4",children:e}),u.jsx(Ax,{})]})})]})]})})}function SV({children:e}){return u.jsxs("div",{className:"flex h-full min-h-screen flex-col",children:[u.jsx(_P,{}),u.jsx("main",{className:"flex-1",children:e}),u.jsx(Ax,{})]})}const CV=ig("inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",{variants:{variant:{default:"border-transparent bg-primary text-primary-foreground hover:bg-primary/80",secondary:"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",destructive:"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",outline:"text-foreground",warning:"border-transparent bg-amber-600 text-amber-100 hover:bg-amber-600/80"}},defaultVariants:{variant:"default"}});function Ff({className:e,variant:t,...n}){return u.jsx("div",{className:ge(CV({variant:t}),e),...n})}function WP({status:e}){const{t}=ze();return e?e==="open"?u.jsx(Ff,{children:t("status.open")}):e==="connecting"?u.jsx(Ff,{variant:"warning",children:t("status.connecting")}):e==="close"||e==="closed"?u.jsx(Ff,{variant:"destructive",children:t("status.closed")}):u.jsx(Ff,{variant:"secondary",children:e}):null}const EV=e=>{navigator.clipboard.writeText(e),X.success("Copiado para a área de transferência")};function GP({token:e,className:t}){const[n,r]=v.useState(!1);return u.jsxs("div",{className:ge("flex items-center gap-3 truncate rounded-sm bg-primary/20 px-2 py-1",t),children:[u.jsx("pre",{className:"block truncate text-xs",children:n?e:e==null?void 0:e.replace(/\w/g,"*")}),u.jsx(q,{variant:"ghost",size:"icon",onClick:()=>{EV(e)},children:u.jsx(I3,{size:"15"})}),u.jsx(q,{variant:"ghost",size:"icon",onClick:()=>{r(s=>!s)},children:n?u.jsx(A3,{size:"15"}):u.jsx(F3,{size:"15"})})]})}const Ja=v.forwardRef(({className:e,...t},n)=>u.jsx("div",{ref:n,className:ge("flex flex-col rounded-lg border bg-card text-card-foreground shadow-sm",e),...t}));Ja.displayName="Card";const Qa=v.forwardRef(({className:e,...t},n)=>u.jsx("div",{ref:n,className:ge("flex flex-col space-y-1.5 p-6",e),...t}));Qa.displayName="CardHeader";const jc=v.forwardRef(({className:e,...t},n)=>u.jsx("h3",{ref:n,className:ge("text-2xl font-semibold leading-none tracking-tight",e),...t}));jc.displayName="CardTitle";const JP=v.forwardRef(({className:e,...t},n)=>u.jsx("p",{ref:n,className:ge("text-sm text-muted-foreground",e),...t}));JP.displayName="CardDescription";const Za=v.forwardRef(({className:e,...t},n)=>u.jsx("div",{ref:n,className:ge("p-6 pt-0",e),...t}));Za.displayName="CardContent";const kg=v.forwardRef(({className:e,...t},n)=>u.jsx("div",{ref:n,className:ge("flex items-center p-6 pt-0",e),...t}));kg.displayName="CardFooter";const QP="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",K=v.forwardRef(({className:e,type:t,...n},r)=>u.jsx("input",{type:t,className:ge(QP,e),ref:r,...n}));K.displayName="Input";const TV=["instance","fetchInstances"],kV=async()=>(await he.get("/instance/fetchInstances")).data,_V=e=>lt({...e,queryKey:TV,queryFn:()=>kV()});function Ye(e,t){const n=Ab(),r=WD({mutationFn:e});return(s,o)=>r.mutateAsync(s,{onSuccess:async(a,l,c)=>{var i;t!=null&&t.invalidateKeys&&await Promise.all(t.invalidateKeys.map(d=>n.invalidateQueries({queryKey:d}))),(i=o==null?void 0:o.onSuccess)==null||i.call(o,a,l,c)},onError(a,l,c){var i;(i=o==null?void 0:o.onError)==null||i.call(o,a,l,c)},onSettled(a,l,c,i){var d;(d=o==null?void 0:o.onSettled)==null||d.call(o,a,l,c,i)}})}const jV=async e=>(await he.post("/instance/create",e)).data,RV=async e=>(await he.post(`/instance/restart/${e}`)).data,PV=async e=>(await he.delete(`/instance/logout/${e}`)).data,MV=async e=>(await he.delete(`/instance/delete/${e}`)).data,OV=async({instanceName:e,token:t,number:n})=>(await he.get(`/instance/connect/${e}`,{headers:{apikey:t},params:{number:n}})).data,NV=async({instanceName:e,token:t,data:n})=>(await he.post(`/settings/set/${e}`,n,{headers:{apikey:t}})).data;function _g(){const e=Ye(OV,{invalidateKeys:[["instance","fetchInstance"],["instance","fetchInstances"]]}),t=Ye(NV,{invalidateKeys:[["instance","fetchSettings"]]}),n=Ye(MV,{invalidateKeys:[["instance","fetchInstance"],["instance","fetchInstances"]]}),r=Ye(PV,{invalidateKeys:[["instance","fetchInstance"],["instance","fetchInstances"]]}),s=Ye(RV,{invalidateKeys:[["instance","fetchInstance"],["instance","fetchInstances"]]}),o=Ye(jV,{invalidateKeys:[["instance","fetchInstances"]]});return{connect:e,updateSettings:t,deleteInstance:n,logout:r,restart:s,createInstance:o}}var Yd=e=>e.type==="checkbox",ml=e=>e instanceof Date,Un=e=>e==null;const ZP=e=>typeof e=="object";var pn=e=>!Un(e)&&!Array.isArray(e)&&ZP(e)&&!ml(e),YP=e=>pn(e)&&e.target?Yd(e.target)?e.target.checked:e.target.value:e,IV=e=>e.substring(0,e.search(/\.\d+(\.|$)/))||e,XP=(e,t)=>e.has(IV(t)),DV=e=>{const t=e.constructor&&e.constructor.prototype;return pn(t)&&t.hasOwnProperty("isPrototypeOf")},vw=typeof window<"u"&&typeof window.HTMLElement<"u"&&typeof document<"u";function Jn(e){let t;const n=Array.isArray(e);if(e instanceof Date)t=new Date(e);else if(e instanceof Set)t=new Set(e);else if(!(vw&&(e instanceof Blob||e instanceof FileList))&&(n||pn(e)))if(t=n?[]:{},!n&&!DV(e))t=e;else for(const r in e)e.hasOwnProperty(r)&&(t[r]=Jn(e[r]));else return e;return t}var jg=e=>Array.isArray(e)?e.filter(Boolean):[],qt=e=>e===void 0,ce=(e,t,n)=>{if(!t||!pn(e))return n;const r=jg(t.split(/[,[\].]+?/)).reduce((s,o)=>Un(s)?s:s[o],e);return qt(r)||r===e?qt(e[t])?n:e[t]:r},js=e=>typeof e=="boolean",yw=e=>/^\w*$/.test(e),eM=e=>jg(e.replace(/["|']|\]/g,"").split(/\.|\[/)),ht=(e,t,n)=>{let r=-1;const s=yw(t)?[t]:eM(t),o=s.length,a=o-1;for(;++r<o;){const l=s[r];let c=n;if(r!==a){const i=e[l];c=pn(i)||Array.isArray(i)?i:isNaN(+s[r+1])?{}:[]}if(l==="__proto__")return;e[l]=c,e=e[l]}return e};const dh={BLUR:"blur",FOCUS_OUT:"focusout",CHANGE:"change"},Yr={onBlur:"onBlur",onChange:"onChange",onSubmit:"onSubmit",onTouched:"onTouched",all:"all"},Ws={max:"max",min:"min",maxLength:"maxLength",minLength:"minLength",pattern:"pattern",required:"required",validate:"validate"},tM=Te.createContext(null),Rg=()=>Te.useContext(tM),Tr=e=>{const{children:t,...n}=e;return Te.createElement(tM.Provider,{value:n},t)};var nM=(e,t,n,r=!0)=>{const s={defaultValues:t._defaultValues};for(const o in e)Object.defineProperty(s,o,{get:()=>{const a=o;return t._proxyFormState[a]!==Yr.all&&(t._proxyFormState[a]=!r||Yr.all),n&&(n[a]=!0),e[a]}});return s},ur=e=>pn(e)&&!Object.keys(e).length,rM=(e,t,n,r)=>{n(e);const{name:s,...o}=e;return ur(o)||Object.keys(o).length>=Object.keys(t).length||Object.keys(o).find(a=>t[a]===(!r||Yr.all))},Rc=e=>Array.isArray(e)?e:[e],sM=(e,t,n)=>!e||!t||e===t||Rc(e).some(r=>r&&(n?r===t:r.startsWith(t)||t.startsWith(r)));function bw(e){const t=Te.useRef(e);t.current=e,Te.useEffect(()=>{const n=!e.disabled&&t.current.subject&&t.current.subject.subscribe({next:t.current.next});return()=>{n&&n.unsubscribe()}},[e.disabled])}function AV(e){const t=Rg(),{control:n=t.control,disabled:r,name:s,exact:o}=e||{},[a,l]=Te.useState(n._formState),c=Te.useRef(!0),i=Te.useRef({isDirty:!1,isLoading:!1,dirtyFields:!1,touchedFields:!1,validatingFields:!1,isValidating:!1,isValid:!1,errors:!1}),d=Te.useRef(s);return d.current=s,bw({disabled:r,next:p=>c.current&&sM(d.current,p.name,o)&&rM(p,i.current,n._updateFormState)&&l({...n._formState,...p}),subject:n._subjects.state}),Te.useEffect(()=>(c.current=!0,i.current.isValid&&n._updateValid(!0),()=>{c.current=!1}),[n]),nM(a,n,i.current,!1)}var Os=e=>typeof e=="string",oM=(e,t,n,r,s)=>Os(e)?(r&&t.watch.add(e),ce(n,e,s)):Array.isArray(e)?e.map(o=>(r&&t.watch.add(o),ce(n,o))):(r&&(t.watchAll=!0),n);function FV(e){const t=Rg(),{control:n=t.control,name:r,defaultValue:s,disabled:o,exact:a}=e||{},l=Te.useRef(r);l.current=r,bw({disabled:o,subject:n._subjects.values,next:d=>{sM(l.current,d.name,a)&&i(Jn(oM(l.current,n._names,d.values||n._formValues,!1,s)))}});const[c,i]=Te.useState(n._getWatch(r,s));return Te.useEffect(()=>n._removeUnmounted()),c}function LV(e){const t=Rg(),{name:n,disabled:r,control:s=t.control,shouldUnregister:o}=e,a=XP(s._names.array,n),l=FV({control:s,name:n,defaultValue:ce(s._formValues,n,ce(s._defaultValues,n,e.defaultValue)),exact:!0}),c=AV({control:s,name:n}),i=Te.useRef(s.register(n,{...e.rules,value:l,...js(e.disabled)?{disabled:e.disabled}:{}}));return Te.useEffect(()=>{const d=s._options.shouldUnregister||o,p=(f,h)=>{const g=ce(s._fields,f);g&&g._f&&(g._f.mount=h)};if(p(n,!0),d){const f=Jn(ce(s._options.defaultValues,n));ht(s._defaultValues,n,f),qt(ce(s._formValues,n))&&ht(s._formValues,n,f)}return()=>{(a?d&&!s._state.action:d)?s.unregister(n):p(n,!1)}},[n,s,a,o]),Te.useEffect(()=>{ce(s._fields,n)&&s._updateDisabledField({disabled:r,fields:s._fields,name:n,value:ce(s._fields,n)._f.value})},[r,n,s]),{field:{name:n,value:l,...js(r)||c.disabled?{disabled:c.disabled||r}:{},onChange:Te.useCallback(d=>i.current.onChange({target:{value:YP(d),name:n},type:dh.CHANGE}),[n]),onBlur:Te.useCallback(()=>i.current.onBlur({target:{value:ce(s._formValues,n),name:n},type:dh.BLUR}),[n,s]),ref:d=>{const p=ce(s._fields,n);p&&d&&(p._f.ref={focus:()=>d.focus(),select:()=>d.select(),setCustomValidity:f=>d.setCustomValidity(f),reportValidity:()=>d.reportValidity()})}},formState:c,fieldState:Object.defineProperties({},{invalid:{enumerable:!0,get:()=>!!ce(c.errors,n)},isDirty:{enumerable:!0,get:()=>!!ce(c.dirtyFields,n)},isTouched:{enumerable:!0,get:()=>!!ce(c.touchedFields,n)},isValidating:{enumerable:!0,get:()=>!!ce(c.validatingFields,n)},error:{enumerable:!0,get:()=>ce(c.errors,n)}})}}const $V=e=>e.render(LV(e));var aM=(e,t,n,r,s)=>t?{...n[e],types:{...n[e]&&n[e].types?n[e].types:{},[r]:s||!0}}:{},CC=e=>({isOnSubmit:!e||e===Yr.onSubmit,isOnBlur:e===Yr.onBlur,isOnChange:e===Yr.onChange,isOnAll:e===Yr.all,isOnTouch:e===Yr.onTouched}),EC=(e,t,n)=>!n&&(t.watchAll||t.watch.has(e)||[...t.watch].some(r=>e.startsWith(r)&&/^\.\w+/.test(e.slice(r.length))));const Pc=(e,t,n,r)=>{for(const s of n||Object.keys(e)){const o=ce(e,s);if(o){const{_f:a,...l}=o;if(a){if(a.refs&&a.refs[0]&&t(a.refs[0],s)&&!r)break;if(a.ref&&t(a.ref,a.name)&&!r)break;Pc(l,t)}else pn(l)&&Pc(l,t)}}};var BV=(e,t,n)=>{const r=Rc(ce(e,n));return ht(r,"root",t[n]),ht(e,n,r),e},xw=e=>e.type==="file",ta=e=>typeof e=="function",fh=e=>{if(!vw)return!1;const t=e?e.ownerDocument:0;return e instanceof(t&&t.defaultView?t.defaultView.HTMLElement:HTMLElement)},vp=e=>Os(e),ww=e=>e.type==="radio",ph=e=>e instanceof RegExp;const TC={value:!1,isValid:!1},kC={value:!0,isValid:!0};var iM=e=>{if(Array.isArray(e)){if(e.length>1){const t=e.filter(n=>n&&n.checked&&!n.disabled).map(n=>n.value);return{value:t,isValid:!!t.length}}return e[0].checked&&!e[0].disabled?e[0].attributes&&!qt(e[0].attributes.value)?qt(e[0].value)||e[0].value===""?kC:{value:e[0].value,isValid:!0}:kC:TC}return TC};const _C={isValid:!1,value:null};var lM=e=>Array.isArray(e)?e.reduce((t,n)=>n&&n.checked&&!n.disabled?{isValid:!0,value:n.value}:t,_C):_C;function jC(e,t,n="validate"){if(vp(e)||Array.isArray(e)&&e.every(vp)||js(e)&&!e)return{type:n,message:vp(e)?e:"",ref:t}}var Gi=e=>pn(e)&&!ph(e)?e:{value:e,message:""},RC=async(e,t,n,r,s)=>{const{ref:o,refs:a,required:l,maxLength:c,minLength:i,min:d,max:p,pattern:f,validate:h,name:g,valueAsNumber:m,mount:x,disabled:b}=e._f,y=ce(t,g);if(!x||b)return{};const w=a?a[0]:o,S=I=>{r&&w.reportValidity&&(w.setCustomValidity(js(I)?"":I||""),w.reportValidity())},E={},C=ww(o),k=Yd(o),T=C||k,P=(m||xw(o))&&qt(o.value)&&qt(y)||fh(o)&&o.value===""||y===""||Array.isArray(y)&&!y.length,N=aM.bind(null,g,n,E),U=(I,Z,V,Q=Ws.maxLength,ee=Ws.minLength)=>{const W=I?Z:V;E[g]={type:I?Q:ee,message:W,ref:o,...N(I?Q:ee,W)}};if(s?!Array.isArray(y)||!y.length:l&&(!T&&(P||Un(y))||js(y)&&!y||k&&!iM(a).isValid||C&&!lM(a).isValid)){const{value:I,message:Z}=vp(l)?{value:!!l,message:l}:Gi(l);if(I&&(E[g]={type:Ws.required,message:Z,ref:w,...N(Ws.required,Z)},!n))return S(Z),E}if(!P&&(!Un(d)||!Un(p))){let I,Z;const V=Gi(p),Q=Gi(d);if(!Un(y)&&!isNaN(y)){const ee=o.valueAsNumber||y&&+y;Un(V.value)||(I=ee>V.value),Un(Q.value)||(Z=ee<Q.value)}else{const ee=o.valueAsDate||new Date(y),W=Y=>new Date(new Date().toDateString()+" "+Y),F=o.type=="time",A=o.type=="week";Os(V.value)&&y&&(I=F?W(y)>W(V.value):A?y>V.value:ee>new Date(V.value)),Os(Q.value)&&y&&(Z=F?W(y)<W(Q.value):A?y<Q.value:ee<new Date(Q.value))}if((I||Z)&&(U(!!I,V.message,Q.message,Ws.max,Ws.min),!n))return S(E[g].message),E}if((c||i)&&!P&&(Os(y)||s&&Array.isArray(y))){const I=Gi(c),Z=Gi(i),V=!Un(I.value)&&y.length>+I.value,Q=!Un(Z.value)&&y.length<+Z.value;if((V||Q)&&(U(V,I.message,Z.message),!n))return S(E[g].message),E}if(f&&!P&&Os(y)){const{value:I,message:Z}=Gi(f);if(ph(I)&&!y.match(I)&&(E[g]={type:Ws.pattern,message:Z,ref:o,...N(Ws.pattern,Z)},!n))return S(Z),E}if(h){if(ta(h)){const I=await h(y,t),Z=jC(I,w);if(Z&&(E[g]={...Z,...N(Ws.validate,Z.message)},!n))return S(Z.message),E}else if(pn(h)){let I={};for(const Z in h){if(!ur(I)&&!n)break;const V=jC(await h[Z](y,t),w,Z);V&&(I={...V,...N(Z,V.message)},S(V.message),n&&(E[g]=I))}if(!ur(I)&&(E[g]={ref:w,...I},!n))return E}}return S(!0),E};function zV(e,t){const n=t.slice(0,-1).length;let r=0;for(;r<n;)e=qt(e)?r++:e[t[r++]];return e}function UV(e){for(const t in e)if(e.hasOwnProperty(t)&&!qt(e[t]))return!1;return!0}function ln(e,t){const n=Array.isArray(t)?t:yw(t)?[t]:eM(t),r=n.length===1?e:zV(e,n),s=n.length-1,o=n[s];return r&&delete r[o],s!==0&&(pn(r)&&ur(r)||Array.isArray(r)&&UV(r))&&ln(e,n.slice(0,-1)),e}var Qm=()=>{let e=[];return{get observers(){return e},next:s=>{for(const o of e)o.next&&o.next(s)},subscribe:s=>(e.push(s),{unsubscribe:()=>{e=e.filter(o=>o!==s)}}),unsubscribe:()=>{e=[]}}},hh=e=>Un(e)||!ZP(e);function Ya(e,t){if(hh(e)||hh(t))return e===t;if(ml(e)&&ml(t))return e.getTime()===t.getTime();const n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(const s of n){const o=e[s];if(!r.includes(s))return!1;if(s!=="ref"){const a=t[s];if(ml(o)&&ml(a)||pn(o)&&pn(a)||Array.isArray(o)&&Array.isArray(a)?!Ya(o,a):o!==a)return!1}}return!0}var uM=e=>e.type==="select-multiple",VV=e=>ww(e)||Yd(e),Zm=e=>fh(e)&&e.isConnected,cM=e=>{for(const t in e)if(ta(e[t]))return!0;return!1};function gh(e,t={}){const n=Array.isArray(e);if(pn(e)||n)for(const r in e)Array.isArray(e[r])||pn(e[r])&&!cM(e[r])?(t[r]=Array.isArray(e[r])?[]:{},gh(e[r],t[r])):Un(e[r])||(t[r]=!0);return t}function dM(e,t,n){const r=Array.isArray(e);if(pn(e)||r)for(const s in e)Array.isArray(e[s])||pn(e[s])&&!cM(e[s])?qt(t)||hh(n[s])?n[s]=Array.isArray(e[s])?gh(e[s],[]):{...gh(e[s])}:dM(e[s],Un(t)?{}:t[s],n[s]):n[s]=!Ya(e[s],t[s]);return n}var Lf=(e,t)=>dM(e,t,gh(t)),fM=(e,{valueAsNumber:t,valueAsDate:n,setValueAs:r})=>qt(e)?e:t?e===""?NaN:e&&+e:n&&Os(e)?new Date(e):r?r(e):e;function Ym(e){const t=e.ref;if(!(e.refs?e.refs.every(n=>n.disabled):t.disabled))return xw(t)?t.files:ww(t)?lM(e.refs).value:uM(t)?[...t.selectedOptions].map(({value:n})=>n):Yd(t)?iM(e.refs).value:fM(qt(t.value)?e.ref.value:t.value,e)}var HV=(e,t,n,r)=>{const s={};for(const o of e){const a=ce(t,o);a&&ht(s,o,a._f)}return{criteriaMode:n,names:[...e],fields:s,shouldUseNativeValidation:r}},Zu=e=>qt(e)?e:ph(e)?e.source:pn(e)?ph(e.value)?e.value.source:e.value:e,KV=e=>e.mount&&(e.required||e.min||e.max||e.maxLength||e.minLength||e.pattern||e.validate);function PC(e,t,n){const r=ce(e,n);if(r||yw(n))return{error:r,name:n};const s=n.split(".");for(;s.length;){const o=s.join("."),a=ce(t,o),l=ce(e,o);if(a&&!Array.isArray(a)&&n!==o)return{name:n};if(l&&l.type)return{name:o,error:l};s.pop()}return{name:n}}var qV=(e,t,n,r,s)=>s.isOnAll?!1:!n&&s.isOnTouch?!(t||e):(n?r.isOnBlur:s.isOnBlur)?!e:(n?r.isOnChange:s.isOnChange)?e:!0,WV=(e,t)=>!jg(ce(e,t)).length&&ln(e,t);const GV={mode:Yr.onSubmit,reValidateMode:Yr.onChange,shouldFocusError:!0};function JV(e={}){let t={...GV,...e},n={submitCount:0,isDirty:!1,isLoading:ta(t.defaultValues),isValidating:!1,isSubmitted:!1,isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,touchedFields:{},dirtyFields:{},validatingFields:{},errors:t.errors||{},disabled:t.disabled||!1},r={},s=pn(t.defaultValues)||pn(t.values)?Jn(t.defaultValues||t.values)||{}:{},o=t.shouldUnregister?{}:Jn(s),a={action:!1,mount:!1,watch:!1},l={mount:new Set,unMount:new Set,array:new Set,watch:new Set},c,i=0;const d={isDirty:!1,dirtyFields:!1,validatingFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1},p={values:Qm(),array:Qm(),state:Qm()},f=CC(t.mode),h=CC(t.reValidateMode),g=t.criteriaMode===Yr.all,m=j=>D=>{clearTimeout(i),i=setTimeout(j,D)},x=async j=>{if(d.isValid||j){const D=t.resolver?ur((await T()).errors):await N(r,!0);D!==n.isValid&&p.state.next({isValid:D})}},b=(j,D)=>{(d.isValidating||d.validatingFields)&&((j||Array.from(l.mount)).forEach(B=>{B&&(D?ht(n.validatingFields,B,D):ln(n.validatingFields,B))}),p.state.next({validatingFields:n.validatingFields,isValidating:!ur(n.validatingFields)}))},y=(j,D=[],B,pe,le=!0,ae=!0)=>{if(pe&&B){if(a.action=!0,ae&&Array.isArray(ce(r,j))){const Ee=B(ce(r,j),pe.argA,pe.argB);le&&ht(r,j,Ee)}if(ae&&Array.isArray(ce(n.errors,j))){const Ee=B(ce(n.errors,j),pe.argA,pe.argB);le&&ht(n.errors,j,Ee),WV(n.errors,j)}if(d.touchedFields&&ae&&Array.isArray(ce(n.touchedFields,j))){const Ee=B(ce(n.touchedFields,j),pe.argA,pe.argB);le&&ht(n.touchedFields,j,Ee)}d.dirtyFields&&(n.dirtyFields=Lf(s,o)),p.state.next({name:j,isDirty:I(j,D),dirtyFields:n.dirtyFields,errors:n.errors,isValid:n.isValid})}else ht(o,j,D)},w=(j,D)=>{ht(n.errors,j,D),p.state.next({errors:n.errors})},S=j=>{n.errors=j,p.state.next({errors:n.errors,isValid:!1})},E=(j,D,B,pe)=>{const le=ce(r,j);if(le){const ae=ce(o,j,qt(B)?ce(s,j):B);qt(ae)||pe&&pe.defaultChecked||D?ht(o,j,D?ae:Ym(le._f)):Q(j,ae),a.mount&&x()}},C=(j,D,B,pe,le)=>{let ae=!1,Ee=!1;const et={name:j},kt=!!(ce(r,j)&&ce(r,j)._f&&ce(r,j)._f.disabled);if(!B||pe){d.isDirty&&(Ee=n.isDirty,n.isDirty=et.isDirty=I(),ae=Ee!==et.isDirty);const hn=kt||Ya(ce(s,j),D);Ee=!!(!kt&&ce(n.dirtyFields,j)),hn||kt?ln(n.dirtyFields,j):ht(n.dirtyFields,j,!0),et.dirtyFields=n.dirtyFields,ae=ae||d.dirtyFields&&Ee!==!hn}if(B){const hn=ce(n.touchedFields,j);hn||(ht(n.touchedFields,j,B),et.touchedFields=n.touchedFields,ae=ae||d.touchedFields&&hn!==B)}return ae&&le&&p.state.next(et),ae?et:{}},k=(j,D,B,pe)=>{const le=ce(n.errors,j),ae=d.isValid&&js(D)&&n.isValid!==D;if(e.delayError&&B?(c=m(()=>w(j,B)),c(e.delayError)):(clearTimeout(i),c=null,B?ht(n.errors,j,B):ln(n.errors,j)),(B?!Ya(le,B):le)||!ur(pe)||ae){const Ee={...pe,...ae&&js(D)?{isValid:D}:{},errors:n.errors,name:j};n={...n,...Ee},p.state.next(Ee)}},T=async j=>{b(j,!0);const D=await t.resolver(o,t.context,HV(j||l.mount,r,t.criteriaMode,t.shouldUseNativeValidation));return b(j),D},P=async j=>{const{errors:D}=await T(j);if(j)for(const B of j){const pe=ce(D,B);pe?ht(n.errors,B,pe):ln(n.errors,B)}else n.errors=D;return D},N=async(j,D,B={valid:!0})=>{for(const pe in j){const le=j[pe];if(le){const{_f:ae,...Ee}=le;if(ae){const et=l.array.has(ae.name);b([pe],!0);const kt=await RC(le,o,g,t.shouldUseNativeValidation&&!D,et);if(b([pe]),kt[ae.name]&&(B.valid=!1,D))break;!D&&(ce(kt,ae.name)?et?BV(n.errors,kt,ae.name):ht(n.errors,ae.name,kt[ae.name]):ln(n.errors,ae.name))}Ee&&await N(Ee,D,B)}}return B.valid},U=()=>{for(const j of l.unMount){const D=ce(r,j);D&&(D._f.refs?D._f.refs.every(B=>!Zm(B)):!Zm(D._f.ref))&&oe(j)}l.unMount=new Set},I=(j,D)=>(j&&D&&ht(o,j,D),!Ya(de(),s)),Z=(j,D,B)=>oM(j,l,{...a.mount?o:qt(D)?s:Os(j)?{[j]:D}:D},B,D),V=j=>jg(ce(a.mount?o:s,j,e.shouldUnregister?ce(s,j,[]):[])),Q=(j,D,B={})=>{const pe=ce(r,j);let le=D;if(pe){const ae=pe._f;ae&&(!ae.disabled&&ht(o,j,fM(D,ae)),le=fh(ae.ref)&&Un(D)?"":D,uM(ae.ref)?[...ae.ref.options].forEach(Ee=>Ee.selected=le.includes(Ee.value)):ae.refs?Yd(ae.ref)?ae.refs.length>1?ae.refs.forEach(Ee=>(!Ee.defaultChecked||!Ee.disabled)&&(Ee.checked=Array.isArray(le)?!!le.find(et=>et===Ee.value):le===Ee.value)):ae.refs[0]&&(ae.refs[0].checked=!!le):ae.refs.forEach(Ee=>Ee.checked=Ee.value===le):xw(ae.ref)?ae.ref.value="":(ae.ref.value=le,ae.ref.type||p.values.next({name:j,values:{...o}})))}(B.shouldDirty||B.shouldTouch)&&C(j,le,B.shouldTouch,B.shouldDirty,!0),B.shouldValidate&&Y(j)},ee=(j,D,B)=>{for(const pe in D){const le=D[pe],ae=`${j}.${pe}`,Ee=ce(r,ae);(l.array.has(j)||!hh(le)||Ee&&!Ee._f)&&!ml(le)?ee(ae,le,B):Q(ae,le,B)}},W=(j,D,B={})=>{const pe=ce(r,j),le=l.array.has(j),ae=Jn(D);ht(o,j,ae),le?(p.array.next({name:j,values:{...o}}),(d.isDirty||d.dirtyFields)&&B.shouldDirty&&p.state.next({name:j,dirtyFields:Lf(s,o),isDirty:I(j,ae)})):pe&&!pe._f&&!Un(ae)?ee(j,ae,B):Q(j,ae,B),EC(j,l)&&p.state.next({...n}),p.values.next({name:a.mount?j:void 0,values:{...o}})},F=async j=>{a.mount=!0;const D=j.target;let B=D.name,pe=!0;const le=ce(r,B),ae=()=>D.type?Ym(le._f):YP(j),Ee=et=>{pe=Number.isNaN(et)||et===ce(o,B,et)};if(le){let et,kt;const hn=ae(),yn=j.type===dh.BLUR||j.type===dh.FOCUS_OUT,gn=!KV(le._f)&&!t.resolver&&!ce(n.errors,B)&&!le._f.deps||qV(yn,ce(n.touchedFields,B),n.isSubmitted,h,f),jo=EC(B,l,yn);ht(o,B,hn),yn?(le._f.onBlur&&le._f.onBlur(j),c&&c(0)):le._f.onChange&&le._f.onChange(j);const gs=C(B,hn,yn,!1),Aa=!ur(gs)||jo;if(!yn&&p.values.next({name:B,type:j.type,values:{...o}}),gn)return d.isValid&&x(),Aa&&p.state.next({name:B,...jo?{}:gs});if(!yn&&jo&&p.state.next({...n}),t.resolver){const{errors:Fn}=await T([B]);if(Ee(hn),pe){const ue=PC(n.errors,r,B),Ue=PC(Fn,r,ue.name||B);et=Ue.error,B=Ue.name,kt=ur(Fn)}}else b([B],!0),et=(await RC(le,o,g,t.shouldUseNativeValidation))[B],b([B]),Ee(hn),pe&&(et?kt=!1:d.isValid&&(kt=await N(r,!0)));pe&&(le._f.deps&&Y(le._f.deps),k(B,kt,et,gs))}},A=(j,D)=>{if(ce(n.errors,D)&&j.focus)return j.focus(),1},Y=async(j,D={})=>{let B,pe;const le=Rc(j);if(t.resolver){const ae=await P(qt(j)?j:le);B=ur(ae),pe=j?!le.some(Ee=>ce(ae,Ee)):B}else j?(pe=(await Promise.all(le.map(async ae=>{const Ee=ce(r,ae);return await N(Ee&&Ee._f?{[ae]:Ee}:Ee)}))).every(Boolean),!(!pe&&!n.isValid)&&x()):pe=B=await N(r);return p.state.next({...!Os(j)||d.isValid&&B!==n.isValid?{}:{name:j},...t.resolver||!j?{isValid:B}:{},errors:n.errors}),D.shouldFocus&&!pe&&Pc(r,A,j?le:l.mount),pe},de=j=>{const D={...a.mount?o:s};return qt(j)?D:Os(j)?ce(D,j):j.map(B=>ce(D,B))},z=(j,D)=>({invalid:!!ce((D||n).errors,j),isDirty:!!ce((D||n).dirtyFields,j),error:ce((D||n).errors,j),isValidating:!!ce(n.validatingFields,j),isTouched:!!ce((D||n).touchedFields,j)}),se=j=>{j&&Rc(j).forEach(D=>ln(n.errors,D)),p.state.next({errors:j?n.errors:{}})},ne=(j,D,B)=>{const pe=(ce(r,j,{_f:{}})._f||{}).ref,le=ce(n.errors,j)||{},{ref:ae,message:Ee,type:et,...kt}=le;ht(n.errors,j,{...kt,...D,ref:pe}),p.state.next({name:j,errors:n.errors,isValid:!1}),B&&B.shouldFocus&&pe&&pe.focus&&pe.focus()},ie=(j,D)=>ta(j)?p.values.subscribe({next:B=>j(Z(void 0,D),B)}):Z(j,D,!0),oe=(j,D={})=>{for(const B of j?Rc(j):l.mount)l.mount.delete(B),l.array.delete(B),D.keepValue||(ln(r,B),ln(o,B)),!D.keepError&&ln(n.errors,B),!D.keepDirty&&ln(n.dirtyFields,B),!D.keepTouched&&ln(n.touchedFields,B),!D.keepIsValidating&&ln(n.validatingFields,B),!t.shouldUnregister&&!D.keepDefaultValue&&ln(s,B);p.values.next({values:{...o}}),p.state.next({...n,...D.keepDirty?{isDirty:I()}:{}}),!D.keepIsValid&&x()},J=({disabled:j,name:D,field:B,fields:pe,value:le})=>{if(js(j)&&a.mount||j){const ae=j?void 0:qt(le)?Ym(B?B._f:ce(pe,D)._f):le;ht(o,D,ae),C(D,ae,!1,!1,!0)}},Ce=(j,D={})=>{let B=ce(r,j);const pe=js(D.disabled);return ht(r,j,{...B||{},_f:{...B&&B._f?B._f:{ref:{name:j}},name:j,mount:!0,...D}}),l.mount.add(j),B?J({field:B,disabled:D.disabled,name:j,value:D.value}):E(j,!0,D.value),{...pe?{disabled:D.disabled}:{},...t.progressive?{required:!!D.required,min:Zu(D.min),max:Zu(D.max),minLength:Zu(D.minLength),maxLength:Zu(D.maxLength),pattern:Zu(D.pattern)}:{},name:j,onChange:F,onBlur:F,ref:le=>{if(le){Ce(j,D),B=ce(r,j);const ae=qt(le.value)&&le.querySelectorAll&&le.querySelectorAll("input,select,textarea")[0]||le,Ee=VV(ae),et=B._f.refs||[];if(Ee?et.find(kt=>kt===ae):ae===B._f.ref)return;ht(r,j,{_f:{...B._f,...Ee?{refs:[...et.filter(Zm),ae,...Array.isArray(ce(s,j))?[{}]:[]],ref:{type:ae.type,name:j}}:{ref:ae}}}),E(j,!1,void 0,ae)}else B=ce(r,j,{}),B._f&&(B._f.mount=!1),(t.shouldUnregister||D.shouldUnregister)&&!(XP(l.array,j)&&a.action)&&l.unMount.add(j)}}},Pe=()=>t.shouldFocusError&&Pc(r,A,l.mount),Le=j=>{js(j)&&(p.state.next({disabled:j}),Pc(r,(D,B)=>{const pe=ce(r,B);pe&&(D.disabled=pe._f.disabled||j,Array.isArray(pe._f.refs)&&pe._f.refs.forEach(le=>{le.disabled=pe._f.disabled||j}))},0,!1))},Me=(j,D)=>async B=>{let pe;B&&(B.preventDefault&&B.preventDefault(),B.persist&&B.persist());let le=Jn(o);if(p.state.next({isSubmitting:!0}),t.resolver){const{errors:ae,values:Ee}=await T();n.errors=ae,le=Ee}else await N(r);if(ln(n.errors,"root"),ur(n.errors)){p.state.next({errors:{}});try{await j(le,B)}catch(ae){pe=ae}}else D&&await D({...n.errors},B),Pe(),setTimeout(Pe);if(p.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:ur(n.errors)&&!pe,submitCount:n.submitCount+1,errors:n.errors}),pe)throw pe},me=(j,D={})=>{ce(r,j)&&(qt(D.defaultValue)?W(j,Jn(ce(s,j))):(W(j,D.defaultValue),ht(s,j,Jn(D.defaultValue))),D.keepTouched||ln(n.touchedFields,j),D.keepDirty||(ln(n.dirtyFields,j),n.isDirty=D.defaultValue?I(j,Jn(ce(s,j))):I()),D.keepError||(ln(n.errors,j),d.isValid&&x()),p.state.next({...n}))},rt=(j,D={})=>{const B=j?Jn(j):s,pe=Jn(B),le=ur(j),ae=le?s:pe;if(D.keepDefaultValues||(s=B),!D.keepValues){if(D.keepDirtyValues)for(const Ee of l.mount)ce(n.dirtyFields,Ee)?ht(ae,Ee,ce(o,Ee)):W(Ee,ce(ae,Ee));else{if(vw&&qt(j))for(const Ee of l.mount){const et=ce(r,Ee);if(et&&et._f){const kt=Array.isArray(et._f.refs)?et._f.refs[0]:et._f.ref;if(fh(kt)){const hn=kt.closest("form");if(hn){hn.reset();break}}}}r={}}o=e.shouldUnregister?D.keepDefaultValues?Jn(s):{}:Jn(ae),p.array.next({values:{...ae}}),p.values.next({values:{...ae}})}l={mount:D.keepDirtyValues?l.mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1,focus:""},a.mount=!d.isValid||!!D.keepIsValid||!!D.keepDirtyValues,a.watch=!!e.shouldUnregister,p.state.next({submitCount:D.keepSubmitCount?n.submitCount:0,isDirty:le?!1:D.keepDirty?n.isDirty:!!(D.keepDefaultValues&&!Ya(j,s)),isSubmitted:D.keepIsSubmitted?n.isSubmitted:!1,dirtyFields:le?{}:D.keepDirtyValues?D.keepDefaultValues&&o?Lf(s,o):n.dirtyFields:D.keepDefaultValues&&j?Lf(s,j):D.keepDirty?n.dirtyFields:{},touchedFields:D.keepTouched?n.touchedFields:{},errors:D.keepErrors?n.errors:{},isSubmitSuccessful:D.keepIsSubmitSuccessful?n.isSubmitSuccessful:!1,isSubmitting:!1})},It=(j,D)=>rt(ta(j)?j(o):j,D);return{control:{register:Ce,unregister:oe,getFieldState:z,handleSubmit:Me,setError:ne,_executeSchema:T,_getWatch:Z,_getDirty:I,_updateValid:x,_removeUnmounted:U,_updateFieldArray:y,_updateDisabledField:J,_getFieldArray:V,_reset:rt,_resetDefaultValues:()=>ta(t.defaultValues)&&t.defaultValues().then(j=>{It(j,t.resetOptions),p.state.next({isLoading:!1})}),_updateFormState:j=>{n={...n,...j}},_disableForm:Le,_subjects:p,_proxyFormState:d,_setErrors:S,get _fields(){return r},get _formValues(){return o},get _state(){return a},set _state(j){a=j},get _defaultValues(){return s},get _names(){return l},set _names(j){l=j},get _formState(){return n},set _formState(j){n=j},get _options(){return t},set _options(j){t={...t,...j}}},trigger:Y,register:Ce,handleSubmit:Me,watch:ie,setValue:W,getValues:de,reset:It,resetField:me,clearErrors:se,unregister:oe,setError:ne,setFocus:(j,D={})=>{const B=ce(r,j),pe=B&&B._f;if(pe){const le=pe.refs?pe.refs[0]:pe.ref;le.focus&&(le.focus(),D.shouldSelect&&le.select())}},getFieldState:z}}function sn(e={}){const t=Te.useRef(),n=Te.useRef(),[r,s]=Te.useState({isDirty:!1,isValidating:!1,isLoading:ta(e.defaultValues),isSubmitted:!1,isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,submitCount:0,dirtyFields:{},touchedFields:{},validatingFields:{},errors:e.errors||{},disabled:e.disabled||!1,defaultValues:ta(e.defaultValues)?void 0:e.defaultValues});t.current||(t.current={...JV(e),formState:r});const o=t.current.control;return o._options=e,bw({subject:o._subjects.state,next:a=>{rM(a,o._proxyFormState,o._updateFormState,!0)&&s({...o._formState})}}),Te.useEffect(()=>o._disableForm(e.disabled),[o,e.disabled]),Te.useEffect(()=>{if(o._proxyFormState.isDirty){const a=o._getDirty();a!==r.isDirty&&o._subjects.state.next({isDirty:a})}},[o,r.isDirty]),Te.useEffect(()=>{e.values&&!Ya(e.values,n.current)?(o._reset(e.values,o._options.resetOptions),n.current=e.values,s(a=>({...a}))):o._resetDefaultValues()},[e.values,o]),Te.useEffect(()=>{e.errors&&o._setErrors(e.errors)},[e.errors,o]),Te.useEffect(()=>{o._state.mount||(o._updateValid(),o._state.mount=!0),o._state.watch&&(o._state.watch=!1,o._subjects.state.next({...o._formState})),o._removeUnmounted()}),Te.useEffect(()=>{e.shouldUnregister&&o._subjects.values.next({values:o._getWatch()})},[e.shouldUnregister,o]),t.current.formState=nM(r,o),t.current}const MC=(e,t,n)=>{if(e&&"reportValidity"in e){const r=ce(n,t);e.setCustomValidity(r&&r.message||""),e.reportValidity()}},pM=(e,t)=>{for(const n in t.fields){const r=t.fields[n];r&&r.ref&&"reportValidity"in r.ref?MC(r.ref,n,e):r.refs&&r.refs.forEach(s=>MC(s,n,e))}},QV=(e,t)=>{t.shouldUseNativeValidation&&pM(e,t);const n={};for(const r in e){const s=ce(t.fields,r),o=Object.assign(e[r]||{},{ref:s&&s.ref});if(ZV(t.names||Object.keys(e),r)){const a=Object.assign({},ce(n,r));ht(a,"root",o),ht(n,r,a)}else ht(n,r,o)}return n},ZV=(e,t)=>e.some(n=>n.startsWith(t+"."));var YV=function(e,t){for(var n={};e.length;){var r=e[0],s=r.code,o=r.message,a=r.path.join(".");if(!n[a])if("unionErrors"in r){var l=r.unionErrors[0].errors[0];n[a]={message:l.message,type:l.code}}else n[a]={message:o,type:s};if("unionErrors"in r&&r.unionErrors.forEach(function(d){return d.errors.forEach(function(p){return e.push(p)})}),t){var c=n[a].types,i=c&&c[r.code];n[a]=aM(a,t,n,s,i?[].concat(i,r.message):r.message)}e.shift()}return n},on=function(e,t,n){return n===void 0&&(n={}),function(r,s,o){try{return Promise.resolve(function(a,l){try{var c=Promise.resolve(e[n.mode==="sync"?"parse":"parseAsync"](r,t)).then(function(i){return o.shouldUseNativeValidation&&pM({},o),{errors:{},values:n.raw?r:i}})}catch(i){return l(i)}return c&&c.then?c.then(void 0,l):c}(0,function(a){if(function(l){return Array.isArray(l==null?void 0:l.errors)}(a))return{values:{},errors:QV(YV(a.errors,!o.shouldUseNativeValidation&&o.criteriaMode==="all"),o)};throw a}))}catch(a){return Promise.reject(a)}}},xn=[];for(var Xm=0;Xm<256;++Xm)xn.push((Xm+256).toString(16).slice(1));function XV(e,t=0){return(xn[e[t+0]]+xn[e[t+1]]+xn[e[t+2]]+xn[e[t+3]]+"-"+xn[e[t+4]]+xn[e[t+5]]+"-"+xn[e[t+6]]+xn[e[t+7]]+"-"+xn[e[t+8]]+xn[e[t+9]]+"-"+xn[e[t+10]]+xn[e[t+11]]+xn[e[t+12]]+xn[e[t+13]]+xn[e[t+14]]+xn[e[t+15]]).toLowerCase()}var $f,e6=new Uint8Array(16);function t6(){if(!$f&&($f=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!$f))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return $f(e6)}var n6=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);const OC={randomUUID:n6};function NC(e,t,n){if(OC.randomUUID&&!t&&!e)return OC.randomUUID();e=e||{};var r=e.random||(e.rng||t6)();return r[6]=r[6]&15|64,r[8]=r[8]&63|128,XV(r)}var ut;(function(e){e.assertEqual=s=>s;function t(s){}e.assertIs=t;function n(s){throw new Error}e.assertNever=n,e.arrayToEnum=s=>{const o={};for(const a of s)o[a]=a;return o},e.getValidEnumValues=s=>{const o=e.objectKeys(s).filter(l=>typeof s[s[l]]!="number"),a={};for(const l of o)a[l]=s[l];return e.objectValues(a)},e.objectValues=s=>e.objectKeys(s).map(function(o){return s[o]}),e.objectKeys=typeof Object.keys=="function"?s=>Object.keys(s):s=>{const o=[];for(const a in s)Object.prototype.hasOwnProperty.call(s,a)&&o.push(a);return o},e.find=(s,o)=>{for(const a of s)if(o(a))return a},e.isInteger=typeof Number.isInteger=="function"?s=>Number.isInteger(s):s=>typeof s=="number"&&isFinite(s)&&Math.floor(s)===s;function r(s,o=" | "){return s.map(a=>typeof a=="string"?`'${a}'`:a).join(o)}e.joinValues=r,e.jsonStringifyReplacer=(s,o)=>typeof o=="bigint"?o.toString():o})(ut||(ut={}));var Xy;(function(e){e.mergeShapes=(t,n)=>({...t,...n})})(Xy||(Xy={}));const be=ut.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),Vo=e=>{switch(typeof e){case"undefined":return be.undefined;case"string":return be.string;case"number":return isNaN(e)?be.nan:be.number;case"boolean":return be.boolean;case"function":return be.function;case"bigint":return be.bigint;case"symbol":return be.symbol;case"object":return Array.isArray(e)?be.array:e===null?be.null:e.then&&typeof e.then=="function"&&e.catch&&typeof e.catch=="function"?be.promise:typeof Map<"u"&&e instanceof Map?be.map:typeof Set<"u"&&e instanceof Set?be.set:typeof Date<"u"&&e instanceof Date?be.date:be.object;default:return be.unknown}},re=ut.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]),r6=e=>JSON.stringify(e,null,2).replace(/"([^"]+)":/g,"$1:");class yr extends Error{constructor(t){super(),this.issues=[],this.addIssue=r=>{this.issues=[...this.issues,r]},this.addIssues=(r=[])=>{this.issues=[...this.issues,...r]};const n=new.target.prototype;Object.setPrototypeOf?Object.setPrototypeOf(this,n):this.__proto__=n,this.name="ZodError",this.issues=t}get errors(){return this.issues}format(t){const n=t||function(o){return o.message},r={_errors:[]},s=o=>{for(const a of o.issues)if(a.code==="invalid_union")a.unionErrors.map(s);else if(a.code==="invalid_return_type")s(a.returnTypeError);else if(a.code==="invalid_arguments")s(a.argumentsError);else if(a.path.length===0)r._errors.push(n(a));else{let l=r,c=0;for(;c<a.path.length;){const i=a.path[c];c===a.path.length-1?(l[i]=l[i]||{_errors:[]},l[i]._errors.push(n(a))):l[i]=l[i]||{_errors:[]},l=l[i],c++}}};return s(this),r}static assert(t){if(!(t instanceof yr))throw new Error(`Not a ZodError: ${t}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,ut.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten(t=n=>n.message){const n={},r=[];for(const s of this.issues)s.path.length>0?(n[s.path[0]]=n[s.path[0]]||[],n[s.path[0]].push(t(s))):r.push(t(s));return{formErrors:r,fieldErrors:n}}get formErrors(){return this.flatten()}}yr.create=e=>new yr(e);const nu=(e,t)=>{let n;switch(e.code){case re.invalid_type:e.received===be.undefined?n="Required":n=`Expected ${e.expected}, received ${e.received}`;break;case re.invalid_literal:n=`Invalid literal value, expected ${JSON.stringify(e.expected,ut.jsonStringifyReplacer)}`;break;case re.unrecognized_keys:n=`Unrecognized key(s) in object: ${ut.joinValues(e.keys,", ")}`;break;case re.invalid_union:n="Invalid input";break;case re.invalid_union_discriminator:n=`Invalid discriminator value. Expected ${ut.joinValues(e.options)}`;break;case re.invalid_enum_value:n=`Invalid enum value. Expected ${ut.joinValues(e.options)}, received '${e.received}'`;break;case re.invalid_arguments:n="Invalid function arguments";break;case re.invalid_return_type:n="Invalid function return type";break;case re.invalid_date:n="Invalid date";break;case re.invalid_string:typeof e.validation=="object"?"includes"in e.validation?(n=`Invalid input: must include "${e.validation.includes}"`,typeof e.validation.position=="number"&&(n=`${n} at one or more positions greater than or equal to ${e.validation.position}`)):"startsWith"in e.validation?n=`Invalid input: must start with "${e.validation.startsWith}"`:"endsWith"in e.validation?n=`Invalid input: must end with "${e.validation.endsWith}"`:ut.assertNever(e.validation):e.validation!=="regex"?n=`Invalid ${e.validation}`:n="Invalid";break;case re.too_small:e.type==="array"?n=`Array must contain ${e.exact?"exactly":e.inclusive?"at least":"more than"} ${e.minimum} element(s)`:e.type==="string"?n=`String must contain ${e.exact?"exactly":e.inclusive?"at least":"over"} ${e.minimum} character(s)`:e.type==="number"?n=`Number must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${e.minimum}`:e.type==="date"?n=`Date must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(e.minimum))}`:n="Invalid input";break;case re.too_big:e.type==="array"?n=`Array must contain ${e.exact?"exactly":e.inclusive?"at most":"less than"} ${e.maximum} element(s)`:e.type==="string"?n=`String must contain ${e.exact?"exactly":e.inclusive?"at most":"under"} ${e.maximum} character(s)`:e.type==="number"?n=`Number must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}`:e.type==="bigint"?n=`BigInt must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}`:e.type==="date"?n=`Date must be ${e.exact?"exactly":e.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(e.maximum))}`:n="Invalid input";break;case re.custom:n="Invalid input";break;case re.invalid_intersection_types:n="Intersection results could not be merged";break;case re.not_multiple_of:n=`Number must be a multiple of ${e.multipleOf}`;break;case re.not_finite:n="Number must be finite";break;default:n=t.defaultError,ut.assertNever(e)}return{message:n}};let hM=nu;function s6(e){hM=e}function mh(){return hM}const vh=e=>{const{data:t,path:n,errorMaps:r,issueData:s}=e,o=[...n,...s.path||[]],a={...s,path:o};if(s.message!==void 0)return{...s,path:o,message:s.message};let l="";const c=r.filter(i=>!!i).slice().reverse();for(const i of c)l=i(a,{data:t,defaultError:l}).message;return{...s,path:o,message:l}},o6=[];function ve(e,t){const n=mh(),r=vh({issueData:t,data:e.data,path:e.path,errorMaps:[e.common.contextualErrorMap,e.schemaErrorMap,n,n===nu?void 0:nu].filter(s=>!!s)});e.common.issues.push(r)}class Dn{constructor(){this.value="valid"}dirty(){this.value==="valid"&&(this.value="dirty")}abort(){this.value!=="aborted"&&(this.value="aborted")}static mergeArray(t,n){const r=[];for(const s of n){if(s.status==="aborted")return Be;s.status==="dirty"&&t.dirty(),r.push(s.value)}return{status:t.value,value:r}}static async mergeObjectAsync(t,n){const r=[];for(const s of n){const o=await s.key,a=await s.value;r.push({key:o,value:a})}return Dn.mergeObjectSync(t,r)}static mergeObjectSync(t,n){const r={};for(const s of n){const{key:o,value:a}=s;if(o.status==="aborted"||a.status==="aborted")return Be;o.status==="dirty"&&t.dirty(),a.status==="dirty"&&t.dirty(),o.value!=="__proto__"&&(typeof a.value<"u"||s.alwaysSet)&&(r[o.value]=a.value)}return{status:t.value,value:r}}}const Be=Object.freeze({status:"aborted"}),vl=e=>({status:"dirty",value:e}),Kn=e=>({status:"valid",value:e}),eb=e=>e.status==="aborted",tb=e=>e.status==="dirty",cd=e=>e.status==="valid",dd=e=>typeof Promise<"u"&&e instanceof Promise;function yh(e,t,n,r){if(typeof t=="function"?e!==t||!r:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t.get(e)}function gM(e,t,n,r,s){if(typeof t=="function"?e!==t||!s:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return t.set(e,n),n}var je;(function(e){e.errToObj=t=>typeof t=="string"?{message:t}:t||{},e.toString=t=>typeof t=="string"?t:t==null?void 0:t.message})(je||(je={}));var fc,pc;class zs{constructor(t,n,r,s){this._cachedPath=[],this.parent=t,this.data=n,this._path=r,this._key=s}get path(){return this._cachedPath.length||(this._key instanceof Array?this._cachedPath.push(...this._path,...this._key):this._cachedPath.push(...this._path,this._key)),this._cachedPath}}const IC=(e,t)=>{if(cd(t))return{success:!0,data:t.value};if(!e.common.issues.length)throw new Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;const n=new yr(e.common.issues);return this._error=n,this._error}}};function Ke(e){if(!e)return{};const{errorMap:t,invalid_type_error:n,required_error:r,description:s}=e;if(t&&(n||r))throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);return t?{errorMap:t,description:s}:{errorMap:(a,l)=>{var c,i;const{message:d}=e;return a.code==="invalid_enum_value"?{message:d??l.defaultError}:typeof l.data>"u"?{message:(c=d??r)!==null&&c!==void 0?c:l.defaultError}:a.code!=="invalid_type"?{message:l.defaultError}:{message:(i=d??n)!==null&&i!==void 0?i:l.defaultError}},description:s}}class Qe{constructor(t){this.spa=this.safeParseAsync,this._def=t,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this)}get description(){return this._def.description}_getType(t){return Vo(t.data)}_getOrReturnCtx(t,n){return n||{common:t.parent.common,data:t.data,parsedType:Vo(t.data),schemaErrorMap:this._def.errorMap,path:t.path,parent:t.parent}}_processInputParams(t){return{status:new Dn,ctx:{common:t.parent.common,data:t.data,parsedType:Vo(t.data),schemaErrorMap:this._def.errorMap,path:t.path,parent:t.parent}}}_parseSync(t){const n=this._parse(t);if(dd(n))throw new Error("Synchronous parse encountered promise.");return n}_parseAsync(t){const n=this._parse(t);return Promise.resolve(n)}parse(t,n){const r=this.safeParse(t,n);if(r.success)return r.data;throw r.error}safeParse(t,n){var r;const s={common:{issues:[],async:(r=n==null?void 0:n.async)!==null&&r!==void 0?r:!1,contextualErrorMap:n==null?void 0:n.errorMap},path:(n==null?void 0:n.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:t,parsedType:Vo(t)},o=this._parseSync({data:t,path:s.path,parent:s});return IC(s,o)}async parseAsync(t,n){const r=await this.safeParseAsync(t,n);if(r.success)return r.data;throw r.error}async safeParseAsync(t,n){const r={common:{issues:[],contextualErrorMap:n==null?void 0:n.errorMap,async:!0},path:(n==null?void 0:n.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:t,parsedType:Vo(t)},s=this._parse({data:t,path:r.path,parent:r}),o=await(dd(s)?s:Promise.resolve(s));return IC(r,o)}refine(t,n){const r=s=>typeof n=="string"||typeof n>"u"?{message:n}:typeof n=="function"?n(s):n;return this._refinement((s,o)=>{const a=t(s),l=()=>o.addIssue({code:re.custom,...r(s)});return typeof Promise<"u"&&a instanceof Promise?a.then(c=>c?!0:(l(),!1)):a?!0:(l(),!1)})}refinement(t,n){return this._refinement((r,s)=>t(r)?!0:(s.addIssue(typeof n=="function"?n(r,s):n),!1))}_refinement(t){return new ds({schema:this,typeName:Fe.ZodEffects,effect:{type:"refinement",refinement:t}})}superRefine(t){return this._refinement(t)}optional(){return Ls.create(this,this._def)}nullable(){return xa.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return as.create(this,this._def)}promise(){return su.create(this,this._def)}or(t){return gd.create([this,t],this._def)}and(t){return md.create(this,t,this._def)}transform(t){return new ds({...Ke(this._def),schema:this,typeName:Fe.ZodEffects,effect:{type:"transform",transform:t}})}default(t){const n=typeof t=="function"?t:()=>t;return new wd({...Ke(this._def),innerType:this,defaultValue:n,typeName:Fe.ZodDefault})}brand(){return new Sw({typeName:Fe.ZodBranded,type:this,...Ke(this._def)})}catch(t){const n=typeof t=="function"?t:()=>t;return new Sd({...Ke(this._def),innerType:this,catchValue:n,typeName:Fe.ZodCatch})}describe(t){const n=this.constructor;return new n({...this._def,description:t})}pipe(t){return Xd.create(this,t)}readonly(){return Cd.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}const a6=/^c[^\s-]{8,}$/i,i6=/^[0-9a-z]+$/,l6=/^[0-9A-HJKMNP-TV-Z]{26}$/,u6=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,c6=/^[a-z0-9_-]{21}$/i,d6=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,f6=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,p6="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";let ev;const h6=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,g6=/^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,m6=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,mM="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",v6=new RegExp(`^${mM}$`);function vM(e){let t="([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";return e.precision?t=`${t}\\.\\d{${e.precision}}`:e.precision==null&&(t=`${t}(\\.\\d+)?`),t}function y6(e){return new RegExp(`^${vM(e)}$`)}function yM(e){let t=`${mM}T${vM(e)}`;const n=[];return n.push(e.local?"Z?":"Z"),e.offset&&n.push("([+-]\\d{2}:?\\d{2})"),t=`${t}(${n.join("|")})`,new RegExp(`^${t}$`)}function b6(e,t){return!!((t==="v4"||!t)&&h6.test(e)||(t==="v6"||!t)&&g6.test(e))}class es extends Qe{_parse(t){if(this._def.coerce&&(t.data=String(t.data)),this._getType(t)!==be.string){const o=this._getOrReturnCtx(t);return ve(o,{code:re.invalid_type,expected:be.string,received:o.parsedType}),Be}const r=new Dn;let s;for(const o of this._def.checks)if(o.kind==="min")t.data.length<o.value&&(s=this._getOrReturnCtx(t,s),ve(s,{code:re.too_small,minimum:o.value,type:"string",inclusive:!0,exact:!1,message:o.message}),r.dirty());else if(o.kind==="max")t.data.length>o.value&&(s=this._getOrReturnCtx(t,s),ve(s,{code:re.too_big,maximum:o.value,type:"string",inclusive:!0,exact:!1,message:o.message}),r.dirty());else if(o.kind==="length"){const a=t.data.length>o.value,l=t.data.length<o.value;(a||l)&&(s=this._getOrReturnCtx(t,s),a?ve(s,{code:re.too_big,maximum:o.value,type:"string",inclusive:!0,exact:!0,message:o.message}):l&&ve(s,{code:re.too_small,minimum:o.value,type:"string",inclusive:!0,exact:!0,message:o.message}),r.dirty())}else if(o.kind==="email")f6.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"email",code:re.invalid_string,message:o.message}),r.dirty());else if(o.kind==="emoji")ev||(ev=new RegExp(p6,"u")),ev.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"emoji",code:re.invalid_string,message:o.message}),r.dirty());else if(o.kind==="uuid")u6.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"uuid",code:re.invalid_string,message:o.message}),r.dirty());else if(o.kind==="nanoid")c6.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"nanoid",code:re.invalid_string,message:o.message}),r.dirty());else if(o.kind==="cuid")a6.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"cuid",code:re.invalid_string,message:o.message}),r.dirty());else if(o.kind==="cuid2")i6.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"cuid2",code:re.invalid_string,message:o.message}),r.dirty());else if(o.kind==="ulid")l6.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"ulid",code:re.invalid_string,message:o.message}),r.dirty());else if(o.kind==="url")try{new URL(t.data)}catch{s=this._getOrReturnCtx(t,s),ve(s,{validation:"url",code:re.invalid_string,message:o.message}),r.dirty()}else o.kind==="regex"?(o.regex.lastIndex=0,o.regex.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"regex",code:re.invalid_string,message:o.message}),r.dirty())):o.kind==="trim"?t.data=t.data.trim():o.kind==="includes"?t.data.includes(o.value,o.position)||(s=this._getOrReturnCtx(t,s),ve(s,{code:re.invalid_string,validation:{includes:o.value,position:o.position},message:o.message}),r.dirty()):o.kind==="toLowerCase"?t.data=t.data.toLowerCase():o.kind==="toUpperCase"?t.data=t.data.toUpperCase():o.kind==="startsWith"?t.data.startsWith(o.value)||(s=this._getOrReturnCtx(t,s),ve(s,{code:re.invalid_string,validation:{startsWith:o.value},message:o.message}),r.dirty()):o.kind==="endsWith"?t.data.endsWith(o.value)||(s=this._getOrReturnCtx(t,s),ve(s,{code:re.invalid_string,validation:{endsWith:o.value},message:o.message}),r.dirty()):o.kind==="datetime"?yM(o).test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{code:re.invalid_string,validation:"datetime",message:o.message}),r.dirty()):o.kind==="date"?v6.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{code:re.invalid_string,validation:"date",message:o.message}),r.dirty()):o.kind==="time"?y6(o).test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{code:re.invalid_string,validation:"time",message:o.message}),r.dirty()):o.kind==="duration"?d6.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"duration",code:re.invalid_string,message:o.message}),r.dirty()):o.kind==="ip"?b6(t.data,o.version)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"ip",code:re.invalid_string,message:o.message}),r.dirty()):o.kind==="base64"?m6.test(t.data)||(s=this._getOrReturnCtx(t,s),ve(s,{validation:"base64",code:re.invalid_string,message:o.message}),r.dirty()):ut.assertNever(o);return{status:r.value,value:t.data}}_regex(t,n,r){return this.refinement(s=>t.test(s),{validation:n,code:re.invalid_string,...je.errToObj(r)})}_addCheck(t){return new es({...this._def,checks:[...this._def.checks,t]})}email(t){return this._addCheck({kind:"email",...je.errToObj(t)})}url(t){return this._addCheck({kind:"url",...je.errToObj(t)})}emoji(t){return this._addCheck({kind:"emoji",...je.errToObj(t)})}uuid(t){return this._addCheck({kind:"uuid",...je.errToObj(t)})}nanoid(t){return this._addCheck({kind:"nanoid",...je.errToObj(t)})}cuid(t){return this._addCheck({kind:"cuid",...je.errToObj(t)})}cuid2(t){return this._addCheck({kind:"cuid2",...je.errToObj(t)})}ulid(t){return this._addCheck({kind:"ulid",...je.errToObj(t)})}base64(t){return this._addCheck({kind:"base64",...je.errToObj(t)})}ip(t){return this._addCheck({kind:"ip",...je.errToObj(t)})}datetime(t){var n,r;return typeof t=="string"?this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:t}):this._addCheck({kind:"datetime",precision:typeof(t==null?void 0:t.precision)>"u"?null:t==null?void 0:t.precision,offset:(n=t==null?void 0:t.offset)!==null&&n!==void 0?n:!1,local:(r=t==null?void 0:t.local)!==null&&r!==void 0?r:!1,...je.errToObj(t==null?void 0:t.message)})}date(t){return this._addCheck({kind:"date",message:t})}time(t){return typeof t=="string"?this._addCheck({kind:"time",precision:null,message:t}):this._addCheck({kind:"time",precision:typeof(t==null?void 0:t.precision)>"u"?null:t==null?void 0:t.precision,...je.errToObj(t==null?void 0:t.message)})}duration(t){return this._addCheck({kind:"duration",...je.errToObj(t)})}regex(t,n){return this._addCheck({kind:"regex",regex:t,...je.errToObj(n)})}includes(t,n){return this._addCheck({kind:"includes",value:t,position:n==null?void 0:n.position,...je.errToObj(n==null?void 0:n.message)})}startsWith(t,n){return this._addCheck({kind:"startsWith",value:t,...je.errToObj(n)})}endsWith(t,n){return this._addCheck({kind:"endsWith",value:t,...je.errToObj(n)})}min(t,n){return this._addCheck({kind:"min",value:t,...je.errToObj(n)})}max(t,n){return this._addCheck({kind:"max",value:t,...je.errToObj(n)})}length(t,n){return this._addCheck({kind:"length",value:t,...je.errToObj(n)})}nonempty(t){return this.min(1,je.errToObj(t))}trim(){return new es({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new es({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new es({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find(t=>t.kind==="datetime")}get isDate(){return!!this._def.checks.find(t=>t.kind==="date")}get isTime(){return!!this._def.checks.find(t=>t.kind==="time")}get isDuration(){return!!this._def.checks.find(t=>t.kind==="duration")}get isEmail(){return!!this._def.checks.find(t=>t.kind==="email")}get isURL(){return!!this._def.checks.find(t=>t.kind==="url")}get isEmoji(){return!!this._def.checks.find(t=>t.kind==="emoji")}get isUUID(){return!!this._def.checks.find(t=>t.kind==="uuid")}get isNANOID(){return!!this._def.checks.find(t=>t.kind==="nanoid")}get isCUID(){return!!this._def.checks.find(t=>t.kind==="cuid")}get isCUID2(){return!!this._def.checks.find(t=>t.kind==="cuid2")}get isULID(){return!!this._def.checks.find(t=>t.kind==="ulid")}get isIP(){return!!this._def.checks.find(t=>t.kind==="ip")}get isBase64(){return!!this._def.checks.find(t=>t.kind==="base64")}get minLength(){let t=null;for(const n of this._def.checks)n.kind==="min"&&(t===null||n.value>t)&&(t=n.value);return t}get maxLength(){let t=null;for(const n of this._def.checks)n.kind==="max"&&(t===null||n.value<t)&&(t=n.value);return t}}es.create=e=>{var t;return new es({checks:[],typeName:Fe.ZodString,coerce:(t=e==null?void 0:e.coerce)!==null&&t!==void 0?t:!1,...Ke(e)})};function x6(e,t){const n=(e.toString().split(".")[1]||"").length,r=(t.toString().split(".")[1]||"").length,s=n>r?n:r,o=parseInt(e.toFixed(s).replace(".","")),a=parseInt(t.toFixed(s).replace(".",""));return o%a/Math.pow(10,s)}class va extends Qe{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(t){if(this._def.coerce&&(t.data=Number(t.data)),this._getType(t)!==be.number){const o=this._getOrReturnCtx(t);return ve(o,{code:re.invalid_type,expected:be.number,received:o.parsedType}),Be}let r;const s=new Dn;for(const o of this._def.checks)o.kind==="int"?ut.isInteger(t.data)||(r=this._getOrReturnCtx(t,r),ve(r,{code:re.invalid_type,expected:"integer",received:"float",message:o.message}),s.dirty()):o.kind==="min"?(o.inclusive?t.data<o.value:t.data<=o.value)&&(r=this._getOrReturnCtx(t,r),ve(r,{code:re.too_small,minimum:o.value,type:"number",inclusive:o.inclusive,exact:!1,message:o.message}),s.dirty()):o.kind==="max"?(o.inclusive?t.data>o.value:t.data>=o.value)&&(r=this._getOrReturnCtx(t,r),ve(r,{code:re.too_big,maximum:o.value,type:"number",inclusive:o.inclusive,exact:!1,message:o.message}),s.dirty()):o.kind==="multipleOf"?x6(t.data,o.value)!==0&&(r=this._getOrReturnCtx(t,r),ve(r,{code:re.not_multiple_of,multipleOf:o.value,message:o.message}),s.dirty()):o.kind==="finite"?Number.isFinite(t.data)||(r=this._getOrReturnCtx(t,r),ve(r,{code:re.not_finite,message:o.message}),s.dirty()):ut.assertNever(o);return{status:s.value,value:t.data}}gte(t,n){return this.setLimit("min",t,!0,je.toString(n))}gt(t,n){return this.setLimit("min",t,!1,je.toString(n))}lte(t,n){return this.setLimit("max",t,!0,je.toString(n))}lt(t,n){return this.setLimit("max",t,!1,je.toString(n))}setLimit(t,n,r,s){return new va({...this._def,checks:[...this._def.checks,{kind:t,value:n,inclusive:r,message:je.toString(s)}]})}_addCheck(t){return new va({...this._def,checks:[...this._def.checks,t]})}int(t){return this._addCheck({kind:"int",message:je.toString(t)})}positive(t){return this._addCheck({kind:"min",value:0,inclusive:!1,message:je.toString(t)})}negative(t){return this._addCheck({kind:"max",value:0,inclusive:!1,message:je.toString(t)})}nonpositive(t){return this._addCheck({kind:"max",value:0,inclusive:!0,message:je.toString(t)})}nonnegative(t){return this._addCheck({kind:"min",value:0,inclusive:!0,message:je.toString(t)})}multipleOf(t,n){return this._addCheck({kind:"multipleOf",value:t,message:je.toString(n)})}finite(t){return this._addCheck({kind:"finite",message:je.toString(t)})}safe(t){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:je.toString(t)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:je.toString(t)})}get minValue(){let t=null;for(const n of this._def.checks)n.kind==="min"&&(t===null||n.value>t)&&(t=n.value);return t}get maxValue(){let t=null;for(const n of this._def.checks)n.kind==="max"&&(t===null||n.value<t)&&(t=n.value);return t}get isInt(){return!!this._def.checks.find(t=>t.kind==="int"||t.kind==="multipleOf"&&ut.isInteger(t.value))}get isFinite(){let t=null,n=null;for(const r of this._def.checks){if(r.kind==="finite"||r.kind==="int"||r.kind==="multipleOf")return!0;r.kind==="min"?(n===null||r.value>n)&&(n=r.value):r.kind==="max"&&(t===null||r.value<t)&&(t=r.value)}return Number.isFinite(n)&&Number.isFinite(t)}}va.create=e=>new va({checks:[],typeName:Fe.ZodNumber,coerce:(e==null?void 0:e.coerce)||!1,...Ke(e)});class ya extends Qe{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte}_parse(t){if(this._def.coerce&&(t.data=BigInt(t.data)),this._getType(t)!==be.bigint){const o=this._getOrReturnCtx(t);return ve(o,{code:re.invalid_type,expected:be.bigint,received:o.parsedType}),Be}let r;const s=new Dn;for(const o of this._def.checks)o.kind==="min"?(o.inclusive?t.data<o.value:t.data<=o.value)&&(r=this._getOrReturnCtx(t,r),ve(r,{code:re.too_small,type:"bigint",minimum:o.value,inclusive:o.inclusive,message:o.message}),s.dirty()):o.kind==="max"?(o.inclusive?t.data>o.value:t.data>=o.value)&&(r=this._getOrReturnCtx(t,r),ve(r,{code:re.too_big,type:"bigint",maximum:o.value,inclusive:o.inclusive,message:o.message}),s.dirty()):o.kind==="multipleOf"?t.data%o.value!==BigInt(0)&&(r=this._getOrReturnCtx(t,r),ve(r,{code:re.not_multiple_of,multipleOf:o.value,message:o.message}),s.dirty()):ut.assertNever(o);return{status:s.value,value:t.data}}gte(t,n){return this.setLimit("min",t,!0,je.toString(n))}gt(t,n){return this.setLimit("min",t,!1,je.toString(n))}lte(t,n){return this.setLimit("max",t,!0,je.toString(n))}lt(t,n){return this.setLimit("max",t,!1,je.toString(n))}setLimit(t,n,r,s){return new ya({...this._def,checks:[...this._def.checks,{kind:t,value:n,inclusive:r,message:je.toString(s)}]})}_addCheck(t){return new ya({...this._def,checks:[...this._def.checks,t]})}positive(t){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:je.toString(t)})}negative(t){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:je.toString(t)})}nonpositive(t){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:je.toString(t)})}nonnegative(t){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:je.toString(t)})}multipleOf(t,n){return this._addCheck({kind:"multipleOf",value:t,message:je.toString(n)})}get minValue(){let t=null;for(const n of this._def.checks)n.kind==="min"&&(t===null||n.value>t)&&(t=n.value);return t}get maxValue(){let t=null;for(const n of this._def.checks)n.kind==="max"&&(t===null||n.value<t)&&(t=n.value);return t}}ya.create=e=>{var t;return new ya({checks:[],typeName:Fe.ZodBigInt,coerce:(t=e==null?void 0:e.coerce)!==null&&t!==void 0?t:!1,...Ke(e)})};class fd extends Qe{_parse(t){if(this._def.coerce&&(t.data=!!t.data),this._getType(t)!==be.boolean){const r=this._getOrReturnCtx(t);return ve(r,{code:re.invalid_type,expected:be.boolean,received:r.parsedType}),Be}return Kn(t.data)}}fd.create=e=>new fd({typeName:Fe.ZodBoolean,coerce:(e==null?void 0:e.coerce)||!1,...Ke(e)});class Ti extends Qe{_parse(t){if(this._def.coerce&&(t.data=new Date(t.data)),this._getType(t)!==be.date){const o=this._getOrReturnCtx(t);return ve(o,{code:re.invalid_type,expected:be.date,received:o.parsedType}),Be}if(isNaN(t.data.getTime())){const o=this._getOrReturnCtx(t);return ve(o,{code:re.invalid_date}),Be}const r=new Dn;let s;for(const o of this._def.checks)o.kind==="min"?t.data.getTime()<o.value&&(s=this._getOrReturnCtx(t,s),ve(s,{code:re.too_small,message:o.message,inclusive:!0,exact:!1,minimum:o.value,type:"date"}),r.dirty()):o.kind==="max"?t.data.getTime()>o.value&&(s=this._getOrReturnCtx(t,s),ve(s,{code:re.too_big,message:o.message,inclusive:!0,exact:!1,maximum:o.value,type:"date"}),r.dirty()):ut.assertNever(o);return{status:r.value,value:new Date(t.data.getTime())}}_addCheck(t){return new Ti({...this._def,checks:[...this._def.checks,t]})}min(t,n){return this._addCheck({kind:"min",value:t.getTime(),message:je.toString(n)})}max(t,n){return this._addCheck({kind:"max",value:t.getTime(),message:je.toString(n)})}get minDate(){let t=null;for(const n of this._def.checks)n.kind==="min"&&(t===null||n.value>t)&&(t=n.value);return t!=null?new Date(t):null}get maxDate(){let t=null;for(const n of this._def.checks)n.kind==="max"&&(t===null||n.value<t)&&(t=n.value);return t!=null?new Date(t):null}}Ti.create=e=>new Ti({checks:[],coerce:(e==null?void 0:e.coerce)||!1,typeName:Fe.ZodDate,...Ke(e)});class bh extends Qe{_parse(t){if(this._getType(t)!==be.symbol){const r=this._getOrReturnCtx(t);return ve(r,{code:re.invalid_type,expected:be.symbol,received:r.parsedType}),Be}return Kn(t.data)}}bh.create=e=>new bh({typeName:Fe.ZodSymbol,...Ke(e)});class pd extends Qe{_parse(t){if(this._getType(t)!==be.undefined){const r=this._getOrReturnCtx(t);return ve(r,{code:re.invalid_type,expected:be.undefined,received:r.parsedType}),Be}return Kn(t.data)}}pd.create=e=>new pd({typeName:Fe.ZodUndefined,...Ke(e)});class hd extends Qe{_parse(t){if(this._getType(t)!==be.null){const r=this._getOrReturnCtx(t);return ve(r,{code:re.invalid_type,expected:be.null,received:r.parsedType}),Be}return Kn(t.data)}}hd.create=e=>new hd({typeName:Fe.ZodNull,...Ke(e)});class ru extends Qe{constructor(){super(...arguments),this._any=!0}_parse(t){return Kn(t.data)}}ru.create=e=>new ru({typeName:Fe.ZodAny,...Ke(e)});class fi extends Qe{constructor(){super(...arguments),this._unknown=!0}_parse(t){return Kn(t.data)}}fi.create=e=>new fi({typeName:Fe.ZodUnknown,...Ke(e)});class bo extends Qe{_parse(t){const n=this._getOrReturnCtx(t);return ve(n,{code:re.invalid_type,expected:be.never,received:n.parsedType}),Be}}bo.create=e=>new bo({typeName:Fe.ZodNever,...Ke(e)});class xh extends Qe{_parse(t){if(this._getType(t)!==be.undefined){const r=this._getOrReturnCtx(t);return ve(r,{code:re.invalid_type,expected:be.void,received:r.parsedType}),Be}return Kn(t.data)}}xh.create=e=>new xh({typeName:Fe.ZodVoid,...Ke(e)});class as extends Qe{_parse(t){const{ctx:n,status:r}=this._processInputParams(t),s=this._def;if(n.parsedType!==be.array)return ve(n,{code:re.invalid_type,expected:be.array,received:n.parsedType}),Be;if(s.exactLength!==null){const a=n.data.length>s.exactLength.value,l=n.data.length<s.exactLength.value;(a||l)&&(ve(n,{code:a?re.too_big:re.too_small,minimum:l?s.exactLength.value:void 0,maximum:a?s.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:s.exactLength.message}),r.dirty())}if(s.minLength!==null&&n.data.length<s.minLength.value&&(ve(n,{code:re.too_small,minimum:s.minLength.value,type:"array",inclusive:!0,exact:!1,message:s.minLength.message}),r.dirty()),s.maxLength!==null&&n.data.length>s.maxLength.value&&(ve(n,{code:re.too_big,maximum:s.maxLength.value,type:"array",inclusive:!0,exact:!1,message:s.maxLength.message}),r.dirty()),n.common.async)return Promise.all([...n.data].map((a,l)=>s.type._parseAsync(new zs(n,a,n.path,l)))).then(a=>Dn.mergeArray(r,a));const o=[...n.data].map((a,l)=>s.type._parseSync(new zs(n,a,n.path,l)));return Dn.mergeArray(r,o)}get element(){return this._def.type}min(t,n){return new as({...this._def,minLength:{value:t,message:je.toString(n)}})}max(t,n){return new as({...this._def,maxLength:{value:t,message:je.toString(n)}})}length(t,n){return new as({...this._def,exactLength:{value:t,message:je.toString(n)}})}nonempty(t){return this.min(1,t)}}as.create=(e,t)=>new as({type:e,minLength:null,maxLength:null,exactLength:null,typeName:Fe.ZodArray,...Ke(t)});function tl(e){if(e instanceof Dt){const t={};for(const n in e.shape){const r=e.shape[n];t[n]=Ls.create(tl(r))}return new Dt({...e._def,shape:()=>t})}else return e instanceof as?new as({...e._def,type:tl(e.element)}):e instanceof Ls?Ls.create(tl(e.unwrap())):e instanceof xa?xa.create(tl(e.unwrap())):e instanceof Us?Us.create(e.items.map(t=>tl(t))):e}class Dt extends Qe{constructor(){super(...arguments),this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;const t=this._def.shape(),n=ut.objectKeys(t);return this._cached={shape:t,keys:n}}_parse(t){if(this._getType(t)!==be.object){const i=this._getOrReturnCtx(t);return ve(i,{code:re.invalid_type,expected:be.object,received:i.parsedType}),Be}const{status:r,ctx:s}=this._processInputParams(t),{shape:o,keys:a}=this._getCached(),l=[];if(!(this._def.catchall instanceof bo&&this._def.unknownKeys==="strip"))for(const i in s.data)a.includes(i)||l.push(i);const c=[];for(const i of a){const d=o[i],p=s.data[i];c.push({key:{status:"valid",value:i},value:d._parse(new zs(s,p,s.path,i)),alwaysSet:i in s.data})}if(this._def.catchall instanceof bo){const i=this._def.unknownKeys;if(i==="passthrough")for(const d of l)c.push({key:{status:"valid",value:d},value:{status:"valid",value:s.data[d]}});else if(i==="strict")l.length>0&&(ve(s,{code:re.unrecognized_keys,keys:l}),r.dirty());else if(i!=="strip")throw new Error("Internal ZodObject error: invalid unknownKeys value.")}else{const i=this._def.catchall;for(const d of l){const p=s.data[d];c.push({key:{status:"valid",value:d},value:i._parse(new zs(s,p,s.path,d)),alwaysSet:d in s.data})}}return s.common.async?Promise.resolve().then(async()=>{const i=[];for(const d of c){const p=await d.key,f=await d.value;i.push({key:p,value:f,alwaysSet:d.alwaysSet})}return i}).then(i=>Dn.mergeObjectSync(r,i)):Dn.mergeObjectSync(r,c)}get shape(){return this._def.shape()}strict(t){return je.errToObj,new Dt({...this._def,unknownKeys:"strict",...t!==void 0?{errorMap:(n,r)=>{var s,o,a,l;const c=(a=(o=(s=this._def).errorMap)===null||o===void 0?void 0:o.call(s,n,r).message)!==null&&a!==void 0?a:r.defaultError;return n.code==="unrecognized_keys"?{message:(l=je.errToObj(t).message)!==null&&l!==void 0?l:c}:{message:c}}}:{}})}strip(){return new Dt({...this._def,unknownKeys:"strip"})}passthrough(){return new Dt({...this._def,unknownKeys:"passthrough"})}extend(t){return new Dt({...this._def,shape:()=>({...this._def.shape(),...t})})}merge(t){return new Dt({unknownKeys:t._def.unknownKeys,catchall:t._def.catchall,shape:()=>({...this._def.shape(),...t._def.shape()}),typeName:Fe.ZodObject})}setKey(t,n){return this.augment({[t]:n})}catchall(t){return new Dt({...this._def,catchall:t})}pick(t){const n={};return ut.objectKeys(t).forEach(r=>{t[r]&&this.shape[r]&&(n[r]=this.shape[r])}),new Dt({...this._def,shape:()=>n})}omit(t){const n={};return ut.objectKeys(this.shape).forEach(r=>{t[r]||(n[r]=this.shape[r])}),new Dt({...this._def,shape:()=>n})}deepPartial(){return tl(this)}partial(t){const n={};return ut.objectKeys(this.shape).forEach(r=>{const s=this.shape[r];t&&!t[r]?n[r]=s:n[r]=s.optional()}),new Dt({...this._def,shape:()=>n})}required(t){const n={};return ut.objectKeys(this.shape).forEach(r=>{if(t&&!t[r])n[r]=this.shape[r];else{let o=this.shape[r];for(;o instanceof Ls;)o=o._def.innerType;n[r]=o}}),new Dt({...this._def,shape:()=>n})}keyof(){return bM(ut.objectKeys(this.shape))}}Dt.create=(e,t)=>new Dt({shape:()=>e,unknownKeys:"strip",catchall:bo.create(),typeName:Fe.ZodObject,...Ke(t)});Dt.strictCreate=(e,t)=>new Dt({shape:()=>e,unknownKeys:"strict",catchall:bo.create(),typeName:Fe.ZodObject,...Ke(t)});Dt.lazycreate=(e,t)=>new Dt({shape:e,unknownKeys:"strip",catchall:bo.create(),typeName:Fe.ZodObject,...Ke(t)});class gd extends Qe{_parse(t){const{ctx:n}=this._processInputParams(t),r=this._def.options;function s(o){for(const l of o)if(l.result.status==="valid")return l.result;for(const l of o)if(l.result.status==="dirty")return n.common.issues.push(...l.ctx.common.issues),l.result;const a=o.map(l=>new yr(l.ctx.common.issues));return ve(n,{code:re.invalid_union,unionErrors:a}),Be}if(n.common.async)return Promise.all(r.map(async o=>{const a={...n,common:{...n.common,issues:[]},parent:null};return{result:await o._parseAsync({data:n.data,path:n.path,parent:a}),ctx:a}})).then(s);{let o;const a=[];for(const c of r){const i={...n,common:{...n.common,issues:[]},parent:null},d=c._parseSync({data:n.data,path:n.path,parent:i});if(d.status==="valid")return d;d.status==="dirty"&&!o&&(o={result:d,ctx:i}),i.common.issues.length&&a.push(i.common.issues)}if(o)return n.common.issues.push(...o.ctx.common.issues),o.result;const l=a.map(c=>new yr(c));return ve(n,{code:re.invalid_union,unionErrors:l}),Be}}get options(){return this._def.options}}gd.create=(e,t)=>new gd({options:e,typeName:Fe.ZodUnion,...Ke(t)});const Qs=e=>e instanceof yd?Qs(e.schema):e instanceof ds?Qs(e.innerType()):e instanceof bd?[e.value]:e instanceof ba?e.options:e instanceof xd?ut.objectValues(e.enum):e instanceof wd?Qs(e._def.innerType):e instanceof pd?[void 0]:e instanceof hd?[null]:e instanceof Ls?[void 0,...Qs(e.unwrap())]:e instanceof xa?[null,...Qs(e.unwrap())]:e instanceof Sw||e instanceof Cd?Qs(e.unwrap()):e instanceof Sd?Qs(e._def.innerType):[];class Pg extends Qe{_parse(t){const{ctx:n}=this._processInputParams(t);if(n.parsedType!==be.object)return ve(n,{code:re.invalid_type,expected:be.object,received:n.parsedType}),Be;const r=this.discriminator,s=n.data[r],o=this.optionsMap.get(s);return o?n.common.async?o._parseAsync({data:n.data,path:n.path,parent:n}):o._parseSync({data:n.data,path:n.path,parent:n}):(ve(n,{code:re.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[r]}),Be)}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create(t,n,r){const s=new Map;for(const o of n){const a=Qs(o.shape[t]);if(!a.length)throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);for(const l of a){if(s.has(l))throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(l)}`);s.set(l,o)}}return new Pg({typeName:Fe.ZodDiscriminatedUnion,discriminator:t,options:n,optionsMap:s,...Ke(r)})}}function nb(e,t){const n=Vo(e),r=Vo(t);if(e===t)return{valid:!0,data:e};if(n===be.object&&r===be.object){const s=ut.objectKeys(t),o=ut.objectKeys(e).filter(l=>s.indexOf(l)!==-1),a={...e,...t};for(const l of o){const c=nb(e[l],t[l]);if(!c.valid)return{valid:!1};a[l]=c.data}return{valid:!0,data:a}}else if(n===be.array&&r===be.array){if(e.length!==t.length)return{valid:!1};const s=[];for(let o=0;o<e.length;o++){const a=e[o],l=t[o],c=nb(a,l);if(!c.valid)return{valid:!1};s.push(c.data)}return{valid:!0,data:s}}else return n===be.date&&r===be.date&&+e==+t?{valid:!0,data:e}:{valid:!1}}class md extends Qe{_parse(t){const{status:n,ctx:r}=this._processInputParams(t),s=(o,a)=>{if(eb(o)||eb(a))return Be;const l=nb(o.value,a.value);return l.valid?((tb(o)||tb(a))&&n.dirty(),{status:n.value,value:l.data}):(ve(r,{code:re.invalid_intersection_types}),Be)};return r.common.async?Promise.all([this._def.left._parseAsync({data:r.data,path:r.path,parent:r}),this._def.right._parseAsync({data:r.data,path:r.path,parent:r})]).then(([o,a])=>s(o,a)):s(this._def.left._parseSync({data:r.data,path:r.path,parent:r}),this._def.right._parseSync({data:r.data,path:r.path,parent:r}))}}md.create=(e,t,n)=>new md({left:e,right:t,typeName:Fe.ZodIntersection,...Ke(n)});class Us extends Qe{_parse(t){const{status:n,ctx:r}=this._processInputParams(t);if(r.parsedType!==be.array)return ve(r,{code:re.invalid_type,expected:be.array,received:r.parsedType}),Be;if(r.data.length<this._def.items.length)return ve(r,{code:re.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),Be;!this._def.rest&&r.data.length>this._def.items.length&&(ve(r,{code:re.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),n.dirty());const o=[...r.data].map((a,l)=>{const c=this._def.items[l]||this._def.rest;return c?c._parse(new zs(r,a,r.path,l)):null}).filter(a=>!!a);return r.common.async?Promise.all(o).then(a=>Dn.mergeArray(n,a)):Dn.mergeArray(n,o)}get items(){return this._def.items}rest(t){return new Us({...this._def,rest:t})}}Us.create=(e,t)=>{if(!Array.isArray(e))throw new Error("You must pass an array of schemas to z.tuple([ ... ])");return new Us({items:e,typeName:Fe.ZodTuple,rest:null,...Ke(t)})};class vd extends Qe{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(t){const{status:n,ctx:r}=this._processInputParams(t);if(r.parsedType!==be.object)return ve(r,{code:re.invalid_type,expected:be.object,received:r.parsedType}),Be;const s=[],o=this._def.keyType,a=this._def.valueType;for(const l in r.data)s.push({key:o._parse(new zs(r,l,r.path,l)),value:a._parse(new zs(r,r.data[l],r.path,l)),alwaysSet:l in r.data});return r.common.async?Dn.mergeObjectAsync(n,s):Dn.mergeObjectSync(n,s)}get element(){return this._def.valueType}static create(t,n,r){return n instanceof Qe?new vd({keyType:t,valueType:n,typeName:Fe.ZodRecord,...Ke(r)}):new vd({keyType:es.create(),valueType:t,typeName:Fe.ZodRecord,...Ke(n)})}}class wh extends Qe{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(t){const{status:n,ctx:r}=this._processInputParams(t);if(r.parsedType!==be.map)return ve(r,{code:re.invalid_type,expected:be.map,received:r.parsedType}),Be;const s=this._def.keyType,o=this._def.valueType,a=[...r.data.entries()].map(([l,c],i)=>({key:s._parse(new zs(r,l,r.path,[i,"key"])),value:o._parse(new zs(r,c,r.path,[i,"value"]))}));if(r.common.async){const l=new Map;return Promise.resolve().then(async()=>{for(const c of a){const i=await c.key,d=await c.value;if(i.status==="aborted"||d.status==="aborted")return Be;(i.status==="dirty"||d.status==="dirty")&&n.dirty(),l.set(i.value,d.value)}return{status:n.value,value:l}})}else{const l=new Map;for(const c of a){const i=c.key,d=c.value;if(i.status==="aborted"||d.status==="aborted")return Be;(i.status==="dirty"||d.status==="dirty")&&n.dirty(),l.set(i.value,d.value)}return{status:n.value,value:l}}}}wh.create=(e,t,n)=>new wh({valueType:t,keyType:e,typeName:Fe.ZodMap,...Ke(n)});class ki extends Qe{_parse(t){const{status:n,ctx:r}=this._processInputParams(t);if(r.parsedType!==be.set)return ve(r,{code:re.invalid_type,expected:be.set,received:r.parsedType}),Be;const s=this._def;s.minSize!==null&&r.data.size<s.minSize.value&&(ve(r,{code:re.too_small,minimum:s.minSize.value,type:"set",inclusive:!0,exact:!1,message:s.minSize.message}),n.dirty()),s.maxSize!==null&&r.data.size>s.maxSize.value&&(ve(r,{code:re.too_big,maximum:s.maxSize.value,type:"set",inclusive:!0,exact:!1,message:s.maxSize.message}),n.dirty());const o=this._def.valueType;function a(c){const i=new Set;for(const d of c){if(d.status==="aborted")return Be;d.status==="dirty"&&n.dirty(),i.add(d.value)}return{status:n.value,value:i}}const l=[...r.data.values()].map((c,i)=>o._parse(new zs(r,c,r.path,i)));return r.common.async?Promise.all(l).then(c=>a(c)):a(l)}min(t,n){return new ki({...this._def,minSize:{value:t,message:je.toString(n)}})}max(t,n){return new ki({...this._def,maxSize:{value:t,message:je.toString(n)}})}size(t,n){return this.min(t,n).max(t,n)}nonempty(t){return this.min(1,t)}}ki.create=(e,t)=>new ki({valueType:e,minSize:null,maxSize:null,typeName:Fe.ZodSet,...Ke(t)});class jl extends Qe{constructor(){super(...arguments),this.validate=this.implement}_parse(t){const{ctx:n}=this._processInputParams(t);if(n.parsedType!==be.function)return ve(n,{code:re.invalid_type,expected:be.function,received:n.parsedType}),Be;function r(l,c){return vh({data:l,path:n.path,errorMaps:[n.common.contextualErrorMap,n.schemaErrorMap,mh(),nu].filter(i=>!!i),issueData:{code:re.invalid_arguments,argumentsError:c}})}function s(l,c){return vh({data:l,path:n.path,errorMaps:[n.common.contextualErrorMap,n.schemaErrorMap,mh(),nu].filter(i=>!!i),issueData:{code:re.invalid_return_type,returnTypeError:c}})}const o={errorMap:n.common.contextualErrorMap},a=n.data;if(this._def.returns instanceof su){const l=this;return Kn(async function(...c){const i=new yr([]),d=await l._def.args.parseAsync(c,o).catch(h=>{throw i.addIssue(r(c,h)),i}),p=await Reflect.apply(a,this,d);return await l._def.returns._def.type.parseAsync(p,o).catch(h=>{throw i.addIssue(s(p,h)),i})})}else{const l=this;return Kn(function(...c){const i=l._def.args.safeParse(c,o);if(!i.success)throw new yr([r(c,i.error)]);const d=Reflect.apply(a,this,i.data),p=l._def.returns.safeParse(d,o);if(!p.success)throw new yr([s(d,p.error)]);return p.data})}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...t){return new jl({...this._def,args:Us.create(t).rest(fi.create())})}returns(t){return new jl({...this._def,returns:t})}implement(t){return this.parse(t)}strictImplement(t){return this.parse(t)}static create(t,n,r){return new jl({args:t||Us.create([]).rest(fi.create()),returns:n||fi.create(),typeName:Fe.ZodFunction,...Ke(r)})}}class yd extends Qe{get schema(){return this._def.getter()}_parse(t){const{ctx:n}=this._processInputParams(t);return this._def.getter()._parse({data:n.data,path:n.path,parent:n})}}yd.create=(e,t)=>new yd({getter:e,typeName:Fe.ZodLazy,...Ke(t)});class bd extends Qe{_parse(t){if(t.data!==this._def.value){const n=this._getOrReturnCtx(t);return ve(n,{received:n.data,code:re.invalid_literal,expected:this._def.value}),Be}return{status:"valid",value:t.data}}get value(){return this._def.value}}bd.create=(e,t)=>new bd({value:e,typeName:Fe.ZodLiteral,...Ke(t)});function bM(e,t){return new ba({values:e,typeName:Fe.ZodEnum,...Ke(t)})}class ba extends Qe{constructor(){super(...arguments),fc.set(this,void 0)}_parse(t){if(typeof t.data!="string"){const n=this._getOrReturnCtx(t),r=this._def.values;return ve(n,{expected:ut.joinValues(r),received:n.parsedType,code:re.invalid_type}),Be}if(yh(this,fc)||gM(this,fc,new Set(this._def.values)),!yh(this,fc).has(t.data)){const n=this._getOrReturnCtx(t),r=this._def.values;return ve(n,{received:n.data,code:re.invalid_enum_value,options:r}),Be}return Kn(t.data)}get options(){return this._def.values}get enum(){const t={};for(const n of this._def.values)t[n]=n;return t}get Values(){const t={};for(const n of this._def.values)t[n]=n;return t}get Enum(){const t={};for(const n of this._def.values)t[n]=n;return t}extract(t,n=this._def){return ba.create(t,{...this._def,...n})}exclude(t,n=this._def){return ba.create(this.options.filter(r=>!t.includes(r)),{...this._def,...n})}}fc=new WeakMap;ba.create=bM;class xd extends Qe{constructor(){super(...arguments),pc.set(this,void 0)}_parse(t){const n=ut.getValidEnumValues(this._def.values),r=this._getOrReturnCtx(t);if(r.parsedType!==be.string&&r.parsedType!==be.number){const s=ut.objectValues(n);return ve(r,{expected:ut.joinValues(s),received:r.parsedType,code:re.invalid_type}),Be}if(yh(this,pc)||gM(this,pc,new Set(ut.getValidEnumValues(this._def.values))),!yh(this,pc).has(t.data)){const s=ut.objectValues(n);return ve(r,{received:r.data,code:re.invalid_enum_value,options:s}),Be}return Kn(t.data)}get enum(){return this._def.values}}pc=new WeakMap;xd.create=(e,t)=>new xd({values:e,typeName:Fe.ZodNativeEnum,...Ke(t)});class su extends Qe{unwrap(){return this._def.type}_parse(t){const{ctx:n}=this._processInputParams(t);if(n.parsedType!==be.promise&&n.common.async===!1)return ve(n,{code:re.invalid_type,expected:be.promise,received:n.parsedType}),Be;const r=n.parsedType===be.promise?n.data:Promise.resolve(n.data);return Kn(r.then(s=>this._def.type.parseAsync(s,{path:n.path,errorMap:n.common.contextualErrorMap})))}}su.create=(e,t)=>new su({type:e,typeName:Fe.ZodPromise,...Ke(t)});class ds extends Qe{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===Fe.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(t){const{status:n,ctx:r}=this._processInputParams(t),s=this._def.effect||null,o={addIssue:a=>{ve(r,a),a.fatal?n.abort():n.dirty()},get path(){return r.path}};if(o.addIssue=o.addIssue.bind(o),s.type==="preprocess"){const a=s.transform(r.data,o);if(r.common.async)return Promise.resolve(a).then(async l=>{if(n.value==="aborted")return Be;const c=await this._def.schema._parseAsync({data:l,path:r.path,parent:r});return c.status==="aborted"?Be:c.status==="dirty"||n.value==="dirty"?vl(c.value):c});{if(n.value==="aborted")return Be;const l=this._def.schema._parseSync({data:a,path:r.path,parent:r});return l.status==="aborted"?Be:l.status==="dirty"||n.value==="dirty"?vl(l.value):l}}if(s.type==="refinement"){const a=l=>{const c=s.refinement(l,o);if(r.common.async)return Promise.resolve(c);if(c instanceof Promise)throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return l};if(r.common.async===!1){const l=this._def.schema._parseSync({data:r.data,path:r.path,parent:r});return l.status==="aborted"?Be:(l.status==="dirty"&&n.dirty(),a(l.value),{status:n.value,value:l.value})}else return this._def.schema._parseAsync({data:r.data,path:r.path,parent:r}).then(l=>l.status==="aborted"?Be:(l.status==="dirty"&&n.dirty(),a(l.value).then(()=>({status:n.value,value:l.value}))))}if(s.type==="transform")if(r.common.async===!1){const a=this._def.schema._parseSync({data:r.data,path:r.path,parent:r});if(!cd(a))return a;const l=s.transform(a.value,o);if(l instanceof Promise)throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:n.value,value:l}}else return this._def.schema._parseAsync({data:r.data,path:r.path,parent:r}).then(a=>cd(a)?Promise.resolve(s.transform(a.value,o)).then(l=>({status:n.value,value:l})):a);ut.assertNever(s)}}ds.create=(e,t,n)=>new ds({schema:e,typeName:Fe.ZodEffects,effect:t,...Ke(n)});ds.createWithPreprocess=(e,t,n)=>new ds({schema:t,effect:{type:"preprocess",transform:e},typeName:Fe.ZodEffects,...Ke(n)});class Ls extends Qe{_parse(t){return this._getType(t)===be.undefined?Kn(void 0):this._def.innerType._parse(t)}unwrap(){return this._def.innerType}}Ls.create=(e,t)=>new Ls({innerType:e,typeName:Fe.ZodOptional,...Ke(t)});class xa extends Qe{_parse(t){return this._getType(t)===be.null?Kn(null):this._def.innerType._parse(t)}unwrap(){return this._def.innerType}}xa.create=(e,t)=>new xa({innerType:e,typeName:Fe.ZodNullable,...Ke(t)});class wd extends Qe{_parse(t){const{ctx:n}=this._processInputParams(t);let r=n.data;return n.parsedType===be.undefined&&(r=this._def.defaultValue()),this._def.innerType._parse({data:r,path:n.path,parent:n})}removeDefault(){return this._def.innerType}}wd.create=(e,t)=>new wd({innerType:e,typeName:Fe.ZodDefault,defaultValue:typeof t.default=="function"?t.default:()=>t.default,...Ke(t)});class Sd extends Qe{_parse(t){const{ctx:n}=this._processInputParams(t),r={...n,common:{...n.common,issues:[]}},s=this._def.innerType._parse({data:r.data,path:r.path,parent:{...r}});return dd(s)?s.then(o=>({status:"valid",value:o.status==="valid"?o.value:this._def.catchValue({get error(){return new yr(r.common.issues)},input:r.data})})):{status:"valid",value:s.status==="valid"?s.value:this._def.catchValue({get error(){return new yr(r.common.issues)},input:r.data})}}removeCatch(){return this._def.innerType}}Sd.create=(e,t)=>new Sd({innerType:e,typeName:Fe.ZodCatch,catchValue:typeof t.catch=="function"?t.catch:()=>t.catch,...Ke(t)});class Sh extends Qe{_parse(t){if(this._getType(t)!==be.nan){const r=this._getOrReturnCtx(t);return ve(r,{code:re.invalid_type,expected:be.nan,received:r.parsedType}),Be}return{status:"valid",value:t.data}}}Sh.create=e=>new Sh({typeName:Fe.ZodNaN,...Ke(e)});const w6=Symbol("zod_brand");class Sw extends Qe{_parse(t){const{ctx:n}=this._processInputParams(t),r=n.data;return this._def.type._parse({data:r,path:n.path,parent:n})}unwrap(){return this._def.type}}class Xd extends Qe{_parse(t){const{status:n,ctx:r}=this._processInputParams(t);if(r.common.async)return(async()=>{const o=await this._def.in._parseAsync({data:r.data,path:r.path,parent:r});return o.status==="aborted"?Be:o.status==="dirty"?(n.dirty(),vl(o.value)):this._def.out._parseAsync({data:o.value,path:r.path,parent:r})})();{const s=this._def.in._parseSync({data:r.data,path:r.path,parent:r});return s.status==="aborted"?Be:s.status==="dirty"?(n.dirty(),{status:"dirty",value:s.value}):this._def.out._parseSync({data:s.value,path:r.path,parent:r})}}static create(t,n){return new Xd({in:t,out:n,typeName:Fe.ZodPipeline})}}class Cd extends Qe{_parse(t){const n=this._def.innerType._parse(t),r=s=>(cd(s)&&(s.value=Object.freeze(s.value)),s);return dd(n)?n.then(s=>r(s)):r(n)}unwrap(){return this._def.innerType}}Cd.create=(e,t)=>new Cd({innerType:e,typeName:Fe.ZodReadonly,...Ke(t)});function xM(e,t={},n){return e?ru.create().superRefine((r,s)=>{var o,a;if(!e(r)){const l=typeof t=="function"?t(r):typeof t=="string"?{message:t}:t,c=(a=(o=l.fatal)!==null&&o!==void 0?o:n)!==null&&a!==void 0?a:!0,i=typeof l=="string"?{message:l}:l;s.addIssue({code:"custom",...i,fatal:c})}}):ru.create()}const S6={object:Dt.lazycreate};var Fe;(function(e){e.ZodString="ZodString",e.ZodNumber="ZodNumber",e.ZodNaN="ZodNaN",e.ZodBigInt="ZodBigInt",e.ZodBoolean="ZodBoolean",e.ZodDate="ZodDate",e.ZodSymbol="ZodSymbol",e.ZodUndefined="ZodUndefined",e.ZodNull="ZodNull",e.ZodAny="ZodAny",e.ZodUnknown="ZodUnknown",e.ZodNever="ZodNever",e.ZodVoid="ZodVoid",e.ZodArray="ZodArray",e.ZodObject="ZodObject",e.ZodUnion="ZodUnion",e.ZodDiscriminatedUnion="ZodDiscriminatedUnion",e.ZodIntersection="ZodIntersection",e.ZodTuple="ZodTuple",e.ZodRecord="ZodRecord",e.ZodMap="ZodMap",e.ZodSet="ZodSet",e.ZodFunction="ZodFunction",e.ZodLazy="ZodLazy",e.ZodLiteral="ZodLiteral",e.ZodEnum="ZodEnum",e.ZodEffects="ZodEffects",e.ZodNativeEnum="ZodNativeEnum",e.ZodOptional="ZodOptional",e.ZodNullable="ZodNullable",e.ZodDefault="ZodDefault",e.ZodCatch="ZodCatch",e.ZodPromise="ZodPromise",e.ZodBranded="ZodBranded",e.ZodPipeline="ZodPipeline",e.ZodReadonly="ZodReadonly"})(Fe||(Fe={}));const C6=(e,t={message:`Input not instance of ${e.name}`})=>xM(n=>n instanceof e,t),wM=es.create,SM=va.create,E6=Sh.create,T6=ya.create,CM=fd.create,k6=Ti.create,_6=bh.create,j6=pd.create,R6=hd.create,P6=ru.create,M6=fi.create,O6=bo.create,N6=xh.create,I6=as.create,D6=Dt.create,A6=Dt.strictCreate,F6=gd.create,L6=Pg.create,$6=md.create,B6=Us.create,z6=vd.create,U6=wh.create,V6=ki.create,H6=jl.create,K6=yd.create,q6=bd.create,W6=ba.create,G6=xd.create,J6=su.create,DC=ds.create,Q6=Ls.create,Z6=xa.create,Y6=ds.createWithPreprocess,X6=Xd.create,e8=()=>wM().optional(),t8=()=>SM().optional(),n8=()=>CM().optional(),r8={string:e=>es.create({...e,coerce:!0}),number:e=>va.create({...e,coerce:!0}),boolean:e=>fd.create({...e,coerce:!0}),bigint:e=>ya.create({...e,coerce:!0}),date:e=>Ti.create({...e,coerce:!0})},s8=Be;var _=Object.freeze({__proto__:null,defaultErrorMap:nu,setErrorMap:s6,getErrorMap:mh,makeIssue:vh,EMPTY_PATH:o6,addIssueToContext:ve,ParseStatus:Dn,INVALID:Be,DIRTY:vl,OK:Kn,isAborted:eb,isDirty:tb,isValid:cd,isAsync:dd,get util(){return ut},get objectUtil(){return Xy},ZodParsedType:be,getParsedType:Vo,ZodType:Qe,datetimeRegex:yM,ZodString:es,ZodNumber:va,ZodBigInt:ya,ZodBoolean:fd,ZodDate:Ti,ZodSymbol:bh,ZodUndefined:pd,ZodNull:hd,ZodAny:ru,ZodUnknown:fi,ZodNever:bo,ZodVoid:xh,ZodArray:as,ZodObject:Dt,ZodUnion:gd,ZodDiscriminatedUnion:Pg,ZodIntersection:md,ZodTuple:Us,ZodRecord:vd,ZodMap:wh,ZodSet:ki,ZodFunction:jl,ZodLazy:yd,ZodLiteral:bd,ZodEnum:ba,ZodNativeEnum:xd,ZodPromise:su,ZodEffects:ds,ZodTransformer:ds,ZodOptional:Ls,ZodNullable:xa,ZodDefault:wd,ZodCatch:Sd,ZodNaN:Sh,BRAND:w6,ZodBranded:Sw,ZodPipeline:Xd,ZodReadonly:Cd,custom:xM,Schema:Qe,ZodSchema:Qe,late:S6,get ZodFirstPartyTypeKind(){return Fe},coerce:r8,any:P6,array:I6,bigint:T6,boolean:CM,date:k6,discriminatedUnion:L6,effect:DC,enum:W6,function:H6,instanceof:C6,intersection:$6,lazy:K6,literal:q6,map:U6,nan:E6,nativeEnum:G6,never:O6,null:R6,nullable:Z6,number:SM,object:D6,oboolean:n8,onumber:t8,optional:Q6,ostring:e8,pipeline:X6,preprocess:Y6,promise:J6,record:z6,set:V6,strictObject:A6,string:wM,symbol:_6,transformer:DC,tuple:B6,undefined:j6,union:F6,unknown:M6,void:N6,NEVER:s8,ZodIssueCode:re,quotelessJson:r6,ZodError:yr}),EM=v.createContext({dragDropManager:void 0}),Dr;(function(e){e.SOURCE="SOURCE",e.TARGET="TARGET"})(Dr||(Dr={}));function Ve(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),s=2;s<n;s++)r[s-2]=arguments[s];if(!e){var o;if(t===void 0)o=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var a=0;o=new Error(t.replace(/%s/g,function(){return r[a++]})),o.name="Invariant Violation"}throw o.framesToPop=1,o}}var Cw="dnd-core/INIT_COORDS",Mg="dnd-core/BEGIN_DRAG",Ew="dnd-core/PUBLISH_DRAG_SOURCE",Og="dnd-core/HOVER",Ng="dnd-core/DROP",Ig="dnd-core/END_DRAG";function AC(e,t){return{type:Cw,payload:{sourceClientOffset:t||null,clientOffset:e||null}}}function yp(e){"@babel/helpers - typeof";return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?yp=function(n){return typeof n}:yp=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},yp(e)}function o8(e,t,n){return t.split(".").reduce(function(r,s){return r&&r[s]?r[s]:n||null},e)}function a8(e,t){return e.filter(function(n){return n!==t})}function TM(e){return yp(e)==="object"}function i8(e,t){var n=new Map,r=function(a){n.set(a,n.has(a)?n.get(a)+1:1)};e.forEach(r),t.forEach(r);var s=[];return n.forEach(function(o,a){o===1&&s.push(a)}),s}function l8(e,t){return e.filter(function(n){return t.indexOf(n)>-1})}var u8={type:Cw,payload:{clientOffset:null,sourceClientOffset:null}};function c8(e){return function(){var n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{publishSource:!0},s=r.publishSource,o=s===void 0?!0:s,a=r.clientOffset,l=r.getSourceClientOffset,c=e.getMonitor(),i=e.getRegistry();e.dispatch(AC(a)),d8(n,c,i);var d=h8(n,c);if(d===null){e.dispatch(u8);return}var p=null;if(a){if(!l)throw new Error("getSourceClientOffset must be defined");f8(l),p=l(d)}e.dispatch(AC(a,p));var f=i.getSource(d),h=f.beginDrag(c,d);if(h!=null){p8(h),i.pinSource(d);var g=i.getSourceType(d);return{type:Mg,payload:{itemType:g,item:h,sourceId:d,clientOffset:a||null,sourceClientOffset:p||null,isSourcePublic:!!o}}}}}function d8(e,t,n){Ve(!t.isDragging(),"Cannot call beginDrag while dragging."),e.forEach(function(r){Ve(n.getSource(r),"Expected sourceIds to be registered.")})}function f8(e){Ve(typeof e=="function","When clientOffset is provided, getSourceClientOffset must be a function.")}function p8(e){Ve(TM(e),"Item must be an object.")}function h8(e,t){for(var n=null,r=e.length-1;r>=0;r--)if(t.canDragSource(e[r])){n=e[r];break}return n}function g8(e){return function(){var n=e.getMonitor();if(n.isDragging())return{type:Ew}}}function rb(e,t){return t===null?e===null:Array.isArray(e)?e.some(function(n){return n===t}):e===t}function m8(e){return function(n){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},s=r.clientOffset;v8(n);var o=n.slice(0),a=e.getMonitor(),l=e.getRegistry();y8(o,a,l);var c=a.getItemType();return b8(o,l,c),x8(o,a,l),{type:Og,payload:{targetIds:o,clientOffset:s||null}}}}function v8(e){Ve(Array.isArray(e),"Expected targetIds to be an array.")}function y8(e,t,n){Ve(t.isDragging(),"Cannot call hover while not dragging."),Ve(!t.didDrop(),"Cannot call hover after drop.");for(var r=0;r<e.length;r++){var s=e[r];Ve(e.lastIndexOf(s)===r,"Expected targetIds to be unique in the passed array.");var o=n.getTarget(s);Ve(o,"Expected targetIds to be registered.")}}function b8(e,t,n){for(var r=e.length-1;r>=0;r--){var s=e[r],o=t.getTargetType(s);rb(o,n)||e.splice(r,1)}}function x8(e,t,n){e.forEach(function(r){var s=n.getTarget(r);s.hover(t,r)})}function FC(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,r)}return n}function LC(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?FC(Object(n),!0).forEach(function(r){w8(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):FC(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function w8(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function S8(e){return function(){var n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},r=e.getMonitor(),s=e.getRegistry();C8(r);var o=k8(r);o.forEach(function(a,l){var c=E8(a,l,s,r),i={type:Ng,payload:{dropResult:LC(LC({},n),c)}};e.dispatch(i)})}}function C8(e){Ve(e.isDragging(),"Cannot call drop while not dragging."),Ve(!e.didDrop(),"Cannot call drop twice during one drag operation.")}function E8(e,t,n,r){var s=n.getTarget(e),o=s?s.drop(r,e):void 0;return T8(o),typeof o>"u"&&(o=t===0?{}:r.getDropResult()),o}function T8(e){Ve(typeof e>"u"||TM(e),"Drop result must either be an object or undefined.")}function k8(e){var t=e.getTargetIds().filter(e.canDropOnTarget,e);return t.reverse(),t}function _8(e){return function(){var n=e.getMonitor(),r=e.getRegistry();j8(n);var s=n.getSourceId();if(s!=null){var o=r.getSource(s,!0);o.endDrag(n,s),r.unpinSource()}return{type:Ig}}}function j8(e){Ve(e.isDragging(),"Cannot call endDrag while not dragging.")}function R8(e){return{beginDrag:c8(e),publishDragSource:g8(e),hover:m8(e),drop:S8(e),endDrag:_8(e)}}function P8(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function M8(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function O8(e,t,n){return t&&M8(e.prototype,t),e}function Yu(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var N8=function(){function e(t,n){var r=this;P8(this,e),Yu(this,"store",void 0),Yu(this,"monitor",void 0),Yu(this,"backend",void 0),Yu(this,"isSetUp",!1),Yu(this,"handleRefCountChange",function(){var s=r.store.getState().refCount>0;r.backend&&(s&&!r.isSetUp?(r.backend.setup(),r.isSetUp=!0):!s&&r.isSetUp&&(r.backend.teardown(),r.isSetUp=!1))}),this.store=t,this.monitor=n,t.subscribe(this.handleRefCountChange)}return O8(e,[{key:"receiveBackend",value:function(n){this.backend=n}},{key:"getMonitor",value:function(){return this.monitor}},{key:"getBackend",value:function(){return this.backend}},{key:"getRegistry",value:function(){return this.monitor.registry}},{key:"getActions",value:function(){var n=this,r=this.store.dispatch;function s(a){return function(){for(var l=arguments.length,c=new Array(l),i=0;i<l;i++)c[i]=arguments[i];var d=a.apply(n,c);typeof d<"u"&&r(d)}}var o=R8(this);return Object.keys(o).reduce(function(a,l){var c=o[l];return a[l]=s(c),a},{})}},{key:"dispatch",value:function(n){this.store.dispatch(n)}}]),e}();function _r(e){return"Minified Redux error #"+e+"; visit https://redux.js.org/Errors?code="+e+" for the full message or use the non-minified dev environment for full errors. "}var $C=function(){return typeof Symbol=="function"&&Symbol.observable||"@@observable"}(),tv=function(){return Math.random().toString(36).substring(7).split("").join(".")},BC={INIT:"@@redux/INIT"+tv(),REPLACE:"@@redux/REPLACE"+tv(),PROBE_UNKNOWN_ACTION:function(){return"@@redux/PROBE_UNKNOWN_ACTION"+tv()}};function I8(e){if(typeof e!="object"||e===null)return!1;for(var t=e;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}function kM(e,t,n){var r;if(typeof t=="function"&&typeof n=="function"||typeof n=="function"&&typeof arguments[3]=="function")throw new Error(_r(0));if(typeof t=="function"&&typeof n>"u"&&(n=t,t=void 0),typeof n<"u"){if(typeof n!="function")throw new Error(_r(1));return n(kM)(e,t)}if(typeof e!="function")throw new Error(_r(2));var s=e,o=t,a=[],l=a,c=!1;function i(){l===a&&(l=a.slice())}function d(){if(c)throw new Error(_r(3));return o}function p(m){if(typeof m!="function")throw new Error(_r(4));if(c)throw new Error(_r(5));var x=!0;return i(),l.push(m),function(){if(x){if(c)throw new Error(_r(6));x=!1,i();var y=l.indexOf(m);l.splice(y,1),a=null}}}function f(m){if(!I8(m))throw new Error(_r(7));if(typeof m.type>"u")throw new Error(_r(8));if(c)throw new Error(_r(9));try{c=!0,o=s(o,m)}finally{c=!1}for(var x=a=l,b=0;b<x.length;b++){var y=x[b];y()}return m}function h(m){if(typeof m!="function")throw new Error(_r(10));s=m,f({type:BC.REPLACE})}function g(){var m,x=p;return m={subscribe:function(y){if(typeof y!="object"||y===null)throw new Error(_r(11));function w(){y.next&&y.next(d())}w();var S=x(w);return{unsubscribe:S}}},m[$C]=function(){return this},m}return f({type:BC.INIT}),r={dispatch:f,subscribe:p,getState:d,replaceReducer:h},r[$C]=g,r}var D8=function(t,n){return t===n};function A8(e,t){return!e&&!t?!0:!e||!t?!1:e.x===t.x&&e.y===t.y}function F8(e,t){var n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:D8;if(e.length!==t.length)return!1;for(var r=0;r<e.length;++r)if(!n(e[r],t[r]))return!1;return!0}function zC(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,r)}return n}function UC(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?zC(Object(n),!0).forEach(function(r){L8(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):zC(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function L8(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var VC={initialSourceClientOffset:null,initialClientOffset:null,clientOffset:null};function $8(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:VC,t=arguments.length>1?arguments[1]:void 0,n=t.payload;switch(t.type){case Cw:case Mg:return{initialSourceClientOffset:n.sourceClientOffset,initialClientOffset:n.clientOffset,clientOffset:n.clientOffset};case Og:return A8(e.clientOffset,n.clientOffset)?e:UC(UC({},e),{},{clientOffset:n.clientOffset});case Ig:case Ng:return VC;default:return e}}var Tw="dnd-core/ADD_SOURCE",kw="dnd-core/ADD_TARGET",_w="dnd-core/REMOVE_SOURCE",Dg="dnd-core/REMOVE_TARGET";function B8(e){return{type:Tw,payload:{sourceId:e}}}function z8(e){return{type:kw,payload:{targetId:e}}}function U8(e){return{type:_w,payload:{sourceId:e}}}function V8(e){return{type:Dg,payload:{targetId:e}}}function HC(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,r)}return n}function jr(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?HC(Object(n),!0).forEach(function(r){H8(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):HC(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function H8(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var K8={itemType:null,item:null,sourceId:null,targetIds:[],dropResult:null,didDrop:!1,isSourcePublic:null};function q8(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:K8,t=arguments.length>1?arguments[1]:void 0,n=t.payload;switch(t.type){case Mg:return jr(jr({},e),{},{itemType:n.itemType,item:n.item,sourceId:n.sourceId,isSourcePublic:n.isSourcePublic,dropResult:null,didDrop:!1});case Ew:return jr(jr({},e),{},{isSourcePublic:!0});case Og:return jr(jr({},e),{},{targetIds:n.targetIds});case Dg:return e.targetIds.indexOf(n.targetId)===-1?e:jr(jr({},e),{},{targetIds:a8(e.targetIds,n.targetId)});case Ng:return jr(jr({},e),{},{dropResult:n.dropResult,didDrop:!0,targetIds:[]});case Ig:return jr(jr({},e),{},{itemType:null,item:null,sourceId:null,dropResult:null,didDrop:!1,isSourcePublic:null,targetIds:[]});default:return e}}function W8(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,t=arguments.length>1?arguments[1]:void 0;switch(t.type){case Tw:case kw:return e+1;case _w:case Dg:return e-1;default:return e}}var Ch=[],jw=[];Ch.__IS_NONE__=!0;jw.__IS_ALL__=!0;function G8(e,t){if(e===Ch)return!1;if(e===jw||typeof t>"u")return!0;var n=l8(t,e);return n.length>0}function J8(){var e=arguments.length>1?arguments[1]:void 0;switch(e.type){case Og:break;case Tw:case kw:case Dg:case _w:return Ch;case Mg:case Ew:case Ig:case Ng:default:return jw}var t=e.payload,n=t.targetIds,r=n===void 0?[]:n,s=t.prevTargetIds,o=s===void 0?[]:s,a=i8(r,o),l=a.length>0||!F8(r,o);if(!l)return Ch;var c=o[o.length-1],i=r[r.length-1];return c!==i&&(c&&a.push(c),i&&a.push(i)),a}function Q8(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return e+1}function KC(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,r)}return n}function qC(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?KC(Object(n),!0).forEach(function(r){Z8(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):KC(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function Z8(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Y8(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;return{dirtyHandlerIds:J8(e.dirtyHandlerIds,{type:t.type,payload:qC(qC({},t.payload),{},{prevTargetIds:o8(e,"dragOperation.targetIds",[])})}),dragOffset:$8(e.dragOffset,t),refCount:W8(e.refCount,t),dragOperation:q8(e.dragOperation,t),stateId:Q8(e.stateId)}}function X8(e,t){return{x:e.x+t.x,y:e.y+t.y}}function _M(e,t){return{x:e.x-t.x,y:e.y-t.y}}function eH(e){var t=e.clientOffset,n=e.initialClientOffset,r=e.initialSourceClientOffset;return!t||!n||!r?null:_M(X8(t,r),n)}function tH(e){var t=e.clientOffset,n=e.initialClientOffset;return!t||!n?null:_M(t,n)}function nH(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function rH(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function sH(e,t,n){return t&&rH(e.prototype,t),e}function WC(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var oH=function(){function e(t,n){nH(this,e),WC(this,"store",void 0),WC(this,"registry",void 0),this.store=t,this.registry=n}return sH(e,[{key:"subscribeToStateChange",value:function(n){var r=this,s=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{handlerIds:void 0},o=s.handlerIds;Ve(typeof n=="function","listener must be a function."),Ve(typeof o>"u"||Array.isArray(o),"handlerIds, when specified, must be an array of strings.");var a=this.store.getState().stateId,l=function(){var i=r.store.getState(),d=i.stateId;try{var p=d===a||d===a+1&&!G8(i.dirtyHandlerIds,o);p||n()}finally{a=d}};return this.store.subscribe(l)}},{key:"subscribeToOffsetChange",value:function(n){var r=this;Ve(typeof n=="function","listener must be a function.");var s=this.store.getState().dragOffset,o=function(){var l=r.store.getState().dragOffset;l!==s&&(s=l,n())};return this.store.subscribe(o)}},{key:"canDragSource",value:function(n){if(!n)return!1;var r=this.registry.getSource(n);return Ve(r,"Expected to find a valid source. sourceId=".concat(n)),this.isDragging()?!1:r.canDrag(this,n)}},{key:"canDropOnTarget",value:function(n){if(!n)return!1;var r=this.registry.getTarget(n);if(Ve(r,"Expected to find a valid target. targetId=".concat(n)),!this.isDragging()||this.didDrop())return!1;var s=this.registry.getTargetType(n),o=this.getItemType();return rb(s,o)&&r.canDrop(this,n)}},{key:"isDragging",value:function(){return!!this.getItemType()}},{key:"isDraggingSource",value:function(n){if(!n)return!1;var r=this.registry.getSource(n,!0);if(Ve(r,"Expected to find a valid source. sourceId=".concat(n)),!this.isDragging()||!this.isSourcePublic())return!1;var s=this.registry.getSourceType(n),o=this.getItemType();return s!==o?!1:r.isDragging(this,n)}},{key:"isOverTarget",value:function(n){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{shallow:!1};if(!n)return!1;var s=r.shallow;if(!this.isDragging())return!1;var o=this.registry.getTargetType(n),a=this.getItemType();if(a&&!rb(o,a))return!1;var l=this.getTargetIds();if(!l.length)return!1;var c=l.indexOf(n);return s?c===l.length-1:c>-1}},{key:"getItemType",value:function(){return this.store.getState().dragOperation.itemType}},{key:"getItem",value:function(){return this.store.getState().dragOperation.item}},{key:"getSourceId",value:function(){return this.store.getState().dragOperation.sourceId}},{key:"getTargetIds",value:function(){return this.store.getState().dragOperation.targetIds}},{key:"getDropResult",value:function(){return this.store.getState().dragOperation.dropResult}},{key:"didDrop",value:function(){return this.store.getState().dragOperation.didDrop}},{key:"isSourcePublic",value:function(){return!!this.store.getState().dragOperation.isSourcePublic}},{key:"getInitialClientOffset",value:function(){return this.store.getState().dragOffset.initialClientOffset}},{key:"getInitialSourceClientOffset",value:function(){return this.store.getState().dragOffset.initialSourceClientOffset}},{key:"getClientOffset",value:function(){return this.store.getState().dragOffset.clientOffset}},{key:"getSourceClientOffset",value:function(){return eH(this.store.getState().dragOffset)}},{key:"getDifferenceFromInitialOffset",value:function(){return tH(this.store.getState().dragOffset)}}]),e}(),aH=0;function iH(){return aH++}function bp(e){"@babel/helpers - typeof";return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?bp=function(n){return typeof n}:bp=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},bp(e)}function lH(e){Ve(typeof e.canDrag=="function","Expected canDrag to be a function."),Ve(typeof e.beginDrag=="function","Expected beginDrag to be a function."),Ve(typeof e.endDrag=="function","Expected endDrag to be a function.")}function uH(e){Ve(typeof e.canDrop=="function","Expected canDrop to be a function."),Ve(typeof e.hover=="function","Expected hover to be a function."),Ve(typeof e.drop=="function","Expected beginDrag to be a function.")}function sb(e,t){if(t&&Array.isArray(e)){e.forEach(function(n){return sb(n,!1)});return}Ve(typeof e=="string"||bp(e)==="symbol",t?"Type can only be a string, a symbol, or an array of either.":"Type can only be a string or a symbol.")}const GC=typeof global<"u"?global:self,jM=GC.MutationObserver||GC.WebKitMutationObserver;function RM(e){return function(){const n=setTimeout(s,0),r=setInterval(s,50);function s(){clearTimeout(n),clearInterval(r),e()}}}function cH(e){let t=1;const n=new jM(e),r=document.createTextNode("");return n.observe(r,{characterData:!0}),function(){t=-t,r.data=t}}const dH=typeof jM=="function"?cH:RM;class fH{enqueueTask(t){const{queue:n,requestFlush:r}=this;n.length||(r(),this.flushing=!0),n[n.length]=t}constructor(){this.queue=[],this.pendingErrors=[],this.flushing=!1,this.index=0,this.capacity=1024,this.flush=()=>{const{queue:t}=this;for(;this.index<t.length;){const n=this.index;if(this.index++,t[n].call(),this.index>this.capacity){for(let r=0,s=t.length-this.index;r<s;r++)t[r]=t[r+this.index];t.length-=this.index,this.index=0}}t.length=0,this.index=0,this.flushing=!1},this.registerPendingError=t=>{this.pendingErrors.push(t),this.requestErrorThrow()},this.requestFlush=dH(this.flush),this.requestErrorThrow=RM(()=>{if(this.pendingErrors.length)throw this.pendingErrors.shift()})}}class pH{call(){try{this.task&&this.task()}catch(t){this.onError(t)}finally{this.task=null,this.release(this)}}constructor(t,n){this.onError=t,this.release=n,this.task=null}}class hH{create(t){const n=this.freeTasks,r=n.length?n.pop():new pH(this.onError,s=>n[n.length]=s);return r.task=t,r}constructor(t){this.onError=t,this.freeTasks=[]}}const PM=new fH,gH=new hH(PM.registerPendingError);function mH(e){PM.enqueueTask(gH.create(e))}function vH(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function yH(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function bH(e,t,n){return t&&yH(e.prototype,t),e}function Ji(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function xH(e,t){return EH(e)||CH(e,t)||SH(e,t)||wH()}function wH(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function SH(e,t){if(e){if(typeof e=="string")return JC(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return JC(e,t)}}function JC(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function CH(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var r=[],s=!0,o=!1,a,l;try{for(n=n.call(e);!(s=(a=n.next()).done)&&(r.push(a.value),!(t&&r.length===t));s=!0);}catch(c){o=!0,l=c}finally{try{!s&&n.return!=null&&n.return()}finally{if(o)throw l}}return r}}function EH(e){if(Array.isArray(e))return e}function TH(e){var t=iH().toString();switch(e){case Dr.SOURCE:return"S".concat(t);case Dr.TARGET:return"T".concat(t);default:throw new Error("Unknown Handler Role: ".concat(e))}}function QC(e){switch(e[0]){case"S":return Dr.SOURCE;case"T":return Dr.TARGET;default:Ve(!1,"Cannot parse handler ID: ".concat(e))}}function ZC(e,t){var n=e.entries(),r=!1;do{var s=n.next(),o=s.done,a=xH(s.value,2),l=a[1];if(l===t)return!0;r=!!o}while(!r);return!1}var kH=function(){function e(t){vH(this,e),Ji(this,"types",new Map),Ji(this,"dragSources",new Map),Ji(this,"dropTargets",new Map),Ji(this,"pinnedSourceId",null),Ji(this,"pinnedSource",null),Ji(this,"store",void 0),this.store=t}return bH(e,[{key:"addSource",value:function(n,r){sb(n),lH(r);var s=this.addHandler(Dr.SOURCE,n,r);return this.store.dispatch(B8(s)),s}},{key:"addTarget",value:function(n,r){sb(n,!0),uH(r);var s=this.addHandler(Dr.TARGET,n,r);return this.store.dispatch(z8(s)),s}},{key:"containsHandler",value:function(n){return ZC(this.dragSources,n)||ZC(this.dropTargets,n)}},{key:"getSource",value:function(n){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;Ve(this.isSourceId(n),"Expected a valid source ID.");var s=r&&n===this.pinnedSourceId,o=s?this.pinnedSource:this.dragSources.get(n);return o}},{key:"getTarget",value:function(n){return Ve(this.isTargetId(n),"Expected a valid target ID."),this.dropTargets.get(n)}},{key:"getSourceType",value:function(n){return Ve(this.isSourceId(n),"Expected a valid source ID."),this.types.get(n)}},{key:"getTargetType",value:function(n){return Ve(this.isTargetId(n),"Expected a valid target ID."),this.types.get(n)}},{key:"isSourceId",value:function(n){var r=QC(n);return r===Dr.SOURCE}},{key:"isTargetId",value:function(n){var r=QC(n);return r===Dr.TARGET}},{key:"removeSource",value:function(n){var r=this;Ve(this.getSource(n),"Expected an existing source."),this.store.dispatch(U8(n)),mH(function(){r.dragSources.delete(n),r.types.delete(n)})}},{key:"removeTarget",value:function(n){Ve(this.getTarget(n),"Expected an existing target."),this.store.dispatch(V8(n)),this.dropTargets.delete(n),this.types.delete(n)}},{key:"pinSource",value:function(n){var r=this.getSource(n);Ve(r,"Expected an existing source."),this.pinnedSourceId=n,this.pinnedSource=r}},{key:"unpinSource",value:function(){Ve(this.pinnedSource,"No source is pinned at the time."),this.pinnedSourceId=null,this.pinnedSource=null}},{key:"addHandler",value:function(n,r,s){var o=TH(n);return this.types.set(o,r),n===Dr.SOURCE?this.dragSources.set(o,s):n===Dr.TARGET&&this.dropTargets.set(o,s),o}}]),e}();function _H(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:void 0,n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!1,s=jH(r),o=new oH(s,new kH(s)),a=new N8(s,o),l=e(a,t,n);return a.receiveBackend(l),a}function jH(e){var t=typeof window<"u"&&window.__REDUX_DEVTOOLS_EXTENSION__;return kM(Y8,e&&t&&t({name:"dnd-core",instanceId:"dnd-core"}))}var RH=["children"];function PH(e,t){return IH(e)||NH(e,t)||OH(e,t)||MH()}function MH(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function OH(e,t){if(e){if(typeof e=="string")return YC(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return YC(e,t)}}function YC(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function NH(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var r=[],s=!0,o=!1,a,l;try{for(n=n.call(e);!(s=(a=n.next()).done)&&(r.push(a.value),!(t&&r.length===t));s=!0);}catch(c){o=!0,l=c}finally{try{!s&&n.return!=null&&n.return()}finally{if(o)throw l}}return r}}function IH(e){if(Array.isArray(e))return e}function DH(e,t){if(e==null)return{};var n=AH(e,t),r,s;if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(s=0;s<o.length;s++)r=o[s],!(t.indexOf(r)>=0)&&Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}function AH(e,t){if(e==null)return{};var n={},r=Object.keys(e),s,o;for(o=0;o<r.length;o++)s=r[o],!(t.indexOf(s)>=0)&&(n[s]=e[s]);return n}var XC=0,xp=Symbol.for("__REACT_DND_CONTEXT_INSTANCE__"),FH=v.memo(function(t){var n=t.children,r=DH(t,RH),s=LH(r),o=PH(s,2),a=o[0],l=o[1];return v.useEffect(function(){if(l){var c=MM();return++XC,function(){--XC===0&&(c[xp]=null)}}},[]),u.jsx(EM.Provider,Object.assign({value:a},{children:n}),void 0)});function LH(e){if("manager"in e){var t={dragDropManager:e.manager};return[t,!1]}var n=$H(e.backend,e.context,e.options,e.debugMode),r=!e.context;return[n,r]}function $H(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:MM(),n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,s=t;return s[xp]||(s[xp]={dragDropManager:_H(e,t,n,r)}),s[xp]}function MM(){return typeof global<"u"?global:window}function BH(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function zH(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function UH(e,t,n){return t&&zH(e.prototype,t),e}function e1(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var nv=!1,rv=!1,VH=function(){function e(t){BH(this,e),e1(this,"internalMonitor",void 0),e1(this,"sourceId",null),this.internalMonitor=t.getMonitor()}return UH(e,[{key:"receiveHandlerId",value:function(n){this.sourceId=n}},{key:"getHandlerId",value:function(){return this.sourceId}},{key:"canDrag",value:function(){Ve(!nv,"You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return nv=!0,this.internalMonitor.canDragSource(this.sourceId)}finally{nv=!1}}},{key:"isDragging",value:function(){if(!this.sourceId)return!1;Ve(!rv,"You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return rv=!0,this.internalMonitor.isDraggingSource(this.sourceId)}finally{rv=!1}}},{key:"subscribeToStateChange",value:function(n,r){return this.internalMonitor.subscribeToStateChange(n,r)}},{key:"isDraggingSource",value:function(n){return this.internalMonitor.isDraggingSource(n)}},{key:"isOverTarget",value:function(n,r){return this.internalMonitor.isOverTarget(n,r)}},{key:"getTargetIds",value:function(){return this.internalMonitor.getTargetIds()}},{key:"isSourcePublic",value:function(){return this.internalMonitor.isSourcePublic()}},{key:"getSourceId",value:function(){return this.internalMonitor.getSourceId()}},{key:"subscribeToOffsetChange",value:function(n){return this.internalMonitor.subscribeToOffsetChange(n)}},{key:"canDragSource",value:function(n){return this.internalMonitor.canDragSource(n)}},{key:"canDropOnTarget",value:function(n){return this.internalMonitor.canDropOnTarget(n)}},{key:"getItemType",value:function(){return this.internalMonitor.getItemType()}},{key:"getItem",value:function(){return this.internalMonitor.getItem()}},{key:"getDropResult",value:function(){return this.internalMonitor.getDropResult()}},{key:"didDrop",value:function(){return this.internalMonitor.didDrop()}},{key:"getInitialClientOffset",value:function(){return this.internalMonitor.getInitialClientOffset()}},{key:"getInitialSourceClientOffset",value:function(){return this.internalMonitor.getInitialSourceClientOffset()}},{key:"getSourceClientOffset",value:function(){return this.internalMonitor.getSourceClientOffset()}},{key:"getClientOffset",value:function(){return this.internalMonitor.getClientOffset()}},{key:"getDifferenceFromInitialOffset",value:function(){return this.internalMonitor.getDifferenceFromInitialOffset()}}]),e}();function HH(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function KH(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function qH(e,t,n){return t&&KH(e.prototype,t),e}function t1(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var sv=!1,WH=function(){function e(t){HH(this,e),t1(this,"internalMonitor",void 0),t1(this,"targetId",null),this.internalMonitor=t.getMonitor()}return qH(e,[{key:"receiveHandlerId",value:function(n){this.targetId=n}},{key:"getHandlerId",value:function(){return this.targetId}},{key:"subscribeToStateChange",value:function(n,r){return this.internalMonitor.subscribeToStateChange(n,r)}},{key:"canDrop",value:function(){if(!this.targetId)return!1;Ve(!sv,"You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");try{return sv=!0,this.internalMonitor.canDropOnTarget(this.targetId)}finally{sv=!1}}},{key:"isOver",value:function(n){return this.targetId?this.internalMonitor.isOverTarget(this.targetId,n):!1}},{key:"getItemType",value:function(){return this.internalMonitor.getItemType()}},{key:"getItem",value:function(){return this.internalMonitor.getItem()}},{key:"getDropResult",value:function(){return this.internalMonitor.getDropResult()}},{key:"didDrop",value:function(){return this.internalMonitor.didDrop()}},{key:"getInitialClientOffset",value:function(){return this.internalMonitor.getInitialClientOffset()}},{key:"getInitialSourceClientOffset",value:function(){return this.internalMonitor.getInitialSourceClientOffset()}},{key:"getSourceClientOffset",value:function(){return this.internalMonitor.getSourceClientOffset()}},{key:"getClientOffset",value:function(){return this.internalMonitor.getClientOffset()}},{key:"getDifferenceFromInitialOffset",value:function(){return this.internalMonitor.getDifferenceFromInitialOffset()}}]),e}();function GH(e){if(typeof e.type!="string"){var t=e.type.displayName||e.type.name||"the component";throw new Error("Only native element nodes can now be passed to React DnD connectors."+"You can either wrap ".concat(t," into a <div>, or turn it into a ")+"drag source or a drop target itself.")}}function JH(e){return function(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:null,n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;if(!v.isValidElement(t)){var r=t;return e(r,n),r}var s=t;GH(s);var o=n?function(a){return e(a,n)}:e;return QH(s,o)}}function OM(e){var t={};return Object.keys(e).forEach(function(n){var r=e[n];if(n.endsWith("Ref"))t[n]=e[n];else{var s=JH(r);t[n]=function(){return s}}}),t}function n1(e,t){typeof e=="function"?e(t):e.current=t}function QH(e,t){var n=e.ref;return Ve(typeof n!="string","Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"),n?v.cloneElement(e,{ref:function(s){n1(n,s),n1(t,s)}}):v.cloneElement(e,{ref:t})}function wp(e){"@babel/helpers - typeof";return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?wp=function(n){return typeof n}:wp=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},wp(e)}function ob(e){return e!==null&&wp(e)==="object"&&Object.prototype.hasOwnProperty.call(e,"current")}function ab(e,t,n,r){var s=void 0;if(s!==void 0)return!!s;if(e===t)return!0;if(typeof e!="object"||!e||typeof t!="object"||!t)return!1;var o=Object.keys(e),a=Object.keys(t);if(o.length!==a.length)return!1;for(var l=Object.prototype.hasOwnProperty.bind(t),c=0;c<o.length;c++){var i=o[c];if(!l(i))return!1;var d=e[i],p=t[i];if(s=void 0,s===!1||s===void 0&&d!==p)return!1}return!0}function ZH(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function YH(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function XH(e,t,n){return t&&YH(e.prototype,t),e}function Pn(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var e7=function(){function e(t){var n=this;ZH(this,e),Pn(this,"hooks",OM({dragSource:function(s,o){n.clearDragSource(),n.dragSourceOptions=o||null,ob(s)?n.dragSourceRef=s:n.dragSourceNode=s,n.reconnectDragSource()},dragPreview:function(s,o){n.clearDragPreview(),n.dragPreviewOptions=o||null,ob(s)?n.dragPreviewRef=s:n.dragPreviewNode=s,n.reconnectDragPreview()}})),Pn(this,"handlerId",null),Pn(this,"dragSourceRef",null),Pn(this,"dragSourceNode",void 0),Pn(this,"dragSourceOptionsInternal",null),Pn(this,"dragSourceUnsubscribe",void 0),Pn(this,"dragPreviewRef",null),Pn(this,"dragPreviewNode",void 0),Pn(this,"dragPreviewOptionsInternal",null),Pn(this,"dragPreviewUnsubscribe",void 0),Pn(this,"lastConnectedHandlerId",null),Pn(this,"lastConnectedDragSource",null),Pn(this,"lastConnectedDragSourceOptions",null),Pn(this,"lastConnectedDragPreview",null),Pn(this,"lastConnectedDragPreviewOptions",null),Pn(this,"backend",void 0),this.backend=t}return XH(e,[{key:"receiveHandlerId",value:function(n){this.handlerId!==n&&(this.handlerId=n,this.reconnect())}},{key:"connectTarget",get:function(){return this.dragSource}},{key:"dragSourceOptions",get:function(){return this.dragSourceOptionsInternal},set:function(n){this.dragSourceOptionsInternal=n}},{key:"dragPreviewOptions",get:function(){return this.dragPreviewOptionsInternal},set:function(n){this.dragPreviewOptionsInternal=n}},{key:"reconnect",value:function(){this.reconnectDragSource(),this.reconnectDragPreview()}},{key:"reconnectDragSource",value:function(){var n=this.dragSource,r=this.didHandlerIdChange()||this.didConnectedDragSourceChange()||this.didDragSourceOptionsChange();if(r&&this.disconnectDragSource(),!!this.handlerId){if(!n){this.lastConnectedDragSource=n;return}r&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragSource=n,this.lastConnectedDragSourceOptions=this.dragSourceOptions,this.dragSourceUnsubscribe=this.backend.connectDragSource(this.handlerId,n,this.dragSourceOptions))}}},{key:"reconnectDragPreview",value:function(){var n=this.dragPreview,r=this.didHandlerIdChange()||this.didConnectedDragPreviewChange()||this.didDragPreviewOptionsChange();if(r&&this.disconnectDragPreview(),!!this.handlerId){if(!n){this.lastConnectedDragPreview=n;return}r&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragPreview=n,this.lastConnectedDragPreviewOptions=this.dragPreviewOptions,this.dragPreviewUnsubscribe=this.backend.connectDragPreview(this.handlerId,n,this.dragPreviewOptions))}}},{key:"didHandlerIdChange",value:function(){return this.lastConnectedHandlerId!==this.handlerId}},{key:"didConnectedDragSourceChange",value:function(){return this.lastConnectedDragSource!==this.dragSource}},{key:"didConnectedDragPreviewChange",value:function(){return this.lastConnectedDragPreview!==this.dragPreview}},{key:"didDragSourceOptionsChange",value:function(){return!ab(this.lastConnectedDragSourceOptions,this.dragSourceOptions)}},{key:"didDragPreviewOptionsChange",value:function(){return!ab(this.lastConnectedDragPreviewOptions,this.dragPreviewOptions)}},{key:"disconnectDragSource",value:function(){this.dragSourceUnsubscribe&&(this.dragSourceUnsubscribe(),this.dragSourceUnsubscribe=void 0)}},{key:"disconnectDragPreview",value:function(){this.dragPreviewUnsubscribe&&(this.dragPreviewUnsubscribe(),this.dragPreviewUnsubscribe=void 0,this.dragPreviewNode=null,this.dragPreviewRef=null)}},{key:"dragSource",get:function(){return this.dragSourceNode||this.dragSourceRef&&this.dragSourceRef.current}},{key:"dragPreview",get:function(){return this.dragPreviewNode||this.dragPreviewRef&&this.dragPreviewRef.current}},{key:"clearDragSource",value:function(){this.dragSourceNode=null,this.dragSourceRef=null}},{key:"clearDragPreview",value:function(){this.dragPreviewNode=null,this.dragPreviewRef=null}}]),e}();function t7(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n7(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r7(e,t,n){return t&&n7(e.prototype,t),e}function xs(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s7=function(){function e(t){var n=this;t7(this,e),xs(this,"hooks",OM({dropTarget:function(s,o){n.clearDropTarget(),n.dropTargetOptions=o,ob(s)?n.dropTargetRef=s:n.dropTargetNode=s,n.reconnect()}})),xs(this,"handlerId",null),xs(this,"dropTargetRef",null),xs(this,"dropTargetNode",void 0),xs(this,"dropTargetOptionsInternal",null),xs(this,"unsubscribeDropTarget",void 0),xs(this,"lastConnectedHandlerId",null),xs(this,"lastConnectedDropTarget",null),xs(this,"lastConnectedDropTargetOptions",null),xs(this,"backend",void 0),this.backend=t}return r7(e,[{key:"connectTarget",get:function(){return this.dropTarget}},{key:"reconnect",value:function(){var n=this.didHandlerIdChange()||this.didDropTargetChange()||this.didOptionsChange();n&&this.disconnectDropTarget();var r=this.dropTarget;if(this.handlerId){if(!r){this.lastConnectedDropTarget=r;return}n&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDropTarget=r,this.lastConnectedDropTargetOptions=this.dropTargetOptions,this.unsubscribeDropTarget=this.backend.connectDropTarget(this.handlerId,r,this.dropTargetOptions))}}},{key:"receiveHandlerId",value:function(n){n!==this.handlerId&&(this.handlerId=n,this.reconnect())}},{key:"dropTargetOptions",get:function(){return this.dropTargetOptionsInternal},set:function(n){this.dropTargetOptionsInternal=n}},{key:"didHandlerIdChange",value:function(){return this.lastConnectedHandlerId!==this.handlerId}},{key:"didDropTargetChange",value:function(){return this.lastConnectedDropTarget!==this.dropTarget}},{key:"didOptionsChange",value:function(){return!ab(this.lastConnectedDropTargetOptions,this.dropTargetOptions)}},{key:"disconnectDropTarget",value:function(){this.unsubscribeDropTarget&&(this.unsubscribeDropTarget(),this.unsubscribeDropTarget=void 0)}},{key:"dropTarget",get:function(){return this.dropTargetNode||this.dropTargetRef&&this.dropTargetRef.current}},{key:"clearDropTarget",value:function(){this.dropTargetRef=null,this.dropTargetNode=null}}]),e}();function o7(e,t,n){var r=n.getRegistry(),s=r.addTarget(e,t);return[s,function(){return r.removeTarget(s)}]}function a7(e,t,n){var r=n.getRegistry(),s=r.addSource(e,t);return[s,function(){return r.removeSource(s)}]}var _i=typeof window<"u"?v.useLayoutEffect:v.useEffect;function Sp(e){"@babel/helpers - typeof";return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?Sp=function(n){return typeof n}:Sp=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Sp(e)}function i7(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l7(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function u7(e,t,n){return t&&l7(e.prototype,t),e}function ov(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var c7=function(){function e(t,n,r){i7(this,e),ov(this,"spec",void 0),ov(this,"monitor",void 0),ov(this,"connector",void 0),this.spec=t,this.monitor=n,this.connector=r}return u7(e,[{key:"beginDrag",value:function(){var n,r=this.spec,s=this.monitor,o=null;return Sp(r.item)==="object"?o=r.item:typeof r.item=="function"?o=r.item(s):o={},(n=o)!==null&&n!==void 0?n:null}},{key:"canDrag",value:function(){var n=this.spec,r=this.monitor;return typeof n.canDrag=="boolean"?n.canDrag:typeof n.canDrag=="function"?n.canDrag(r):!0}},{key:"isDragging",value:function(n,r){var s=this.spec,o=this.monitor,a=s.isDragging;return a?a(o):r===n.getSourceId()}},{key:"endDrag",value:function(){var n=this.spec,r=this.monitor,s=this.connector,o=n.end;o&&o(r.getItem(),r),s.reconnect()}}]),e}();function d7(e,t,n){var r=v.useMemo(function(){return new c7(e,t,n)},[t,n]);return v.useEffect(function(){r.spec=e},[e]),r}function xu(){var e=v.useContext(EM),t=e.dragDropManager;return Ve(t!=null,"Expected drag drop context"),t}function f7(e){return v.useMemo(function(){var t=e.type;return Ve(t!=null,"spec.type must be defined"),t},[e])}function p7(e,t){return v7(e)||m7(e,t)||g7(e,t)||h7()}function h7(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function g7(e,t){if(e){if(typeof e=="string")return r1(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return r1(e,t)}}function r1(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function m7(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var r=[],s=!0,o=!1,a,l;try{for(n=n.call(e);!(s=(a=n.next()).done)&&(r.push(a.value),!(t&&r.length===t));s=!0);}catch(c){o=!0,l=c}finally{try{!s&&n.return!=null&&n.return()}finally{if(o)throw l}}return r}}function v7(e){if(Array.isArray(e))return e}function y7(e,t,n){var r=xu(),s=d7(e,t,n),o=f7(e);_i(function(){if(o!=null){var l=a7(o,s,r),c=p7(l,2),i=c[0],d=c[1];return t.receiveHandlerId(i),n.receiveHandlerId(i),d}},[r,t,n,s,o])}function b7(e){return C7(e)||S7(e)||w7(e)||x7()}function x7(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function w7(e,t){if(e){if(typeof e=="string")return ib(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return ib(e,t)}}function S7(e){if(typeof Symbol<"u"&&e[Symbol.iterator]!=null||e["@@iterator"]!=null)return Array.from(e)}function C7(e){if(Array.isArray(e))return ib(e)}function ib(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function NM(e,t){var n=b7(t||[]);return t==null&&typeof e!="function"&&n.push(e),v.useMemo(function(){return typeof e=="function"?e():e},n)}function E7(){var e=xu();return v.useMemo(function(){return new VH(e)},[e])}function T7(e,t){var n=xu(),r=v.useMemo(function(){return new e7(n.getBackend())},[n]);return _i(function(){return r.dragSourceOptions=e||null,r.reconnect(),function(){return r.disconnectDragSource()}},[r,e]),_i(function(){return r.dragPreviewOptions=t||null,r.reconnect(),function(){return r.disconnectDragPreview()}},[r,t]),r}var k7=function e(t,n){if(t===n)return!0;if(t&&n&&typeof t=="object"&&typeof n=="object"){if(t.constructor!==n.constructor)return!1;var r,s,o;if(Array.isArray(t)){if(r=t.length,r!=n.length)return!1;for(s=r;s--!==0;)if(!e(t[s],n[s]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if(o=Object.keys(t),r=o.length,r!==Object.keys(n).length)return!1;for(s=r;s--!==0;)if(!Object.prototype.hasOwnProperty.call(n,o[s]))return!1;for(s=r;s--!==0;){var a=o[s];if(!e(t[a],n[a]))return!1}return!0}return t!==t&&n!==n};const _7=jb(k7);function j7(e,t){return O7(e)||M7(e,t)||P7(e,t)||R7()}function R7(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function P7(e,t){if(e){if(typeof e=="string")return s1(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return s1(e,t)}}function s1(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function M7(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var r=[],s=!0,o=!1,a,l;try{for(n=n.call(e);!(s=(a=n.next()).done)&&(r.push(a.value),!(t&&r.length===t));s=!0);}catch(c){o=!0,l=c}finally{try{!s&&n.return!=null&&n.return()}finally{if(o)throw l}}return r}}function O7(e){if(Array.isArray(e))return e}function N7(e,t,n){var r=v.useState(function(){return t(e)}),s=j7(r,2),o=s[0],a=s[1],l=v.useCallback(function(){var c=t(e);_7(o,c)||(a(c),n&&n())},[o,e,n]);return _i(l),[o,l]}function I7(e,t){return L7(e)||F7(e,t)||A7(e,t)||D7()}function D7(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function A7(e,t){if(e){if(typeof e=="string")return o1(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return o1(e,t)}}function o1(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function F7(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var r=[],s=!0,o=!1,a,l;try{for(n=n.call(e);!(s=(a=n.next()).done)&&(r.push(a.value),!(t&&r.length===t));s=!0);}catch(c){o=!0,l=c}finally{try{!s&&n.return!=null&&n.return()}finally{if(o)throw l}}return r}}function L7(e){if(Array.isArray(e))return e}function $7(e,t,n){var r=N7(e,t,n),s=I7(r,2),o=s[0],a=s[1];return _i(function(){var c=e.getHandlerId();if(c!=null)return e.subscribeToStateChange(a,{handlerIds:[c]})},[e,a]),o}function IM(e,t,n){return $7(t,e||function(){return{}},function(){return n.reconnect()})}function B7(e){return v.useMemo(function(){return e.hooks.dragSource()},[e])}function z7(e){return v.useMemo(function(){return e.hooks.dragPreview()},[e])}function U7(e,t){var n=NM(e,t);Ve(!n.begin,"useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");var r=E7(),s=T7(n.options,n.previewOptions);return y7(n,r,s),[IM(n.collect,r,s),B7(s),z7(s)]}function V7(e){var t=e.accept;return v.useMemo(function(){return Ve(e.accept!=null,"accept must be defined"),Array.isArray(t)?t:[t]},[t])}function H7(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function K7(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function q7(e,t,n){return t&&K7(e.prototype,t),e}function a1(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var W7=function(){function e(t,n){H7(this,e),a1(this,"spec",void 0),a1(this,"monitor",void 0),this.spec=t,this.monitor=n}return q7(e,[{key:"canDrop",value:function(){var n=this.spec,r=this.monitor;return n.canDrop?n.canDrop(r.getItem(),r):!0}},{key:"hover",value:function(){var n=this.spec,r=this.monitor;n.hover&&n.hover(r.getItem(),r)}},{key:"drop",value:function(){var n=this.spec,r=this.monitor;if(n.drop)return n.drop(r.getItem(),r)}}]),e}();function G7(e,t){var n=v.useMemo(function(){return new W7(e,t)},[t]);return v.useEffect(function(){n.spec=e},[e]),n}function J7(e,t){return X7(e)||Y7(e,t)||Z7(e,t)||Q7()}function Q7(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function Z7(e,t){if(e){if(typeof e=="string")return i1(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);if(n==="Object"&&e.constructor&&(n=e.constructor.name),n==="Map"||n==="Set")return Array.from(e);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return i1(e,t)}}function i1(e,t){(t==null||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function Y7(e,t){var n=e==null?null:typeof Symbol<"u"&&e[Symbol.iterator]||e["@@iterator"];if(n!=null){var r=[],s=!0,o=!1,a,l;try{for(n=n.call(e);!(s=(a=n.next()).done)&&(r.push(a.value),!(t&&r.length===t));s=!0);}catch(c){o=!0,l=c}finally{try{!s&&n.return!=null&&n.return()}finally{if(o)throw l}}return r}}function X7(e){if(Array.isArray(e))return e}function eK(e,t,n){var r=xu(),s=G7(e,t),o=V7(e);_i(function(){var l=o7(o,s,r),c=J7(l,2),i=c[0],d=c[1];return t.receiveHandlerId(i),n.receiveHandlerId(i),d},[r,t,s,n,o.map(function(a){return a.toString()}).join("|")])}function tK(){var e=xu();return v.useMemo(function(){return new WH(e)},[e])}function nK(e){var t=xu(),n=v.useMemo(function(){return new s7(t.getBackend())},[t]);return _i(function(){return n.dropTargetOptions=e||null,n.reconnect(),function(){return n.disconnectDropTarget()}},[e]),n}function rK(e){return v.useMemo(function(){return e.hooks.dropTarget()},[e])}function sK(e,t){var n=NM(e,t),r=tK(),s=nK(n.options);return eK(n,r,s),[IM(n.collect,r,s),rK(s)]}function DM(e){var t=null,n=function(){return t==null&&(t=e()),t};return n}function oK(e,t){return e.filter(function(n){return n!==t})}function aK(e,t){var n=new Set,r=function(a){return n.add(a)};e.forEach(r),t.forEach(r);var s=[];return n.forEach(function(o){return s.push(o)}),s}function iK(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function lK(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function uK(e,t,n){return t&&lK(e.prototype,t),e}function l1(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var cK=function(){function e(t){iK(this,e),l1(this,"entered",[]),l1(this,"isNodeInDocument",void 0),this.isNodeInDocument=t}return uK(e,[{key:"enter",value:function(n){var r=this,s=this.entered.length,o=function(l){return r.isNodeInDocument(l)&&(!l.contains||l.contains(n))};return this.entered=aK(this.entered.filter(o),[n]),s===0&&this.entered.length>0}},{key:"leave",value:function(n){var r=this.entered.length;return this.entered=oK(this.entered.filter(this.isNodeInDocument),n),r>0&&this.entered.length===0}},{key:"reset",value:function(){this.entered=[]}}]),e}(),dK=DM(function(){return/firefox/i.test(navigator.userAgent)}),AM=DM(function(){return!!window.safari});function fK(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function pK(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function hK(e,t,n){return t&&pK(e.prototype,t),e}function Xu(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var u1=function(){function e(t,n){fK(this,e),Xu(this,"xs",void 0),Xu(this,"ys",void 0),Xu(this,"c1s",void 0),Xu(this,"c2s",void 0),Xu(this,"c3s",void 0);for(var r=t.length,s=[],o=0;o<r;o++)s.push(o);s.sort(function(T,P){return t[T]<t[P]?-1:1});for(var a=[],l=[],c,i,d=0;d<r-1;d++)c=t[d+1]-t[d],i=n[d+1]-n[d],a.push(c),l.push(i/c);for(var p=[l[0]],f=0;f<a.length-1;f++){var h=l[f],g=l[f+1];if(h*g<=0)p.push(0);else{c=a[f];var m=a[f+1],x=c+m;p.push(3*x/((x+m)/h+(x+c)/g))}}p.push(l[l.length-1]);for(var b=[],y=[],w,S=0;S<p.length-1;S++){w=l[S];var E=p[S],C=1/a[S],k=E+p[S+1]-w-w;b.push((w-E-k)*C),y.push(k*C*C)}this.xs=t,this.ys=n,this.c1s=p,this.c2s=b,this.c3s=y}return hK(e,[{key:"interpolate",value:function(n){var r=this.xs,s=this.ys,o=this.c1s,a=this.c2s,l=this.c3s,c=r.length-1;if(n===r[c])return s[c];for(var i=0,d=l.length-1,p;i<=d;){p=Math.floor(.5*(i+d));var f=r[p];if(f<n)i=p+1;else if(f>n)d=p-1;else return s[p]}c=Math.max(0,d);var h=n-r[c],g=h*h;return s[c]+o[c]*h+a[c]*g+l[c]*h*g}}]),e}(),gK=1;function FM(e){var t=e.nodeType===gK?e:e.parentElement;if(!t)return null;var n=t.getBoundingClientRect(),r=n.top,s=n.left;return{x:s,y:r}}function Bf(e){return{x:e.clientX,y:e.clientY}}function mK(e){var t;return e.nodeName==="IMG"&&(dK()||!((t=document.documentElement)!==null&&t!==void 0&&t.contains(e)))}function vK(e,t,n,r){var s=e?t.width:n,o=e?t.height:r;return AM()&&e&&(o/=window.devicePixelRatio,s/=window.devicePixelRatio),{dragPreviewWidth:s,dragPreviewHeight:o}}function yK(e,t,n,r,s){var o=mK(t),a=o?e:t,l=FM(a),c={x:n.x-l.x,y:n.y-l.y},i=e.offsetWidth,d=e.offsetHeight,p=r.anchorX,f=r.anchorY,h=vK(o,t,i,d),g=h.dragPreviewWidth,m=h.dragPreviewHeight,x=function(){var k=new u1([0,.5,1],[c.y,c.y/d*m,c.y+m-d]),T=k.interpolate(f);return AM()&&o&&(T+=(window.devicePixelRatio-1)*m),T},b=function(){var k=new u1([0,.5,1],[c.x,c.x/i*g,c.x+g-i]);return k.interpolate(p)},y=s.offsetX,w=s.offsetY,S=y===0||y,E=w===0||w;return{x:S?y:b(),y:E?w:x()}}var LM="__NATIVE_FILE__",$M="__NATIVE_URL__",BM="__NATIVE_TEXT__",zM="__NATIVE_HTML__";const c1=Object.freeze(Object.defineProperty({__proto__:null,FILE:LM,HTML:zM,TEXT:BM,URL:$M},Symbol.toStringTag,{value:"Module"}));function av(e,t,n){var r=t.reduce(function(s,o){return s||e.getData(o)},"");return r??n}var Qi;function zf(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var lb=(Qi={},zf(Qi,LM,{exposeProperties:{files:function(t){return Array.prototype.slice.call(t.files)},items:function(t){return t.items},dataTransfer:function(t){return t}},matchesTypes:["Files"]}),zf(Qi,zM,{exposeProperties:{html:function(t,n){return av(t,n,"")},dataTransfer:function(t){return t}},matchesTypes:["Html","text/html"]}),zf(Qi,$M,{exposeProperties:{urls:function(t,n){return av(t,n,"").split(`
`)},dataTransfer:function(t){return t}},matchesTypes:["Url","text/uri-list"]}),zf(Qi,BM,{exposeProperties:{text:function(t,n){return av(t,n,"")},dataTransfer:function(t){return t}},matchesTypes:["Text","text/plain"]}),Qi);function bK(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function xK(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function wK(e,t,n){return t&&xK(e.prototype,t),e}function d1(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var SK=function(){function e(t){bK(this,e),d1(this,"item",void 0),d1(this,"config",void 0),this.config=t,this.item={},this.initializeExposedProperties()}return wK(e,[{key:"initializeExposedProperties",value:function(){var n=this;Object.keys(this.config.exposeProperties).forEach(function(r){Object.defineProperty(n.item,r,{configurable:!0,enumerable:!0,get:function(){return console.warn(`Browser doesn't allow reading "`.concat(r,'" until the drop event.')),null}})})}},{key:"loadDataTransfer",value:function(n){var r=this;if(n){var s={};Object.keys(this.config.exposeProperties).forEach(function(o){s[o]={value:r.config.exposeProperties[o](n,r.config.matchesTypes),configurable:!0,enumerable:!0}}),Object.defineProperties(this.item,s)}}},{key:"canDrag",value:function(){return!0}},{key:"beginDrag",value:function(){return this.item}},{key:"isDragging",value:function(n,r){return r===n.getSourceId()}},{key:"endDrag",value:function(){}}]),e}();function CK(e,t){var n=new SK(lb[e]);return n.loadDataTransfer(t),n}function iv(e){if(!e)return null;var t=Array.prototype.slice.call(e.types||[]);return Object.keys(lb).filter(function(n){var r=lb[n].matchesTypes;return r.some(function(s){return t.indexOf(s)>-1})})[0]||null}function EK(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function TK(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function kK(e,t,n){return t&&TK(e.prototype,t),e}function lv(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var _K=function(){function e(t,n){EK(this,e),lv(this,"ownerDocument",null),lv(this,"globalContext",void 0),lv(this,"optionsArgs",void 0),this.globalContext=t,this.optionsArgs=n}return kK(e,[{key:"window",get:function(){if(this.globalContext)return this.globalContext;if(typeof window<"u")return window}},{key:"document",get:function(){var n;return(n=this.globalContext)!==null&&n!==void 0&&n.document?this.globalContext.document:this.window?this.window.document:void 0}},{key:"rootElement",get:function(){var n;return((n=this.optionsArgs)===null||n===void 0?void 0:n.rootElement)||this.window}}]),e}();function f1(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable})),n.push.apply(n,r)}return n}function p1(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?f1(Object(n),!0).forEach(function(r){st(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):f1(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function jK(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function RK(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function PK(e,t,n){return t&&RK(e.prototype,t),e}function st(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var MK=function(){function e(t,n,r){var s=this;jK(this,e),st(this,"options",void 0),st(this,"actions",void 0),st(this,"monitor",void 0),st(this,"registry",void 0),st(this,"enterLeaveCounter",void 0),st(this,"sourcePreviewNodes",new Map),st(this,"sourcePreviewNodeOptions",new Map),st(this,"sourceNodes",new Map),st(this,"sourceNodeOptions",new Map),st(this,"dragStartSourceIds",null),st(this,"dropTargetIds",[]),st(this,"dragEnterTargetIds",[]),st(this,"currentNativeSource",null),st(this,"currentNativeHandle",null),st(this,"currentDragSourceNode",null),st(this,"altKeyPressed",!1),st(this,"mouseMoveTimeoutTimer",null),st(this,"asyncEndDragFrameId",null),st(this,"dragOverTargetIds",null),st(this,"lastClientOffset",null),st(this,"hoverRafId",null),st(this,"getSourceClientOffset",function(o){var a=s.sourceNodes.get(o);return a&&FM(a)||null}),st(this,"endDragNativeItem",function(){s.isDraggingNativeItem()&&(s.actions.endDrag(),s.currentNativeHandle&&s.registry.removeSource(s.currentNativeHandle),s.currentNativeHandle=null,s.currentNativeSource=null)}),st(this,"isNodeInDocument",function(o){return!!(o&&s.document&&s.document.body&&s.document.body.contains(o))}),st(this,"endDragIfSourceWasRemovedFromDOM",function(){var o=s.currentDragSourceNode;o==null||s.isNodeInDocument(o)||s.clearCurrentDragSourceNode()&&s.monitor.isDragging()&&s.actions.endDrag()}),st(this,"handleTopDragStartCapture",function(){s.clearCurrentDragSourceNode(),s.dragStartSourceIds=[]}),st(this,"handleTopDragStart",function(o){if(!o.defaultPrevented){var a=s.dragStartSourceIds;s.dragStartSourceIds=null;var l=Bf(o);s.monitor.isDragging()&&s.actions.endDrag(),s.actions.beginDrag(a||[],{publishSource:!1,getSourceClientOffset:s.getSourceClientOffset,clientOffset:l});var c=o.dataTransfer,i=iv(c);if(s.monitor.isDragging()){if(c&&typeof c.setDragImage=="function"){var d=s.monitor.getSourceId(),p=s.sourceNodes.get(d),f=s.sourcePreviewNodes.get(d)||p;if(f){var h=s.getCurrentSourcePreviewNodeOptions(),g=h.anchorX,m=h.anchorY,x=h.offsetX,b=h.offsetY,y={anchorX:g,anchorY:m},w={offsetX:x,offsetY:b},S=yK(p,f,l,y,w);c.setDragImage(f,S.x,S.y)}}try{c==null||c.setData("application/json",{})}catch{}s.setCurrentDragSourceNode(o.target);var E=s.getCurrentSourcePreviewNodeOptions(),C=E.captureDraggingState;C?s.actions.publishDragSource():setTimeout(function(){return s.actions.publishDragSource()},0)}else if(i)s.beginDragNativeItem(i);else{if(c&&!c.types&&(o.target&&!o.target.hasAttribute||!o.target.hasAttribute("draggable")))return;o.preventDefault()}}}),st(this,"handleTopDragEndCapture",function(){s.clearCurrentDragSourceNode()&&s.monitor.isDragging()&&s.actions.endDrag()}),st(this,"handleTopDragEnterCapture",function(o){s.dragEnterTargetIds=[];var a=s.enterLeaveCounter.enter(o.target);if(!(!a||s.monitor.isDragging())){var l=o.dataTransfer,c=iv(l);c&&s.beginDragNativeItem(c,l)}}),st(this,"handleTopDragEnter",function(o){var a=s.dragEnterTargetIds;if(s.dragEnterTargetIds=[],!!s.monitor.isDragging()){s.altKeyPressed=o.altKey,a.length>0&&s.actions.hover(a,{clientOffset:Bf(o)});var l=a.some(function(c){return s.monitor.canDropOnTarget(c)});l&&(o.preventDefault(),o.dataTransfer&&(o.dataTransfer.dropEffect=s.getCurrentDropEffect()))}}),st(this,"handleTopDragOverCapture",function(){s.dragOverTargetIds=[]}),st(this,"handleTopDragOver",function(o){var a=s.dragOverTargetIds;if(s.dragOverTargetIds=[],!s.monitor.isDragging()){o.preventDefault(),o.dataTransfer&&(o.dataTransfer.dropEffect="none");return}s.altKeyPressed=o.altKey,s.lastClientOffset=Bf(o),s.hoverRafId===null&&typeof requestAnimationFrame<"u"&&(s.hoverRafId=requestAnimationFrame(function(){s.monitor.isDragging()&&s.actions.hover(a||[],{clientOffset:s.lastClientOffset}),s.hoverRafId=null}));var l=(a||[]).some(function(c){return s.monitor.canDropOnTarget(c)});l?(o.preventDefault(),o.dataTransfer&&(o.dataTransfer.dropEffect=s.getCurrentDropEffect())):s.isDraggingNativeItem()?o.preventDefault():(o.preventDefault(),o.dataTransfer&&(o.dataTransfer.dropEffect="none"))}),st(this,"handleTopDragLeaveCapture",function(o){s.isDraggingNativeItem()&&o.preventDefault();var a=s.enterLeaveCounter.leave(o.target);a&&s.isDraggingNativeItem()&&setTimeout(function(){return s.endDragNativeItem()},0)}),st(this,"handleTopDropCapture",function(o){if(s.dropTargetIds=[],s.isDraggingNativeItem()){var a;o.preventDefault(),(a=s.currentNativeSource)===null||a===void 0||a.loadDataTransfer(o.dataTransfer)}else iv(o.dataTransfer)&&o.preventDefault();s.enterLeaveCounter.reset()}),st(this,"handleTopDrop",function(o){var a=s.dropTargetIds;s.dropTargetIds=[],s.actions.hover(a,{clientOffset:Bf(o)}),s.actions.drop({dropEffect:s.getCurrentDropEffect()}),s.isDraggingNativeItem()?s.endDragNativeItem():s.monitor.isDragging()&&s.actions.endDrag()}),st(this,"handleSelectStart",function(o){var a=o.target;typeof a.dragDrop=="function"&&(a.tagName==="INPUT"||a.tagName==="SELECT"||a.tagName==="TEXTAREA"||a.isContentEditable||(o.preventDefault(),a.dragDrop()))}),this.options=new _K(n,r),this.actions=t.getActions(),this.monitor=t.getMonitor(),this.registry=t.getRegistry(),this.enterLeaveCounter=new cK(this.isNodeInDocument)}return PK(e,[{key:"profile",value:function(){var n,r;return{sourcePreviewNodes:this.sourcePreviewNodes.size,sourcePreviewNodeOptions:this.sourcePreviewNodeOptions.size,sourceNodeOptions:this.sourceNodeOptions.size,sourceNodes:this.sourceNodes.size,dragStartSourceIds:((n=this.dragStartSourceIds)===null||n===void 0?void 0:n.length)||0,dropTargetIds:this.dropTargetIds.length,dragEnterTargetIds:this.dragEnterTargetIds.length,dragOverTargetIds:((r=this.dragOverTargetIds)===null||r===void 0?void 0:r.length)||0}}},{key:"window",get:function(){return this.options.window}},{key:"document",get:function(){return this.options.document}},{key:"rootElement",get:function(){return this.options.rootElement}},{key:"setup",value:function(){var n=this.rootElement;if(n!==void 0){if(n.__isReactDndBackendSetUp)throw new Error("Cannot have two HTML5 backends at the same time.");n.__isReactDndBackendSetUp=!0,this.addEventListeners(n)}}},{key:"teardown",value:function(){var n=this.rootElement;if(n!==void 0&&(n.__isReactDndBackendSetUp=!1,this.removeEventListeners(this.rootElement),this.clearCurrentDragSourceNode(),this.asyncEndDragFrameId)){var r;(r=this.window)===null||r===void 0||r.cancelAnimationFrame(this.asyncEndDragFrameId)}}},{key:"connectDragPreview",value:function(n,r,s){var o=this;return this.sourcePreviewNodeOptions.set(n,s),this.sourcePreviewNodes.set(n,r),function(){o.sourcePreviewNodes.delete(n),o.sourcePreviewNodeOptions.delete(n)}}},{key:"connectDragSource",value:function(n,r,s){var o=this;this.sourceNodes.set(n,r),this.sourceNodeOptions.set(n,s);var a=function(i){return o.handleDragStart(i,n)},l=function(i){return o.handleSelectStart(i)};return r.setAttribute("draggable","true"),r.addEventListener("dragstart",a),r.addEventListener("selectstart",l),function(){o.sourceNodes.delete(n),o.sourceNodeOptions.delete(n),r.removeEventListener("dragstart",a),r.removeEventListener("selectstart",l),r.setAttribute("draggable","false")}}},{key:"connectDropTarget",value:function(n,r){var s=this,o=function(i){return s.handleDragEnter(i,n)},a=function(i){return s.handleDragOver(i,n)},l=function(i){return s.handleDrop(i,n)};return r.addEventListener("dragenter",o),r.addEventListener("dragover",a),r.addEventListener("drop",l),function(){r.removeEventListener("dragenter",o),r.removeEventListener("dragover",a),r.removeEventListener("drop",l)}}},{key:"addEventListeners",value:function(n){n.addEventListener&&(n.addEventListener("dragstart",this.handleTopDragStart),n.addEventListener("dragstart",this.handleTopDragStartCapture,!0),n.addEventListener("dragend",this.handleTopDragEndCapture,!0),n.addEventListener("dragenter",this.handleTopDragEnter),n.addEventListener("dragenter",this.handleTopDragEnterCapture,!0),n.addEventListener("dragleave",this.handleTopDragLeaveCapture,!0),n.addEventListener("dragover",this.handleTopDragOver),n.addEventListener("dragover",this.handleTopDragOverCapture,!0),n.addEventListener("drop",this.handleTopDrop),n.addEventListener("drop",this.handleTopDropCapture,!0))}},{key:"removeEventListeners",value:function(n){n.removeEventListener&&(n.removeEventListener("dragstart",this.handleTopDragStart),n.removeEventListener("dragstart",this.handleTopDragStartCapture,!0),n.removeEventListener("dragend",this.handleTopDragEndCapture,!0),n.removeEventListener("dragenter",this.handleTopDragEnter),n.removeEventListener("dragenter",this.handleTopDragEnterCapture,!0),n.removeEventListener("dragleave",this.handleTopDragLeaveCapture,!0),n.removeEventListener("dragover",this.handleTopDragOver),n.removeEventListener("dragover",this.handleTopDragOverCapture,!0),n.removeEventListener("drop",this.handleTopDrop),n.removeEventListener("drop",this.handleTopDropCapture,!0))}},{key:"getCurrentSourceNodeOptions",value:function(){var n=this.monitor.getSourceId(),r=this.sourceNodeOptions.get(n);return p1({dropEffect:this.altKeyPressed?"copy":"move"},r||{})}},{key:"getCurrentDropEffect",value:function(){return this.isDraggingNativeItem()?"copy":this.getCurrentSourceNodeOptions().dropEffect}},{key:"getCurrentSourcePreviewNodeOptions",value:function(){var n=this.monitor.getSourceId(),r=this.sourcePreviewNodeOptions.get(n);return p1({anchorX:.5,anchorY:.5,captureDraggingState:!1},r||{})}},{key:"isDraggingNativeItem",value:function(){var n=this.monitor.getItemType();return Object.keys(c1).some(function(r){return c1[r]===n})}},{key:"beginDragNativeItem",value:function(n,r){this.clearCurrentDragSourceNode(),this.currentNativeSource=CK(n,r),this.currentNativeHandle=this.registry.addSource(n,this.currentNativeSource),this.actions.beginDrag([this.currentNativeHandle])}},{key:"setCurrentDragSourceNode",value:function(n){var r=this;this.clearCurrentDragSourceNode(),this.currentDragSourceNode=n;var s=1e3;this.mouseMoveTimeoutTimer=setTimeout(function(){var o;return(o=r.rootElement)===null||o===void 0?void 0:o.addEventListener("mousemove",r.endDragIfSourceWasRemovedFromDOM,!0)},s)}},{key:"clearCurrentDragSourceNode",value:function(){if(this.currentDragSourceNode){if(this.currentDragSourceNode=null,this.rootElement){var n;(n=this.window)===null||n===void 0||n.clearTimeout(this.mouseMoveTimeoutTimer||void 0),this.rootElement.removeEventListener("mousemove",this.endDragIfSourceWasRemovedFromDOM,!0)}return this.mouseMoveTimeoutTimer=null,!0}return!1}},{key:"handleDragStart",value:function(n,r){n.defaultPrevented||(this.dragStartSourceIds||(this.dragStartSourceIds=[]),this.dragStartSourceIds.unshift(r))}},{key:"handleDragEnter",value:function(n,r){this.dragEnterTargetIds.unshift(r)}},{key:"handleDragOver",value:function(n,r){this.dragOverTargetIds===null&&(this.dragOverTargetIds=[]),this.dragOverTargetIds.unshift(r)}},{key:"handleDrop",value:function(n,r){this.dropTargetIds.unshift(r)}}]),e}(),OK=function(t,n,r){return new MK(t,n,r)},NK=Object.create,UM=Object.defineProperty,IK=Object.getOwnPropertyDescriptor,VM=Object.getOwnPropertyNames,DK=Object.getPrototypeOf,AK=Object.prototype.hasOwnProperty,FK=(e,t)=>function(){return t||(0,e[VM(e)[0]])((t={exports:{}}).exports,t),t.exports},LK=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of VM(t))!AK.call(e,s)&&s!==n&&UM(e,s,{get:()=>t[s],enumerable:!(r=IK(t,s))||r.enumerable});return e},HM=(e,t,n)=>(n=e!=null?NK(DK(e)):{},LK(UM(n,"default",{value:e,enumerable:!0}),e)),KM=FK({"node_modules/classnames/index.js"(e,t){(function(){var n={}.hasOwnProperty;function r(){for(var s=[],o=0;o<arguments.length;o++){var a=arguments[o];if(a){var l=typeof a;if(l==="string"||l==="number")s.push(a);else if(Array.isArray(a)){if(a.length){var c=r.apply(null,a);c&&s.push(c)}}else if(l==="object"){if(a.toString!==Object.prototype.toString&&!a.toString.toString().includes("[native code]")){s.push(a.toString());continue}for(var i in a)n.call(a,i)&&a[i]&&s.push(i)}}}return s.join(" ")}typeof t<"u"&&t.exports?(r.default=r,t.exports=r):typeof define=="function"&&typeof define.amd=="object"&&define.amd?define("classnames",[],function(){return r}):window.classNames=r})()}}),Rl={ENTER:[10,13],TAB:9,BACKSPACE:8,UP_ARROW:38,DOWN_ARROW:40,ESCAPE:27,SPACE:32,COMMA:188},Rs={ENTER:"Enter",TAB:"Tab",COMMA:",",SPACE:" ",SEMICOLON:";"},$K="Press enter to add new tag",BK="text",h1={tags:"ReactTags__tags",tagInput:"ReactTags__tagInput",tagInputField:"ReactTags__tagInputField",selected:"ReactTags__selected",tag:"ReactTags__tag",remove:"ReactTags__remove",suggestions:"ReactTags__suggestions",activeSuggestion:"ReactTags__activeSuggestion",editTagInput:"ReactTags__editTagInput",editTagInputField:"ReactTags__editTagInputField",clearAll:"ReactTags__clearAll"},ec={INLINE:"inline",TOP:"top",BOTTOM:"bottom"},g1={TAG_LIMIT:"Tag limit reached!"},zK=typeof global=="object"&&global&&global.Object===Object&&global,qM=zK,UK=typeof self=="object"&&self&&self.Object===Object&&self,VK=qM||UK||Function("return this")(),ko=VK,HK=ko.Symbol,wa=HK,WM=Object.prototype,KK=WM.hasOwnProperty,qK=WM.toString,tc=wa?wa.toStringTag:void 0;function WK(e){var t=KK.call(e,tc),n=e[tc];try{e[tc]=void 0;var r=!0}catch{}var s=qK.call(e);return r&&(t?e[tc]=n:delete e[tc]),s}var GK=WK,JK=Object.prototype,QK=JK.toString;function ZK(e){return QK.call(e)}var YK=ZK,XK="[object Null]",eq="[object Undefined]",m1=wa?wa.toStringTag:void 0;function tq(e){return e==null?e===void 0?eq:XK:m1&&m1 in Object(e)?GK(e):YK(e)}var wu=tq;function nq(e){return e!=null&&typeof e=="object"}var ou=nq,rq="[object Symbol]";function sq(e){return typeof e=="symbol"||ou(e)&&wu(e)==rq}var oq=sq;function aq(e,t){for(var n=-1,r=e==null?0:e.length,s=Array(r);++n<r;)s[n]=t(e[n],n,e);return s}var iq=aq,lq=Array.isArray,Ed=lq,uq=1/0,v1=wa?wa.prototype:void 0,y1=v1?v1.toString:void 0;function GM(e){if(typeof e=="string")return e;if(Ed(e))return iq(e,GM)+"";if(oq(e))return y1?y1.call(e):"";var t=e+"";return t=="0"&&1/e==-uq?"-0":t}var cq=GM;function dq(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}var JM=dq,fq="[object AsyncFunction]",pq="[object Function]",hq="[object GeneratorFunction]",gq="[object Proxy]";function mq(e){if(!JM(e))return!1;var t=wu(e);return t==pq||t==hq||t==fq||t==gq}var QM=mq,vq=ko["__core-js_shared__"],uv=vq,b1=function(){var e=/[^.]+$/.exec(uv&&uv.keys&&uv.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();function yq(e){return!!b1&&b1 in e}var bq=yq,xq=Function.prototype,wq=xq.toString;function Sq(e){if(e!=null){try{return wq.call(e)}catch{}try{return e+""}catch{}}return""}var Li=Sq,Cq=/[\\^$.*+?()[\]{}|]/g,Eq=/^\[object .+?Constructor\]$/,Tq=Function.prototype,kq=Object.prototype,_q=Tq.toString,jq=kq.hasOwnProperty,Rq=RegExp("^"+_q.call(jq).replace(Cq,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function Pq(e){if(!JM(e)||bq(e))return!1;var t=QM(e)?Rq:Eq;return t.test(Li(e))}var Mq=Pq;function Oq(e,t){return e==null?void 0:e[t]}var Nq=Oq;function Iq(e,t){var n=Nq(e,t);return Mq(n)?n:void 0}var Su=Iq,Dq=Su(ko,"WeakMap"),ub=Dq;function Aq(){}var Fq=Aq;function Lq(e,t,n,r){for(var s=e.length,o=n+(r?1:-1);r?o--:++o<s;)if(t(e[o],o,e))return o;return-1}var $q=Lq;function Bq(e){return e!==e}var zq=Bq;function Uq(e,t,n){for(var r=n-1,s=e.length;++r<s;)if(e[r]===t)return r;return-1}var Vq=Uq;function Hq(e,t,n){return t===t?Vq(e,t,n):$q(e,zq,n)}var Kq=Hq;function qq(e,t){var n=e==null?0:e.length;return!!n&&Kq(e,t,0)>-1}var Wq=qq,Gq=9007199254740991,Jq=/^(?:0|[1-9]\d*)$/;function Qq(e,t){var n=typeof e;return t=t??Gq,!!t&&(n=="number"||n!="symbol"&&Jq.test(e))&&e>-1&&e%1==0&&e<t}var Zq=Qq;function Yq(e,t){return e===t||e!==e&&t!==t}var ZM=Yq,Xq=9007199254740991;function eW(e){return typeof e=="number"&&e>-1&&e%1==0&&e<=Xq}var YM=eW;function tW(e){return e!=null&&YM(e.length)&&!QM(e)}var nW=tW,rW=Object.prototype;function sW(e){var t=e&&e.constructor,n=typeof t=="function"&&t.prototype||rW;return e===n}var oW=sW;function aW(e,t){for(var n=-1,r=Array(e);++n<e;)r[n]=t(n);return r}var iW=aW,lW="[object Arguments]";function uW(e){return ou(e)&&wu(e)==lW}var x1=uW,XM=Object.prototype,cW=XM.hasOwnProperty,dW=XM.propertyIsEnumerable,fW=x1(function(){return arguments}())?x1:function(e){return ou(e)&&cW.call(e,"callee")&&!dW.call(e,"callee")},pW=fW;function hW(){return!1}var gW=hW,eO=typeof ao=="object"&&ao&&!ao.nodeType&&ao,w1=eO&&typeof io=="object"&&io&&!io.nodeType&&io,mW=w1&&w1.exports===eO,S1=mW?ko.Buffer:void 0,vW=S1?S1.isBuffer:void 0,yW=vW||gW,cb=yW,bW="[object Arguments]",xW="[object Array]",wW="[object Boolean]",SW="[object Date]",CW="[object Error]",EW="[object Function]",TW="[object Map]",kW="[object Number]",_W="[object Object]",jW="[object RegExp]",RW="[object Set]",PW="[object String]",MW="[object WeakMap]",OW="[object ArrayBuffer]",NW="[object DataView]",IW="[object Float32Array]",DW="[object Float64Array]",AW="[object Int8Array]",FW="[object Int16Array]",LW="[object Int32Array]",$W="[object Uint8Array]",BW="[object Uint8ClampedArray]",zW="[object Uint16Array]",UW="[object Uint32Array]",Rt={};Rt[IW]=Rt[DW]=Rt[AW]=Rt[FW]=Rt[LW]=Rt[$W]=Rt[BW]=Rt[zW]=Rt[UW]=!0;Rt[bW]=Rt[xW]=Rt[OW]=Rt[wW]=Rt[NW]=Rt[SW]=Rt[CW]=Rt[EW]=Rt[TW]=Rt[kW]=Rt[_W]=Rt[jW]=Rt[RW]=Rt[PW]=Rt[MW]=!1;function VW(e){return ou(e)&&YM(e.length)&&!!Rt[wu(e)]}var HW=VW;function KW(e){return function(t){return e(t)}}var qW=KW,tO=typeof ao=="object"&&ao&&!ao.nodeType&&ao,Mc=tO&&typeof io=="object"&&io&&!io.nodeType&&io,WW=Mc&&Mc.exports===tO,cv=WW&&qM.process,GW=function(){try{var e=Mc&&Mc.require&&Mc.require("util").types;return e||cv&&cv.binding&&cv.binding("util")}catch{}}(),C1=GW,E1=C1&&C1.isTypedArray,JW=E1?qW(E1):HW,nO=JW,QW=Object.prototype,ZW=QW.hasOwnProperty;function YW(e,t){var n=Ed(e),r=!n&&pW(e),s=!n&&!r&&cb(e),o=!n&&!r&&!s&&nO(e),a=n||r||s||o,l=a?iW(e.length,String):[],c=l.length;for(var i in e)(t||ZW.call(e,i))&&!(a&&(i=="length"||s&&(i=="offset"||i=="parent")||o&&(i=="buffer"||i=="byteLength"||i=="byteOffset")||Zq(i,c)))&&l.push(i);return l}var XW=YW;function eG(e,t){return function(n){return e(t(n))}}var tG=eG,nG=tG(Object.keys,Object),rG=nG,sG=Object.prototype,oG=sG.hasOwnProperty;function aG(e){if(!oW(e))return rG(e);var t=[];for(var n in Object(e))oG.call(e,n)&&n!="constructor"&&t.push(n);return t}var iG=aG;function lG(e){return nW(e)?XW(e):iG(e)}var uG=lG,cG=Su(Object,"create"),Td=cG;function dG(){this.__data__=Td?Td(null):{},this.size=0}var fG=dG;function pG(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}var hG=pG,gG="__lodash_hash_undefined__",mG=Object.prototype,vG=mG.hasOwnProperty;function yG(e){var t=this.__data__;if(Td){var n=t[e];return n===gG?void 0:n}return vG.call(t,e)?t[e]:void 0}var bG=yG,xG=Object.prototype,wG=xG.hasOwnProperty;function SG(e){var t=this.__data__;return Td?t[e]!==void 0:wG.call(t,e)}var CG=SG,EG="__lodash_hash_undefined__";function TG(e,t){var n=this.__data__;return this.size+=this.has(e)?0:1,n[e]=Td&&t===void 0?EG:t,this}var kG=TG;function Cu(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}Cu.prototype.clear=fG;Cu.prototype.delete=hG;Cu.prototype.get=bG;Cu.prototype.has=CG;Cu.prototype.set=kG;var T1=Cu;function _G(){this.__data__=[],this.size=0}var jG=_G;function RG(e,t){for(var n=e.length;n--;)if(ZM(e[n][0],t))return n;return-1}var Ag=RG,PG=Array.prototype,MG=PG.splice;function OG(e){var t=this.__data__,n=Ag(t,e);if(n<0)return!1;var r=t.length-1;return n==r?t.pop():MG.call(t,n,1),--this.size,!0}var NG=OG;function IG(e){var t=this.__data__,n=Ag(t,e);return n<0?void 0:t[n][1]}var DG=IG;function AG(e){return Ag(this.__data__,e)>-1}var FG=AG;function LG(e,t){var n=this.__data__,r=Ag(n,e);return r<0?(++this.size,n.push([e,t])):n[r][1]=t,this}var $G=LG;function Eu(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}Eu.prototype.clear=jG;Eu.prototype.delete=NG;Eu.prototype.get=DG;Eu.prototype.has=FG;Eu.prototype.set=$G;var Fg=Eu,BG=Su(ko,"Map"),kd=BG;function zG(){this.size=0,this.__data__={hash:new T1,map:new(kd||Fg),string:new T1}}var UG=zG;function VG(e){var t=typeof e;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?e!=="__proto__":e===null}var HG=VG;function KG(e,t){var n=e.__data__;return HG(t)?n[typeof t=="string"?"string":"hash"]:n.map}var Lg=KG;function qG(e){var t=Lg(this,e).delete(e);return this.size-=t?1:0,t}var WG=qG;function GG(e){return Lg(this,e).get(e)}var JG=GG;function QG(e){return Lg(this,e).has(e)}var ZG=QG;function YG(e,t){var n=Lg(this,e),r=n.size;return n.set(e,t),this.size+=n.size==r?0:1,this}var XG=YG;function Tu(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}Tu.prototype.clear=UG;Tu.prototype.delete=WG;Tu.prototype.get=JG;Tu.prototype.has=ZG;Tu.prototype.set=XG;var rO=Tu;function e9(e){return e==null?"":cq(e)}var sO=e9;function t9(e,t){for(var n=-1,r=t.length,s=e.length;++n<r;)e[s+n]=t[n];return e}var n9=t9;function r9(e){return function(t){return e==null?void 0:e[t]}}var s9=r9;function o9(){this.__data__=new Fg,this.size=0}var a9=o9;function i9(e){var t=this.__data__,n=t.delete(e);return this.size=t.size,n}var l9=i9;function u9(e){return this.__data__.get(e)}var c9=u9;function d9(e){return this.__data__.has(e)}var f9=d9,p9=200;function h9(e,t){var n=this.__data__;if(n instanceof Fg){var r=n.__data__;if(!kd||r.length<p9-1)return r.push([e,t]),this.size=++n.size,this;n=this.__data__=new rO(r)}return n.set(e,t),this.size=n.size,this}var g9=h9;function ku(e){var t=this.__data__=new Fg(e);this.size=t.size}ku.prototype.clear=a9;ku.prototype.delete=l9;ku.prototype.get=c9;ku.prototype.has=f9;ku.prototype.set=g9;var dv=ku;function m9(e,t){for(var n=-1,r=e==null?0:e.length,s=0,o=[];++n<r;){var a=e[n];t(a,n,e)&&(o[s++]=a)}return o}var v9=m9;function y9(){return[]}var b9=y9,x9=Object.prototype,w9=x9.propertyIsEnumerable,k1=Object.getOwnPropertySymbols,S9=k1?function(e){return e==null?[]:(e=Object(e),v9(k1(e),function(t){return w9.call(e,t)}))}:b9,C9=S9;function E9(e,t,n){var r=t(e);return Ed(e)?r:n9(r,n(e))}var T9=E9;function k9(e){return T9(e,uG,C9)}var _1=k9,_9=Su(ko,"DataView"),db=_9,j9=Su(ko,"Promise"),fb=j9,R9=Su(ko,"Set"),Pl=R9,j1="[object Map]",P9="[object Object]",R1="[object Promise]",P1="[object Set]",M1="[object WeakMap]",O1="[object DataView]",M9=Li(db),O9=Li(kd),N9=Li(fb),I9=Li(Pl),D9=Li(ub),za=wu;(db&&za(new db(new ArrayBuffer(1)))!=O1||kd&&za(new kd)!=j1||fb&&za(fb.resolve())!=R1||Pl&&za(new Pl)!=P1||ub&&za(new ub)!=M1)&&(za=function(e){var t=wu(e),n=t==P9?e.constructor:void 0,r=n?Li(n):"";if(r)switch(r){case M9:return O1;case O9:return j1;case N9:return R1;case I9:return P1;case D9:return M1}return t});var N1=za,A9=ko.Uint8Array,I1=A9,F9="__lodash_hash_undefined__";function L9(e){return this.__data__.set(e,F9),this}var $9=L9;function B9(e){return this.__data__.has(e)}var z9=B9;function Eh(e){var t=-1,n=e==null?0:e.length;for(this.__data__=new rO;++t<n;)this.add(e[t])}Eh.prototype.add=Eh.prototype.push=$9;Eh.prototype.has=z9;var oO=Eh;function U9(e,t){for(var n=-1,r=e==null?0:e.length;++n<r;)if(t(e[n],n,e))return!0;return!1}var V9=U9;function H9(e,t){return e.has(t)}var aO=H9,K9=1,q9=2;function W9(e,t,n,r,s,o){var a=n&K9,l=e.length,c=t.length;if(l!=c&&!(a&&c>l))return!1;var i=o.get(e),d=o.get(t);if(i&&d)return i==t&&d==e;var p=-1,f=!0,h=n&q9?new oO:void 0;for(o.set(e,t),o.set(t,e);++p<l;){var g=e[p],m=t[p];if(r)var x=a?r(m,g,p,t,e,o):r(g,m,p,e,t,o);if(x!==void 0){if(x)continue;f=!1;break}if(h){if(!V9(t,function(b,y){if(!aO(h,y)&&(g===b||s(g,b,n,r,o)))return h.push(y)})){f=!1;break}}else if(!(g===m||s(g,m,n,r,o))){f=!1;break}}return o.delete(e),o.delete(t),f}var iO=W9;function G9(e){var t=-1,n=Array(e.size);return e.forEach(function(r,s){n[++t]=[s,r]}),n}var J9=G9;function Q9(e){var t=-1,n=Array(e.size);return e.forEach(function(r){n[++t]=r}),n}var Rw=Q9,Z9=1,Y9=2,X9="[object Boolean]",eJ="[object Date]",tJ="[object Error]",nJ="[object Map]",rJ="[object Number]",sJ="[object RegExp]",oJ="[object Set]",aJ="[object String]",iJ="[object Symbol]",lJ="[object ArrayBuffer]",uJ="[object DataView]",D1=wa?wa.prototype:void 0,fv=D1?D1.valueOf:void 0;function cJ(e,t,n,r,s,o,a){switch(n){case uJ:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case lJ:return!(e.byteLength!=t.byteLength||!o(new I1(e),new I1(t)));case X9:case eJ:case rJ:return ZM(+e,+t);case tJ:return e.name==t.name&&e.message==t.message;case sJ:case aJ:return e==t+"";case nJ:var l=J9;case oJ:var c=r&Z9;if(l||(l=Rw),e.size!=t.size&&!c)return!1;var i=a.get(e);if(i)return i==t;r|=Y9,a.set(e,t);var d=iO(l(e),l(t),r,s,o,a);return a.delete(e),d;case iJ:if(fv)return fv.call(e)==fv.call(t)}return!1}var dJ=cJ,fJ=1,pJ=Object.prototype,hJ=pJ.hasOwnProperty;function gJ(e,t,n,r,s,o){var a=n&fJ,l=_1(e),c=l.length,i=_1(t),d=i.length;if(c!=d&&!a)return!1;for(var p=c;p--;){var f=l[p];if(!(a?f in t:hJ.call(t,f)))return!1}var h=o.get(e),g=o.get(t);if(h&&g)return h==t&&g==e;var m=!0;o.set(e,t),o.set(t,e);for(var x=a;++p<c;){f=l[p];var b=e[f],y=t[f];if(r)var w=a?r(y,b,f,t,e,o):r(b,y,f,e,t,o);if(!(w===void 0?b===y||s(b,y,n,r,o):w)){m=!1;break}x||(x=f=="constructor")}if(m&&!x){var S=e.constructor,E=t.constructor;S!=E&&"constructor"in e&&"constructor"in t&&!(typeof S=="function"&&S instanceof S&&typeof E=="function"&&E instanceof E)&&(m=!1)}return o.delete(e),o.delete(t),m}var mJ=gJ,vJ=1,A1="[object Arguments]",F1="[object Array]",Uf="[object Object]",yJ=Object.prototype,L1=yJ.hasOwnProperty;function bJ(e,t,n,r,s,o){var a=Ed(e),l=Ed(t),c=a?F1:N1(e),i=l?F1:N1(t);c=c==A1?Uf:c,i=i==A1?Uf:i;var d=c==Uf,p=i==Uf,f=c==i;if(f&&cb(e)){if(!cb(t))return!1;a=!0,d=!1}if(f&&!d)return o||(o=new dv),a||nO(e)?iO(e,t,n,r,s,o):dJ(e,t,c,n,r,s,o);if(!(n&vJ)){var h=d&&L1.call(e,"__wrapped__"),g=p&&L1.call(t,"__wrapped__");if(h||g){var m=h?e.value():e,x=g?t.value():t;return o||(o=new dv),s(m,x,n,r,o)}}return f?(o||(o=new dv),mJ(e,t,n,r,s,o)):!1}var xJ=bJ;function lO(e,t,n,r,s){return e===t?!0:e==null||t==null||!ou(e)&&!ou(t)?e!==e&&t!==t:xJ(e,t,n,r,lO,s)}var wJ=lO;function SJ(e,t,n){for(var r=-1,s=e==null?0:e.length;++r<s;)if(n(t,e[r]))return!0;return!1}var CJ=SJ,EJ={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},TJ=s9(EJ),kJ=TJ,uO=/[&<>"']/g,_J=RegExp(uO.source);function jJ(e){return e=sO(e),e&&_J.test(e)?e.replace(uO,kJ):e}var RJ=jJ,cO=/[\\^$.*+?()[\]{}|]/g,PJ=RegExp(cO.source);function MJ(e){return e=sO(e),e&&PJ.test(e)?e.replace(cO,"\\$&"):e}var OJ=MJ;function NJ(e,t){return wJ(e,t)}var IJ=NJ,DJ=1/0,AJ=Pl&&1/Rw(new Pl([,-0]))[1]==DJ?function(e){return new Pl(e)}:Fq,FJ=AJ,LJ=200;function $J(e,t,n){var r=-1,s=Wq,o=e.length,a=!0,l=[],c=l;if(n)a=!1,s=CJ;else if(o>=LJ){var i=t?null:FJ(e);if(i)return Rw(i);a=!1,s=aO,c=new oO}else c=t?[]:l;e:for(;++r<o;){var d=e[r],p=t?t(d):d;if(d=n||d!==0?d:0,a&&p===p){for(var f=c.length;f--;)if(c[f]===p)continue e;t&&c.push(p),l.push(d)}else s(c,p,n)||(c!==l&&c.push(p),l.push(d))}return l}var BJ=$J;function zJ(e){return e&&e.length?BJ(e):[]}var UJ=zJ,VJ=e=>u.jsx("button",{className:e.classNames.clearAll,onClick:e.onClick,children:"Clear all"}),HJ=VJ,KJ=(e,t)=>{const n=t.offsetHeight,r=e.offsetHeight,s=e.offsetTop-t.scrollTop;s+r>=n?t.scrollTop+=s-n+r:s<0&&(t.scrollTop+=s)},pb=(e,t,n,r)=>typeof r=="function"?r(e):e.length>=t&&n,qJ=e=>{const t=v.createRef(),{labelField:n,minQueryLength:r,isFocused:s,classNames:o,selectedIndex:a,query:l}=e;v.useEffect(()=>{if(!t.current)return;const p=t.current.querySelector(`.${o.activeSuggestion}`);p&&KJ(p,t.current)},[a]);const c=(p,f)=>{const h=f.trim().replace(/[-\\^$*+?.()|[\]{}]/g,"\\$&"),{[n]:g}=p;return{__html:g.replace(RegExp(h,"gi"),m=>`<mark>${RJ(m)}</mark>`)}},i=(p,f)=>typeof e.renderSuggestion=="function"?e.renderSuggestion(p,f):u.jsx("span",{dangerouslySetInnerHTML:c(p,f)}),d=e.suggestions.map((p,f)=>u.jsx("li",{onMouseDown:e.handleClick.bind(null,f),onTouchStart:e.handleClick.bind(null,f),onMouseOver:e.handleHover.bind(null,f),className:f===e.selectedIndex?e.classNames.activeSuggestion:"",children:i(p,e.query)},f));return d.length===0||!pb(l,r||2,s,e.shouldRenderSuggestions)?null:u.jsx("div",{ref:t,className:o.suggestions,"data-testid":"suggestions",children:u.jsxs("ul",{children:[" ",d," "]})})},WJ=(e,t)=>{const{query:n,minQueryLength:r=2,isFocused:s,suggestions:o}=t;return!!(e.isFocused===s&&IJ(e.suggestions,o)&&pb(n,r,s,t.shouldRenderSuggestions)===pb(e.query,e.minQueryLength??2,e.isFocused,e.shouldRenderSuggestions)&&e.selectedIndex===t.selectedIndex)},GJ=v.memo(qJ,WJ),JJ=GJ,QJ=HM(KM()),ZJ=HM(KM());function YJ(e){const t=e.map(r=>{const s=r-48*Math.floor(r/48);return String.fromCharCode(96<=r?s:r)}).join(""),n=OJ(t);return new RegExp(`[${n}]+`)}function XJ(e){switch(e){case Rs.ENTER:return[10,13];case Rs.TAB:return 9;case Rs.COMMA:return 188;case Rs.SPACE:return 32;case Rs.SEMICOLON:return 186;default:return 0}}function $1(e){const{moveTag:t,readOnly:n,allowDragDrop:r}=e;return t!==void 0&&!n&&r}function eQ(e){const{readOnly:t,allowDragDrop:n}=e;return!t&&n}var tQ=e=>{const{readOnly:t,removeComponent:n,onRemove:r,className:s,tag:o,index:a}=e,l=i=>{if(Rl.ENTER.includes(i.keyCode)||i.keyCode===Rl.SPACE){i.preventDefault(),i.stopPropagation();return}i.keyCode===Rl.BACKSPACE&&r(i)};if(t)return u.jsx("span",{});const c=`Tag at index ${a} with value ${o.id} focussed. Press backspace to remove`;if(n){const i=n;return u.jsx(i,{"data-testid":"remove",onRemove:r,onKeyDown:l,className:s,"aria-label":c,tag:o,index:a})}return u.jsx("button",{"data-testid":"remove",onClick:r,onKeyDown:l,className:s,type:"button","aria-label":c,children:u.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 512 512",height:"12",width:"12",fill:"#fff",children:u.jsx("path",{d:"M376.6 84.5c11.3-13.6 9.5-33.8-4.1-45.1s-33.8-9.5-45.1 4.1L192 206 56.6 43.5C45.3 29.9 25.1 28.1 11.5 39.4S-3.9 70.9 7.4 84.5L150.3 256 7.4 427.5c-11.3 13.6-9.5 33.8 4.1 45.1s33.8 9.5 45.1-4.1L192 306 327.4 468.5c11.3 13.6 31.5 15.4 45.1 4.1s15.4-31.5 4.1-45.1L233.7 256 376.6 84.5z"})})})},nQ=tQ,B1={TAG:"tag"},rQ=e=>{const t=v.useRef(null),{readOnly:n=!1,tag:r,classNames:s,index:o,moveTag:a,allowDragDrop:l=!0,labelField:c="text",tags:i}=e,[{isDragging:d},p]=U7(()=>({type:B1.TAG,collect:x=>({isDragging:!!x.isDragging()}),item:e,canDrag:()=>$1({moveTag:a,readOnly:n,allowDragDrop:l})}),[i]),[,f]=sK(()=>({accept:B1.TAG,drop:x=>{var w;const b=x.index,y=o;b!==y&&((w=e==null?void 0:e.moveTag)==null||w.call(e,b,y))},canDrop:x=>eQ(x)}),[i]);p(f(t));const h=e.tag[c],{className:g=""}=r,m=d?0:1;return u.jsxs("span",{ref:t,className:(0,ZJ.default)("tag-wrapper",s.tag,g),style:{opacity:m,cursor:$1({moveTag:a,readOnly:n,allowDragDrop:l})?"move":"auto"},"data-testid":"tag",onClick:e.onTagClicked,onTouchStart:e.onTagClicked,children:[h,u.jsx(nQ,{tag:e.tag,className:s.remove,removeComponent:e.removeComponent,onRemove:e.onDelete,readOnly:n,index:o})]})},sQ=e=>{const{autofocus:t,autoFocus:n,readOnly:r,labelField:s,allowDeleteFromEmptyInput:o,allowAdditionFromPaste:a,allowDragDrop:l,minQueryLength:c,shouldRenderSuggestions:i,removeComponent:d,autocomplete:p,inline:f,maxTags:h,allowUnique:g,editable:m,placeholder:x,delimiters:b,separators:y,tags:w,inputFieldPosition:S,inputProps:E,classNames:C,maxLength:k,inputValue:T,clearAll:P}=e,[N,U]=v.useState(e.suggestions),[I,Z]=v.useState(""),[V,Q]=v.useState(!1),[ee,W]=v.useState(-1),[F,A]=v.useState(!1),[Y,de]=v.useState(""),[z,se]=v.useState(-1),[ne,ie]=v.useState(""),oe=v.createRef(),J=v.useRef(null),Ce=v.useRef(null);v.useEffect(()=>{b.length&&console.warn("[Deprecation] The delimiters prop is deprecated and will be removed in v7.x.x, please use separators instead. If you have any concerns regarding this, please share your thoughts in https://github.com/react-tags/react-tags/issues/960")},[]),v.useEffect(()=>{typeof f<"u"&&console.warn("[Deprecation] The inline attribute is deprecated and will be removed in v7.x.x, please use inputFieldPosition instead.")},[f]),v.useEffect(()=>{typeof t<"u"&&console.warn("[Deprecated] autofocus prop will be removed in 7.x so please migrate to autoFocus prop."),(t||n&&t!==!1)&&!r&&Me()},[n,n,r]),v.useEffect(()=>{Wt()},[I,e.suggestions]);const Pe=ue=>{let Ue=e.suggestions.slice();if(g){const _n=w.map(ms=>ms.id.trim().toLowerCase());Ue=Ue.filter(ms=>!_n.includes(ms.id.toLowerCase()))}if(e.handleFilterSuggestions)return e.handleFilterSuggestions(ue,Ue);const St=Ue.filter(_n=>Le(ue,_n)===0),dt=Ue.filter(_n=>Le(ue,_n)>0);return St.concat(dt)},Le=(ue,Ue)=>Ue[s].toLowerCase().indexOf(ue.toLowerCase()),Me=()=>{Z(""),J.current&&(J.current.value="",J.current.focus())},me=(ue,Ue)=>{var dt;Ue.preventDefault(),Ue.stopPropagation();const St=w.slice();St.length!==0&&(ie(""),(dt=e==null?void 0:e.handleDelete)==null||dt.call(e,ue,Ue),rt(ue,St))},rt=(ue,Ue)=>{var _n;if(!(oe!=null&&oe.current))return;const St=oe.current.querySelectorAll(".ReactTags__remove");let dt="";ue===0&&Ue.length>1?(dt=`Tag at index ${ue} with value ${Ue[ue].id} deleted. Tag at index 0 with value ${Ue[1].id} focussed. Press backspace to remove`,St[0].focus()):ue>0?(dt=`Tag at index ${ue} with value ${Ue[ue].id} deleted. Tag at index ${ue-1} with value ${Ue[ue-1].id} focussed. Press backspace to remove`,St[ue-1].focus()):(dt=`Tag at index ${ue} with value ${Ue[ue].id} deleted. Input focussed. Press enter to add a new tag`,(_n=J.current)==null||_n.focus()),de(dt)},It=(ue,Ue,St)=>{var dt,_n;r||(m&&(se(ue),Z(Ue[s]),(dt=Ce.current)==null||dt.focus()),(_n=e.handleTagClick)==null||_n.call(e,ue,St))},Zt=ue=>{e.handleInputChange&&e.handleInputChange(ue.target.value,ue);const Ue=ue.target.value.trim();Z(Ue)},Wt=()=>{const ue=Pe(I);U(ue),W(ee>=ue.length?ue.length-1:ee)},an=ue=>{const Ue=ue.target.value;e.handleInputFocus&&e.handleInputFocus(Ue,ue),Q(!0)},j=ue=>{const Ue=ue.target.value;e.handleInputBlur&&(e.handleInputBlur(Ue,ue),J.current&&(J.current.value="")),Q(!1),se(-1)},D=ue=>{if(ue.key==="Escape"&&(ue.preventDefault(),ue.stopPropagation(),W(-1),A(!1),U([]),se(-1)),(y.indexOf(ue.key)!==-1||b.indexOf(ue.keyCode)!==-1)&&!ue.shiftKey){(ue.keyCode!==Rl.TAB||I!=="")&&ue.preventDefault();const Ue=F&&ee!==-1?N[ee]:{id:I.trim(),[s]:I.trim(),className:""};Object.keys(Ue)&&le(Ue)}ue.key==="Backspace"&&I===""&&(o||S===ec.INLINE)&&me(w.length-1,ue),ue.keyCode===Rl.UP_ARROW&&(ue.preventDefault(),W(ee<=0?N.length-1:ee-1),A(!0)),ue.keyCode===Rl.DOWN_ARROW&&(ue.preventDefault(),A(!0),N.length===0?W(-1):W((ee+1)%N.length))},B=()=>h&&w.length>=h,pe=ue=>{if(!a)return;if(B()){ie(g1.TAG_LIMIT),Me();return}ie(""),ue.preventDefault();const Ue=ue.clipboardData||window.clipboardData,St=Ue.getData("text"),{maxLength:dt=St.length}=e,_n=Math.min(dt,St.length),ms=Ue.getData("text").substr(0,_n);let Ro=b;y.length&&(Ro=[],y.forEach(vs=>{const Du=XJ(vs);Array.isArray(Du)?Ro=[...Ro,...Du]:Ro.push(Du)}));const Iu=YJ(Ro),$i=ms.split(Iu).map(vs=>vs.trim());UJ($i).forEach(vs=>le({id:vs.trim(),[s]:vs.trim(),className:""}))},le=ue=>{var St;if(!ue.id||!ue[s])return;if(z===-1){if(B()){ie(g1.TAG_LIMIT),Me();return}ie("")}const Ue=w.map(dt=>dt.id.toLowerCase());if(!(g&&Ue.indexOf(ue.id.trim().toLowerCase())>=0)){if(p){const dt=Pe(ue[s]);console.warn("[Deprecation] The autocomplete prop will be removed in 7.x to simplify the integration and make it more intutive. If you have any concerns regarding this, please share your thoughts in https://github.com/react-tags/react-tags/issues/949"),(p===1&&dt.length===1||p===!0&&dt.length)&&(ue=dt[0])}z!==-1&&e.onTagUpdate?e.onTagUpdate(z,ue):(St=e==null?void 0:e.handleAddition)==null||St.call(e,ue),Z(""),A(!1),W(-1),se(-1),Me()}},ae=ue=>{le(N[ue])},Ee=()=>{e.onClearAll&&e.onClearAll(),ie(""),Me()},et=ue=>{W(ue),A(!0)},kt=(ue,Ue)=>{var dt;const St=w[ue];(dt=e==null?void 0:e.handleDrag)==null||dt.call(e,St,ue,Ue)},yn=(()=>{const ue={...h1,...e.classNames};return w.map((Ue,St)=>u.jsx(v.Fragment,{children:z===St?u.jsx("div",{className:ue.editTagInput,children:u.jsx("input",{ref:dt=>{Ce.current=dt},onFocus:an,value:I,onChange:Zt,onKeyDown:D,onBlur:j,className:ue.editTagInputField,onPaste:pe,"data-testid":"tag-edit"})}):u.jsx(rQ,{index:St,tag:Ue,tags:w,labelField:s,onDelete:dt=>me(St,dt),moveTag:l?kt:void 0,removeComponent:d,onTagClicked:dt=>It(St,Ue,dt),readOnly:r,classNames:ue,allowDragDrop:l})},St))})(),gn={...h1,...C},{name:jo,id:gs}=e,Aa=f===!1?ec.BOTTOM:S,Fn=r?null:u.jsxs("div",{className:gn.tagInput,children:[u.jsx("input",{...E,ref:ue=>{J.current=ue},className:gn.tagInputField,type:"text",placeholder:x,"aria-label":x,onFocus:an,onBlur:j,onChange:Zt,onKeyDown:D,onPaste:pe,name:jo,id:gs,maxLength:k,value:T,"data-automation":"input","data-testid":"input"}),u.jsx(JJ,{query:I.trim(),suggestions:N,labelField:s,selectedIndex:ee,handleClick:ae,handleHover:et,minQueryLength:c,shouldRenderSuggestions:i,isFocused:V,classNames:gn,renderSuggestion:e.renderSuggestion}),P&&w.length>0&&u.jsx(HJ,{classNames:gn,onClick:Ee}),ne&&u.jsxs("div",{"data-testid":"error",className:"ReactTags__error",children:[u.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 512 512",height:"24",width:"24",fill:"#e03131",children:u.jsx("path",{d:"M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"})}),ne]})]});return u.jsxs("div",{className:(0,QJ.default)(gn.tags,"react-tags-wrapper"),ref:oe,children:[u.jsx("p",{role:"alert",className:"sr-only",style:{position:"absolute",overflow:"hidden",clip:"rect(0 0 0 0)",margin:"-1px",padding:0,width:"1px",height:"1px",border:0},children:Y}),Aa===ec.TOP&&Fn,u.jsxs("div",{className:gn.selected,children:[yn,Aa===ec.INLINE&&Fn]}),Aa===ec.BOTTOM&&Fn]})},oQ=sQ,aQ=e=>{var ne;const{placeholder:t=$K,labelField:n=BK,suggestions:r=[],delimiters:s=[],separators:o=(ne=e.delimiters)!=null&&ne.length?[]:[Rs.ENTER,Rs.TAB],autofocus:a,autoFocus:l=!0,inline:c,inputFieldPosition:i="inline",allowDeleteFromEmptyInput:d=!1,allowAdditionFromPaste:p=!0,autocomplete:f=!1,readOnly:h=!1,allowUnique:g=!0,allowDragDrop:m=!0,tags:x=[],inputProps:b={},editable:y=!1,clearAll:w=!1,handleDelete:S,handleAddition:E,onTagUpdate:C,handleDrag:k,handleFilterSuggestions:T,handleTagClick:P,handleInputChange:N,handleInputFocus:U,handleInputBlur:I,minQueryLength:Z,shouldRenderSuggestions:V,removeComponent:Q,onClearAll:ee,classNames:W,name:F,id:A,maxLength:Y,inputValue:de,maxTags:z,renderSuggestion:se}=e;return u.jsx(oQ,{placeholder:t,labelField:n,suggestions:r,delimiters:s,separators:o,autofocus:a,autoFocus:l,inline:c,inputFieldPosition:i,allowDeleteFromEmptyInput:d,allowAdditionFromPaste:p,autocomplete:f,readOnly:h,allowUnique:g,allowDragDrop:m,tags:x,inputProps:b,editable:y,clearAll:w,handleDelete:S,handleAddition:E,onTagUpdate:C,handleDrag:k,handleFilterSuggestions:T,handleTagClick:P,handleInputChange:N,handleInputFocus:U,handleInputBlur:I,minQueryLength:Z,shouldRenderSuggestions:V,removeComponent:Q,onClearAll:ee,classNames:W,name:F,id:A,maxLength:Y,inputValue:de,maxTags:z,renderSuggestion:se})},iQ=({...e})=>u.jsx(FH,{backend:OK,children:u.jsx(aQ,{...e})});/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/var lQ="Label",dO=v.forwardRef((e,t)=>u.jsx(Ne.label,{...e,ref:t,onMouseDown:n=>{var s;n.target.closest("button, input, select, textarea")||((s=e.onMouseDown)==null||s.call(e,n),!n.defaultPrevented&&n.detail>1&&n.preventDefault())}}));dO.displayName=lQ;var fO=dO;const uQ=ig("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"),pO=v.forwardRef(({className:e,...t},n)=>u.jsx(fO,{ref:n,className:ge(uQ(),e),...t}));pO.displayName=fO.displayName;function hO(e){const t=v.useRef({value:e,previous:e});return v.useMemo(()=>(t.current.value!==e&&(t.current.previous=t.current.value,t.current.value=e),t.current.previous),[e])}var cQ="VisuallyHidden",gO=v.forwardRef((e,t)=>u.jsx(Ne.span,{...e,ref:t,style:{position:"absolute",border:0,width:1,height:1,padding:0,margin:-1,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",wordWrap:"normal",...e.style}}));gO.displayName=cQ;var dQ=[" ","Enter","ArrowUp","ArrowDown"],fQ=[" ","Enter"],ef="Select",[$g,Bg,pQ]=Fx(ef),[_u,Xse]=Vr(ef,[pQ,hg]),zg=hg(),[hQ,Ma]=_u(ef),[gQ,mQ]=_u(ef),mO=e=>{const{__scopeSelect:t,children:n,open:r,defaultOpen:s,onOpenChange:o,value:a,defaultValue:l,onValueChange:c,dir:i,name:d,autoComplete:p,disabled:f,required:h}=e,g=zg(t),[m,x]=v.useState(null),[b,y]=v.useState(null),[w,S]=v.useState(!1),E=Gd(i),[C=!1,k]=pa({prop:r,defaultProp:s,onChange:o}),[T,P]=pa({prop:a,defaultProp:l,onChange:c}),N=v.useRef(null),U=m?!!m.closest("form"):!0,[I,Z]=v.useState(new Set),V=Array.from(I).map(Q=>Q.props.value).join(";");return u.jsx($j,{...g,children:u.jsxs(hQ,{required:h,scope:t,trigger:m,onTriggerChange:x,valueNode:b,onValueNodeChange:y,valueNodeHasChildren:w,onValueNodeHasChildrenChange:S,contentId:os(),value:T,onValueChange:P,open:C,onOpenChange:k,dir:E,triggerPointerDownPosRef:N,disabled:f,children:[u.jsx($g.Provider,{scope:t,children:u.jsx(gQ,{scope:e.__scopeSelect,onNativeOptionAdd:v.useCallback(Q=>{Z(ee=>new Set(ee).add(Q))},[]),onNativeOptionRemove:v.useCallback(Q=>{Z(ee=>{const W=new Set(ee);return W.delete(Q),W})},[]),children:n})}),U?u.jsxs(zO,{"aria-hidden":!0,required:h,tabIndex:-1,name:d,autoComplete:p,value:T,onChange:Q=>P(Q.target.value),disabled:f,children:[T===void 0?u.jsx("option",{value:""}):null,Array.from(I)]},V):null]})})};mO.displayName=ef;var vO="SelectTrigger",yO=v.forwardRef((e,t)=>{const{__scopeSelect:n,disabled:r=!1,...s}=e,o=zg(n),a=Ma(vO,n),l=a.disabled||r,c=it(t,a.onTriggerChange),i=Bg(n),[d,p,f]=UO(g=>{const m=i().filter(y=>!y.disabled),x=m.find(y=>y.value===a.value),b=VO(m,g,x);b!==void 0&&a.onValueChange(b.value)}),h=()=>{l||(a.onOpenChange(!0),f())};return u.jsx(Bj,{asChild:!0,...o,children:u.jsx(Ne.button,{type:"button",role:"combobox","aria-controls":a.contentId,"aria-expanded":a.open,"aria-required":a.required,"aria-autocomplete":"none",dir:a.dir,"data-state":a.open?"open":"closed",disabled:l,"data-disabled":l?"":void 0,"data-placeholder":BO(a.value)?"":void 0,...s,ref:c,onClick:Se(s.onClick,g=>{g.currentTarget.focus()}),onPointerDown:Se(s.onPointerDown,g=>{const m=g.target;m.hasPointerCapture(g.pointerId)&&m.releasePointerCapture(g.pointerId),g.button===0&&g.ctrlKey===!1&&(h(),a.triggerPointerDownPosRef.current={x:Math.round(g.pageX),y:Math.round(g.pageY)},g.preventDefault())}),onKeyDown:Se(s.onKeyDown,g=>{const m=d.current!=="";!(g.ctrlKey||g.altKey||g.metaKey)&&g.key.length===1&&p(g.key),!(m&&g.key===" ")&&dQ.includes(g.key)&&(h(),g.preventDefault())})})})});yO.displayName=vO;var bO="SelectValue",xO=v.forwardRef((e,t)=>{const{__scopeSelect:n,className:r,style:s,children:o,placeholder:a="",...l}=e,c=Ma(bO,n),{onValueNodeHasChildrenChange:i}=c,d=o!==void 0,p=it(t,c.onValueNodeChange);return fn(()=>{i(d)},[i,d]),u.jsx(Ne.span,{...l,ref:p,style:{pointerEvents:"none"},children:BO(c.value)?u.jsx(u.Fragment,{children:a}):o})});xO.displayName=bO;var vQ="SelectIcon",wO=v.forwardRef((e,t)=>{const{__scopeSelect:n,children:r,...s}=e;return u.jsx(Ne.span,{"aria-hidden":!0,...s,ref:t,children:r||"▼"})});wO.displayName=vQ;var yQ="SelectPortal",SO=e=>u.jsx(gg,{asChild:!0,...e});SO.displayName=yQ;var ji="SelectContent",CO=v.forwardRef((e,t)=>{const n=Ma(ji,e.__scopeSelect),[r,s]=v.useState();if(fn(()=>{s(new DocumentFragment)},[]),!n.open){const o=r;return o?ka.createPortal(u.jsx(EO,{scope:e.__scopeSelect,children:u.jsx($g.Slot,{scope:e.__scopeSelect,children:u.jsx("div",{children:e.children})})}),o):null}return u.jsx(TO,{...e,ref:t})});CO.displayName=ji;var Ys=10,[EO,Oa]=_u(ji),bQ="SelectContentImpl",TO=v.forwardRef((e,t)=>{const{__scopeSelect:n,position:r="item-aligned",onCloseAutoFocus:s,onEscapeKeyDown:o,onPointerDownOutside:a,side:l,sideOffset:c,align:i,alignOffset:d,arrowPadding:p,collisionBoundary:f,collisionPadding:h,sticky:g,hideWhenDetached:m,avoidCollisions:x,...b}=e,y=Ma(ji,n),[w,S]=v.useState(null),[E,C]=v.useState(null),k=it(t,J=>S(J)),[T,P]=v.useState(null),[N,U]=v.useState(null),I=Bg(n),[Z,V]=v.useState(!1),Q=v.useRef(!1);v.useEffect(()=>{if(w)return Wx(w)},[w]),Lx();const ee=v.useCallback(J=>{const[Ce,...Pe]=I().map(me=>me.ref.current),[Le]=Pe.slice(-1),Me=document.activeElement;for(const me of J)if(me===Me||(me==null||me.scrollIntoView({block:"nearest"}),me===Ce&&E&&(E.scrollTop=0),me===Le&&E&&(E.scrollTop=E.scrollHeight),me==null||me.focus(),document.activeElement!==Me))return},[I,E]),W=v.useCallback(()=>ee([T,w]),[ee,T,w]);v.useEffect(()=>{Z&&W()},[Z,W]);const{onOpenChange:F,triggerPointerDownPosRef:A}=y;v.useEffect(()=>{if(w){let J={x:0,y:0};const Ce=Le=>{var Me,me;J={x:Math.abs(Math.round(Le.pageX)-(((Me=A.current)==null?void 0:Me.x)??0)),y:Math.abs(Math.round(Le.pageY)-(((me=A.current)==null?void 0:me.y)??0))}},Pe=Le=>{J.x<=10&&J.y<=10?Le.preventDefault():w.contains(Le.target)||F(!1),document.removeEventListener("pointermove",Ce),A.current=null};return A.current!==null&&(document.addEventListener("pointermove",Ce),document.addEventListener("pointerup",Pe,{capture:!0,once:!0})),()=>{document.removeEventListener("pointermove",Ce),document.removeEventListener("pointerup",Pe,{capture:!0})}}},[w,F,A]),v.useEffect(()=>{const J=()=>F(!1);return window.addEventListener("blur",J),window.addEventListener("resize",J),()=>{window.removeEventListener("blur",J),window.removeEventListener("resize",J)}},[F]);const[Y,de]=UO(J=>{const Ce=I().filter(Me=>!Me.disabled),Pe=Ce.find(Me=>Me.ref.current===document.activeElement),Le=VO(Ce,J,Pe);Le&&setTimeout(()=>Le.ref.current.focus())}),z=v.useCallback((J,Ce,Pe)=>{const Le=!Q.current&&!Pe;(y.value!==void 0&&y.value===Ce||Le)&&(P(J),Le&&(Q.current=!0))},[y.value]),se=v.useCallback(()=>w==null?void 0:w.focus(),[w]),ne=v.useCallback((J,Ce,Pe)=>{const Le=!Q.current&&!Pe;(y.value!==void 0&&y.value===Ce||Le)&&U(J)},[y.value]),ie=r==="popper"?hb:kO,oe=ie===hb?{side:l,sideOffset:c,align:i,alignOffset:d,arrowPadding:p,collisionBoundary:f,collisionPadding:h,sticky:g,hideWhenDetached:m,avoidCollisions:x}:{};return u.jsx(EO,{scope:n,content:w,viewport:E,onViewportChange:C,itemRefCallback:z,selectedItem:T,onItemLeave:se,itemTextRefCallback:ne,focusSelectedItem:W,selectedItemText:N,position:r,isPositioned:Z,searchRef:Y,children:u.jsx(bg,{as:mo,allowPinchZoom:!0,children:u.jsx(dg,{asChild:!0,trapped:y.open,onMountAutoFocus:J=>{J.preventDefault()},onUnmountAutoFocus:Se(s,J=>{var Ce;(Ce=y.trigger)==null||Ce.focus({preventScroll:!0}),J.preventDefault()}),children:u.jsx(cg,{asChild:!0,disableOutsidePointerEvents:!0,onEscapeKeyDown:o,onPointerDownOutside:a,onFocusOutside:J=>J.preventDefault(),onDismiss:()=>y.onOpenChange(!1),children:u.jsx(ie,{role:"listbox",id:y.contentId,"data-state":y.open?"open":"closed",dir:y.dir,onContextMenu:J=>J.preventDefault(),...b,...oe,onPlaced:()=>V(!0),ref:k,style:{display:"flex",flexDirection:"column",outline:"none",...b.style},onKeyDown:Se(b.onKeyDown,J=>{const Ce=J.ctrlKey||J.altKey||J.metaKey;if(J.key==="Tab"&&J.preventDefault(),!Ce&&J.key.length===1&&de(J.key),["ArrowUp","ArrowDown","Home","End"].includes(J.key)){let Le=I().filter(Me=>!Me.disabled).map(Me=>Me.ref.current);if(["ArrowUp","End"].includes(J.key)&&(Le=Le.slice().reverse()),["ArrowUp","ArrowDown"].includes(J.key)){const Me=J.target,me=Le.indexOf(Me);Le=Le.slice(me+1)}setTimeout(()=>ee(Le)),J.preventDefault()}})})})})})})});TO.displayName=bQ;var xQ="SelectItemAlignedPosition",kO=v.forwardRef((e,t)=>{const{__scopeSelect:n,onPlaced:r,...s}=e,o=Ma(ji,n),a=Oa(ji,n),[l,c]=v.useState(null),[i,d]=v.useState(null),p=it(t,k=>d(k)),f=Bg(n),h=v.useRef(!1),g=v.useRef(!0),{viewport:m,selectedItem:x,selectedItemText:b,focusSelectedItem:y}=a,w=v.useCallback(()=>{if(o.trigger&&o.valueNode&&l&&i&&m&&x&&b){const k=o.trigger.getBoundingClientRect(),T=i.getBoundingClientRect(),P=o.valueNode.getBoundingClientRect(),N=b.getBoundingClientRect();if(o.dir!=="rtl"){const Me=N.left-T.left,me=P.left-Me,rt=k.left-me,It=k.width+rt,Zt=Math.max(It,T.width),Wt=window.innerWidth-Ys,an=Zy(me,[Ys,Wt-Zt]);l.style.minWidth=It+"px",l.style.left=an+"px"}else{const Me=T.right-N.right,me=window.innerWidth-P.right-Me,rt=window.innerWidth-k.right-me,It=k.width+rt,Zt=Math.max(It,T.width),Wt=window.innerWidth-Ys,an=Zy(me,[Ys,Wt-Zt]);l.style.minWidth=It+"px",l.style.right=an+"px"}const U=f(),I=window.innerHeight-Ys*2,Z=m.scrollHeight,V=window.getComputedStyle(i),Q=parseInt(V.borderTopWidth,10),ee=parseInt(V.paddingTop,10),W=parseInt(V.borderBottomWidth,10),F=parseInt(V.paddingBottom,10),A=Q+ee+Z+F+W,Y=Math.min(x.offsetHeight*5,A),de=window.getComputedStyle(m),z=parseInt(de.paddingTop,10),se=parseInt(de.paddingBottom,10),ne=k.top+k.height/2-Ys,ie=I-ne,oe=x.offsetHeight/2,J=x.offsetTop+oe,Ce=Q+ee+J,Pe=A-Ce;if(Ce<=ne){const Me=x===U[U.length-1].ref.current;l.style.bottom="0px";const me=i.clientHeight-m.offsetTop-m.offsetHeight,rt=Math.max(ie,oe+(Me?se:0)+me+W),It=Ce+rt;l.style.height=It+"px"}else{const Me=x===U[0].ref.current;l.style.top="0px";const rt=Math.max(ne,Q+m.offsetTop+(Me?z:0)+oe)+Pe;l.style.height=rt+"px",m.scrollTop=Ce-ne+m.offsetTop}l.style.margin=`${Ys}px 0`,l.style.minHeight=Y+"px",l.style.maxHeight=I+"px",r==null||r(),requestAnimationFrame(()=>h.current=!0)}},[f,o.trigger,o.valueNode,l,i,m,x,b,o.dir,r]);fn(()=>w(),[w]);const[S,E]=v.useState();fn(()=>{i&&E(window.getComputedStyle(i).zIndex)},[i]);const C=v.useCallback(k=>{k&&g.current===!0&&(w(),y==null||y(),g.current=!1)},[w,y]);return u.jsx(SQ,{scope:n,contentWrapper:l,shouldExpandOnScrollRef:h,onScrollButtonChange:C,children:u.jsx("div",{ref:c,style:{display:"flex",flexDirection:"column",position:"fixed",zIndex:S},children:u.jsx(Ne.div,{...s,ref:p,style:{boxSizing:"border-box",maxHeight:"100%",...s.style}})})})});kO.displayName=xQ;var wQ="SelectPopperPosition",hb=v.forwardRef((e,t)=>{const{__scopeSelect:n,align:r="start",collisionPadding:s=Ys,...o}=e,a=zg(n);return u.jsx(zj,{...a,...o,ref:t,align:r,collisionPadding:s,style:{boxSizing:"border-box",...o.style,"--radix-select-content-transform-origin":"var(--radix-popper-transform-origin)","--radix-select-content-available-width":"var(--radix-popper-available-width)","--radix-select-content-available-height":"var(--radix-popper-available-height)","--radix-select-trigger-width":"var(--radix-popper-anchor-width)","--radix-select-trigger-height":"var(--radix-popper-anchor-height)"}})});hb.displayName=wQ;var[SQ,Pw]=_u(ji,{}),gb="SelectViewport",_O=v.forwardRef((e,t)=>{const{__scopeSelect:n,nonce:r,...s}=e,o=Oa(gb,n),a=Pw(gb,n),l=it(t,o.onViewportChange),c=v.useRef(0);return u.jsxs(u.Fragment,{children:[u.jsx("style",{dangerouslySetInnerHTML:{__html:"[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"},nonce:r}),u.jsx($g.Slot,{scope:n,children:u.jsx(Ne.div,{"data-radix-select-viewport":"",role:"presentation",...s,ref:l,style:{position:"relative",flex:1,overflow:"auto",...s.style},onScroll:Se(s.onScroll,i=>{const d=i.currentTarget,{contentWrapper:p,shouldExpandOnScrollRef:f}=a;if(f!=null&&f.current&&p){const h=Math.abs(c.current-d.scrollTop);if(h>0){const g=window.innerHeight-Ys*2,m=parseFloat(p.style.minHeight),x=parseFloat(p.style.height),b=Math.max(m,x);if(b<g){const y=b+h,w=Math.min(g,y),S=y-w;p.style.height=w+"px",p.style.bottom==="0px"&&(d.scrollTop=S>0?S:0,p.style.justifyContent="flex-end")}}}c.current=d.scrollTop})})})]})});_O.displayName=gb;var jO="SelectGroup",[CQ,EQ]=_u(jO),TQ=v.forwardRef((e,t)=>{const{__scopeSelect:n,...r}=e,s=os();return u.jsx(CQ,{scope:n,id:s,children:u.jsx(Ne.div,{role:"group","aria-labelledby":s,...r,ref:t})})});TQ.displayName=jO;var RO="SelectLabel",PO=v.forwardRef((e,t)=>{const{__scopeSelect:n,...r}=e,s=EQ(RO,n);return u.jsx(Ne.div,{id:s.id,...r,ref:t})});PO.displayName=RO;var Th="SelectItem",[kQ,MO]=_u(Th),OO=v.forwardRef((e,t)=>{const{__scopeSelect:n,value:r,disabled:s=!1,textValue:o,...a}=e,l=Ma(Th,n),c=Oa(Th,n),i=l.value===r,[d,p]=v.useState(o??""),[f,h]=v.useState(!1),g=it(t,b=>{var y;return(y=c.itemRefCallback)==null?void 0:y.call(c,b,r,s)}),m=os(),x=()=>{s||(l.onValueChange(r),l.onOpenChange(!1))};if(r==="")throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");return u.jsx(kQ,{scope:n,value:r,disabled:s,textId:m,isSelected:i,onItemTextChange:v.useCallback(b=>{p(y=>y||((b==null?void 0:b.textContent)??"").trim())},[]),children:u.jsx($g.ItemSlot,{scope:n,value:r,disabled:s,textValue:d,children:u.jsx(Ne.div,{role:"option","aria-labelledby":m,"data-highlighted":f?"":void 0,"aria-selected":i&&f,"data-state":i?"checked":"unchecked","aria-disabled":s||void 0,"data-disabled":s?"":void 0,tabIndex:s?void 0:-1,...a,ref:g,onFocus:Se(a.onFocus,()=>h(!0)),onBlur:Se(a.onBlur,()=>h(!1)),onPointerUp:Se(a.onPointerUp,x),onPointerMove:Se(a.onPointerMove,b=>{var y;s?(y=c.onItemLeave)==null||y.call(c):b.currentTarget.focus({preventScroll:!0})}),onPointerLeave:Se(a.onPointerLeave,b=>{var y;b.currentTarget===document.activeElement&&((y=c.onItemLeave)==null||y.call(c))}),onKeyDown:Se(a.onKeyDown,b=>{var w;((w=c.searchRef)==null?void 0:w.current)!==""&&b.key===" "||(fQ.includes(b.key)&&x(),b.key===" "&&b.preventDefault())})})})})});OO.displayName=Th;var hc="SelectItemText",NO=v.forwardRef((e,t)=>{const{__scopeSelect:n,className:r,style:s,...o}=e,a=Ma(hc,n),l=Oa(hc,n),c=MO(hc,n),i=mQ(hc,n),[d,p]=v.useState(null),f=it(t,b=>p(b),c.onItemTextChange,b=>{var y;return(y=l.itemTextRefCallback)==null?void 0:y.call(l,b,c.value,c.disabled)}),h=d==null?void 0:d.textContent,g=v.useMemo(()=>u.jsx("option",{value:c.value,disabled:c.disabled,children:h},c.value),[c.disabled,c.value,h]),{onNativeOptionAdd:m,onNativeOptionRemove:x}=i;return fn(()=>(m(g),()=>x(g)),[m,x,g]),u.jsxs(u.Fragment,{children:[u.jsx(Ne.span,{id:c.textId,...o,ref:f}),c.isSelected&&a.valueNode&&!a.valueNodeHasChildren?ka.createPortal(o.children,a.valueNode):null]})});NO.displayName=hc;var IO="SelectItemIndicator",DO=v.forwardRef((e,t)=>{const{__scopeSelect:n,...r}=e;return MO(IO,n).isSelected?u.jsx(Ne.span,{"aria-hidden":!0,...r,ref:t}):null});DO.displayName=IO;var mb="SelectScrollUpButton",AO=v.forwardRef((e,t)=>{const n=Oa(mb,e.__scopeSelect),r=Pw(mb,e.__scopeSelect),[s,o]=v.useState(!1),a=it(t,r.onScrollButtonChange);return fn(()=>{if(n.viewport&&n.isPositioned){let l=function(){const i=c.scrollTop>0;o(i)};const c=n.viewport;return l(),c.addEventListener("scroll",l),()=>c.removeEventListener("scroll",l)}},[n.viewport,n.isPositioned]),s?u.jsx(LO,{...e,ref:a,onAutoScroll:()=>{const{viewport:l,selectedItem:c}=n;l&&c&&(l.scrollTop=l.scrollTop-c.offsetHeight)}}):null});AO.displayName=mb;var vb="SelectScrollDownButton",FO=v.forwardRef((e,t)=>{const n=Oa(vb,e.__scopeSelect),r=Pw(vb,e.__scopeSelect),[s,o]=v.useState(!1),a=it(t,r.onScrollButtonChange);return fn(()=>{if(n.viewport&&n.isPositioned){let l=function(){const i=c.scrollHeight-c.clientHeight,d=Math.ceil(c.scrollTop)<i;o(d)};const c=n.viewport;return l(),c.addEventListener("scroll",l),()=>c.removeEventListener("scroll",l)}},[n.viewport,n.isPositioned]),s?u.jsx(LO,{...e,ref:a,onAutoScroll:()=>{const{viewport:l,selectedItem:c}=n;l&&c&&(l.scrollTop=l.scrollTop+c.offsetHeight)}}):null});FO.displayName=vb;var LO=v.forwardRef((e,t)=>{const{__scopeSelect:n,onAutoScroll:r,...s}=e,o=Oa("SelectScrollButton",n),a=v.useRef(null),l=Bg(n),c=v.useCallback(()=>{a.current!==null&&(window.clearInterval(a.current),a.current=null)},[]);return v.useEffect(()=>()=>c(),[c]),fn(()=>{var d;const i=l().find(p=>p.ref.current===document.activeElement);(d=i==null?void 0:i.ref.current)==null||d.scrollIntoView({block:"nearest"})},[l]),u.jsx(Ne.div,{"aria-hidden":!0,...s,ref:t,style:{flexShrink:0,...s.style},onPointerDown:Se(s.onPointerDown,()=>{a.current===null&&(a.current=window.setInterval(r,50))}),onPointerMove:Se(s.onPointerMove,()=>{var i;(i=o.onItemLeave)==null||i.call(o),a.current===null&&(a.current=window.setInterval(r,50))}),onPointerLeave:Se(s.onPointerLeave,()=>{c()})})}),_Q="SelectSeparator",$O=v.forwardRef((e,t)=>{const{__scopeSelect:n,...r}=e;return u.jsx(Ne.div,{"aria-hidden":!0,...r,ref:t})});$O.displayName=_Q;var yb="SelectArrow",jQ=v.forwardRef((e,t)=>{const{__scopeSelect:n,...r}=e,s=zg(n),o=Ma(yb,n),a=Oa(yb,n);return o.open&&a.position==="popper"?u.jsx(Uj,{...s,...r,ref:t}):null});jQ.displayName=yb;function BO(e){return e===""||e===void 0}var zO=v.forwardRef((e,t)=>{const{value:n,...r}=e,s=v.useRef(null),o=it(t,s),a=hO(n);return v.useEffect(()=>{const l=s.current,c=window.HTMLSelectElement.prototype,d=Object.getOwnPropertyDescriptor(c,"value").set;if(a!==n&&d){const p=new Event("change",{bubbles:!0});d.call(l,n),l.dispatchEvent(p)}},[a,n]),u.jsx(gO,{asChild:!0,children:u.jsx("select",{...r,ref:o,defaultValue:n})})});zO.displayName="BubbleSelect";function UO(e){const t=nn(e),n=v.useRef(""),r=v.useRef(0),s=v.useCallback(a=>{const l=n.current+a;t(l),function c(i){n.current=i,window.clearTimeout(r.current),i!==""&&(r.current=window.setTimeout(()=>c(""),1e3))}(l)},[t]),o=v.useCallback(()=>{n.current="",window.clearTimeout(r.current)},[]);return v.useEffect(()=>()=>window.clearTimeout(r.current),[]),[n,s,o]}function VO(e,t,n){const s=t.length>1&&Array.from(t).every(i=>i===t[0])?t[0]:t,o=n?e.indexOf(n):-1;let a=RQ(e,Math.max(o,0));s.length===1&&(a=a.filter(i=>i!==n));const c=a.find(i=>i.textValue.toLowerCase().startsWith(s.toLowerCase()));return c!==n?c:void 0}function RQ(e,t){return e.map((n,r)=>e[(t+r)%e.length])}var PQ=mO,HO=yO,MQ=xO,OQ=wO,NQ=SO,KO=CO,IQ=_O,qO=PO,WO=OO,DQ=NO,AQ=DO,GO=AO,JO=FO,QO=$O;const FQ=PQ,LQ=MQ,ZO=v.forwardRef(({className:e,children:t,...n},r)=>u.jsxs(HO,{ref:r,className:ge("flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",e),...n,children:[t,u.jsx(OQ,{asChild:!0,children:u.jsx(lg,{className:"h-4 w-4 opacity-50"})})]}));ZO.displayName=HO.displayName;const YO=v.forwardRef(({className:e,...t},n)=>u.jsx(GO,{ref:n,className:ge("flex cursor-default items-center justify-center py-1",e),...t,children:u.jsx(P3,{className:"h-4 w-4"})}));YO.displayName=GO.displayName;const XO=v.forwardRef(({className:e,...t},n)=>u.jsx(JO,{ref:n,className:ge("flex cursor-default items-center justify-center py-1",e),...t,children:u.jsx(lg,{className:"h-4 w-4"})}));XO.displayName=JO.displayName;const eN=v.forwardRef(({className:e,children:t,position:n="popper",...r},s)=>u.jsx(NQ,{children:u.jsxs(KO,{ref:s,className:ge("relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",n==="popper"&&"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",e),position:n,...r,children:[u.jsx(YO,{}),u.jsx(IQ,{className:ge("p-1",n==="popper"&&"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"),children:t}),u.jsx(XO,{})]})}));eN.displayName=KO.displayName;const $Q=v.forwardRef(({className:e,...t},n)=>u.jsx(qO,{ref:n,className:ge("py-1.5 pl-8 pr-2 text-sm font-semibold",e),...t}));$Q.displayName=qO.displayName;const tN=v.forwardRef(({className:e,children:t,...n},r)=>u.jsxs(WO,{ref:r,className:ge("relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",e),...n,children:[u.jsx("span",{className:"absolute left-2 flex h-3.5 w-3.5 items-center justify-center",children:u.jsx(AQ,{children:u.jsx(cj,{className:"h-4 w-4"})})}),u.jsx(DQ,{children:t})]}));tN.displayName=WO.displayName;const BQ=v.forwardRef(({className:e,...t},n)=>u.jsx(QO,{ref:n,className:ge("-mx-1 my-1 h-px bg-muted",e),...t}));BQ.displayName=QO.displayName;var Mw="Switch",[zQ,eoe]=Vr(Mw),[UQ,VQ]=zQ(Mw),nN=v.forwardRef((e,t)=>{const{__scopeSwitch:n,name:r,checked:s,defaultChecked:o,required:a,disabled:l,value:c="on",onCheckedChange:i,...d}=e,[p,f]=v.useState(null),h=it(t,y=>f(y)),g=v.useRef(!1),m=p?!!p.closest("form"):!0,[x=!1,b]=pa({prop:s,defaultProp:o,onChange:i});return u.jsxs(UQ,{scope:n,checked:x,disabled:l,children:[u.jsx(Ne.button,{type:"button",role:"switch","aria-checked":x,"aria-required":a,"data-state":oN(x),"data-disabled":l?"":void 0,disabled:l,value:c,...d,ref:h,onClick:Se(e.onClick,y=>{b(w=>!w),m&&(g.current=y.isPropagationStopped(),g.current||y.stopPropagation())})}),m&&u.jsx(HQ,{control:p,bubbles:!g.current,name:r,value:c,checked:x,required:a,disabled:l,style:{transform:"translateX(-100%)"}})]})});nN.displayName=Mw;var rN="SwitchThumb",sN=v.forwardRef((e,t)=>{const{__scopeSwitch:n,...r}=e,s=VQ(rN,n);return u.jsx(Ne.span,{"data-state":oN(s.checked),"data-disabled":s.disabled?"":void 0,...r,ref:t})});sN.displayName=rN;var HQ=e=>{const{control:t,checked:n,bubbles:r=!0,...s}=e,o=v.useRef(null),a=hO(n),l=Rj(t);return v.useEffect(()=>{const c=o.current,i=window.HTMLInputElement.prototype,p=Object.getOwnPropertyDescriptor(i,"checked").set;if(a!==n&&p){const f=new Event("click",{bubbles:r});p.call(c,n),c.dispatchEvent(f)}},[a,n,r]),u.jsx("input",{type:"checkbox","aria-hidden":!0,defaultChecked:n,...s,tabIndex:-1,ref:o,style:{...e.style,...l,position:"absolute",pointerEvents:"none",opacity:0,margin:0}})};function oN(e){return e?"checked":"unchecked"}var aN=nN,KQ=sN;const ju=v.forwardRef(({className:e,...t},n)=>u.jsx(aN,{className:ge("peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-slate-400",e),...t,ref:n,children:u.jsx(KQ,{className:ge("pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0")})}));ju.displayName=aN.displayName;const Na=Tr,iN=v.createContext({}),Ia=({...e})=>u.jsx(iN.Provider,{value:{name:e.name},children:u.jsx($V,{...e})}),Ug=()=>{const e=v.useContext(iN),t=v.useContext(lN),{getFieldState:n,formState:r}=Rg(),s=n(e.name,r);if(!e)throw new Error("useFormField should be used within <FormField>");const{id:o}=t;return{id:o,name:e.name,formItemId:`${o}-form-item`,formDescriptionId:`${o}-form-item-description`,formMessageId:`${o}-form-item-message`,...s}},lN=v.createContext({}),_o=v.forwardRef(({className:e,...t},n)=>{const r=v.useId();return u.jsx(lN.Provider,{value:{id:r},children:u.jsx("div",{ref:n,className:ge("space-y-2",e),...t})})});_o.displayName="FormItem";const xr=v.forwardRef(({className:e,...t},n)=>{const{error:r,formItemId:s}=Ug();return u.jsx(pO,{ref:n,className:ge(r&&"text-rose-600",e),htmlFor:s,...t})});xr.displayName="FormLabel";const Vs=v.forwardRef(({...e},t)=>{const{error:n,formItemId:r,formDescriptionId:s,formMessageId:o}=Ug();return u.jsx(mo,{ref:t,id:r,"aria-describedby":n?`${s} ${o}`:`${s}`,"aria-invalid":!!n,...e})});Vs.displayName="FormControl";const Vg=v.forwardRef(({className:e,...t},n)=>{const{formDescriptionId:r}=Ug();return u.jsx("p",{ref:n,id:r,className:ge("text-sm text-muted-foreground",e),...t})});Vg.displayName="FormDescription";const tf=v.forwardRef(({className:e,children:t,...n},r)=>{const{error:s,formMessageId:o}=Ug(),a=s?String(s==null?void 0:s.message):t;return a?u.jsx("p",{ref:r,id:o,className:ge("text-sm font-medium text-rose-600",e),...n,children:a}):null});tf.displayName="FormMessage";const G=({name:e,label:t,children:n,required:r,readOnly:s,className:o,...a})=>u.jsx(Ia,{...a,name:e,render:({field:l})=>u.jsxs(_o,{className:o,children:[t&&u.jsxs(xr,{children:[t,r&&u.jsx("span",{className:"ml-2 text-rose-600",children:"*"})]}),u.jsx(Vs,{children:v.isValidElement(n)&&v.cloneElement(n,{...l,value:l.value??"",required:r,readOnly:s,checked:l.value,onCheckedChange:l.onChange})}),u.jsx(tf,{})]})}),ke=({name:e,label:t,required:n,className:r,helper:s,reverse:o,...a})=>u.jsx(Ia,{...a,name:e,render:({field:l})=>u.jsxs(_o,{className:ge("flex items-center gap-3",o&&"flex-row-reverse justify-end",r),children:[u.jsx("div",{className:"flex flex-col gap-2",children:t&&u.jsxs(xr,{children:[u.jsxs("p",{className:"break-all",children:[t,n&&u.jsx("span",{className:"ml-2 text-rose-600",children:"*"})]}),s&&u.jsx(Vg,{className:"mt-2",children:s})]})}),u.jsx(Vs,{children:u.jsx(ju,{checked:l.value,onCheckedChange:l.onChange,required:n})}),u.jsx(tf,{})]})}),Qt=({name:e,label:t,helper:n,required:r,options:s,placeholder:o,...a})=>u.jsx(Ia,{...a,name:e,render:({field:l})=>u.jsxs(_o,{children:[t&&u.jsxs(xr,{children:[t,r&&u.jsx("span",{className:"ml-2 text-rose-600",children:"*"})]}),u.jsx(Vs,{children:u.jsxs(FQ,{onValueChange:l.onChange,defaultValue:l.value,children:[u.jsx(Vs,{children:u.jsx(ZO,{children:u.jsx(LQ,{placeholder:o})})}),u.jsx(eN,{children:s.map(c=>u.jsx(tN,{value:c.value,children:c.label},c.value))})]})}),n&&u.jsx(Vg,{children:n}),u.jsx(tf,{})]})}),Ru=({name:e,label:t,helper:n,required:r,placeholder:s,...o})=>u.jsx(Ia,{...o,name:e,render:({field:a})=>{let l=[];return Array.isArray(a.value)&&(l=a.value),u.jsxs(_o,{children:[t&&u.jsxs(xr,{children:[t,r&&u.jsx("span",{className:"ml-2 text-rose-600",children:"*"})]}),u.jsx(Vs,{children:u.jsx(iQ,{tags:l.map(c=>({id:c,text:c,className:""})),handleDelete:c=>a.onChange(l.filter((i,d)=>d!==c)),handleAddition:c=>a.onChange([...l,c.id]),inputFieldPosition:"bottom",placeholder:s,autoFocus:!1,allowDragDrop:!1,separators:[Rs.ENTER,Rs.TAB,Rs.COMMA],classNames:{tags:"tagsClass",tagInput:"tagInputClass",tagInputField:QP,selected:"my-2 flex flex-wrap gap-2",tag:"flex items-center gap-2 px-2 py-1 bg-primary/30 rounded-md text-xs",remove:"[&>svg]:fill-rose-600 hover:[&>svg]:fill-rose-700",suggestions:"suggestionsClass",activeSuggestion:"activeSuggestionClass",editTagInput:"editTagInputClass",editTagInputField:"editTagInputFieldClass",clearAll:"clearAllClass"}})}),n&&u.jsx(Vg,{children:n}),u.jsx(tf,{})]})}}),pv=_.string().optional().transform(e=>e===""?void 0:e),qQ=_.object({name:_.string(),token:pv,number:pv,businessId:pv,integration:_.enum(["WHATSAPP-BUSINESS","WHATSAPP-BAILEYS","EVOLUTION"])});function WQ({resetTable:e}){const{t}=ze(),{createInstance:n}=_g(),[r,s]=v.useState(!1),o=[{value:"WHATSAPP-BAILEYS",label:t("instance.form.integration.baileys")},{value:"WHATSAPP-BUSINESS",label:t("instance.form.integration.whatsapp")},{value:"EVOLUTION",label:t("instance.form.integration.evolution")}],a=sn({resolver:on(qQ),defaultValues:{name:"",integration:"WHATSAPP-BAILEYS",token:NC().replace("-","").toUpperCase(),number:"",businessId:""}}),l=a.watch("integration"),c=async d=>{var p,f,h;try{const g={instanceName:d.name,integration:d.integration,token:d.token===""?null:d.token,number:d.number===""?null:d.number,businessId:d.businessId===""?null:d.businessId};await n(g),X.success(t("toast.instance.created")),s(!1),i(),e()}catch(g){console.error("Error:",g),X.error(`Error : ${(h=(f=(p=g==null?void 0:g.response)==null?void 0:p.data)==null?void 0:f.response)==null?void 0:h.message}`)}},i=()=>{a.reset({name:"",integration:"WHATSAPP-BAILEYS",token:NC().replace("-","").toLocaleUpperCase(),number:"",businessId:""})};return u.jsxs(Tt,{open:r,onOpenChange:s,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"default",size:"sm",children:[t("instance.button.create")," ",u.jsx(Ni,{size:"18"})]})}),u.jsxs(xt,{className:"sm:max-w-[650px]",onCloseAutoFocus:i,children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("instance.modal.title")})}),u.jsx(Tr,{...a,children:u.jsxs("form",{onSubmit:a.handleSubmit(c),className:"grid gap-4 py-4",children:[u.jsx(G,{required:!0,name:"name",label:t("instance.form.name"),children:u.jsx(K,{})}),u.jsx(Qt,{name:"integration",label:t("instance.form.integration.label"),options:o}),u.jsx(G,{required:!0,name:"token",label:t("instance.form.token"),children:u.jsx(K,{})}),u.jsx(G,{name:"number",label:t("instance.form.number"),children:u.jsx(K,{type:"tel"})}),l==="WHATSAPP-BUSINESS"&&u.jsx(G,{required:!0,name:"businessId",label:t("instance.form.businessId"),children:u.jsx(K,{})}),u.jsx(rn,{children:u.jsx(q,{type:"submit",children:t("instance.button.save")})})]})})]})]})}function GQ(){const{t:e}=ze(),[t,n]=v.useState(null),{deleteInstance:r,logout:s}=_g(),{data:o,refetch:a}=_V(),[l,c]=v.useState([]),[i,d]=v.useState("all"),[p,f]=v.useState(""),h=async()=>{await a()},g=async b=>{var y,w,S;n(null),c([...l,b]);try{try{await s(b)}catch(E){console.error("Error logout:",E)}await r(b),await new Promise(E=>setTimeout(E,1e3)),h()}catch(E){console.error("Error instance delete:",E),X.error(`Error : ${(S=(w=(y=E==null?void 0:E.response)==null?void 0:y.data)==null?void 0:w.response)==null?void 0:S.message}`)}finally{c(l.filter(E=>E!==b))}},m=v.useMemo(()=>{let b=o?[...o]:[];return i!=="all"&&(b=b.filter(y=>y.connectionStatus===i)),p!==""&&(b=b.filter(y=>y.name.toLowerCase().includes(p.toLowerCase()))),b},[o,p,i]),x=[{value:"all",label:e("status.all")},{value:"close",label:e("status.closed")},{value:"connecting",label:e("status.connecting")},{value:"open",label:e("status.open")}];return u.jsxs("div",{className:"my-4 px-4",children:[u.jsxs("div",{className:"flex w-full items-center justify-between",children:[u.jsx("h2",{className:"text-lg",children:e("dashboard.title")}),u.jsxs("div",{className:"flex gap-2",children:[u.jsx(q,{variant:"outline",size:"icon",children:u.jsx(fj,{onClick:h,size:"20"})}),u.jsx(WQ,{resetTable:h})]})]}),u.jsxs("div",{className:"my-4 flex items-center justify-between gap-3 px-4",children:[u.jsx("div",{className:"flex-1",children:u.jsx(K,{placeholder:e("dashboard.search"),value:p,onChange:b=>f(b.target.value)})}),u.jsxs(Eo,{children:[u.jsx(To,{asChild:!0,children:u.jsxs(q,{variant:"secondary",children:[e("dashboard.status")," ",u.jsx(M3,{size:"15"})]})}),u.jsx(ps,{children:x.map(b=>u.jsx(GR,{checked:i===b.value,onCheckedChange:y=>{y&&d(b.value)},children:b.label},b.value))})]})]}),u.jsx("main",{className:"grid gap-6 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4",children:m.length>0&&Array.isArray(o)&&o.map(b=>{var y,w;return u.jsxs(Ja,{children:[u.jsx(Qa,{children:u.jsxs(nd,{to:`/manager/instance/${b.id}/dashboard`,className:"flex w-full flex-row items-center justify-between gap-4",children:[u.jsx("h3",{className:"text-wrap font-semibold",children:b.name}),u.jsx(q,{variant:"ghost",size:"icon",children:u.jsx(Oi,{className:"card-icon",size:"20"})})]})}),u.jsxs(Za,{className:"flex-1 space-y-6",children:[u.jsx(GP,{token:b.token}),u.jsxs("div",{className:"flex w-full flex-wrap",children:[u.jsx("div",{className:"flex flex-1 gap-2",children:b.profileName&&u.jsxs(u.Fragment,{children:[u.jsx(Sg,{children:u.jsx(Cg,{src:b.profilePicUrl,alt:""})}),u.jsxs("div",{className:"space-y-1",children:[u.jsx("strong",{children:b.profileName}),u.jsx("p",{className:"text-sm text-muted-foreground",children:b.ownerJid&&b.ownerJid.split("@")[0]})]})]})}),u.jsxs("div",{className:"flex items-center justify-end gap-4 text-sm",children:[u.jsxs("div",{className:"flex flex-col items-center justify-center gap-1",children:[u.jsx(dj,{className:"text-muted-foreground",size:"20"}),u.jsx("span",{children:new Intl.NumberFormat("pt-BR").format(((y=b==null?void 0:b._count)==null?void 0:y.Contact)||0)})]}),u.jsxs("div",{className:"flex flex-col items-center justify-center gap-1",children:[u.jsx(ug,{className:"text-muted-foreground",size:"20"}),u.jsx("span",{children:new Intl.NumberFormat("pt-BR").format(((w=b==null?void 0:b._count)==null?void 0:w.Message)||0)})]})]})]})]}),u.jsxs(kg,{className:"justify-between",children:[u.jsx(WP,{status:b.connectionStatus}),u.jsx(q,{variant:"destructive",size:"sm",onClick:()=>n(b.name),disabled:l.includes(b.name),children:l.includes(b.name)?u.jsx("span",{children:e("button.deleting")}):u.jsx("span",{children:e("button.delete")})})]})]},b.id)})}),!!t&&u.jsx(Tt,{onOpenChange:()=>n(null),open:!0,children:u.jsxs(xt,{children:[u.jsx(TP,{}),u.jsx(wt,{children:e("modal.delete.title")}),u.jsx("p",{children:e("modal.delete.message",{instanceName:t})}),u.jsx(rn,{children:u.jsxs("div",{className:"flex items-center gap-4",children:[u.jsx(q,{onClick:()=>n(null),size:"sm",variant:"outline",children:e("button.cancel")}),u.jsx(q,{onClick:()=>g(t),variant:"destructive",children:e("button.delete")})]})})]})})]})}const{createElement:au,createContext:JQ,createRef:toe,forwardRef:uN,useCallback:ir,useContext:cN,useEffect:pi,useImperativeHandle:dN,useLayoutEffect:QQ,useMemo:ZQ,useRef:Yn,useState:Oc}=Nh,z1=Nh.useId,YQ=QQ,Hg=JQ(null);Hg.displayName="PanelGroupContext";const hi=YQ,XQ=typeof z1=="function"?z1:()=>null;let eZ=0;function Ow(e=null){const t=XQ(),n=Yn(e||t||null);return n.current===null&&(n.current=""+eZ++),e??n.current}function fN({children:e,className:t="",collapsedSize:n,collapsible:r,defaultSize:s,forwardedRef:o,id:a,maxSize:l,minSize:c,onCollapse:i,onExpand:d,onResize:p,order:f,style:h,tagName:g="div",...m}){const x=cN(Hg);if(x===null)throw Error("Panel components must be rendered within a PanelGroup container");const{collapsePanel:b,expandPanel:y,getPanelSize:w,getPanelStyle:S,groupId:E,isPanelCollapsed:C,reevaluatePanelConstraints:k,registerPanel:T,resizePanel:P,unregisterPanel:N}=x,U=Ow(a),I=Yn({callbacks:{onCollapse:i,onExpand:d,onResize:p},constraints:{collapsedSize:n,collapsible:r,defaultSize:s,maxSize:l,minSize:c},id:U,idIsFromProps:a!==void 0,order:f});Yn({didLogMissingDefaultSizeWarning:!1}),hi(()=>{const{callbacks:V,constraints:Q}=I.current,ee={...Q};I.current.id=U,I.current.idIsFromProps=a!==void 0,I.current.order=f,V.onCollapse=i,V.onExpand=d,V.onResize=p,Q.collapsedSize=n,Q.collapsible=r,Q.defaultSize=s,Q.maxSize=l,Q.minSize=c,(ee.collapsedSize!==Q.collapsedSize||ee.collapsible!==Q.collapsible||ee.maxSize!==Q.maxSize||ee.minSize!==Q.minSize)&&k(I.current,ee)}),hi(()=>{const V=I.current;return T(V),()=>{N(V)}},[f,U,T,N]),dN(o,()=>({collapse:()=>{b(I.current)},expand:V=>{y(I.current,V)},getId(){return U},getSize(){return w(I.current)},isCollapsed(){return C(I.current)},isExpanded(){return!C(I.current)},resize:V=>{P(I.current,V)}}),[b,y,w,C,U,P]);const Z=S(I.current,s);return au(g,{...m,children:e,className:t,id:a,style:{...Z,...h},"data-panel":"","data-panel-collapsible":r||void 0,"data-panel-group-id":E,"data-panel-id":U,"data-panel-size":parseFloat(""+Z.flexGrow).toFixed(1)})}const pN=uN((e,t)=>au(fN,{...e,forwardedRef:t}));fN.displayName="Panel";pN.displayName="forwardRef(Panel)";let bb=null,Xa=null;function tZ(e,t){if(t){const n=(t&yN)!==0,r=(t&bN)!==0,s=(t&xN)!==0,o=(t&wN)!==0;if(n)return s?"se-resize":o?"ne-resize":"e-resize";if(r)return s?"sw-resize":o?"nw-resize":"w-resize";if(s)return"s-resize";if(o)return"n-resize"}switch(e){case"horizontal":return"ew-resize";case"intersection":return"move";case"vertical":return"ns-resize"}}function nZ(){Xa!==null&&(document.head.removeChild(Xa),bb=null,Xa=null)}function hv(e,t){const n=tZ(e,t);bb!==n&&(bb=n,Xa===null&&(Xa=document.createElement("style"),document.head.appendChild(Xa)),Xa.innerHTML=`*{cursor: ${n}!important;}`)}function hN(e){return e.type==="keydown"}function gN(e){return e.type.startsWith("pointer")}function mN(e){return e.type.startsWith("mouse")}function Kg(e){if(gN(e)){if(e.isPrimary)return{x:e.clientX,y:e.clientY}}else if(mN(e))return{x:e.clientX,y:e.clientY};return{x:1/0,y:1/0}}function rZ(){if(typeof matchMedia=="function")return matchMedia("(pointer:coarse)").matches?"coarse":"fine"}function sZ(e,t,n){return e.x<t.x+t.width&&e.x+e.width>t.x&&e.y<t.y+t.height&&e.y+e.height>t.y}function oZ(e,t){if(e===t)throw new Error("Cannot compare node with itself");const n={a:H1(e),b:H1(t)};let r;for(;n.a.at(-1)===n.b.at(-1);)e=n.a.pop(),t=n.b.pop(),r=e;tt(r,"Stacking order can only be calculated for elements with a common ancestor");const s={a:V1(U1(n.a)),b:V1(U1(n.b))};if(s.a===s.b){const o=r.childNodes,a={a:n.a.at(-1),b:n.b.at(-1)};let l=o.length;for(;l--;){const c=o[l];if(c===a.a)return 1;if(c===a.b)return-1}}return Math.sign(s.a-s.b)}const aZ=/\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;function iZ(e){var t;const n=getComputedStyle((t=vN(e))!==null&&t!==void 0?t:e).display;return n==="flex"||n==="inline-flex"}function lZ(e){const t=getComputedStyle(e);return!!(t.position==="fixed"||t.zIndex!=="auto"&&(t.position!=="static"||iZ(e))||+t.opacity<1||"transform"in t&&t.transform!=="none"||"webkitTransform"in t&&t.webkitTransform!=="none"||"mixBlendMode"in t&&t.mixBlendMode!=="normal"||"filter"in t&&t.filter!=="none"||"webkitFilter"in t&&t.webkitFilter!=="none"||"isolation"in t&&t.isolation==="isolate"||aZ.test(t.willChange)||t.webkitOverflowScrolling==="touch")}function U1(e){let t=e.length;for(;t--;){const n=e[t];if(tt(n,"Missing node"),lZ(n))return n}return null}function V1(e){return e&&Number(getComputedStyle(e).zIndex)||0}function H1(e){const t=[];for(;e;)t.push(e),e=vN(e);return t}function vN(e){const{parentNode:t}=e;return t&&t instanceof ShadowRoot?t.host:t}const yN=1,bN=2,xN=4,wN=8,uZ=rZ()==="coarse";let is=[],_d=!1,Ho=new Map,qg=new Map;const jd=new Set;function cZ(e,t,n,r,s){var o;const{ownerDocument:a}=t,l={direction:n,element:t,hitAreaMargins:r,setResizeHandlerState:s},c=(o=Ho.get(a))!==null&&o!==void 0?o:0;return Ho.set(a,c+1),jd.add(l),kh(),function(){var d;qg.delete(e),jd.delete(l);const p=(d=Ho.get(a))!==null&&d!==void 0?d:1;if(Ho.set(a,p-1),kh(),p===1&&Ho.delete(a),is.includes(l)){const f=is.indexOf(l);f>=0&&is.splice(f,1),Iw()}}}function K1(e){const{target:t}=e,{x:n,y:r}=Kg(e);_d=!0,Nw({target:t,x:n,y:r}),kh(),is.length>0&&(_h("down",e),e.preventDefault(),e.stopPropagation())}function nc(e){const{x:t,y:n}=Kg(e);if(e.buttons===0&&(_d=!1,_h("up",e)),!_d){const{target:r}=e;Nw({target:r,x:t,y:n})}_h("move",e),Iw(),is.length>0&&e.preventDefault()}function Zi(e){const{target:t}=e,{x:n,y:r}=Kg(e);qg.clear(),_d=!1,is.length>0&&e.preventDefault(),_h("up",e),Nw({target:t,x:n,y:r}),Iw(),kh()}function Nw({target:e,x:t,y:n}){is.splice(0);let r=null;e instanceof HTMLElement&&(r=e),jd.forEach(s=>{const{element:o,hitAreaMargins:a}=s,l=o.getBoundingClientRect(),{bottom:c,left:i,right:d,top:p}=l,f=uZ?a.coarse:a.fine;if(t>=i-f&&t<=d+f&&n>=p-f&&n<=c+f){if(r!==null&&o!==r&&!o.contains(r)&&!r.contains(o)&&oZ(r,o)>0){let g=r,m=!1;for(;g&&!g.contains(o);){if(sZ(g.getBoundingClientRect(),l)){m=!0;break}g=g.parentElement}if(m)return}is.push(s)}})}function gv(e,t){qg.set(e,t)}function Iw(){let e=!1,t=!1;is.forEach(r=>{const{direction:s}=r;s==="horizontal"?e=!0:t=!0});let n=0;qg.forEach(r=>{n|=r}),e&&t?hv("intersection",n):e?hv("horizontal",n):t?hv("vertical",n):nZ()}function kh(){Ho.forEach((e,t)=>{const{body:n}=t;n.removeEventListener("contextmenu",Zi),n.removeEventListener("pointerdown",K1),n.removeEventListener("pointerleave",nc),n.removeEventListener("pointermove",nc)}),window.removeEventListener("pointerup",Zi),window.removeEventListener("pointercancel",Zi),jd.size>0&&(_d?(is.length>0&&Ho.forEach((e,t)=>{const{body:n}=t;e>0&&(n.addEventListener("contextmenu",Zi),n.addEventListener("pointerleave",nc),n.addEventListener("pointermove",nc))}),window.addEventListener("pointerup",Zi),window.addEventListener("pointercancel",Zi)):Ho.forEach((e,t)=>{const{body:n}=t;e>0&&(n.addEventListener("pointerdown",K1,{capture:!0}),n.addEventListener("pointermove",nc))}))}function _h(e,t){jd.forEach(n=>{const{setResizeHandlerState:r}=n,s=is.includes(n);r(e,s,t)})}function tt(e,t){if(!e)throw console.error(t),Error(t)}const Dw=10;function Ri(e,t,n=Dw){return e.toFixed(n)===t.toFixed(n)?0:e>t?1:-1}function no(e,t,n=Dw){return Ri(e,t,n)===0}function dr(e,t,n){return Ri(e,t,n)===0}function dZ(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++){const s=e[r],o=t[r];if(!dr(s,o,n))return!1}return!0}function yl({panelConstraints:e,panelIndex:t,size:n}){const r=e[t];tt(r!=null,`Panel constraints not found for index ${t}`);let{collapsedSize:s=0,collapsible:o,maxSize:a=100,minSize:l=0}=r;if(Ri(n,l)<0)if(o){const c=(s+l)/2;Ri(n,c)<0?n=s:n=l}else n=l;return n=Math.min(a,n),n=parseFloat(n.toFixed(Dw)),n}function gc({delta:e,initialLayout:t,panelConstraints:n,pivotIndices:r,prevLayout:s,trigger:o}){if(dr(e,0))return t;const a=[...t],[l,c]=r;tt(l!=null,"Invalid first pivot index"),tt(c!=null,"Invalid second pivot index");let i=0;if(o==="keyboard"){{const p=e<0?c:l,f=n[p];tt(f,`Panel constraints not found for index ${p}`);const{collapsedSize:h=0,collapsible:g,minSize:m=0}=f;if(g){const x=t[p];if(tt(x!=null,`Previous layout not found for panel index ${p}`),dr(x,h)){const b=m-x;Ri(b,Math.abs(e))>0&&(e=e<0?0-b:b)}}}{const p=e<0?l:c,f=n[p];tt(f,`No panel constraints found for index ${p}`);const{collapsedSize:h=0,collapsible:g,minSize:m=0}=f;if(g){const x=t[p];if(tt(x!=null,`Previous layout not found for panel index ${p}`),dr(x,m)){const b=x-h;Ri(b,Math.abs(e))>0&&(e=e<0?0-b:b)}}}}{const p=e<0?1:-1;let f=e<0?c:l,h=0;for(;;){const m=t[f];tt(m!=null,`Previous layout not found for panel index ${f}`);const b=yl({panelConstraints:n,panelIndex:f,size:100})-m;if(h+=b,f+=p,f<0||f>=n.length)break}const g=Math.min(Math.abs(e),Math.abs(h));e=e<0?0-g:g}{let f=e<0?l:c;for(;f>=0&&f<n.length;){const h=Math.abs(e)-Math.abs(i),g=t[f];tt(g!=null,`Previous layout not found for panel index ${f}`);const m=g-h,x=yl({panelConstraints:n,panelIndex:f,size:m});if(!dr(g,x)&&(i+=g-x,a[f]=x,i.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3),void 0,{numeric:!0})>=0))break;e<0?f--:f++}}if(dZ(s,a))return s;{const p=e<0?c:l,f=t[p];tt(f!=null,`Previous layout not found for panel index ${p}`);const h=f+i,g=yl({panelConstraints:n,panelIndex:p,size:h});if(a[p]=g,!dr(g,h)){let m=h-g,b=e<0?c:l;for(;b>=0&&b<n.length;){const y=a[b];tt(y!=null,`Previous layout not found for panel index ${b}`);const w=y+m,S=yl({panelConstraints:n,panelIndex:b,size:w});if(dr(y,S)||(m-=S-y,a[b]=S),dr(m,0))break;e>0?b--:b++}}}const d=a.reduce((p,f)=>f+p,0);return dr(d,100)?a:s}function fZ({layout:e,panelsArray:t,pivotIndices:n}){let r=0,s=100,o=0,a=0;const l=n[0];tt(l!=null,"No pivot index found"),t.forEach((p,f)=>{const{constraints:h}=p,{maxSize:g=100,minSize:m=0}=h;f===l?(r=m,s=g):(o+=m,a+=g)});const c=Math.min(s,100-o),i=Math.max(r,100-a),d=e[l];return{valueMax:c,valueMin:i,valueNow:d}}function Rd(e,t=document){return Array.from(t.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`))}function SN(e,t,n=document){const s=Rd(e,n).findIndex(o=>o.getAttribute("data-panel-resize-handle-id")===t);return s??null}function CN(e,t,n){const r=SN(e,t,n);return r!=null?[r,r+1]:[-1,-1]}function EN(e,t=document){var n;if(t instanceof HTMLElement&&(t==null||(n=t.dataset)===null||n===void 0?void 0:n.panelGroupId)==e)return t;const r=t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);return r||null}function Wg(e,t=document){const n=t.querySelector(`[data-panel-resize-handle-id="${e}"]`);return n||null}function pZ(e,t,n,r=document){var s,o,a,l;const c=Wg(t,r),i=Rd(e,r),d=c?i.indexOf(c):-1,p=(s=(o=n[d])===null||o===void 0?void 0:o.id)!==null&&s!==void 0?s:null,f=(a=(l=n[d+1])===null||l===void 0?void 0:l.id)!==null&&a!==void 0?a:null;return[p,f]}function hZ({committedValuesRef:e,eagerValuesRef:t,groupId:n,layout:r,panelDataArray:s,panelGroupElement:o,setLayout:a}){Yn({didWarnAboutMissingResizeHandle:!1}),hi(()=>{if(!o)return;const l=Rd(n,o);for(let c=0;c<s.length-1;c++){const{valueMax:i,valueMin:d,valueNow:p}=fZ({layout:r,panelsArray:s,pivotIndices:[c,c+1]}),f=l[c];if(f!=null){const h=s[c];tt(h,`No panel data found for index "${c}"`),f.setAttribute("aria-controls",h.id),f.setAttribute("aria-valuemax",""+Math.round(i)),f.setAttribute("aria-valuemin",""+Math.round(d)),f.setAttribute("aria-valuenow",p!=null?""+Math.round(p):"")}}return()=>{l.forEach((c,i)=>{c.removeAttribute("aria-controls"),c.removeAttribute("aria-valuemax"),c.removeAttribute("aria-valuemin"),c.removeAttribute("aria-valuenow")})}},[n,r,s,o]),pi(()=>{if(!o)return;const l=t.current;tt(l,"Eager values not found");const{panelDataArray:c}=l,i=EN(n,o);tt(i!=null,`No group found for id "${n}"`);const d=Rd(n,o);tt(d,`No resize handles found for group id "${n}"`);const p=d.map(f=>{const h=f.getAttribute("data-panel-resize-handle-id");tt(h,"Resize handle element has no handle id attribute");const[g,m]=pZ(n,h,c,o);if(g==null||m==null)return()=>{};const x=b=>{if(!b.defaultPrevented)switch(b.key){case"Enter":{b.preventDefault();const y=c.findIndex(w=>w.id===g);if(y>=0){const w=c[y];tt(w,`No panel data found for index ${y}`);const S=r[y],{collapsedSize:E=0,collapsible:C,minSize:k=0}=w.constraints;if(S!=null&&C){const T=gc({delta:dr(S,E)?k-E:E-S,initialLayout:r,panelConstraints:c.map(P=>P.constraints),pivotIndices:CN(n,h,o),prevLayout:r,trigger:"keyboard"});r!==T&&a(T)}}break}}};return f.addEventListener("keydown",x),()=>{f.removeEventListener("keydown",x)}});return()=>{p.forEach(f=>f())}},[o,e,t,n,r,s,a])}function q1(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function TN(e,t){const n=e==="horizontal",{x:r,y:s}=Kg(t);return n?r:s}function gZ(e,t,n,r,s){const o=n==="horizontal",a=Wg(t,s);tt(a,`No resize handle element found for id "${t}"`);const l=a.getAttribute("data-panel-group-id");tt(l,"Resize handle element has no group id attribute");let{initialCursorPosition:c}=r;const i=TN(n,e),d=EN(l,s);tt(d,`No group element found for id "${l}"`);const p=d.getBoundingClientRect(),f=o?p.width:p.height;return(i-c)/f*100}function mZ(e,t,n,r,s,o){if(hN(e)){const a=n==="horizontal";let l=0;e.shiftKey?l=100:s!=null?l=s:l=10;let c=0;switch(e.key){case"ArrowDown":c=a?0:l;break;case"ArrowLeft":c=a?-l:0;break;case"ArrowRight":c=a?l:0;break;case"ArrowUp":c=a?0:-l;break;case"End":c=100;break;case"Home":c=-100;break}return c}else return r==null?0:gZ(e,t,n,r,o)}function vZ({panelDataArray:e}){const t=Array(e.length),n=e.map(o=>o.constraints);let r=0,s=100;for(let o=0;o<e.length;o++){const a=n[o];tt(a,`Panel constraints not found for index ${o}`);const{defaultSize:l}=a;l!=null&&(r++,t[o]=l,s-=l)}for(let o=0;o<e.length;o++){const a=n[o];tt(a,`Panel constraints not found for index ${o}`);const{defaultSize:l}=a;if(l!=null)continue;const c=e.length-r,i=s/c;r++,t[o]=i,s-=i}return t}function Yi(e,t,n){t.forEach((r,s)=>{const o=e[s];tt(o,`Panel data not found for index ${s}`);const{callbacks:a,constraints:l,id:c}=o,{collapsedSize:i=0,collapsible:d}=l,p=n[c];if(p==null||r!==p){n[c]=r;const{onCollapse:f,onExpand:h,onResize:g}=a;g&&g(r,p),d&&(f||h)&&(h&&(p==null||no(p,i))&&!no(r,i)&&h(),f&&(p==null||!no(p,i))&&no(r,i)&&f())}})}function Vf(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!=t[n])return!1;return!0}function yZ({defaultSize:e,dragState:t,layout:n,panelData:r,panelIndex:s,precision:o=3}){const a=n[s];let l;return a==null?l=e!=null?e.toPrecision(o):"1":r.length===1?l="1":l=a.toPrecision(o),{flexBasis:0,flexGrow:l,flexShrink:1,overflow:"hidden",pointerEvents:t!==null?"none":void 0}}function bZ(e,t=10){let n=null;return(...s)=>{n!==null&&clearTimeout(n),n=setTimeout(()=>{e(...s)},t)}}function W1(e){try{if(typeof localStorage<"u")e.getItem=t=>localStorage.getItem(t),e.setItem=(t,n)=>{localStorage.setItem(t,n)};else throw new Error("localStorage not supported in this environment")}catch(t){console.error(t),e.getItem=()=>null,e.setItem=()=>{}}}function kN(e){return`react-resizable-panels:${e}`}function _N(e){return e.map(t=>{const{constraints:n,id:r,idIsFromProps:s,order:o}=t;return s?r:o?`${o}:${JSON.stringify(n)}`:JSON.stringify(n)}).sort((t,n)=>t.localeCompare(n)).join(",")}function jN(e,t){try{const n=kN(e),r=t.getItem(n);if(r){const s=JSON.parse(r);if(typeof s=="object"&&s!=null)return s}}catch{}return null}function xZ(e,t,n){var r,s;const o=(r=jN(e,n))!==null&&r!==void 0?r:{},a=_N(t);return(s=o[a])!==null&&s!==void 0?s:null}function wZ(e,t,n,r,s){var o;const a=kN(e),l=_N(t),c=(o=jN(e,s))!==null&&o!==void 0?o:{};c[l]={expandToSizes:Object.fromEntries(n.entries()),layout:r};try{s.setItem(a,JSON.stringify(c))}catch(i){console.error(i)}}function G1({layout:e,panelConstraints:t}){const n=[...e],r=n.reduce((o,a)=>o+a,0);if(n.length!==t.length)throw Error(`Invalid ${t.length} panel layout: ${n.map(o=>`${o}%`).join(", ")}`);if(!dr(r,100))for(let o=0;o<t.length;o++){const a=n[o];tt(a!=null,`No layout data found for index ${o}`);const l=100/r*a;n[o]=l}let s=0;for(let o=0;o<t.length;o++){const a=n[o];tt(a!=null,`No layout data found for index ${o}`);const l=yl({panelConstraints:t,panelIndex:o,size:a});a!=l&&(s+=a-l,n[o]=l)}if(!dr(s,0))for(let o=0;o<t.length;o++){const a=n[o];tt(a!=null,`No layout data found for index ${o}`);const l=a+s,c=yl({panelConstraints:t,panelIndex:o,size:l});if(a!==c&&(s-=c-a,n[o]=c,dr(s,0)))break}return n}const SZ=100,mc={getItem:e=>(W1(mc),mc.getItem(e)),setItem:(e,t)=>{W1(mc),mc.setItem(e,t)}},J1={};function RN({autoSaveId:e=null,children:t,className:n="",direction:r,forwardedRef:s,id:o=null,onLayout:a=null,keyboardResizeBy:l=null,storage:c=mc,style:i,tagName:d="div",...p}){const f=Ow(o),h=Yn(null),[g,m]=Oc(null),[x,b]=Oc([]),y=Yn({}),w=Yn(new Map),S=Yn(0),E=Yn({autoSaveId:e,direction:r,dragState:g,id:f,keyboardResizeBy:l,onLayout:a,storage:c}),C=Yn({layout:x,panelDataArray:[],panelDataArrayChanged:!1});Yn({didLogIdAndOrderWarning:!1,didLogPanelConstraintsWarning:!1,prevPanelIds:[]}),dN(s,()=>({getId:()=>E.current.id,getLayout:()=>{const{layout:z}=C.current;return z},setLayout:z=>{const{onLayout:se}=E.current,{layout:ne,panelDataArray:ie}=C.current,oe=G1({layout:z,panelConstraints:ie.map(J=>J.constraints)});q1(ne,oe)||(b(oe),C.current.layout=oe,se&&se(oe),Yi(ie,oe,y.current))}}),[]),hi(()=>{E.current.autoSaveId=e,E.current.direction=r,E.current.dragState=g,E.current.id=f,E.current.onLayout=a,E.current.storage=c}),hZ({committedValuesRef:E,eagerValuesRef:C,groupId:f,layout:x,panelDataArray:C.current.panelDataArray,setLayout:b,panelGroupElement:h.current}),pi(()=>{const{panelDataArray:z}=C.current;if(e){if(x.length===0||x.length!==z.length)return;let se=J1[e];se==null&&(se=bZ(wZ,SZ),J1[e]=se);const ne=[...z],ie=new Map(w.current);se(e,ne,ie,x,c)}},[e,x,c]),pi(()=>{});const k=ir(z=>{const{onLayout:se}=E.current,{layout:ne,panelDataArray:ie}=C.current;if(z.constraints.collapsible){const oe=ie.map(Le=>Le.constraints),{collapsedSize:J=0,panelSize:Ce,pivotIndices:Pe}=Fa(ie,z,ne);if(tt(Ce!=null,`Panel size not found for panel "${z.id}"`),!no(Ce,J)){w.current.set(z.id,Ce);const Me=nl(ie,z)===ie.length-1?Ce-J:J-Ce,me=gc({delta:Me,initialLayout:ne,panelConstraints:oe,pivotIndices:Pe,prevLayout:ne,trigger:"imperative-api"});Vf(ne,me)||(b(me),C.current.layout=me,se&&se(me),Yi(ie,me,y.current))}}},[]),T=ir((z,se)=>{const{onLayout:ne}=E.current,{layout:ie,panelDataArray:oe}=C.current;if(z.constraints.collapsible){const J=oe.map(rt=>rt.constraints),{collapsedSize:Ce=0,panelSize:Pe=0,minSize:Le=0,pivotIndices:Me}=Fa(oe,z,ie),me=se??Le;if(no(Pe,Ce)){const rt=w.current.get(z.id),It=rt!=null&&rt>=me?rt:me,Wt=nl(oe,z)===oe.length-1?Pe-It:It-Pe,an=gc({delta:Wt,initialLayout:ie,panelConstraints:J,pivotIndices:Me,prevLayout:ie,trigger:"imperative-api"});Vf(ie,an)||(b(an),C.current.layout=an,ne&&ne(an),Yi(oe,an,y.current))}}},[]),P=ir(z=>{const{layout:se,panelDataArray:ne}=C.current,{panelSize:ie}=Fa(ne,z,se);return tt(ie!=null,`Panel size not found for panel "${z.id}"`),ie},[]),N=ir((z,se)=>{const{panelDataArray:ne}=C.current,ie=nl(ne,z);return yZ({defaultSize:se,dragState:g,layout:x,panelData:ne,panelIndex:ie})},[g,x]),U=ir(z=>{const{layout:se,panelDataArray:ne}=C.current,{collapsedSize:ie=0,collapsible:oe,panelSize:J}=Fa(ne,z,se);return tt(J!=null,`Panel size not found for panel "${z.id}"`),oe===!0&&no(J,ie)},[]),I=ir(z=>{const{layout:se,panelDataArray:ne}=C.current,{collapsedSize:ie=0,collapsible:oe,panelSize:J}=Fa(ne,z,se);return tt(J!=null,`Panel size not found for panel "${z.id}"`),!oe||Ri(J,ie)>0},[]),Z=ir(z=>{const{panelDataArray:se}=C.current;se.push(z),se.sort((ne,ie)=>{const oe=ne.order,J=ie.order;return oe==null&&J==null?0:oe==null?-1:J==null?1:oe-J}),C.current.panelDataArrayChanged=!0},[]);hi(()=>{if(C.current.panelDataArrayChanged){C.current.panelDataArrayChanged=!1;const{autoSaveId:z,onLayout:se,storage:ne}=E.current,{layout:ie,panelDataArray:oe}=C.current;let J=null;if(z){const Pe=xZ(z,oe,ne);Pe&&(w.current=new Map(Object.entries(Pe.expandToSizes)),J=Pe.layout)}J==null&&(J=vZ({panelDataArray:oe}));const Ce=G1({layout:J,panelConstraints:oe.map(Pe=>Pe.constraints)});q1(ie,Ce)||(b(Ce),C.current.layout=Ce,se&&se(Ce),Yi(oe,Ce,y.current))}}),hi(()=>{const z=C.current;return()=>{z.layout=[]}},[]);const V=ir(z=>function(ne){ne.preventDefault();const ie=h.current;if(!ie)return()=>null;const{direction:oe,dragState:J,id:Ce,keyboardResizeBy:Pe,onLayout:Le}=E.current,{layout:Me,panelDataArray:me}=C.current,{initialLayout:rt}=J??{},It=CN(Ce,z,ie);let Zt=mZ(ne,z,oe,J,Pe,ie);const Wt=oe==="horizontal";document.dir==="rtl"&&Wt&&(Zt=-Zt);const an=me.map(B=>B.constraints),j=gc({delta:Zt,initialLayout:rt??Me,panelConstraints:an,pivotIndices:It,prevLayout:Me,trigger:hN(ne)?"keyboard":"mouse-or-touch"}),D=!Vf(Me,j);(gN(ne)||mN(ne))&&S.current!=Zt&&(S.current=Zt,D?gv(z,0):Wt?gv(z,Zt<0?yN:bN):gv(z,Zt<0?xN:wN)),D&&(b(j),C.current.layout=j,Le&&Le(j),Yi(me,j,y.current))},[]),Q=ir((z,se)=>{const{onLayout:ne}=E.current,{layout:ie,panelDataArray:oe}=C.current,J=oe.map(rt=>rt.constraints),{panelSize:Ce,pivotIndices:Pe}=Fa(oe,z,ie);tt(Ce!=null,`Panel size not found for panel "${z.id}"`);const Me=nl(oe,z)===oe.length-1?Ce-se:se-Ce,me=gc({delta:Me,initialLayout:ie,panelConstraints:J,pivotIndices:Pe,prevLayout:ie,trigger:"imperative-api"});Vf(ie,me)||(b(me),C.current.layout=me,ne&&ne(me),Yi(oe,me,y.current))},[]),ee=ir((z,se)=>{const{layout:ne,panelDataArray:ie}=C.current,{collapsedSize:oe=0,collapsible:J}=se,{collapsedSize:Ce=0,collapsible:Pe,maxSize:Le=100,minSize:Me=0}=z.constraints,{panelSize:me}=Fa(ie,z,ne);me!=null&&(J&&Pe&&no(me,oe)?no(oe,Ce)||Q(z,Ce):me<Me?Q(z,Me):me>Le&&Q(z,Le))},[Q]),W=ir((z,se)=>{const{direction:ne}=E.current,{layout:ie}=C.current;if(!h.current)return;const oe=Wg(z,h.current);tt(oe,`Drag handle element not found for id "${z}"`);const J=TN(ne,se);m({dragHandleId:z,dragHandleRect:oe.getBoundingClientRect(),initialCursorPosition:J,initialLayout:ie})},[]),F=ir(()=>{m(null)},[]),A=ir(z=>{const{panelDataArray:se}=C.current,ne=nl(se,z);ne>=0&&(se.splice(ne,1),delete y.current[z.id],C.current.panelDataArrayChanged=!0)},[]),Y=ZQ(()=>({collapsePanel:k,direction:r,dragState:g,expandPanel:T,getPanelSize:P,getPanelStyle:N,groupId:f,isPanelCollapsed:U,isPanelExpanded:I,reevaluatePanelConstraints:ee,registerPanel:Z,registerResizeHandle:V,resizePanel:Q,startDragging:W,stopDragging:F,unregisterPanel:A,panelGroupElement:h.current}),[k,g,r,T,P,N,f,U,I,ee,Z,V,Q,W,F,A]),de={display:"flex",flexDirection:r==="horizontal"?"row":"column",height:"100%",overflow:"hidden",width:"100%"};return au(Hg.Provider,{value:Y},au(d,{...p,children:t,className:n,id:o,ref:h,style:{...de,...i},"data-panel-group":"","data-panel-group-direction":r,"data-panel-group-id":f}))}const PN=uN((e,t)=>au(RN,{...e,forwardedRef:t}));RN.displayName="PanelGroup";PN.displayName="forwardRef(PanelGroup)";function nl(e,t){return e.findIndex(n=>n===t||n.id===t.id)}function Fa(e,t,n){const r=nl(e,t),o=r===e.length-1?[r-1,r]:[r,r+1],a=n[r];return{...t.constraints,panelSize:a,pivotIndices:o}}function CZ({disabled:e,handleId:t,resizeHandler:n,panelGroupElement:r}){pi(()=>{if(e||n==null||r==null)return;const s=Wg(t,r);if(s==null)return;const o=a=>{if(!a.defaultPrevented)switch(a.key){case"ArrowDown":case"ArrowLeft":case"ArrowRight":case"ArrowUp":case"End":case"Home":{a.preventDefault(),n(a);break}case"F6":{a.preventDefault();const l=s.getAttribute("data-panel-group-id");tt(l,`No group element found for id "${l}"`);const c=Rd(l,r),i=SN(l,t,r);tt(i!==null,`No resize element found for id "${t}"`);const d=a.shiftKey?i>0?i-1:c.length-1:i+1<c.length?i+1:0;c[d].focus();break}}};return s.addEventListener("keydown",o),()=>{s.removeEventListener("keydown",o)}},[r,e,t,n])}function MN({children:e=null,className:t="",disabled:n=!1,hitAreaMargins:r,id:s,onBlur:o,onDragging:a,onFocus:l,style:c={},tabIndex:i=0,tagName:d="div",...p}){var f,h;const g=Yn(null),m=Yn({onDragging:a});pi(()=>{m.current.onDragging=a});const x=cN(Hg);if(x===null)throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");const{direction:b,groupId:y,registerResizeHandle:w,startDragging:S,stopDragging:E,panelGroupElement:C}=x,k=Ow(s),[T,P]=Oc("inactive"),[N,U]=Oc(!1),[I,Z]=Oc(null),V=Yn({state:T});hi(()=>{V.current.state=T}),pi(()=>{if(n)Z(null);else{const F=w(k);Z(()=>F)}},[n,k,w]);const Q=(f=r==null?void 0:r.coarse)!==null&&f!==void 0?f:15,ee=(h=r==null?void 0:r.fine)!==null&&h!==void 0?h:5;return pi(()=>{if(n||I==null)return;const F=g.current;return tt(F,"Element ref not attached"),cZ(k,F,b,{coarse:Q,fine:ee},(Y,de,z)=>{if(de)switch(Y){case"down":{P("drag"),S(k,z);const{onDragging:se}=m.current;se&&se(!0);break}case"move":{const{state:se}=V.current;se!=="drag"&&P("hover"),I(z);break}case"up":{P("hover"),E();const{onDragging:se}=m.current;se&&se(!1);break}}else P("inactive")})},[Q,b,n,ee,w,k,I,S,E]),CZ({disabled:n,handleId:k,resizeHandler:I,panelGroupElement:C}),au(d,{...p,children:e,className:t,id:s,onBlur:()=>{U(!1),o==null||o()},onFocus:()=>{U(!0),l==null||l()},ref:g,role:"separator",style:{...{touchAction:"none",userSelect:"none"},...c},tabIndex:i,"data-panel-group-direction":b,"data-panel-group-id":y,"data-resize-handle":"","data-resize-handle-active":T==="drag"?"pointer":N?"keyboard":void 0,"data-resize-handle-state":T,"data-panel-resize-handle-enabled":!n,"data-panel-resize-handle-id":k})}MN.displayName="PanelResizeHandle";const Pu=({className:e,...t})=>u.jsx(PN,{className:ge("flex h-full w-full data-[panel-group-direction=vertical]:flex-col",e),...t}),Ur=pN,Mu=({withHandle:e,className:t,...n})=>u.jsx(MN,{className:ge("relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 after:bg-border focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",t),...n,children:e&&u.jsx("div",{className:"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border",children:u.jsx($3,{className:"h-2.5 w-2.5"})})});var Aw="Tabs",[EZ,noe]=Vr(Aw,[vg]),ON=vg(),[TZ,Fw]=EZ(Aw),NN=v.forwardRef((e,t)=>{const{__scopeTabs:n,value:r,onValueChange:s,defaultValue:o,orientation:a="horizontal",dir:l,activationMode:c="automatic",...i}=e,d=Gd(l),[p,f]=pa({prop:r,onChange:s,defaultProp:o});return u.jsx(TZ,{scope:n,baseId:os(),value:p,onValueChange:f,orientation:a,dir:d,activationMode:c,children:u.jsx(Ne.div,{dir:d,"data-orientation":a,...i,ref:t})})});NN.displayName=Aw;var IN="TabsList",DN=v.forwardRef((e,t)=>{const{__scopeTabs:n,loop:r=!0,...s}=e,o=Fw(IN,n),a=ON(n);return u.jsx(Gj,{asChild:!0,...a,orientation:o.orientation,dir:o.dir,loop:r,children:u.jsx(Ne.div,{role:"tablist","aria-orientation":o.orientation,...s,ref:t})})});DN.displayName=IN;var AN="TabsTrigger",FN=v.forwardRef((e,t)=>{const{__scopeTabs:n,value:r,disabled:s=!1,...o}=e,a=Fw(AN,n),l=ON(n),c=BN(a.baseId,r),i=zN(a.baseId,r),d=r===a.value;return u.jsx(Jj,{asChild:!0,...l,focusable:!s,active:d,children:u.jsx(Ne.button,{type:"button",role:"tab","aria-selected":d,"aria-controls":i,"data-state":d?"active":"inactive","data-disabled":s?"":void 0,disabled:s,id:c,...o,ref:t,onMouseDown:Se(e.onMouseDown,p=>{!s&&p.button===0&&p.ctrlKey===!1?a.onValueChange(r):p.preventDefault()}),onKeyDown:Se(e.onKeyDown,p=>{[" ","Enter"].includes(p.key)&&a.onValueChange(r)}),onFocus:Se(e.onFocus,()=>{const p=a.activationMode!=="manual";!d&&!s&&p&&a.onValueChange(r)})})})});FN.displayName=AN;var LN="TabsContent",$N=v.forwardRef((e,t)=>{const{__scopeTabs:n,value:r,forceMount:s,children:o,...a}=e,l=Fw(LN,n),c=BN(l.baseId,r),i=zN(l.baseId,r),d=r===l.value,p=v.useRef(d);return v.useEffect(()=>{const f=requestAnimationFrame(()=>p.current=!1);return()=>cancelAnimationFrame(f)},[]),u.jsx(or,{present:s||d,children:({present:f})=>u.jsx(Ne.div,{"data-state":d?"active":"inactive","data-orientation":l.orientation,role:"tabpanel","aria-labelledby":c,hidden:!f,id:i,tabIndex:0,...a,ref:t,style:{...e.style,animationDuration:p.current?"0s":void 0},children:f&&o})})});$N.displayName=LN;function BN(e,t){return`${e}-trigger-${t}`}function zN(e,t){return`${e}-content-${t}`}var kZ=NN,UN=DN,VN=FN,HN=$N;const _Z=kZ,KN=v.forwardRef(({className:e,...t},n)=>u.jsx(UN,{ref:n,className:ge("inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",e),...t}));KN.displayName=UN.displayName;const xb=v.forwardRef(({className:e,...t},n)=>u.jsx(VN,{ref:n,className:ge("inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",e),...t}));xb.displayName=VN.displayName;const wb=v.forwardRef(({className:e,...t},n)=>u.jsx(HN,{ref:n,className:ge("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",e),...t}));wb.displayName=HN.displayName;const jZ=e=>["chats","findChats",JSON.stringify(e)],RZ=async({instanceName:e})=>(await he.post(`/chat/findChats/${e}`,{where:{}})).data,PZ=e=>{const{instanceName:t,...n}=e;return lt({...n,queryKey:jZ({instanceName:t}),queryFn:()=>RZ({instanceName:t}),enabled:!!t})};function Ou(e){const t=o=>typeof window<"u"?window.matchMedia(o).matches:!1,[n,r]=v.useState(t(e));function s(){r(t(e))}return v.useEffect(()=>{const o=window.matchMedia(e);return s(),o.addListener?o.addListener(s):o.addEventListener("change",s),()=>{o.removeListener?o.removeListener(s):o.removeEventListener("change",s)}},[e]),n}const Ml=v.forwardRef(({className:e,...t},n)=>u.jsx("textarea",{className:ge("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",e),ref:n,...t}));Ml.displayName="Textarea";const MZ=e=>["chats","findChats",JSON.stringify(e)],OZ=async({instanceName:e,remoteJid:t})=>{const n=await he.post(`/chat/findChats/${e}`,{where:{remoteJid:t}});return Array.isArray(n.data)?n.data[0]:n.data},NZ=e=>{const{instanceName:t,remoteJid:n,...r}=e;return lt({...r,queryKey:MZ({instanceName:t,remoteJid:n}),queryFn:()=>OZ({instanceName:t,remoteJid:n}),enabled:!!t&&!!n})},IZ=e=>["chats","findMessages",JSON.stringify(e)],DZ=async({instanceName:e,remoteJid:t})=>{var r,s;const n=await he.post(`/chat/findMessages/${e}`,{where:{key:{remoteJid:t}}});return(s=(r=n.data)==null?void 0:r.messages)!=null&&s.records?n.data.messages.records:n.data},AZ=e=>{const{instanceName:t,remoteJid:n,...r}=e;return lt({...r,queryKey:IZ({instanceName:t,remoteJid:n}),queryFn:()=>DZ({instanceName:t,remoteJid:n}),enabled:!!t&&!!n})};function FZ({textareaRef:e,handleTextareaChange:t,textareaHeight:n,lastMessageRef:r,scrollToBottom:s}){const{instance:o}=nt(),{remoteJid:a}=So(),{data:l}=NZ({remoteJid:a,instanceName:o==null?void 0:o.name}),{data:c,isSuccess:i}=AZ({remoteJid:a,instanceName:o==null?void 0:o.name});v.useEffect(()=>{i&&c&&s()},[i,c,s]);const d=f=>u.jsx("div",{className:"bubble-right",children:u.jsx("div",{className:"flex items-start gap-4 self-end",children:u.jsx("div",{className:"grid gap-1",children:u.jsx("div",{className:"prose text-muted-foreground",children:u.jsx("div",{className:"bubble",children:JSON.stringify(f.message)})})})})}),p=f=>u.jsx("div",{className:"bubble-left",children:u.jsx("div",{className:"flex items-start gap-4",children:u.jsx("div",{className:"grid gap-1",children:u.jsx("div",{className:"prose text-muted-foreground",children:u.jsx("div",{className:"bubble",children:JSON.stringify(f.message)})})})})});return u.jsxs("div",{className:"flex min-h-screen flex-col",children:[u.jsx("div",{className:"sticky top-0 p-2",children:u.jsxs(nw,{children:[u.jsx(rw,{asChild:!0,children:u.jsxs(q,{variant:"ghost",className:"h-10 gap-1 rounded-xl px-3 text-lg data-[state=open]:bg-muted",children:[(l==null?void 0:l.pushName)||(l==null?void 0:l.remoteJid.split("@")[0]),u.jsx(lg,{className:"h-4 w-4 text-muted-foreground"})]})}),u.jsxs(ps,{align:"start",className:"max-w-[300px]",children:[u.jsxs(ft,{className:"items-start gap-2",children:[u.jsx(W3,{className:"mr-2 h-4 w-4 shrink-0 translate-y-1"}),u.jsxs("div",{children:[u.jsx("div",{className:"font-medium",children:"GPT-4"}),u.jsx("div",{className:"text-muted-foreground/80",children:"With DALL-E, browsing and analysis. Limit 40 messages / 3 hours"})]})]}),u.jsx(Pa,{}),u.jsxs(ft,{className:"items-start gap-2",children:[u.jsx(pj,{className:"mr-2 h-4 w-4 shrink-0 translate-y-1"}),u.jsxs("div",{children:[u.jsx("div",{className:"font-medium",children:"GPT-3"}),u.jsx("div",{className:"text-muted-foreground/80",children:"Great for everyday tasks"})]})]})]})]})}),u.jsxs("div",{className:"message-container mx-auto flex max-w-4xl flex-1 flex-col gap-8 overflow-y-auto px-4",children:[c==null?void 0:c.map(f=>f.key.fromMe?d(f):p(f)),u.jsx("div",{ref:r})]}),u.jsx("div",{className:"sticky bottom-0 mx-auto flex w-full max-w-2xl flex-col gap-1.5 bg-background px-4 py-2",children:u.jsxs("div",{className:"input-message relative",children:[u.jsxs(q,{type:"button",size:"icon",className:"absolute bottom-3 left-3 h-8 w-8 rounded-full bg-transparent text-white hover:bg-transparent",children:[u.jsx(q3,{className:"h-4 w-4 text-white"}),u.jsx("span",{className:"sr-only",children:"Anexar"})]}),u.jsx(Ml,{placeholder:"Enviar mensagem...",name:"message",id:"message",rows:1,ref:e,onChange:t,style:{height:n},className:"max-h-[240px] min-h-[48px] resize-none rounded-3xl border border-none p-4 pl-12 pr-16 shadow-sm"}),u.jsxs(q,{type:"submit",size:"icon",className:"absolute bottom-3 right-3 h-8 w-8 rounded-full",children:[u.jsx(j3,{className:"h-4 w-4"}),u.jsx("span",{className:"sr-only",children:"Enviar"})]})]})})]})}function Q1(){const e=Ou("(min-width: 768px)"),t=v.useRef(null),[n]=v.useState("auto"),r=v.useRef(null),{instance:s}=nt(),{data:o,isSuccess:a}=PZ({instanceName:s==null?void 0:s.name}),{instanceId:l,remoteJid:c}=So(),i=An(),d=v.useCallback(()=>{t.current&&t.current.scrollIntoView({})},[]),p=()=>{if(r.current){r.current.style.height="auto";const h=r.current.scrollHeight,m=parseInt(getComputedStyle(r.current).lineHeight)*10;r.current.style.height=`${Math.min(h,m)}px`}};v.useEffect(()=>{a&&d()},[a,d]);const f=h=>{i(`/manager/instance/${l}/chat/${h}`)};return u.jsxs(Pu,{direction:e?"horizontal":"vertical",children:[u.jsx(Ur,{defaultSize:20,children:u.jsxs("div",{className:"hidden flex-col gap-2 bg-background text-foreground md:flex",children:[u.jsx("div",{className:"sticky top-0 p-2",children:u.jsxs(q,{variant:"ghost",className:"w-full justify-start gap-2 px-2 text-left",children:[u.jsx("div",{className:"flex h-7 w-7 items-center justify-center rounded-full",children:u.jsx(ug,{className:"h-4 w-4"})}),u.jsx("div",{className:"grow overflow-hidden text-ellipsis whitespace-nowrap text-sm",children:"Chat"}),u.jsx(Ni,{className:"h-4 w-4"})]})}),u.jsxs(_Z,{defaultValue:"contacts",children:[u.jsxs(KN,{className:"tabs-chat",children:[u.jsx(xb,{value:"contacts",children:"Contatos"}),u.jsx(xb,{value:"groups",children:"Grupos"})]}),u.jsx(wb,{value:"contacts",children:u.jsx("div",{className:"flex-1 overflow-auto",children:u.jsxs("div",{className:"grid gap-1 p-2 text-foreground",children:[u.jsx("div",{className:"px-2 text-xs font-medium text-muted-foreground",children:"Contatos"}),o==null?void 0:o.map(h=>h.remoteJid.includes("@s.whatsapp.net")&&u.jsxs(nd,{to:"#",onClick:()=>f(h.remoteJid),className:`chat-item flex items-center overflow-hidden truncate whitespace-nowrap rounded-md border-b border-gray-600/50 p-2 text-sm transition-colors hover:bg-muted/50 ${c===h.remoteJid?"active":""}`,children:[u.jsx("span",{className:"chat-avatar mr-2",children:u.jsx("img",{src:h.profilePicUrl||"https://via.placeholder.com/150",alt:"Avatar",className:"h-8 w-8 rounded-full"})}),u.jsxs("div",{className:"min-w-0 flex-1",children:[u.jsx("span",{className:"chat-title block font-medium",children:h.pushName}),u.jsx("span",{className:"chat-description block text-xs text-gray-500",children:h.remoteJid.split("@")[0]})]})]},h.id))]})})}),u.jsx(wb,{value:"groups",children:u.jsx("div",{className:"flex-1 overflow-auto",children:u.jsx("div",{className:"grid gap-1 p-2 text-foreground",children:o==null?void 0:o.map(h=>h.remoteJid.includes("@g.us")&&u.jsxs(nd,{to:"#",onClick:()=>f(h.remoteJid),className:`chat-item flex items-center overflow-hidden truncate whitespace-nowrap rounded-md border-b border-gray-600/50 p-2 text-sm transition-colors hover:bg-muted/50 ${c===h.remoteJid?"active":""}`,children:[u.jsx("span",{className:"chat-avatar mr-2",children:u.jsx("img",{src:h.profilePicUrl||"https://via.placeholder.com/150",alt:"Avatar",className:"h-8 w-8 rounded-full"})}),u.jsxs("div",{className:"min-w-0 flex-1",children:[u.jsx("span",{className:"chat-title block font-medium",children:h.pushName}),u.jsx("span",{className:"chat-description block text-xs text-gray-500",children:h.remoteJid})]})]},h.id))})})})]})]})}),u.jsx(Mu,{withHandle:!0,className:"border border-black"}),u.jsx(Ur,{children:c&&u.jsx(FZ,{textareaRef:r,handleTextareaChange:p,textareaHeight:n,lastMessageRef:t,scrollToBottom:d})})]})}const LZ=e=>["chatwoot","fetchChatwoot",JSON.stringify(e)],$Z=async({instanceName:e,token:t})=>(await he.get(`/chatwoot/find/${e}`,{headers:{apiKey:t}})).data,BZ=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:LZ({instanceName:t,token:n}),queryFn:()=>$Z({instanceName:t,token:n}),enabled:!!t})},zZ=async({instanceName:e,token:t,data:n})=>(await he.post(`/chatwoot/set/${e}`,n,{headers:{apikey:t}})).data;function UZ(){return{createChatwoot:Ye(zZ,{invalidateKeys:[["chatwoot","fetchChatwoot"]]})}}const Hf=_.string().optional().transform(e=>e===""?void 0:e),VZ=_.object({enabled:_.boolean(),accountId:_.string(),token:_.string(),url:_.string(),signMsg:_.boolean().optional(),signDelimiter:Hf,nameInbox:Hf,organization:Hf,logo:Hf,reopenConversation:_.boolean().optional(),conversationPending:_.boolean().optional(),mergeBrazilContacts:_.boolean().optional(),importContacts:_.boolean().optional(),importMessages:_.boolean().optional(),daysLimitImportMessages:_.coerce.number().optional(),autoCreate:_.boolean(),ignoreJids:_.array(_.string()).default([])});function HZ(){const{t:e}=ze(),{instance:t}=nt(),[,n]=v.useState(!1),{createChatwoot:r}=UZ(),{data:s}=BZ({instanceName:t==null?void 0:t.name,token:t==null?void 0:t.token}),o=sn({resolver:on(VZ),defaultValues:{enabled:!0,accountId:"",token:"",url:"",signMsg:!0,signDelimiter:"\\n",nameInbox:"",organization:"",logo:"",reopenConversation:!0,conversationPending:!1,mergeBrazilContacts:!0,importContacts:!1,importMessages:!1,daysLimitImportMessages:7,autoCreate:!0,ignoreJids:[]}});v.useEffect(()=>{if(s){o.setValue("ignoreJids",s.ignoreJids||[]);const l={enabled:s.enabled,accountId:s.accountId,token:s.token,url:s.url,signMsg:s.signMsg||!1,signDelimiter:s.signDelimiter||"\\n",nameInbox:s.nameInbox||"",organization:s.organization||"",logo:s.logo||"",reopenConversation:s.reopenConversation||!1,conversationPending:s.conversationPending||!1,mergeBrazilContacts:s.mergeBrazilContacts||!1,importContacts:s.importContacts||!1,importMessages:s.importMessages||!1,daysLimitImportMessages:s.daysLimitImportMessages||7,autoCreate:s.autoCreate||!1,ignoreJids:s.ignoreJids};o.reset(l)}},[s,o]);const a=async l=>{if(!t)return;n(!0);const c={enabled:l.enabled,accountId:l.accountId,token:l.token,url:l.url,signMsg:l.signMsg||!1,signDelimiter:l.signDelimiter||"\\n",nameInbox:l.nameInbox||"",organization:l.organization||"",logo:l.logo||"",reopenConversation:l.reopenConversation||!1,conversationPending:l.conversationPending||!1,mergeBrazilContacts:l.mergeBrazilContacts||!1,importContacts:l.importContacts||!1,importMessages:l.importMessages||!1,daysLimitImportMessages:l.daysLimitImportMessages||7,autoCreate:l.autoCreate,ignoreJids:l.ignoreJids};await r({instanceName:t.name,token:t.token,data:c},{onSuccess:()=>{X.success(e("chatwoot.toast.success"))},onError:i=>{var d,p,f;console.error(e("chatwoot.toast.error"),i),A4(i)?X.error(`Error: ${(f=(p=(d=i==null?void 0:i.response)==null?void 0:d.data)==null?void 0:p.response)==null?void 0:f.message}`):X.error(e("chatwoot.toast.error"))},onSettled:()=>{n(!1)}})};return u.jsx(u.Fragment,{children:u.jsx(Na,{...o,children:u.jsxs("form",{onSubmit:o.handleSubmit(a),className:"w-full space-y-6",children:[u.jsxs("div",{children:[u.jsx("h3",{className:"mb-1 text-lg font-medium",children:e("chatwoot.title")}),u.jsx(Ra,{className:"my-4"}),u.jsxs("div",{className:"mx-4 space-y-2 divide-y [&>*]:px-4 [&>*]:py-2",children:[u.jsx(ke,{name:"enabled",label:e("chatwoot.form.enabled.label"),className:"w-full justify-between",helper:e("chatwoot.form.enabled.description")}),u.jsx(G,{name:"url",label:e("chatwoot.form.url.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"accountId",label:e("chatwoot.form.accountId.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"token",label:e("chatwoot.form.token.label"),children:u.jsx(K,{type:"password"})}),u.jsx(ke,{name:"signMsg",label:e("chatwoot.form.signMsg.label"),className:"w-full justify-between",helper:e("chatwoot.form.signMsg.description")}),u.jsx(G,{name:"signDelimiter",label:e("chatwoot.form.signDelimiter.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"nameInbox",label:e("chatwoot.form.nameInbox.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"organization",label:e("chatwoot.form.organization.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"logo",label:e("chatwoot.form.logo.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"conversationPending",label:e("chatwoot.form.conversationPending.label"),className:"w-full justify-between",helper:e("chatwoot.form.conversationPending.description")}),u.jsx(ke,{name:"reopenConversation",label:e("chatwoot.form.reopenConversation.label"),className:"w-full justify-between",helper:e("chatwoot.form.reopenConversation.description")}),u.jsx(ke,{name:"importContacts",label:e("chatwoot.form.importContacts.label"),className:"w-full justify-between",helper:e("chatwoot.form.importContacts.description")}),u.jsx(ke,{name:"importMessages",label:e("chatwoot.form.importMessages.label"),className:"w-full justify-between",helper:e("chatwoot.form.importMessages.description")}),u.jsx(G,{name:"daysLimitImportMessages",label:e("chatwoot.form.daysLimitImportMessages.label"),children:u.jsx(K,{type:"number"})}),u.jsx(Ru,{name:"ignoreJids",label:e("chatwoot.form.ignoreJids.label"),placeholder:e("chatwoot.form.ignoreJids.placeholder")}),u.jsx(ke,{name:"autoCreate",label:e("chatwoot.form.autoCreate.label"),className:"w-full justify-between",helper:e("chatwoot.form.autoCreate.description")})]})]}),u.jsx("div",{className:"mx-4 flex justify-end",children:u.jsx(q,{type:"submit",children:e("chatwoot.button.save")})})]})})})}var Gg={},qN={exports:{}},KZ="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",qZ=KZ,WZ=qZ;function WN(){}function GN(){}GN.resetWarningCache=WN;var GZ=function(){function e(r,s,o,a,l,c){if(c!==WZ){var i=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw i.name="Invariant Violation",i}}e.isRequired=e;function t(){return e}var n={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:GN,resetWarningCache:WN};return n.PropTypes=n,n};qN.exports=GZ();var JN=qN.exports,QN={L:1,M:0,Q:3,H:2},ZN={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8},JZ=ZN;function YN(e){this.mode=JZ.MODE_8BIT_BYTE,this.data=e}YN.prototype={getLength:function(e){return this.data.length},write:function(e){for(var t=0;t<this.data.length;t++)e.put(this.data.charCodeAt(t),8)}};var QZ=YN,Kf=QN;function Ps(e,t){this.totalCount=e,this.dataCount=t}Ps.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]];Ps.getRSBlocks=function(e,t){var n=Ps.getRsBlockTable(e,t);if(n==null)throw new Error("bad rs block @ typeNumber:"+e+"/errorCorrectLevel:"+t);for(var r=n.length/3,s=new Array,o=0;o<r;o++)for(var a=n[o*3+0],l=n[o*3+1],c=n[o*3+2],i=0;i<a;i++)s.push(new Ps(l,c));return s};Ps.getRsBlockTable=function(e,t){switch(t){case Kf.L:return Ps.RS_BLOCK_TABLE[(e-1)*4+0];case Kf.M:return Ps.RS_BLOCK_TABLE[(e-1)*4+1];case Kf.Q:return Ps.RS_BLOCK_TABLE[(e-1)*4+2];case Kf.H:return Ps.RS_BLOCK_TABLE[(e-1)*4+3];default:return}};var ZZ=Ps;function XN(){this.buffer=new Array,this.length=0}XN.prototype={get:function(e){var t=Math.floor(e/8);return(this.buffer[t]>>>7-e%8&1)==1},put:function(e,t){for(var n=0;n<t;n++)this.putBit((e>>>t-n-1&1)==1)},getLengthInBits:function(){return this.length},putBit:function(e){var t=Math.floor(this.length/8);this.buffer.length<=t&&this.buffer.push(0),e&&(this.buffer[t]|=128>>>this.length%8),this.length++}};var YZ=XN,Xr={glog:function(e){if(e<1)throw new Error("glog("+e+")");return Xr.LOG_TABLE[e]},gexp:function(e){for(;e<0;)e+=255;for(;e>=256;)e-=255;return Xr.EXP_TABLE[e]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)};for(var Cn=0;Cn<8;Cn++)Xr.EXP_TABLE[Cn]=1<<Cn;for(var Cn=8;Cn<256;Cn++)Xr.EXP_TABLE[Cn]=Xr.EXP_TABLE[Cn-4]^Xr.EXP_TABLE[Cn-5]^Xr.EXP_TABLE[Cn-6]^Xr.EXP_TABLE[Cn-8];for(var Cn=0;Cn<255;Cn++)Xr.LOG_TABLE[Xr.EXP_TABLE[Cn]]=Cn;var eI=Xr,La=eI;function Cp(e,t){if(e.length==null)throw new Error(e.length+"/"+t);for(var n=0;n<e.length&&e[n]==0;)n++;this.num=new Array(e.length-n+t);for(var r=0;r<e.length-n;r++)this.num[r]=e[r+n]}Cp.prototype={get:function(e){return this.num[e]},getLength:function(){return this.num.length},multiply:function(e){for(var t=new Array(this.getLength()+e.getLength()-1),n=0;n<this.getLength();n++)for(var r=0;r<e.getLength();r++)t[n+r]^=La.gexp(La.glog(this.get(n))+La.glog(e.get(r)));return new Cp(t,0)},mod:function(e){if(this.getLength()-e.getLength()<0)return this;for(var t=La.glog(this.get(0))-La.glog(e.get(0)),n=new Array(this.getLength()),r=0;r<this.getLength();r++)n[r]=this.get(r);for(var r=0;r<e.getLength();r++)n[r]^=La.gexp(La.glog(e.get(r))+t);return new Cp(n,0).mod(e)}};var tI=Cp,Rr=ZN,Z1=tI,XZ=eI,Do={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},wn={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(e){for(var t=e<<10;wn.getBCHDigit(t)-wn.getBCHDigit(wn.G15)>=0;)t^=wn.G15<<wn.getBCHDigit(t)-wn.getBCHDigit(wn.G15);return(e<<10|t)^wn.G15_MASK},getBCHTypeNumber:function(e){for(var t=e<<12;wn.getBCHDigit(t)-wn.getBCHDigit(wn.G18)>=0;)t^=wn.G18<<wn.getBCHDigit(t)-wn.getBCHDigit(wn.G18);return e<<12|t},getBCHDigit:function(e){for(var t=0;e!=0;)t++,e>>>=1;return t},getPatternPosition:function(e){return wn.PATTERN_POSITION_TABLE[e-1]},getMask:function(e,t,n){switch(e){case Do.PATTERN000:return(t+n)%2==0;case Do.PATTERN001:return t%2==0;case Do.PATTERN010:return n%3==0;case Do.PATTERN011:return(t+n)%3==0;case Do.PATTERN100:return(Math.floor(t/2)+Math.floor(n/3))%2==0;case Do.PATTERN101:return t*n%2+t*n%3==0;case Do.PATTERN110:return(t*n%2+t*n%3)%2==0;case Do.PATTERN111:return(t*n%3+(t+n)%2)%2==0;default:throw new Error("bad maskPattern:"+e)}},getErrorCorrectPolynomial:function(e){for(var t=new Z1([1],0),n=0;n<e;n++)t=t.multiply(new Z1([1,XZ.gexp(n)],0));return t},getLengthInBits:function(e,t){if(1<=t&&t<10)switch(e){case Rr.MODE_NUMBER:return 10;case Rr.MODE_ALPHA_NUM:return 9;case Rr.MODE_8BIT_BYTE:return 8;case Rr.MODE_KANJI:return 8;default:throw new Error("mode:"+e)}else if(t<27)switch(e){case Rr.MODE_NUMBER:return 12;case Rr.MODE_ALPHA_NUM:return 11;case Rr.MODE_8BIT_BYTE:return 16;case Rr.MODE_KANJI:return 10;default:throw new Error("mode:"+e)}else if(t<41)switch(e){case Rr.MODE_NUMBER:return 14;case Rr.MODE_ALPHA_NUM:return 13;case Rr.MODE_8BIT_BYTE:return 16;case Rr.MODE_KANJI:return 12;default:throw new Error("mode:"+e)}else throw new Error("type:"+t)},getLostPoint:function(e){for(var t=e.getModuleCount(),n=0,r=0;r<t;r++)for(var s=0;s<t;s++){for(var o=0,a=e.isDark(r,s),l=-1;l<=1;l++)if(!(r+l<0||t<=r+l))for(var c=-1;c<=1;c++)s+c<0||t<=s+c||l==0&&c==0||a==e.isDark(r+l,s+c)&&o++;o>5&&(n+=3+o-5)}for(var r=0;r<t-1;r++)for(var s=0;s<t-1;s++){var i=0;e.isDark(r,s)&&i++,e.isDark(r+1,s)&&i++,e.isDark(r,s+1)&&i++,e.isDark(r+1,s+1)&&i++,(i==0||i==4)&&(n+=3)}for(var r=0;r<t;r++)for(var s=0;s<t-6;s++)e.isDark(r,s)&&!e.isDark(r,s+1)&&e.isDark(r,s+2)&&e.isDark(r,s+3)&&e.isDark(r,s+4)&&!e.isDark(r,s+5)&&e.isDark(r,s+6)&&(n+=40);for(var s=0;s<t;s++)for(var r=0;r<t-6;r++)e.isDark(r,s)&&!e.isDark(r+1,s)&&e.isDark(r+2,s)&&e.isDark(r+3,s)&&e.isDark(r+4,s)&&!e.isDark(r+5,s)&&e.isDark(r+6,s)&&(n+=40);for(var d=0,s=0;s<t;s++)for(var r=0;r<t;r++)e.isDark(r,s)&&d++;var p=Math.abs(100*d/t/t-50)/5;return n+=p*10,n}},eY=wn,tY=QZ,nI=ZZ,rI=YZ,Da=eY,nY=tI;function Ns(e,t){this.typeNumber=e,this.errorCorrectLevel=t,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}var kr=Ns.prototype;kr.addData=function(e){var t=new tY(e);this.dataList.push(t),this.dataCache=null};kr.isDark=function(e,t){if(e<0||this.moduleCount<=e||t<0||this.moduleCount<=t)throw new Error(e+","+t);return this.modules[e][t]};kr.getModuleCount=function(){return this.moduleCount};kr.make=function(){if(this.typeNumber<1){var e=1;for(e=1;e<40;e++){for(var t=nI.getRSBlocks(e,this.errorCorrectLevel),n=new rI,r=0,s=0;s<t.length;s++)r+=t[s].dataCount;for(var s=0;s<this.dataList.length;s++){var o=this.dataList[s];n.put(o.mode,4),n.put(o.getLength(),Da.getLengthInBits(o.mode,e)),o.write(n)}if(n.getLengthInBits()<=r*8)break}this.typeNumber=e}this.makeImpl(!1,this.getBestMaskPattern())};kr.makeImpl=function(e,t){this.moduleCount=this.typeNumber*4+17,this.modules=new Array(this.moduleCount);for(var n=0;n<this.moduleCount;n++){this.modules[n]=new Array(this.moduleCount);for(var r=0;r<this.moduleCount;r++)this.modules[n][r]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(e,t),this.typeNumber>=7&&this.setupTypeNumber(e),this.dataCache==null&&(this.dataCache=Ns.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,t)};kr.setupPositionProbePattern=function(e,t){for(var n=-1;n<=7;n++)if(!(e+n<=-1||this.moduleCount<=e+n))for(var r=-1;r<=7;r++)t+r<=-1||this.moduleCount<=t+r||(0<=n&&n<=6&&(r==0||r==6)||0<=r&&r<=6&&(n==0||n==6)||2<=n&&n<=4&&2<=r&&r<=4?this.modules[e+n][t+r]=!0:this.modules[e+n][t+r]=!1)};kr.getBestMaskPattern=function(){for(var e=0,t=0,n=0;n<8;n++){this.makeImpl(!0,n);var r=Da.getLostPoint(this);(n==0||e>r)&&(e=r,t=n)}return t};kr.createMovieClip=function(e,t,n){var r=e.createEmptyMovieClip(t,n),s=1;this.make();for(var o=0;o<this.modules.length;o++)for(var a=o*s,l=0;l<this.modules[o].length;l++){var c=l*s,i=this.modules[o][l];i&&(r.beginFill(0,100),r.moveTo(c,a),r.lineTo(c+s,a),r.lineTo(c+s,a+s),r.lineTo(c,a+s),r.endFill())}return r};kr.setupTimingPattern=function(){for(var e=8;e<this.moduleCount-8;e++)this.modules[e][6]==null&&(this.modules[e][6]=e%2==0);for(var t=8;t<this.moduleCount-8;t++)this.modules[6][t]==null&&(this.modules[6][t]=t%2==0)};kr.setupPositionAdjustPattern=function(){for(var e=Da.getPatternPosition(this.typeNumber),t=0;t<e.length;t++)for(var n=0;n<e.length;n++){var r=e[t],s=e[n];if(this.modules[r][s]==null)for(var o=-2;o<=2;o++)for(var a=-2;a<=2;a++)o==-2||o==2||a==-2||a==2||o==0&&a==0?this.modules[r+o][s+a]=!0:this.modules[r+o][s+a]=!1}};kr.setupTypeNumber=function(e){for(var t=Da.getBCHTypeNumber(this.typeNumber),n=0;n<18;n++){var r=!e&&(t>>n&1)==1;this.modules[Math.floor(n/3)][n%3+this.moduleCount-8-3]=r}for(var n=0;n<18;n++){var r=!e&&(t>>n&1)==1;this.modules[n%3+this.moduleCount-8-3][Math.floor(n/3)]=r}};kr.setupTypeInfo=function(e,t){for(var n=this.errorCorrectLevel<<3|t,r=Da.getBCHTypeInfo(n),s=0;s<15;s++){var o=!e&&(r>>s&1)==1;s<6?this.modules[s][8]=o:s<8?this.modules[s+1][8]=o:this.modules[this.moduleCount-15+s][8]=o}for(var s=0;s<15;s++){var o=!e&&(r>>s&1)==1;s<8?this.modules[8][this.moduleCount-s-1]=o:s<9?this.modules[8][15-s-1+1]=o:this.modules[8][15-s-1]=o}this.modules[this.moduleCount-8][8]=!e};kr.mapData=function(e,t){for(var n=-1,r=this.moduleCount-1,s=7,o=0,a=this.moduleCount-1;a>0;a-=2)for(a==6&&a--;;){for(var l=0;l<2;l++)if(this.modules[r][a-l]==null){var c=!1;o<e.length&&(c=(e[o]>>>s&1)==1);var i=Da.getMask(t,r,a-l);i&&(c=!c),this.modules[r][a-l]=c,s--,s==-1&&(o++,s=7)}if(r+=n,r<0||this.moduleCount<=r){r-=n,n=-n;break}}};Ns.PAD0=236;Ns.PAD1=17;Ns.createData=function(e,t,n){for(var r=nI.getRSBlocks(e,t),s=new rI,o=0;o<n.length;o++){var a=n[o];s.put(a.mode,4),s.put(a.getLength(),Da.getLengthInBits(a.mode,e)),a.write(s)}for(var l=0,o=0;o<r.length;o++)l+=r[o].dataCount;if(s.getLengthInBits()>l*8)throw new Error("code length overflow. ("+s.getLengthInBits()+">"+l*8+")");for(s.getLengthInBits()+4<=l*8&&s.put(0,4);s.getLengthInBits()%8!=0;)s.putBit(!1);for(;!(s.getLengthInBits()>=l*8||(s.put(Ns.PAD0,8),s.getLengthInBits()>=l*8));)s.put(Ns.PAD1,8);return Ns.createBytes(s,r)};Ns.createBytes=function(e,t){for(var n=0,r=0,s=0,o=new Array(t.length),a=new Array(t.length),l=0;l<t.length;l++){var c=t[l].dataCount,i=t[l].totalCount-c;r=Math.max(r,c),s=Math.max(s,i),o[l]=new Array(c);for(var d=0;d<o[l].length;d++)o[l][d]=255&e.buffer[d+n];n+=c;var p=Da.getErrorCorrectPolynomial(i),f=new nY(o[l],p.getLength()-1),h=f.mod(p);a[l]=new Array(p.getLength()-1);for(var d=0;d<a[l].length;d++){var g=d+h.getLength()-a[l].length;a[l][d]=g>=0?h.get(g):0}}for(var m=0,d=0;d<t.length;d++)m+=t[d].totalCount;for(var x=new Array(m),b=0,d=0;d<r;d++)for(var l=0;l<t.length;l++)d<o[l].length&&(x[b++]=o[l][d]);for(var d=0;d<s;d++)for(var l=0;l<t.length;l++)d<a[l].length&&(x[b++]=a[l][d]);return x};var rY=Ns,Lw={};Object.defineProperty(Lw,"__esModule",{value:!0});var sY=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},oY=JN,Pr=oI(oY),sI=v,qf=oI(sI);function oI(e){return e&&e.__esModule?e:{default:e}}function aY(e,t){var n={};for(var r in e)t.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}var iY={bgColor:Pr.default.oneOfType([Pr.default.object,Pr.default.string]).isRequired,bgD:Pr.default.string.isRequired,fgColor:Pr.default.oneOfType([Pr.default.object,Pr.default.string]).isRequired,fgD:Pr.default.string.isRequired,size:Pr.default.number.isRequired,title:Pr.default.string,viewBoxSize:Pr.default.number.isRequired,xmlns:Pr.default.string},$w=(0,sI.forwardRef)(function(e,t){var n=e.bgColor,r=e.bgD,s=e.fgD,o=e.fgColor,a=e.size,l=e.title,c=e.viewBoxSize,i=e.xmlns,d=i===void 0?"http://www.w3.org/2000/svg":i,p=aY(e,["bgColor","bgD","fgD","fgColor","size","title","viewBoxSize","xmlns"]);return qf.default.createElement("svg",sY({},p,{height:a,ref:t,viewBox:"0 0 "+c+" "+c,width:a,xmlns:d}),l?qf.default.createElement("title",null,l):null,qf.default.createElement("path",{d:r,fill:n}),qf.default.createElement("path",{d:s,fill:o}))});$w.displayName="QRCodeSvg";$w.propTypes=iY;Lw.default=$w;Object.defineProperty(Gg,"__esModule",{value:!0});Gg.QRCode=void 0;var lY=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},uY=JN,Gs=nf(uY),cY=QN,dY=nf(cY),fY=rY,pY=nf(fY),aI=v,hY=nf(aI),gY=Lw,mY=nf(gY);function nf(e){return e&&e.__esModule?e:{default:e}}function vY(e,t){var n={};for(var r in e)t.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}var yY={bgColor:Gs.default.oneOfType([Gs.default.object,Gs.default.string]),fgColor:Gs.default.oneOfType([Gs.default.object,Gs.default.string]),level:Gs.default.string,size:Gs.default.number,value:Gs.default.string.isRequired},Jg=(0,aI.forwardRef)(function(e,t){var n=e.bgColor,r=n===void 0?"#FFFFFF":n,s=e.fgColor,o=s===void 0?"#000000":s,a=e.level,l=a===void 0?"L":a,c=e.size,i=c===void 0?256:c,d=e.value,p=vY(e,["bgColor","fgColor","level","size","value"]),f=new pY.default(-1,dY.default[l]);f.addData(d),f.make();var h=f.modules;return hY.default.createElement(mY.default,lY({},p,{bgColor:r,bgD:h.map(function(g,m){return g.map(function(x,b){return x?"":"M "+b+" "+m+" l 1 0 0 1 -1 0 Z"}).join(" ")}).join(" "),fgColor:o,fgD:h.map(function(g,m){return g.map(function(x,b){return x?"M "+b+" "+m+" l 1 0 0 1 -1 0 Z":""}).join(" ")}).join(" "),ref:t,size:i,viewBoxSize:h.length}))});Gg.QRCode=Jg;Jg.displayName="QRCode";Jg.propTypes=yY;var bY=Gg.default=Jg;const xY=ig("relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7 space-y-1 [&_strong]:text-foreground",{variants:{variant:{default:"border-zinc-500/20 bg-zinc-50/50 dark:border-zinc-500/30 dark:bg-zinc-500/10 text-zinc-900 dark:text-zinc-300 [&>svg]:text-zinc-400 dark:[&>svg]:text-zinc-300",destructive:"border-red-500/20 bg-red-50/50 dark:border-red-500/30 dark:bg-red-500/10 text-red-900 dark:text-red-200 [&>svg]:text-red-600 dark:[&>svg]:text-red-400/80",warning:"border-amber-500/20 bg-amber-50/50 dark:border-amber-500/30 dark:bg-amber-500/10 text-amber-900 dark:text-amber-200 [&>svg]:text-amber-500",info:"border-sky-500/20 bg-sky-50/50 dark:border-sky-500/30 dark:bg-sky-500/10 text-sky-900 dark:text-sky-200 [&>svg]:text-sky-500",success:"border-emerald-500/20 bg-emerald-50/50 dark:border-emerald-500/30 dark:bg-emerald-500/10 text-emerald-900 dark:text-emerald-200 [&>svg]:text-emerald-600 dark:[&>svg]:text-emerald-400/80"}},defaultVariants:{variant:"default"}}),iI=v.forwardRef(({className:e,variant:t,...n},r)=>u.jsx("div",{ref:r,role:"alert",className:ge(xY({variant:t}),e),...n}));iI.displayName="Alert";const lI=v.forwardRef(({className:e,...t},n)=>u.jsx("h5",{ref:n,className:ge("font-medium leading-none tracking-tight",e),...t}));lI.displayName="AlertTitle";const wY=v.forwardRef(({className:e,...t},n)=>u.jsx("div",{ref:n,className:ge("text-sm [&_p]:leading-relaxed",e),...t}));wY.displayName="AlertDescription";const wr=({size:e=45,className:t,...n})=>u.jsx("div",{style:{display:"flex",justifyContent:"center",alignItems:"center",height:"100vh"},children:u.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",width:e,height:e,...n,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round",className:ge("animate-spin",t),children:u.jsx("path",{d:"M21 12a9 9 0 1 1-6.219-8.56"})})});function SY(){const{t:e,i18n:t}=ze(),n=new Intl.NumberFormat(t.language),[r,s]=v.useState(null),[o,a]=v.useState(""),l=Fs(rs.TOKEN),{theme:c}=R_(),{connect:i,logout:d,restart:p}=_g(),{instance:f,reloadInstance:h}=nt(),g=async()=>{await h()},m=async E=>{try{await p(E),await h()}catch(C){console.error("Error:",C)}},x=async E=>{try{await d(E),await h()}catch(C){console.error("Error:",C)}},b=async(E,C)=>{try{if(s(null),!l){console.error("Token not found.");return}if(C){const k=await i({instanceName:E,token:l,number:f==null?void 0:f.number});a(k.pairingCode)}else{const k=await i({instanceName:E,token:l});s(k.code)}}catch(k){console.error("Error:",k)}},y=async()=>{s(null),a(""),await h()},w=v.useMemo(()=>{var E,C,k;return f?{contacts:((E=f._count)==null?void 0:E.Contact)||0,chats:((C=f._count)==null?void 0:C.Chat)||0,messages:((k=f._count)==null?void 0:k.Message)||0}:{contacts:0,chats:0,messages:0}},[f]),S=v.useMemo(()=>c==="dark"?"#fff":c==="light"?"#000":"#189d68",[c]);return f?u.jsxs("main",{className:"flex flex-col gap-8",children:[u.jsx("section",{children:u.jsxs(Ja,{children:[u.jsx(Qa,{children:u.jsxs("div",{className:"flex flex-wrap items-center justify-between gap-4",children:[u.jsx("h2",{className:"break-all text-lg font-semibold",children:f.name}),u.jsx(WP,{status:f.connectionStatus})]})}),u.jsxs(Za,{className:"flex flex-col items-start space-y-6",children:[u.jsx("div",{className:"flex w-full flex-1",children:u.jsx(GP,{token:f.token})}),f.profileName&&u.jsxs("div",{className:"flex flex-1 gap-2",children:[u.jsx(Sg,{children:u.jsx(Cg,{src:f.profilePicUrl,alt:""})}),u.jsxs("div",{className:"space-y-1",children:[u.jsx("strong",{children:f.profileName}),u.jsx("p",{className:"break-all text-sm text-muted-foreground",children:f.ownerJid})]})]}),f.connectionStatus!=="open"&&u.jsxs(iI,{variant:"warning",className:"flex flex-wrap items-center justify-between gap-3",children:[u.jsx(lI,{className:"text-lg font-bold tracking-wide",children:e("instance.dashboard.alert")}),u.jsxs(Tt,{children:[u.jsx(Nt,{onClick:()=>b(f.name,!1),asChild:!0,children:u.jsx(q,{variant:"warning",children:e("instance.dashboard.button.qrcode.label")})}),u.jsxs(xt,{onCloseAutoFocus:y,children:[u.jsx(wt,{children:e("instance.dashboard.button.qrcode.title")}),u.jsx("div",{className:"flex items-center justify-center",children:r&&u.jsx(bY,{value:r,size:256,bgColor:"transparent",fgColor:S,className:"rounded-sm"})})]})]}),f.number&&u.jsxs(Tt,{children:[u.jsx(Nt,{className:"connect-code-button",onClick:()=>b(f.name,!0),children:e("instance.dashboard.button.pairingCode.label")}),u.jsx(xt,{onCloseAutoFocus:y,children:u.jsx(wt,{children:u.jsx(Fi,{children:o?u.jsxs("div",{className:"py-3",children:[u.jsx("p",{className:"text-center",children:u.jsx("strong",{children:e("instance.dashboard.button.pairingCode.title")})}),u.jsxs("p",{className:"pairing-code text-center",children:[o.substring(0,4),"-",o.substring(4,8)]})]}):u.jsx(wr,{})})})})]})]})]}),u.jsxs(kg,{className:"flex flex-wrap items-center justify-end gap-3",children:[u.jsx(q,{variant:"outline",className:"refresh-button",size:"icon",onClick:g,children:u.jsx(fj,{size:"20"})}),u.jsx(q,{className:"action-button",variant:"secondary",onClick:()=>m(f.name),children:e("instance.dashboard.button.restart").toUpperCase()}),u.jsx(q,{variant:"destructive",onClick:()=>x(f.name),disabled:f.connectionStatus==="close",children:e("instance.dashboard.button.disconnect").toUpperCase()})]})]})}),u.jsxs("section",{className:"grid grid-cols-[repeat(auto-fit,_minmax(15rem,_1fr))] gap-6",children:[u.jsxs(Ja,{className:"instance-card",children:[u.jsx(Qa,{children:u.jsxs(jc,{className:"flex items-center gap-2",children:[u.jsx(dj,{size:"20"}),e("instance.dashboard.contacts")]})}),u.jsx(Za,{children:n.format(w.contacts)})]}),u.jsxs(Ja,{className:"instance-card",children:[u.jsx(Qa,{children:u.jsxs(jc,{className:"flex items-center gap-2",children:[u.jsx(J3,{size:"20"}),e("instance.dashboard.chats")]})}),u.jsx(Za,{children:n.format(w.chats)})]}),u.jsxs(Ja,{className:"instance-card",children:[u.jsx(Qa,{children:u.jsxs(jc,{className:"flex items-center gap-2",children:[u.jsx(ug,{size:"20"}),e("instance.dashboard.messages")]})}),u.jsx(Za,{children:n.format(w.messages)})]})]})]}):u.jsx(wr,{})}var CY="Separator",Y1="horizontal",EY=["horizontal","vertical"],uI=v.forwardRef((e,t)=>{const{decorative:n,orientation:r=Y1,...s}=e,o=TY(r)?r:Y1,l=n?{role:"none"}:{"aria-orientation":o==="vertical"?o:void 0,role:"separator"};return u.jsx(Ne.div,{"data-orientation":o,...l,...s,ref:t})});uI.displayName=CY;function TY(e){return EY.includes(e)}var cI=uI;const $t=v.forwardRef(({className:e,orientation:t="horizontal",decorative:n=!0,...r},s)=>u.jsx(cI,{ref:s,decorative:n,orientation:t,className:ge("shrink-0 bg-border",t==="horizontal"?"h-[1px] w-full":"h-full w-[1px]",e),...r}));$t.displayName=cI.displayName;const kY=e=>["dify","fetchDify",JSON.stringify(e)],_Y=async({instanceName:e,token:t})=>(await he.get(`/dify/find/${e}`,{headers:{apikey:t}})).data,dI=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:kY({instanceName:t,token:n}),queryFn:()=>_Y({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},jY=async({instanceName:e,token:t,data:n})=>(await he.post(`/dify/create/${e}`,n,{headers:{apikey:t}})).data,RY=async({instanceName:e,difyId:t,data:n})=>(await he.put(`/dify/update/${t}/${e}`,n)).data,PY=async({instanceName:e,difyId:t})=>(await he.delete(`/dify/delete/${t}/${e}`)).data,MY=async({instanceName:e,token:t,data:n})=>(await he.post(`/dify/settings/${e}`,n,{headers:{apikey:t}})).data,OY=async({instanceName:e,token:t,remoteJid:n,status:r})=>(await he.post(`/dify/changeStatus/${e}`,{remoteJid:n,status:r},{headers:{apikey:t}})).data;function Qg(){const e=Ye(MY,{invalidateKeys:[["dify","fetchDefaultSettings"]]}),t=Ye(OY,{invalidateKeys:[["dify","getDify"],["dify","fetchSessions"]]}),n=Ye(PY,{invalidateKeys:[["dify","getDify"],["dify","fetchDify"],["dify","fetchSessions"]]}),r=Ye(RY,{invalidateKeys:[["dify","getDify"],["dify","fetchDify"],["dify","fetchSessions"]]}),s=Ye(jY,{invalidateKeys:[["dify","fetchDify"]]});return{setDefaultSettingsDify:e,changeStatusDify:t,deleteDify:n,updateDify:r,createDify:s}}const NY=e=>["dify","fetchDefaultSettings",JSON.stringify(e)],IY=async({instanceName:e,token:t})=>(await he.get(`/dify/fetchSettings/${e}`,{headers:{apikey:t}})).data,DY=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:NY({instanceName:t,token:n}),queryFn:()=>IY({instanceName:t,token:n}),enabled:!!t})},AY=_.object({expire:_.string(),keywordFinish:_.string(),delayMessage:_.string(),unknownMessage:_.string(),listeningFromMe:_.boolean(),stopBotFromMe:_.boolean(),keepOpen:_.boolean(),debounceTime:_.string(),ignoreJids:_.array(_.string()).default([]),difyIdFallback:_.union([_.null(),_.string()]).optional(),splitMessages:_.boolean(),timePerChar:_.string()});function FY(){const{t:e}=ze(),{instance:t}=nt(),{setDefaultSettingsDify:n}=Qg(),[r,s]=v.useState(!1),{data:o,refetch:a}=dI({instanceName:t==null?void 0:t.name,token:t==null?void 0:t.token,enabled:r}),{data:l,refetch:c}=DY({instanceName:t==null?void 0:t.name,token:t==null?void 0:t.token}),i=sn({resolver:on(AY),defaultValues:{expire:"0",keywordFinish:e("dify.form.examples.keywordFinish"),delayMessage:"1000",unknownMessage:e("dify.form.examples.unknownMessage"),listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:"0",ignoreJids:[],difyIdFallback:void 0,splitMessages:!1,timePerChar:"0"}});v.useEffect(()=>{l&&i.reset({expire:l!=null&&l.expire?l.expire.toString():"0",keywordFinish:l.keywordFinish,delayMessage:l.delayMessage?l.delayMessage.toString():"0",unknownMessage:l.unknownMessage,listeningFromMe:l.listeningFromMe,stopBotFromMe:l.stopBotFromMe,keepOpen:l.keepOpen,debounceTime:l.debounceTime?l.debounceTime.toString():"0",ignoreJids:l.ignoreJids,difyIdFallback:l.difyIdFallback,splitMessages:l.splitMessages,timePerChar:l.timePerChar?l.timePerChar.toString():"0"})},[l]);const d=async f=>{var h,g,m;try{if(!t||!t.name)throw new Error("instance not found.");const x={expire:parseInt(f.expire),keywordFinish:f.keywordFinish,delayMessage:parseInt(f.delayMessage),unknownMessage:f.unknownMessage,listeningFromMe:f.listeningFromMe,stopBotFromMe:f.stopBotFromMe,keepOpen:f.keepOpen,debounceTime:parseInt(f.debounceTime),difyIdFallback:f.difyIdFallback||void 0,ignoreJids:f.ignoreJids,splitMessages:f.splitMessages,timePerChar:parseInt(f.timePerChar)};await n({instanceName:t.name,token:t.token,data:x}),X.success(e("dify.toast.defaultSettings.success"))}catch(x){console.error("Error:",x),X.error(`Error: ${(m=(g=(h=x==null?void 0:x.response)==null?void 0:h.data)==null?void 0:g.response)==null?void 0:m.message}`)}};function p(){c(),a()}return u.jsxs(Tt,{open:r,onOpenChange:s,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Oi,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:e("dify.defaultSettings")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",onCloseAutoFocus:p,children:[u.jsx(wt,{children:u.jsx(Ut,{children:e("dify.defaultSettings")})}),u.jsx(Tr,{...i,children:u.jsxs("form",{className:"w-full space-y-6",onSubmit:i.handleSubmit(d),children:[u.jsx("div",{children:u.jsxs("div",{className:"space-y-4",children:[u.jsx(Qt,{name:"difyIdFallback",label:e("dify.form.difyIdFallback.label"),options:(o==null?void 0:o.filter(f=>!!f.id).map(f=>({label:f.description,value:f.id})))??[]}),u.jsx(G,{name:"expire",label:e("dify.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:e("dify.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:e("dify.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:e("dify.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:e("dify.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:e("dify.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:e("dify.form.keepOpen.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:e("dify.form.debounceTime.label"),children:u.jsx(K,{type:"number"})}),u.jsx(ke,{name:"splitMessages",label:e("dify.form.splitMessages.label"),reverse:!0}),u.jsx(G,{name:"timePerChar",label:e("dify.form.timePerChar.label"),children:u.jsx(K,{type:"number"})}),u.jsx(Ru,{name:"ignoreJids",label:e("dify.form.ignoreJids.label"),placeholder:e("dify.form.ignoreJids.placeholder")})]})}),u.jsx(rn,{children:u.jsx(q,{type:"submit",children:e("dify.button.save")})})]})})]})]})}/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */function na(e,t){return typeof e=="function"?e(t):e}function Sr(e,t){return n=>{t.setState(r=>({...r,[e]:na(n,r[e])}))}}function Zg(e){return e instanceof Function}function LY(e){return Array.isArray(e)&&e.every(t=>typeof t=="number")}function fI(e,t){const n=[],r=s=>{s.forEach(o=>{n.push(o);const a=t(o);a!=null&&a.length&&r(a)})};return r(e),n}function De(e,t,n){let r=[],s;return o=>{let a;n.key&&n.debug&&(a=Date.now());const l=e(o);if(!(l.length!==r.length||l.some((d,p)=>r[p]!==d)))return s;r=l;let i;if(n.key&&n.debug&&(i=Date.now()),s=t(...l),n==null||n.onChange==null||n.onChange(s),n.key&&n.debug&&n!=null&&n.debug()){const d=Math.round((Date.now()-a)*100)/100,p=Math.round((Date.now()-i)*100)/100,f=p/16,h=(g,m)=>{for(g=String(g);g.length<m;)g=" "+g;return g};console.info(`%c⏱ ${h(p,5)} /${h(d,5)} ms`,`
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0,Math.min(120-120*f,120))}deg 100% 31%);`,n==null?void 0:n.key)}return s}}function Ae(e,t,n,r){return{debug:()=>{var s;return(s=e==null?void 0:e.debugAll)!=null?s:e[t]},key:!1,onChange:r}}function $Y(e,t,n,r){const s=()=>{var a;return(a=o.getValue())!=null?a:e.options.renderFallbackValue},o={id:`${t.id}_${n.id}`,row:t,column:n,getValue:()=>t.getValue(r),renderValue:s,getContext:De(()=>[e,n,t,o],(a,l,c,i)=>({table:a,column:l,row:c,cell:i,getValue:i.getValue,renderValue:i.renderValue}),Ae(e.options,"debugCells"))};return e._features.forEach(a=>{a.createCell==null||a.createCell(o,n,t,e)},{}),o}function BY(e,t,n,r){var s,o;const l={...e._getDefaultColumnDef(),...t},c=l.accessorKey;let i=(s=(o=l.id)!=null?o:c?typeof String.prototype.replaceAll=="function"?c.replaceAll(".","_"):c.replace(/\./g,"_"):void 0)!=null?s:typeof l.header=="string"?l.header:void 0,d;if(l.accessorFn?d=l.accessorFn:c&&(c.includes(".")?d=f=>{let h=f;for(const m of c.split(".")){var g;h=(g=h)==null?void 0:g[m]}return h}:d=f=>f[l.accessorKey]),!i)throw new Error;let p={id:`${String(i)}`,accessorFn:d,parent:r,depth:n,columnDef:l,columns:[],getFlatColumns:De(()=>[!0],()=>{var f;return[p,...(f=p.columns)==null?void 0:f.flatMap(h=>h.getFlatColumns())]},Ae(e.options,"debugColumns")),getLeafColumns:De(()=>[e._getOrderColumnsFn()],f=>{var h;if((h=p.columns)!=null&&h.length){let g=p.columns.flatMap(m=>m.getLeafColumns());return f(g)}return[p]},Ae(e.options,"debugColumns"))};for(const f of e._features)f.createColumn==null||f.createColumn(p,e);return p}const Mn="debugHeaders";function X1(e,t,n){var r;let o={id:(r=n.id)!=null?r:t.id,column:t,index:n.index,isPlaceholder:!!n.isPlaceholder,placeholderId:n.placeholderId,depth:n.depth,subHeaders:[],colSpan:0,rowSpan:0,headerGroup:null,getLeafHeaders:()=>{const a=[],l=c=>{c.subHeaders&&c.subHeaders.length&&c.subHeaders.map(l),a.push(c)};return l(o),a},getContext:()=>({table:e,header:o,column:t})};return e._features.forEach(a=>{a.createHeader==null||a.createHeader(o,e)}),o}const zY={createTable:e=>{e.getHeaderGroups=De(()=>[e.getAllColumns(),e.getVisibleLeafColumns(),e.getState().columnPinning.left,e.getState().columnPinning.right],(t,n,r,s)=>{var o,a;const l=(o=r==null?void 0:r.map(p=>n.find(f=>f.id===p)).filter(Boolean))!=null?o:[],c=(a=s==null?void 0:s.map(p=>n.find(f=>f.id===p)).filter(Boolean))!=null?a:[],i=n.filter(p=>!(r!=null&&r.includes(p.id))&&!(s!=null&&s.includes(p.id)));return Wf(t,[...l,...i,...c],e)},Ae(e.options,Mn)),e.getCenterHeaderGroups=De(()=>[e.getAllColumns(),e.getVisibleLeafColumns(),e.getState().columnPinning.left,e.getState().columnPinning.right],(t,n,r,s)=>(n=n.filter(o=>!(r!=null&&r.includes(o.id))&&!(s!=null&&s.includes(o.id))),Wf(t,n,e,"center")),Ae(e.options,Mn)),e.getLeftHeaderGroups=De(()=>[e.getAllColumns(),e.getVisibleLeafColumns(),e.getState().columnPinning.left],(t,n,r)=>{var s;const o=(s=r==null?void 0:r.map(a=>n.find(l=>l.id===a)).filter(Boolean))!=null?s:[];return Wf(t,o,e,"left")},Ae(e.options,Mn)),e.getRightHeaderGroups=De(()=>[e.getAllColumns(),e.getVisibleLeafColumns(),e.getState().columnPinning.right],(t,n,r)=>{var s;const o=(s=r==null?void 0:r.map(a=>n.find(l=>l.id===a)).filter(Boolean))!=null?s:[];return Wf(t,o,e,"right")},Ae(e.options,Mn)),e.getFooterGroups=De(()=>[e.getHeaderGroups()],t=>[...t].reverse(),Ae(e.options,Mn)),e.getLeftFooterGroups=De(()=>[e.getLeftHeaderGroups()],t=>[...t].reverse(),Ae(e.options,Mn)),e.getCenterFooterGroups=De(()=>[e.getCenterHeaderGroups()],t=>[...t].reverse(),Ae(e.options,Mn)),e.getRightFooterGroups=De(()=>[e.getRightHeaderGroups()],t=>[...t].reverse(),Ae(e.options,Mn)),e.getFlatHeaders=De(()=>[e.getHeaderGroups()],t=>t.map(n=>n.headers).flat(),Ae(e.options,Mn)),e.getLeftFlatHeaders=De(()=>[e.getLeftHeaderGroups()],t=>t.map(n=>n.headers).flat(),Ae(e.options,Mn)),e.getCenterFlatHeaders=De(()=>[e.getCenterHeaderGroups()],t=>t.map(n=>n.headers).flat(),Ae(e.options,Mn)),e.getRightFlatHeaders=De(()=>[e.getRightHeaderGroups()],t=>t.map(n=>n.headers).flat(),Ae(e.options,Mn)),e.getCenterLeafHeaders=De(()=>[e.getCenterFlatHeaders()],t=>t.filter(n=>{var r;return!((r=n.subHeaders)!=null&&r.length)}),Ae(e.options,Mn)),e.getLeftLeafHeaders=De(()=>[e.getLeftFlatHeaders()],t=>t.filter(n=>{var r;return!((r=n.subHeaders)!=null&&r.length)}),Ae(e.options,Mn)),e.getRightLeafHeaders=De(()=>[e.getRightFlatHeaders()],t=>t.filter(n=>{var r;return!((r=n.subHeaders)!=null&&r.length)}),Ae(e.options,Mn)),e.getLeafHeaders=De(()=>[e.getLeftHeaderGroups(),e.getCenterHeaderGroups(),e.getRightHeaderGroups()],(t,n,r)=>{var s,o,a,l,c,i;return[...(s=(o=t[0])==null?void 0:o.headers)!=null?s:[],...(a=(l=n[0])==null?void 0:l.headers)!=null?a:[],...(c=(i=r[0])==null?void 0:i.headers)!=null?c:[]].map(d=>d.getLeafHeaders()).flat()},Ae(e.options,Mn))}};function Wf(e,t,n,r){var s,o;let a=0;const l=function(f,h){h===void 0&&(h=1),a=Math.max(a,h),f.filter(g=>g.getIsVisible()).forEach(g=>{var m;(m=g.columns)!=null&&m.length&&l(g.columns,h+1)},0)};l(e);let c=[];const i=(f,h)=>{const g={depth:h,id:[r,`${h}`].filter(Boolean).join("_"),headers:[]},m=[];f.forEach(x=>{const b=[...m].reverse()[0],y=x.column.depth===g.depth;let w,S=!1;if(y&&x.column.parent?w=x.column.parent:(w=x.column,S=!0),b&&(b==null?void 0:b.column)===w)b.subHeaders.push(x);else{const E=X1(n,w,{id:[r,h,w.id,x==null?void 0:x.id].filter(Boolean).join("_"),isPlaceholder:S,placeholderId:S?`${m.filter(C=>C.column===w).length}`:void 0,depth:h,index:m.length});E.subHeaders.push(x),m.push(E)}g.headers.push(x),x.headerGroup=g}),c.push(g),h>0&&i(m,h-1)},d=t.map((f,h)=>X1(n,f,{depth:a,index:h}));i(d,a-1),c.reverse();const p=f=>f.filter(g=>g.column.getIsVisible()).map(g=>{let m=0,x=0,b=[0];g.subHeaders&&g.subHeaders.length?(b=[],p(g.subHeaders).forEach(w=>{let{colSpan:S,rowSpan:E}=w;m+=S,b.push(E)})):m=1;const y=Math.min(...b);return x=x+y,g.colSpan=m,g.rowSpan=x,{colSpan:m,rowSpan:x}});return p((s=(o=c[0])==null?void 0:o.headers)!=null?s:[]),c}const Yg=(e,t,n,r,s,o,a)=>{let l={id:t,index:r,original:n,depth:s,parentId:a,_valuesCache:{},_uniqueValuesCache:{},getValue:c=>{if(l._valuesCache.hasOwnProperty(c))return l._valuesCache[c];const i=e.getColumn(c);if(i!=null&&i.accessorFn)return l._valuesCache[c]=i.accessorFn(l.original,r),l._valuesCache[c]},getUniqueValues:c=>{if(l._uniqueValuesCache.hasOwnProperty(c))return l._uniqueValuesCache[c];const i=e.getColumn(c);if(i!=null&&i.accessorFn)return i.columnDef.getUniqueValues?(l._uniqueValuesCache[c]=i.columnDef.getUniqueValues(l.original,r),l._uniqueValuesCache[c]):(l._uniqueValuesCache[c]=[l.getValue(c)],l._uniqueValuesCache[c])},renderValue:c=>{var i;return(i=l.getValue(c))!=null?i:e.options.renderFallbackValue},subRows:[],getLeafRows:()=>fI(l.subRows,c=>c.subRows),getParentRow:()=>l.parentId?e.getRow(l.parentId,!0):void 0,getParentRows:()=>{let c=[],i=l;for(;;){const d=i.getParentRow();if(!d)break;c.push(d),i=d}return c.reverse()},getAllCells:De(()=>[e.getAllLeafColumns()],c=>c.map(i=>$Y(e,l,i,i.id)),Ae(e.options,"debugRows")),_getAllCellsByColumnId:De(()=>[l.getAllCells()],c=>c.reduce((i,d)=>(i[d.column.id]=d,i),{}),Ae(e.options,"debugRows"))};for(let c=0;c<e._features.length;c++){const i=e._features[c];i==null||i.createRow==null||i.createRow(l,e)}return l},UY={createColumn:(e,t)=>{e._getFacetedRowModel=t.options.getFacetedRowModel&&t.options.getFacetedRowModel(t,e.id),e.getFacetedRowModel=()=>e._getFacetedRowModel?e._getFacetedRowModel():t.getPreFilteredRowModel(),e._getFacetedUniqueValues=t.options.getFacetedUniqueValues&&t.options.getFacetedUniqueValues(t,e.id),e.getFacetedUniqueValues=()=>e._getFacetedUniqueValues?e._getFacetedUniqueValues():new Map,e._getFacetedMinMaxValues=t.options.getFacetedMinMaxValues&&t.options.getFacetedMinMaxValues(t,e.id),e.getFacetedMinMaxValues=()=>{if(e._getFacetedMinMaxValues)return e._getFacetedMinMaxValues()}}},pI=(e,t,n)=>{var r;const s=n.toLowerCase();return!!(!((r=e.getValue(t))==null||(r=r.toString())==null||(r=r.toLowerCase())==null)&&r.includes(s))};pI.autoRemove=e=>ls(e);const hI=(e,t,n)=>{var r;return!!(!((r=e.getValue(t))==null||(r=r.toString())==null)&&r.includes(n))};hI.autoRemove=e=>ls(e);const gI=(e,t,n)=>{var r;return((r=e.getValue(t))==null||(r=r.toString())==null?void 0:r.toLowerCase())===(n==null?void 0:n.toLowerCase())};gI.autoRemove=e=>ls(e);const mI=(e,t,n)=>{var r;return(r=e.getValue(t))==null?void 0:r.includes(n)};mI.autoRemove=e=>ls(e)||!(e!=null&&e.length);const vI=(e,t,n)=>!n.some(r=>{var s;return!((s=e.getValue(t))!=null&&s.includes(r))});vI.autoRemove=e=>ls(e)||!(e!=null&&e.length);const yI=(e,t,n)=>n.some(r=>{var s;return(s=e.getValue(t))==null?void 0:s.includes(r)});yI.autoRemove=e=>ls(e)||!(e!=null&&e.length);const bI=(e,t,n)=>e.getValue(t)===n;bI.autoRemove=e=>ls(e);const xI=(e,t,n)=>e.getValue(t)==n;xI.autoRemove=e=>ls(e);const Bw=(e,t,n)=>{let[r,s]=n;const o=e.getValue(t);return o>=r&&o<=s};Bw.resolveFilterValue=e=>{let[t,n]=e,r=typeof t!="number"?parseFloat(t):t,s=typeof n!="number"?parseFloat(n):n,o=t===null||Number.isNaN(r)?-1/0:r,a=n===null||Number.isNaN(s)?1/0:s;if(o>a){const l=o;o=a,a=l}return[o,a]};Bw.autoRemove=e=>ls(e)||ls(e[0])&&ls(e[1]);const Xs={includesString:pI,includesStringSensitive:hI,equalsString:gI,arrIncludes:mI,arrIncludesAll:vI,arrIncludesSome:yI,equals:bI,weakEquals:xI,inNumberRange:Bw};function ls(e){return e==null||e===""}const VY={getDefaultColumnDef:()=>({filterFn:"auto"}),getInitialState:e=>({columnFilters:[],...e}),getDefaultOptions:e=>({onColumnFiltersChange:Sr("columnFilters",e),filterFromLeafRows:!1,maxLeafRowFilterDepth:100}),createColumn:(e,t)=>{e.getAutoFilterFn=()=>{const n=t.getCoreRowModel().flatRows[0],r=n==null?void 0:n.getValue(e.id);return typeof r=="string"?Xs.includesString:typeof r=="number"?Xs.inNumberRange:typeof r=="boolean"||r!==null&&typeof r=="object"?Xs.equals:Array.isArray(r)?Xs.arrIncludes:Xs.weakEquals},e.getFilterFn=()=>{var n,r;return Zg(e.columnDef.filterFn)?e.columnDef.filterFn:e.columnDef.filterFn==="auto"?e.getAutoFilterFn():(n=(r=t.options.filterFns)==null?void 0:r[e.columnDef.filterFn])!=null?n:Xs[e.columnDef.filterFn]},e.getCanFilter=()=>{var n,r,s;return((n=e.columnDef.enableColumnFilter)!=null?n:!0)&&((r=t.options.enableColumnFilters)!=null?r:!0)&&((s=t.options.enableFilters)!=null?s:!0)&&!!e.accessorFn},e.getIsFiltered=()=>e.getFilterIndex()>-1,e.getFilterValue=()=>{var n;return(n=t.getState().columnFilters)==null||(n=n.find(r=>r.id===e.id))==null?void 0:n.value},e.getFilterIndex=()=>{var n,r;return(n=(r=t.getState().columnFilters)==null?void 0:r.findIndex(s=>s.id===e.id))!=null?n:-1},e.setFilterValue=n=>{t.setColumnFilters(r=>{const s=e.getFilterFn(),o=r==null?void 0:r.find(d=>d.id===e.id),a=na(n,o?o.value:void 0);if(eE(s,a,e)){var l;return(l=r==null?void 0:r.filter(d=>d.id!==e.id))!=null?l:[]}const c={id:e.id,value:a};if(o){var i;return(i=r==null?void 0:r.map(d=>d.id===e.id?c:d))!=null?i:[]}return r!=null&&r.length?[...r,c]:[c]})}},createRow:(e,t)=>{e.columnFilters={},e.columnFiltersMeta={}},createTable:e=>{e.setColumnFilters=t=>{const n=e.getAllLeafColumns(),r=s=>{var o;return(o=na(t,s))==null?void 0:o.filter(a=>{const l=n.find(c=>c.id===a.id);if(l){const c=l.getFilterFn();if(eE(c,a.value,l))return!1}return!0})};e.options.onColumnFiltersChange==null||e.options.onColumnFiltersChange(r)},e.resetColumnFilters=t=>{var n,r;e.setColumnFilters(t?[]:(n=(r=e.initialState)==null?void 0:r.columnFilters)!=null?n:[])},e.getPreFilteredRowModel=()=>e.getCoreRowModel(),e.getFilteredRowModel=()=>(!e._getFilteredRowModel&&e.options.getFilteredRowModel&&(e._getFilteredRowModel=e.options.getFilteredRowModel(e)),e.options.manualFiltering||!e._getFilteredRowModel?e.getPreFilteredRowModel():e._getFilteredRowModel())}};function eE(e,t,n){return(e&&e.autoRemove?e.autoRemove(t,n):!1)||typeof t>"u"||typeof t=="string"&&!t}const HY=(e,t,n)=>n.reduce((r,s)=>{const o=s.getValue(e);return r+(typeof o=="number"?o:0)},0),KY=(e,t,n)=>{let r;return n.forEach(s=>{const o=s.getValue(e);o!=null&&(r>o||r===void 0&&o>=o)&&(r=o)}),r},qY=(e,t,n)=>{let r;return n.forEach(s=>{const o=s.getValue(e);o!=null&&(r<o||r===void 0&&o>=o)&&(r=o)}),r},WY=(e,t,n)=>{let r,s;return n.forEach(o=>{const a=o.getValue(e);a!=null&&(r===void 0?a>=a&&(r=s=a):(r>a&&(r=a),s<a&&(s=a)))}),[r,s]},GY=(e,t)=>{let n=0,r=0;if(t.forEach(s=>{let o=s.getValue(e);o!=null&&(o=+o)>=o&&(++n,r+=o)}),n)return r/n},JY=(e,t)=>{if(!t.length)return;const n=t.map(o=>o.getValue(e));if(!LY(n))return;if(n.length===1)return n[0];const r=Math.floor(n.length/2),s=n.sort((o,a)=>o-a);return n.length%2!==0?s[r]:(s[r-1]+s[r])/2},QY=(e,t)=>Array.from(new Set(t.map(n=>n.getValue(e))).values()),ZY=(e,t)=>new Set(t.map(n=>n.getValue(e))).size,YY=(e,t)=>t.length,mv={sum:HY,min:KY,max:qY,extent:WY,mean:GY,median:JY,unique:QY,uniqueCount:ZY,count:YY},XY={getDefaultColumnDef:()=>({aggregatedCell:e=>{var t,n;return(t=(n=e.getValue())==null||n.toString==null?void 0:n.toString())!=null?t:null},aggregationFn:"auto"}),getInitialState:e=>({grouping:[],...e}),getDefaultOptions:e=>({onGroupingChange:Sr("grouping",e),groupedColumnMode:"reorder"}),createColumn:(e,t)=>{e.toggleGrouping=()=>{t.setGrouping(n=>n!=null&&n.includes(e.id)?n.filter(r=>r!==e.id):[...n??[],e.id])},e.getCanGroup=()=>{var n,r;return((n=e.columnDef.enableGrouping)!=null?n:!0)&&((r=t.options.enableGrouping)!=null?r:!0)&&(!!e.accessorFn||!!e.columnDef.getGroupingValue)},e.getIsGrouped=()=>{var n;return(n=t.getState().grouping)==null?void 0:n.includes(e.id)},e.getGroupedIndex=()=>{var n;return(n=t.getState().grouping)==null?void 0:n.indexOf(e.id)},e.getToggleGroupingHandler=()=>{const n=e.getCanGroup();return()=>{n&&e.toggleGrouping()}},e.getAutoAggregationFn=()=>{const n=t.getCoreRowModel().flatRows[0],r=n==null?void 0:n.getValue(e.id);if(typeof r=="number")return mv.sum;if(Object.prototype.toString.call(r)==="[object Date]")return mv.extent},e.getAggregationFn=()=>{var n,r;if(!e)throw new Error;return Zg(e.columnDef.aggregationFn)?e.columnDef.aggregationFn:e.columnDef.aggregationFn==="auto"?e.getAutoAggregationFn():(n=(r=t.options.aggregationFns)==null?void 0:r[e.columnDef.aggregationFn])!=null?n:mv[e.columnDef.aggregationFn]}},createTable:e=>{e.setGrouping=t=>e.options.onGroupingChange==null?void 0:e.options.onGroupingChange(t),e.resetGrouping=t=>{var n,r;e.setGrouping(t?[]:(n=(r=e.initialState)==null?void 0:r.grouping)!=null?n:[])},e.getPreGroupedRowModel=()=>e.getFilteredRowModel(),e.getGroupedRowModel=()=>(!e._getGroupedRowModel&&e.options.getGroupedRowModel&&(e._getGroupedRowModel=e.options.getGroupedRowModel(e)),e.options.manualGrouping||!e._getGroupedRowModel?e.getPreGroupedRowModel():e._getGroupedRowModel())},createRow:(e,t)=>{e.getIsGrouped=()=>!!e.groupingColumnId,e.getGroupingValue=n=>{if(e._groupingValuesCache.hasOwnProperty(n))return e._groupingValuesCache[n];const r=t.getColumn(n);return r!=null&&r.columnDef.getGroupingValue?(e._groupingValuesCache[n]=r.columnDef.getGroupingValue(e.original),e._groupingValuesCache[n]):e.getValue(n)},e._groupingValuesCache={}},createCell:(e,t,n,r)=>{e.getIsGrouped=()=>t.getIsGrouped()&&t.id===n.groupingColumnId,e.getIsPlaceholder=()=>!e.getIsGrouped()&&t.getIsGrouped(),e.getIsAggregated=()=>{var s;return!e.getIsGrouped()&&!e.getIsPlaceholder()&&!!((s=n.subRows)!=null&&s.length)}}};function eX(e,t,n){if(!(t!=null&&t.length)||!n)return e;const r=e.filter(o=>!t.includes(o.id));return n==="remove"?r:[...t.map(o=>e.find(a=>a.id===o)).filter(Boolean),...r]}const tX={getInitialState:e=>({columnOrder:[],...e}),getDefaultOptions:e=>({onColumnOrderChange:Sr("columnOrder",e)}),createColumn:(e,t)=>{e.getIndex=De(n=>[Nc(t,n)],n=>n.findIndex(r=>r.id===e.id),Ae(t.options,"debugColumns")),e.getIsFirstColumn=n=>{var r;return((r=Nc(t,n)[0])==null?void 0:r.id)===e.id},e.getIsLastColumn=n=>{var r;const s=Nc(t,n);return((r=s[s.length-1])==null?void 0:r.id)===e.id}},createTable:e=>{e.setColumnOrder=t=>e.options.onColumnOrderChange==null?void 0:e.options.onColumnOrderChange(t),e.resetColumnOrder=t=>{var n;e.setColumnOrder(t?[]:(n=e.initialState.columnOrder)!=null?n:[])},e._getOrderColumnsFn=De(()=>[e.getState().columnOrder,e.getState().grouping,e.options.groupedColumnMode],(t,n,r)=>s=>{let o=[];if(!(t!=null&&t.length))o=s;else{const a=[...t],l=[...s];for(;l.length&&a.length;){const c=a.shift(),i=l.findIndex(d=>d.id===c);i>-1&&o.push(l.splice(i,1)[0])}o=[...o,...l]}return eX(o,n,r)},Ae(e.options,"debugTable"))}},vv=()=>({left:[],right:[]}),nX={getInitialState:e=>({columnPinning:vv(),...e}),getDefaultOptions:e=>({onColumnPinningChange:Sr("columnPinning",e)}),createColumn:(e,t)=>{e.pin=n=>{const r=e.getLeafColumns().map(s=>s.id).filter(Boolean);t.setColumnPinning(s=>{var o,a;if(n==="right"){var l,c;return{left:((l=s==null?void 0:s.left)!=null?l:[]).filter(p=>!(r!=null&&r.includes(p))),right:[...((c=s==null?void 0:s.right)!=null?c:[]).filter(p=>!(r!=null&&r.includes(p))),...r]}}if(n==="left"){var i,d;return{left:[...((i=s==null?void 0:s.left)!=null?i:[]).filter(p=>!(r!=null&&r.includes(p))),...r],right:((d=s==null?void 0:s.right)!=null?d:[]).filter(p=>!(r!=null&&r.includes(p)))}}return{left:((o=s==null?void 0:s.left)!=null?o:[]).filter(p=>!(r!=null&&r.includes(p))),right:((a=s==null?void 0:s.right)!=null?a:[]).filter(p=>!(r!=null&&r.includes(p)))}})},e.getCanPin=()=>e.getLeafColumns().some(r=>{var s,o,a;return((s=r.columnDef.enablePinning)!=null?s:!0)&&((o=(a=t.options.enableColumnPinning)!=null?a:t.options.enablePinning)!=null?o:!0)}),e.getIsPinned=()=>{const n=e.getLeafColumns().map(l=>l.id),{left:r,right:s}=t.getState().columnPinning,o=n.some(l=>r==null?void 0:r.includes(l)),a=n.some(l=>s==null?void 0:s.includes(l));return o?"left":a?"right":!1},e.getPinnedIndex=()=>{var n,r;const s=e.getIsPinned();return s?(n=(r=t.getState().columnPinning)==null||(r=r[s])==null?void 0:r.indexOf(e.id))!=null?n:-1:0}},createRow:(e,t)=>{e.getCenterVisibleCells=De(()=>[e._getAllVisibleCells(),t.getState().columnPinning.left,t.getState().columnPinning.right],(n,r,s)=>{const o=[...r??[],...s??[]];return n.filter(a=>!o.includes(a.column.id))},Ae(t.options,"debugRows")),e.getLeftVisibleCells=De(()=>[e._getAllVisibleCells(),t.getState().columnPinning.left],(n,r)=>(r??[]).map(o=>n.find(a=>a.column.id===o)).filter(Boolean).map(o=>({...o,position:"left"})),Ae(t.options,"debugRows")),e.getRightVisibleCells=De(()=>[e._getAllVisibleCells(),t.getState().columnPinning.right],(n,r)=>(r??[]).map(o=>n.find(a=>a.column.id===o)).filter(Boolean).map(o=>({...o,position:"right"})),Ae(t.options,"debugRows"))},createTable:e=>{e.setColumnPinning=t=>e.options.onColumnPinningChange==null?void 0:e.options.onColumnPinningChange(t),e.resetColumnPinning=t=>{var n,r;return e.setColumnPinning(t?vv():(n=(r=e.initialState)==null?void 0:r.columnPinning)!=null?n:vv())},e.getIsSomeColumnsPinned=t=>{var n;const r=e.getState().columnPinning;if(!t){var s,o;return!!((s=r.left)!=null&&s.length||(o=r.right)!=null&&o.length)}return!!((n=r[t])!=null&&n.length)},e.getLeftLeafColumns=De(()=>[e.getAllLeafColumns(),e.getState().columnPinning.left],(t,n)=>(n??[]).map(r=>t.find(s=>s.id===r)).filter(Boolean),Ae(e.options,"debugColumns")),e.getRightLeafColumns=De(()=>[e.getAllLeafColumns(),e.getState().columnPinning.right],(t,n)=>(n??[]).map(r=>t.find(s=>s.id===r)).filter(Boolean),Ae(e.options,"debugColumns")),e.getCenterLeafColumns=De(()=>[e.getAllLeafColumns(),e.getState().columnPinning.left,e.getState().columnPinning.right],(t,n,r)=>{const s=[...n??[],...r??[]];return t.filter(o=>!s.includes(o.id))},Ae(e.options,"debugColumns"))}},Gf={size:150,minSize:20,maxSize:Number.MAX_SAFE_INTEGER},yv=()=>({startOffset:null,startSize:null,deltaOffset:null,deltaPercentage:null,isResizingColumn:!1,columnSizingStart:[]}),rX={getDefaultColumnDef:()=>Gf,getInitialState:e=>({columnSizing:{},columnSizingInfo:yv(),...e}),getDefaultOptions:e=>({columnResizeMode:"onEnd",columnResizeDirection:"ltr",onColumnSizingChange:Sr("columnSizing",e),onColumnSizingInfoChange:Sr("columnSizingInfo",e)}),createColumn:(e,t)=>{e.getSize=()=>{var n,r,s;const o=t.getState().columnSizing[e.id];return Math.min(Math.max((n=e.columnDef.minSize)!=null?n:Gf.minSize,(r=o??e.columnDef.size)!=null?r:Gf.size),(s=e.columnDef.maxSize)!=null?s:Gf.maxSize)},e.getStart=De(n=>[n,Nc(t,n),t.getState().columnSizing],(n,r)=>r.slice(0,e.getIndex(n)).reduce((s,o)=>s+o.getSize(),0),Ae(t.options,"debugColumns")),e.getAfter=De(n=>[n,Nc(t,n),t.getState().columnSizing],(n,r)=>r.slice(e.getIndex(n)+1).reduce((s,o)=>s+o.getSize(),0),Ae(t.options,"debugColumns")),e.resetSize=()=>{t.setColumnSizing(n=>{let{[e.id]:r,...s}=n;return s})},e.getCanResize=()=>{var n,r;return((n=e.columnDef.enableResizing)!=null?n:!0)&&((r=t.options.enableColumnResizing)!=null?r:!0)},e.getIsResizing=()=>t.getState().columnSizingInfo.isResizingColumn===e.id},createHeader:(e,t)=>{e.getSize=()=>{let n=0;const r=s=>{if(s.subHeaders.length)s.subHeaders.forEach(r);else{var o;n+=(o=s.column.getSize())!=null?o:0}};return r(e),n},e.getStart=()=>{if(e.index>0){const n=e.headerGroup.headers[e.index-1];return n.getStart()+n.getSize()}return 0},e.getResizeHandler=n=>{const r=t.getColumn(e.column.id),s=r==null?void 0:r.getCanResize();return o=>{if(!r||!s||(o.persist==null||o.persist(),bv(o)&&o.touches&&o.touches.length>1))return;const a=e.getSize(),l=e?e.getLeafHeaders().map(b=>[b.column.id,b.column.getSize()]):[[r.id,r.getSize()]],c=bv(o)?Math.round(o.touches[0].clientX):o.clientX,i={},d=(b,y)=>{typeof y=="number"&&(t.setColumnSizingInfo(w=>{var S,E;const C=t.options.columnResizeDirection==="rtl"?-1:1,k=(y-((S=w==null?void 0:w.startOffset)!=null?S:0))*C,T=Math.max(k/((E=w==null?void 0:w.startSize)!=null?E:0),-.999999);return w.columnSizingStart.forEach(P=>{let[N,U]=P;i[N]=Math.round(Math.max(U+U*T,0)*100)/100}),{...w,deltaOffset:k,deltaPercentage:T}}),(t.options.columnResizeMode==="onChange"||b==="end")&&t.setColumnSizing(w=>({...w,...i})))},p=b=>d("move",b),f=b=>{d("end",b),t.setColumnSizingInfo(y=>({...y,isResizingColumn:!1,startOffset:null,startSize:null,deltaOffset:null,deltaPercentage:null,columnSizingStart:[]}))},h=n||typeof document<"u"?document:null,g={moveHandler:b=>p(b.clientX),upHandler:b=>{h==null||h.removeEventListener("mousemove",g.moveHandler),h==null||h.removeEventListener("mouseup",g.upHandler),f(b.clientX)}},m={moveHandler:b=>(b.cancelable&&(b.preventDefault(),b.stopPropagation()),p(b.touches[0].clientX),!1),upHandler:b=>{var y;h==null||h.removeEventListener("touchmove",m.moveHandler),h==null||h.removeEventListener("touchend",m.upHandler),b.cancelable&&(b.preventDefault(),b.stopPropagation()),f((y=b.touches[0])==null?void 0:y.clientX)}},x=sX()?{passive:!1}:!1;bv(o)?(h==null||h.addEventListener("touchmove",m.moveHandler,x),h==null||h.addEventListener("touchend",m.upHandler,x)):(h==null||h.addEventListener("mousemove",g.moveHandler,x),h==null||h.addEventListener("mouseup",g.upHandler,x)),t.setColumnSizingInfo(b=>({...b,startOffset:c,startSize:a,deltaOffset:0,deltaPercentage:0,columnSizingStart:l,isResizingColumn:r.id}))}}},createTable:e=>{e.setColumnSizing=t=>e.options.onColumnSizingChange==null?void 0:e.options.onColumnSizingChange(t),e.setColumnSizingInfo=t=>e.options.onColumnSizingInfoChange==null?void 0:e.options.onColumnSizingInfoChange(t),e.resetColumnSizing=t=>{var n;e.setColumnSizing(t?{}:(n=e.initialState.columnSizing)!=null?n:{})},e.resetHeaderSizeInfo=t=>{var n;e.setColumnSizingInfo(t?yv():(n=e.initialState.columnSizingInfo)!=null?n:yv())},e.getTotalSize=()=>{var t,n;return(t=(n=e.getHeaderGroups()[0])==null?void 0:n.headers.reduce((r,s)=>r+s.getSize(),0))!=null?t:0},e.getLeftTotalSize=()=>{var t,n;return(t=(n=e.getLeftHeaderGroups()[0])==null?void 0:n.headers.reduce((r,s)=>r+s.getSize(),0))!=null?t:0},e.getCenterTotalSize=()=>{var t,n;return(t=(n=e.getCenterHeaderGroups()[0])==null?void 0:n.headers.reduce((r,s)=>r+s.getSize(),0))!=null?t:0},e.getRightTotalSize=()=>{var t,n;return(t=(n=e.getRightHeaderGroups()[0])==null?void 0:n.headers.reduce((r,s)=>r+s.getSize(),0))!=null?t:0}}};let Jf=null;function sX(){if(typeof Jf=="boolean")return Jf;let e=!1;try{const t={get passive(){return e=!0,!1}},n=()=>{};window.addEventListener("test",n,t),window.removeEventListener("test",n)}catch{e=!1}return Jf=e,Jf}function bv(e){return e.type==="touchstart"}const oX={getInitialState:e=>({columnVisibility:{},...e}),getDefaultOptions:e=>({onColumnVisibilityChange:Sr("columnVisibility",e)}),createColumn:(e,t)=>{e.toggleVisibility=n=>{e.getCanHide()&&t.setColumnVisibility(r=>({...r,[e.id]:n??!e.getIsVisible()}))},e.getIsVisible=()=>{var n,r;const s=e.columns;return(n=s.length?s.some(o=>o.getIsVisible()):(r=t.getState().columnVisibility)==null?void 0:r[e.id])!=null?n:!0},e.getCanHide=()=>{var n,r;return((n=e.columnDef.enableHiding)!=null?n:!0)&&((r=t.options.enableHiding)!=null?r:!0)},e.getToggleVisibilityHandler=()=>n=>{e.toggleVisibility==null||e.toggleVisibility(n.target.checked)}},createRow:(e,t)=>{e._getAllVisibleCells=De(()=>[e.getAllCells(),t.getState().columnVisibility],n=>n.filter(r=>r.column.getIsVisible()),Ae(t.options,"debugRows")),e.getVisibleCells=De(()=>[e.getLeftVisibleCells(),e.getCenterVisibleCells(),e.getRightVisibleCells()],(n,r,s)=>[...n,...r,...s],Ae(t.options,"debugRows"))},createTable:e=>{const t=(n,r)=>De(()=>[r(),r().filter(s=>s.getIsVisible()).map(s=>s.id).join("_")],s=>s.filter(o=>o.getIsVisible==null?void 0:o.getIsVisible()),Ae(e.options,"debugColumns"));e.getVisibleFlatColumns=t("getVisibleFlatColumns",()=>e.getAllFlatColumns()),e.getVisibleLeafColumns=t("getVisibleLeafColumns",()=>e.getAllLeafColumns()),e.getLeftVisibleLeafColumns=t("getLeftVisibleLeafColumns",()=>e.getLeftLeafColumns()),e.getRightVisibleLeafColumns=t("getRightVisibleLeafColumns",()=>e.getRightLeafColumns()),e.getCenterVisibleLeafColumns=t("getCenterVisibleLeafColumns",()=>e.getCenterLeafColumns()),e.setColumnVisibility=n=>e.options.onColumnVisibilityChange==null?void 0:e.options.onColumnVisibilityChange(n),e.resetColumnVisibility=n=>{var r;e.setColumnVisibility(n?{}:(r=e.initialState.columnVisibility)!=null?r:{})},e.toggleAllColumnsVisible=n=>{var r;n=(r=n)!=null?r:!e.getIsAllColumnsVisible(),e.setColumnVisibility(e.getAllLeafColumns().reduce((s,o)=>({...s,[o.id]:n||!(o.getCanHide!=null&&o.getCanHide())}),{}))},e.getIsAllColumnsVisible=()=>!e.getAllLeafColumns().some(n=>!(n.getIsVisible!=null&&n.getIsVisible())),e.getIsSomeColumnsVisible=()=>e.getAllLeafColumns().some(n=>n.getIsVisible==null?void 0:n.getIsVisible()),e.getToggleAllColumnsVisibilityHandler=()=>n=>{var r;e.toggleAllColumnsVisible((r=n.target)==null?void 0:r.checked)}}};function Nc(e,t){return t?t==="center"?e.getCenterVisibleLeafColumns():t==="left"?e.getLeftVisibleLeafColumns():e.getRightVisibleLeafColumns():e.getVisibleLeafColumns()}const aX={createTable:e=>{e._getGlobalFacetedRowModel=e.options.getFacetedRowModel&&e.options.getFacetedRowModel(e,"__global__"),e.getGlobalFacetedRowModel=()=>e.options.manualFiltering||!e._getGlobalFacetedRowModel?e.getPreFilteredRowModel():e._getGlobalFacetedRowModel(),e._getGlobalFacetedUniqueValues=e.options.getFacetedUniqueValues&&e.options.getFacetedUniqueValues(e,"__global__"),e.getGlobalFacetedUniqueValues=()=>e._getGlobalFacetedUniqueValues?e._getGlobalFacetedUniqueValues():new Map,e._getGlobalFacetedMinMaxValues=e.options.getFacetedMinMaxValues&&e.options.getFacetedMinMaxValues(e,"__global__"),e.getGlobalFacetedMinMaxValues=()=>{if(e._getGlobalFacetedMinMaxValues)return e._getGlobalFacetedMinMaxValues()}}},iX={getInitialState:e=>({globalFilter:void 0,...e}),getDefaultOptions:e=>({onGlobalFilterChange:Sr("globalFilter",e),globalFilterFn:"auto",getColumnCanGlobalFilter:t=>{var n;const r=(n=e.getCoreRowModel().flatRows[0])==null||(n=n._getAllCellsByColumnId()[t.id])==null?void 0:n.getValue();return typeof r=="string"||typeof r=="number"}}),createColumn:(e,t)=>{e.getCanGlobalFilter=()=>{var n,r,s,o;return((n=e.columnDef.enableGlobalFilter)!=null?n:!0)&&((r=t.options.enableGlobalFilter)!=null?r:!0)&&((s=t.options.enableFilters)!=null?s:!0)&&((o=t.options.getColumnCanGlobalFilter==null?void 0:t.options.getColumnCanGlobalFilter(e))!=null?o:!0)&&!!e.accessorFn}},createTable:e=>{e.getGlobalAutoFilterFn=()=>Xs.includesString,e.getGlobalFilterFn=()=>{var t,n;const{globalFilterFn:r}=e.options;return Zg(r)?r:r==="auto"?e.getGlobalAutoFilterFn():(t=(n=e.options.filterFns)==null?void 0:n[r])!=null?t:Xs[r]},e.setGlobalFilter=t=>{e.options.onGlobalFilterChange==null||e.options.onGlobalFilterChange(t)},e.resetGlobalFilter=t=>{e.setGlobalFilter(t?void 0:e.initialState.globalFilter)}}},lX={getInitialState:e=>({expanded:{},...e}),getDefaultOptions:e=>({onExpandedChange:Sr("expanded",e),paginateExpandedRows:!0}),createTable:e=>{let t=!1,n=!1;e._autoResetExpanded=()=>{var r,s;if(!t){e._queue(()=>{t=!0});return}if((r=(s=e.options.autoResetAll)!=null?s:e.options.autoResetExpanded)!=null?r:!e.options.manualExpanding){if(n)return;n=!0,e._queue(()=>{e.resetExpanded(),n=!1})}},e.setExpanded=r=>e.options.onExpandedChange==null?void 0:e.options.onExpandedChange(r),e.toggleAllRowsExpanded=r=>{r??!e.getIsAllRowsExpanded()?e.setExpanded(!0):e.setExpanded({})},e.resetExpanded=r=>{var s,o;e.setExpanded(r?{}:(s=(o=e.initialState)==null?void 0:o.expanded)!=null?s:{})},e.getCanSomeRowsExpand=()=>e.getPrePaginationRowModel().flatRows.some(r=>r.getCanExpand()),e.getToggleAllRowsExpandedHandler=()=>r=>{r.persist==null||r.persist(),e.toggleAllRowsExpanded()},e.getIsSomeRowsExpanded=()=>{const r=e.getState().expanded;return r===!0||Object.values(r).some(Boolean)},e.getIsAllRowsExpanded=()=>{const r=e.getState().expanded;return typeof r=="boolean"?r===!0:!(!Object.keys(r).length||e.getRowModel().flatRows.some(s=>!s.getIsExpanded()))},e.getExpandedDepth=()=>{let r=0;return(e.getState().expanded===!0?Object.keys(e.getRowModel().rowsById):Object.keys(e.getState().expanded)).forEach(o=>{const a=o.split(".");r=Math.max(r,a.length)}),r},e.getPreExpandedRowModel=()=>e.getSortedRowModel(),e.getExpandedRowModel=()=>(!e._getExpandedRowModel&&e.options.getExpandedRowModel&&(e._getExpandedRowModel=e.options.getExpandedRowModel(e)),e.options.manualExpanding||!e._getExpandedRowModel?e.getPreExpandedRowModel():e._getExpandedRowModel())},createRow:(e,t)=>{e.toggleExpanded=n=>{t.setExpanded(r=>{var s;const o=r===!0?!0:!!(r!=null&&r[e.id]);let a={};if(r===!0?Object.keys(t.getRowModel().rowsById).forEach(l=>{a[l]=!0}):a=r,n=(s=n)!=null?s:!o,!o&&n)return{...a,[e.id]:!0};if(o&&!n){const{[e.id]:l,...c}=a;return c}return r})},e.getIsExpanded=()=>{var n;const r=t.getState().expanded;return!!((n=t.options.getIsRowExpanded==null?void 0:t.options.getIsRowExpanded(e))!=null?n:r===!0||r!=null&&r[e.id])},e.getCanExpand=()=>{var n,r,s;return(n=t.options.getRowCanExpand==null?void 0:t.options.getRowCanExpand(e))!=null?n:((r=t.options.enableExpanding)!=null?r:!0)&&!!((s=e.subRows)!=null&&s.length)},e.getIsAllParentsExpanded=()=>{let n=!0,r=e;for(;n&&r.parentId;)r=t.getRow(r.parentId,!0),n=r.getIsExpanded();return n},e.getToggleExpandedHandler=()=>{const n=e.getCanExpand();return()=>{n&&e.toggleExpanded()}}}},Sb=0,Cb=10,xv=()=>({pageIndex:Sb,pageSize:Cb}),uX={getInitialState:e=>({...e,pagination:{...xv(),...e==null?void 0:e.pagination}}),getDefaultOptions:e=>({onPaginationChange:Sr("pagination",e)}),createTable:e=>{let t=!1,n=!1;e._autoResetPageIndex=()=>{var r,s;if(!t){e._queue(()=>{t=!0});return}if((r=(s=e.options.autoResetAll)!=null?s:e.options.autoResetPageIndex)!=null?r:!e.options.manualPagination){if(n)return;n=!0,e._queue(()=>{e.resetPageIndex(),n=!1})}},e.setPagination=r=>{const s=o=>na(r,o);return e.options.onPaginationChange==null?void 0:e.options.onPaginationChange(s)},e.resetPagination=r=>{var s;e.setPagination(r?xv():(s=e.initialState.pagination)!=null?s:xv())},e.setPageIndex=r=>{e.setPagination(s=>{let o=na(r,s.pageIndex);const a=typeof e.options.pageCount>"u"||e.options.pageCount===-1?Number.MAX_SAFE_INTEGER:e.options.pageCount-1;return o=Math.max(0,Math.min(o,a)),{...s,pageIndex:o}})},e.resetPageIndex=r=>{var s,o;e.setPageIndex(r?Sb:(s=(o=e.initialState)==null||(o=o.pagination)==null?void 0:o.pageIndex)!=null?s:Sb)},e.resetPageSize=r=>{var s,o;e.setPageSize(r?Cb:(s=(o=e.initialState)==null||(o=o.pagination)==null?void 0:o.pageSize)!=null?s:Cb)},e.setPageSize=r=>{e.setPagination(s=>{const o=Math.max(1,na(r,s.pageSize)),a=s.pageSize*s.pageIndex,l=Math.floor(a/o);return{...s,pageIndex:l,pageSize:o}})},e.setPageCount=r=>e.setPagination(s=>{var o;let a=na(r,(o=e.options.pageCount)!=null?o:-1);return typeof a=="number"&&(a=Math.max(-1,a)),{...s,pageCount:a}}),e.getPageOptions=De(()=>[e.getPageCount()],r=>{let s=[];return r&&r>0&&(s=[...new Array(r)].fill(null).map((o,a)=>a)),s},Ae(e.options,"debugTable")),e.getCanPreviousPage=()=>e.getState().pagination.pageIndex>0,e.getCanNextPage=()=>{const{pageIndex:r}=e.getState().pagination,s=e.getPageCount();return s===-1?!0:s===0?!1:r<s-1},e.previousPage=()=>e.setPageIndex(r=>r-1),e.nextPage=()=>e.setPageIndex(r=>r+1),e.firstPage=()=>e.setPageIndex(0),e.lastPage=()=>e.setPageIndex(e.getPageCount()-1),e.getPrePaginationRowModel=()=>e.getExpandedRowModel(),e.getPaginationRowModel=()=>(!e._getPaginationRowModel&&e.options.getPaginationRowModel&&(e._getPaginationRowModel=e.options.getPaginationRowModel(e)),e.options.manualPagination||!e._getPaginationRowModel?e.getPrePaginationRowModel():e._getPaginationRowModel()),e.getPageCount=()=>{var r;return(r=e.options.pageCount)!=null?r:Math.ceil(e.getRowCount()/e.getState().pagination.pageSize)},e.getRowCount=()=>{var r;return(r=e.options.rowCount)!=null?r:e.getPrePaginationRowModel().rows.length}}},wv=()=>({top:[],bottom:[]}),cX={getInitialState:e=>({rowPinning:wv(),...e}),getDefaultOptions:e=>({onRowPinningChange:Sr("rowPinning",e)}),createRow:(e,t)=>{e.pin=(n,r,s)=>{const o=r?e.getLeafRows().map(c=>{let{id:i}=c;return i}):[],a=s?e.getParentRows().map(c=>{let{id:i}=c;return i}):[],l=new Set([...a,e.id,...o]);t.setRowPinning(c=>{var i,d;if(n==="bottom"){var p,f;return{top:((p=c==null?void 0:c.top)!=null?p:[]).filter(m=>!(l!=null&&l.has(m))),bottom:[...((f=c==null?void 0:c.bottom)!=null?f:[]).filter(m=>!(l!=null&&l.has(m))),...Array.from(l)]}}if(n==="top"){var h,g;return{top:[...((h=c==null?void 0:c.top)!=null?h:[]).filter(m=>!(l!=null&&l.has(m))),...Array.from(l)],bottom:((g=c==null?void 0:c.bottom)!=null?g:[]).filter(m=>!(l!=null&&l.has(m)))}}return{top:((i=c==null?void 0:c.top)!=null?i:[]).filter(m=>!(l!=null&&l.has(m))),bottom:((d=c==null?void 0:c.bottom)!=null?d:[]).filter(m=>!(l!=null&&l.has(m)))}})},e.getCanPin=()=>{var n;const{enableRowPinning:r,enablePinning:s}=t.options;return typeof r=="function"?r(e):(n=r??s)!=null?n:!0},e.getIsPinned=()=>{const n=[e.id],{top:r,bottom:s}=t.getState().rowPinning,o=n.some(l=>r==null?void 0:r.includes(l)),a=n.some(l=>s==null?void 0:s.includes(l));return o?"top":a?"bottom":!1},e.getPinnedIndex=()=>{var n,r;const s=e.getIsPinned();if(!s)return-1;const o=(n=s==="top"?t.getTopRows():t.getBottomRows())==null?void 0:n.map(a=>{let{id:l}=a;return l});return(r=o==null?void 0:o.indexOf(e.id))!=null?r:-1}},createTable:e=>{e.setRowPinning=t=>e.options.onRowPinningChange==null?void 0:e.options.onRowPinningChange(t),e.resetRowPinning=t=>{var n,r;return e.setRowPinning(t?wv():(n=(r=e.initialState)==null?void 0:r.rowPinning)!=null?n:wv())},e.getIsSomeRowsPinned=t=>{var n;const r=e.getState().rowPinning;if(!t){var s,o;return!!((s=r.top)!=null&&s.length||(o=r.bottom)!=null&&o.length)}return!!((n=r[t])!=null&&n.length)},e._getPinnedRows=(t,n,r)=>{var s;return((s=e.options.keepPinnedRows)==null||s?(n??[]).map(a=>{const l=e.getRow(a,!0);return l.getIsAllParentsExpanded()?l:null}):(n??[]).map(a=>t.find(l=>l.id===a))).filter(Boolean).map(a=>({...a,position:r}))},e.getTopRows=De(()=>[e.getRowModel().rows,e.getState().rowPinning.top],(t,n)=>e._getPinnedRows(t,n,"top"),Ae(e.options,"debugRows")),e.getBottomRows=De(()=>[e.getRowModel().rows,e.getState().rowPinning.bottom],(t,n)=>e._getPinnedRows(t,n,"bottom"),Ae(e.options,"debugRows")),e.getCenterRows=De(()=>[e.getRowModel().rows,e.getState().rowPinning.top,e.getState().rowPinning.bottom],(t,n,r)=>{const s=new Set([...n??[],...r??[]]);return t.filter(o=>!s.has(o.id))},Ae(e.options,"debugRows"))}},dX={getInitialState:e=>({rowSelection:{},...e}),getDefaultOptions:e=>({onRowSelectionChange:Sr("rowSelection",e),enableRowSelection:!0,enableMultiRowSelection:!0,enableSubRowSelection:!0}),createTable:e=>{e.setRowSelection=t=>e.options.onRowSelectionChange==null?void 0:e.options.onRowSelectionChange(t),e.resetRowSelection=t=>{var n;return e.setRowSelection(t?{}:(n=e.initialState.rowSelection)!=null?n:{})},e.toggleAllRowsSelected=t=>{e.setRowSelection(n=>{t=typeof t<"u"?t:!e.getIsAllRowsSelected();const r={...n},s=e.getPreGroupedRowModel().flatRows;return t?s.forEach(o=>{o.getCanSelect()&&(r[o.id]=!0)}):s.forEach(o=>{delete r[o.id]}),r})},e.toggleAllPageRowsSelected=t=>e.setRowSelection(n=>{const r=typeof t<"u"?t:!e.getIsAllPageRowsSelected(),s={...n};return e.getRowModel().rows.forEach(o=>{Eb(s,o.id,r,!0,e)}),s}),e.getPreSelectedRowModel=()=>e.getCoreRowModel(),e.getSelectedRowModel=De(()=>[e.getState().rowSelection,e.getCoreRowModel()],(t,n)=>Object.keys(t).length?Sv(e,n):{rows:[],flatRows:[],rowsById:{}},Ae(e.options,"debugTable")),e.getFilteredSelectedRowModel=De(()=>[e.getState().rowSelection,e.getFilteredRowModel()],(t,n)=>Object.keys(t).length?Sv(e,n):{rows:[],flatRows:[],rowsById:{}},Ae(e.options,"debugTable")),e.getGroupedSelectedRowModel=De(()=>[e.getState().rowSelection,e.getSortedRowModel()],(t,n)=>Object.keys(t).length?Sv(e,n):{rows:[],flatRows:[],rowsById:{}},Ae(e.options,"debugTable")),e.getIsAllRowsSelected=()=>{const t=e.getFilteredRowModel().flatRows,{rowSelection:n}=e.getState();let r=!!(t.length&&Object.keys(n).length);return r&&t.some(s=>s.getCanSelect()&&!n[s.id])&&(r=!1),r},e.getIsAllPageRowsSelected=()=>{const t=e.getPaginationRowModel().flatRows.filter(s=>s.getCanSelect()),{rowSelection:n}=e.getState();let r=!!t.length;return r&&t.some(s=>!n[s.id])&&(r=!1),r},e.getIsSomeRowsSelected=()=>{var t;const n=Object.keys((t=e.getState().rowSelection)!=null?t:{}).length;return n>0&&n<e.getFilteredRowModel().flatRows.length},e.getIsSomePageRowsSelected=()=>{const t=e.getPaginationRowModel().flatRows;return e.getIsAllPageRowsSelected()?!1:t.filter(n=>n.getCanSelect()).some(n=>n.getIsSelected()||n.getIsSomeSelected())},e.getToggleAllRowsSelectedHandler=()=>t=>{e.toggleAllRowsSelected(t.target.checked)},e.getToggleAllPageRowsSelectedHandler=()=>t=>{e.toggleAllPageRowsSelected(t.target.checked)}},createRow:(e,t)=>{e.toggleSelected=(n,r)=>{const s=e.getIsSelected();t.setRowSelection(o=>{var a;if(n=typeof n<"u"?n:!s,e.getCanSelect()&&s===n)return o;const l={...o};return Eb(l,e.id,n,(a=r==null?void 0:r.selectChildren)!=null?a:!0,t),l})},e.getIsSelected=()=>{const{rowSelection:n}=t.getState();return zw(e,n)},e.getIsSomeSelected=()=>{const{rowSelection:n}=t.getState();return Tb(e,n)==="some"},e.getIsAllSubRowsSelected=()=>{const{rowSelection:n}=t.getState();return Tb(e,n)==="all"},e.getCanSelect=()=>{var n;return typeof t.options.enableRowSelection=="function"?t.options.enableRowSelection(e):(n=t.options.enableRowSelection)!=null?n:!0},e.getCanSelectSubRows=()=>{var n;return typeof t.options.enableSubRowSelection=="function"?t.options.enableSubRowSelection(e):(n=t.options.enableSubRowSelection)!=null?n:!0},e.getCanMultiSelect=()=>{var n;return typeof t.options.enableMultiRowSelection=="function"?t.options.enableMultiRowSelection(e):(n=t.options.enableMultiRowSelection)!=null?n:!0},e.getToggleSelectedHandler=()=>{const n=e.getCanSelect();return r=>{var s;n&&e.toggleSelected((s=r.target)==null?void 0:s.checked)}}}},Eb=(e,t,n,r,s)=>{var o;const a=s.getRow(t,!0);n?(a.getCanMultiSelect()||Object.keys(e).forEach(l=>delete e[l]),a.getCanSelect()&&(e[t]=!0)):delete e[t],r&&(o=a.subRows)!=null&&o.length&&a.getCanSelectSubRows()&&a.subRows.forEach(l=>Eb(e,l.id,n,r,s))};function Sv(e,t){const n=e.getState().rowSelection,r=[],s={},o=function(a,l){return a.map(c=>{var i;const d=zw(c,n);if(d&&(r.push(c),s[c.id]=c),(i=c.subRows)!=null&&i.length&&(c={...c,subRows:o(c.subRows)}),d)return c}).filter(Boolean)};return{rows:o(t.rows),flatRows:r,rowsById:s}}function zw(e,t){var n;return(n=t[e.id])!=null?n:!1}function Tb(e,t,n){var r;if(!((r=e.subRows)!=null&&r.length))return!1;let s=!0,o=!1;return e.subRows.forEach(a=>{if(!(o&&!s)&&(a.getCanSelect()&&(zw(a,t)?o=!0:s=!1),a.subRows&&a.subRows.length)){const l=Tb(a,t);l==="all"?o=!0:(l==="some"&&(o=!0),s=!1)}}),s?"all":o?"some":!1}const kb=/([0-9]+)/gm,fX=(e,t,n)=>wI(Sa(e.getValue(n)).toLowerCase(),Sa(t.getValue(n)).toLowerCase()),pX=(e,t,n)=>wI(Sa(e.getValue(n)),Sa(t.getValue(n))),hX=(e,t,n)=>Uw(Sa(e.getValue(n)).toLowerCase(),Sa(t.getValue(n)).toLowerCase()),gX=(e,t,n)=>Uw(Sa(e.getValue(n)),Sa(t.getValue(n))),mX=(e,t,n)=>{const r=e.getValue(n),s=t.getValue(n);return r>s?1:r<s?-1:0},vX=(e,t,n)=>Uw(e.getValue(n),t.getValue(n));function Uw(e,t){return e===t?0:e>t?1:-1}function Sa(e){return typeof e=="number"?isNaN(e)||e===1/0||e===-1/0?"":String(e):typeof e=="string"?e:""}function wI(e,t){const n=e.split(kb).filter(Boolean),r=t.split(kb).filter(Boolean);for(;n.length&&r.length;){const s=n.shift(),o=r.shift(),a=parseInt(s,10),l=parseInt(o,10),c=[a,l].sort();if(isNaN(c[0])){if(s>o)return 1;if(o>s)return-1;continue}if(isNaN(c[1]))return isNaN(a)?-1:1;if(a>l)return 1;if(l>a)return-1}return n.length-r.length}const rc={alphanumeric:fX,alphanumericCaseSensitive:pX,text:hX,textCaseSensitive:gX,datetime:mX,basic:vX},yX={getInitialState:e=>({sorting:[],...e}),getDefaultColumnDef:()=>({sortingFn:"auto",sortUndefined:1}),getDefaultOptions:e=>({onSortingChange:Sr("sorting",e),isMultiSortEvent:t=>t.shiftKey}),createColumn:(e,t)=>{e.getAutoSortingFn=()=>{const n=t.getFilteredRowModel().flatRows.slice(10);let r=!1;for(const s of n){const o=s==null?void 0:s.getValue(e.id);if(Object.prototype.toString.call(o)==="[object Date]")return rc.datetime;if(typeof o=="string"&&(r=!0,o.split(kb).length>1))return rc.alphanumeric}return r?rc.text:rc.basic},e.getAutoSortDir=()=>{const n=t.getFilteredRowModel().flatRows[0];return typeof(n==null?void 0:n.getValue(e.id))=="string"?"asc":"desc"},e.getSortingFn=()=>{var n,r;if(!e)throw new Error;return Zg(e.columnDef.sortingFn)?e.columnDef.sortingFn:e.columnDef.sortingFn==="auto"?e.getAutoSortingFn():(n=(r=t.options.sortingFns)==null?void 0:r[e.columnDef.sortingFn])!=null?n:rc[e.columnDef.sortingFn]},e.toggleSorting=(n,r)=>{const s=e.getNextSortingOrder(),o=typeof n<"u"&&n!==null;t.setSorting(a=>{const l=a==null?void 0:a.find(h=>h.id===e.id),c=a==null?void 0:a.findIndex(h=>h.id===e.id);let i=[],d,p=o?n:s==="desc";if(a!=null&&a.length&&e.getCanMultiSort()&&r?l?d="toggle":d="add":a!=null&&a.length&&c!==a.length-1?d="replace":l?d="toggle":d="replace",d==="toggle"&&(o||s||(d="remove")),d==="add"){var f;i=[...a,{id:e.id,desc:p}],i.splice(0,i.length-((f=t.options.maxMultiSortColCount)!=null?f:Number.MAX_SAFE_INTEGER))}else d==="toggle"?i=a.map(h=>h.id===e.id?{...h,desc:p}:h):d==="remove"?i=a.filter(h=>h.id!==e.id):i=[{id:e.id,desc:p}];return i})},e.getFirstSortDir=()=>{var n,r;return((n=(r=e.columnDef.sortDescFirst)!=null?r:t.options.sortDescFirst)!=null?n:e.getAutoSortDir()==="desc")?"desc":"asc"},e.getNextSortingOrder=n=>{var r,s;const o=e.getFirstSortDir(),a=e.getIsSorted();return a?a!==o&&((r=t.options.enableSortingRemoval)==null||r)&&(!(n&&(s=t.options.enableMultiRemove)!=null)||s)?!1:a==="desc"?"asc":"desc":o},e.getCanSort=()=>{var n,r;return((n=e.columnDef.enableSorting)!=null?n:!0)&&((r=t.options.enableSorting)!=null?r:!0)&&!!e.accessorFn},e.getCanMultiSort=()=>{var n,r;return(n=(r=e.columnDef.enableMultiSort)!=null?r:t.options.enableMultiSort)!=null?n:!!e.accessorFn},e.getIsSorted=()=>{var n;const r=(n=t.getState().sorting)==null?void 0:n.find(s=>s.id===e.id);return r?r.desc?"desc":"asc":!1},e.getSortIndex=()=>{var n,r;return(n=(r=t.getState().sorting)==null?void 0:r.findIndex(s=>s.id===e.id))!=null?n:-1},e.clearSorting=()=>{t.setSorting(n=>n!=null&&n.length?n.filter(r=>r.id!==e.id):[])},e.getToggleSortingHandler=()=>{const n=e.getCanSort();return r=>{n&&(r.persist==null||r.persist(),e.toggleSorting==null||e.toggleSorting(void 0,e.getCanMultiSort()?t.options.isMultiSortEvent==null?void 0:t.options.isMultiSortEvent(r):!1))}}},createTable:e=>{e.setSorting=t=>e.options.onSortingChange==null?void 0:e.options.onSortingChange(t),e.resetSorting=t=>{var n,r;e.setSorting(t?[]:(n=(r=e.initialState)==null?void 0:r.sorting)!=null?n:[])},e.getPreSortedRowModel=()=>e.getGroupedRowModel(),e.getSortedRowModel=()=>(!e._getSortedRowModel&&e.options.getSortedRowModel&&(e._getSortedRowModel=e.options.getSortedRowModel(e)),e.options.manualSorting||!e._getSortedRowModel?e.getPreSortedRowModel():e._getSortedRowModel())}},bX=[zY,oX,tX,nX,UY,VY,aX,iX,yX,XY,lX,uX,cX,dX,rX];function xX(e){var t,n;const r=[...bX,...(t=e._features)!=null?t:[]];let s={_features:r};const o=s._features.reduce((f,h)=>Object.assign(f,h.getDefaultOptions==null?void 0:h.getDefaultOptions(s)),{}),a=f=>s.options.mergeOptions?s.options.mergeOptions(o,f):{...o,...f};let c={...{},...(n=e.initialState)!=null?n:{}};s._features.forEach(f=>{var h;c=(h=f.getInitialState==null?void 0:f.getInitialState(c))!=null?h:c});const i=[];let d=!1;const p={_features:r,options:{...o,...e},initialState:c,_queue:f=>{i.push(f),d||(d=!0,Promise.resolve().then(()=>{for(;i.length;)i.shift()();d=!1}).catch(h=>setTimeout(()=>{throw h})))},reset:()=>{s.setState(s.initialState)},setOptions:f=>{const h=na(f,s.options);s.options=a(h)},getState:()=>s.options.state,setState:f=>{s.options.onStateChange==null||s.options.onStateChange(f)},_getRowId:(f,h,g)=>{var m;return(m=s.options.getRowId==null?void 0:s.options.getRowId(f,h,g))!=null?m:`${g?[g.id,h].join("."):h}`},getCoreRowModel:()=>(s._getCoreRowModel||(s._getCoreRowModel=s.options.getCoreRowModel(s)),s._getCoreRowModel()),getRowModel:()=>s.getPaginationRowModel(),getRow:(f,h)=>{let g=(h?s.getPrePaginationRowModel():s.getRowModel()).rowsById[f];if(!g&&(g=s.getCoreRowModel().rowsById[f],!g))throw new Error;return g},_getDefaultColumnDef:De(()=>[s.options.defaultColumn],f=>{var h;return f=(h=f)!=null?h:{},{header:g=>{const m=g.header.column.columnDef;return m.accessorKey?m.accessorKey:m.accessorFn?m.id:null},cell:g=>{var m,x;return(m=(x=g.renderValue())==null||x.toString==null?void 0:x.toString())!=null?m:null},...s._features.reduce((g,m)=>Object.assign(g,m.getDefaultColumnDef==null?void 0:m.getDefaultColumnDef()),{}),...f}},Ae(e,"debugColumns")),_getColumnDefs:()=>s.options.columns,getAllColumns:De(()=>[s._getColumnDefs()],f=>{const h=function(g,m,x){return x===void 0&&(x=0),g.map(b=>{const y=BY(s,b,x,m),w=b;return y.columns=w.columns?h(w.columns,y,x+1):[],y})};return h(f)},Ae(e,"debugColumns")),getAllFlatColumns:De(()=>[s.getAllColumns()],f=>f.flatMap(h=>h.getFlatColumns()),Ae(e,"debugColumns")),_getAllFlatColumnsById:De(()=>[s.getAllFlatColumns()],f=>f.reduce((h,g)=>(h[g.id]=g,h),{}),Ae(e,"debugColumns")),getAllLeafColumns:De(()=>[s.getAllColumns(),s._getOrderColumnsFn()],(f,h)=>{let g=f.flatMap(m=>m.getLeafColumns());return h(g)},Ae(e,"debugColumns")),getColumn:f=>s._getAllFlatColumnsById()[f]};Object.assign(s,p);for(let f=0;f<s._features.length;f++){const h=s._features[f];h==null||h.createTable==null||h.createTable(s)}return s}function wX(){return e=>De(()=>[e.options.data],t=>{const n={rows:[],flatRows:[],rowsById:{}},r=function(s,o,a){o===void 0&&(o=0);const l=[];for(let i=0;i<s.length;i++){const d=Yg(e,e._getRowId(s[i],i,a),s[i],i,o,void 0,a==null?void 0:a.id);if(n.flatRows.push(d),n.rowsById[d.id]=d,l.push(d),e.options.getSubRows){var c;d.originalSubRows=e.options.getSubRows(s[i],i),(c=d.originalSubRows)!=null&&c.length&&(d.subRows=r(d.originalSubRows,o+1,d))}}return l};return n.rows=r(t),n},Ae(e.options,"debugTable","getRowModel",()=>e._autoResetPageIndex()))}function SX(e,t,n){return n.options.filterFromLeafRows?CX(e,t,n):EX(e,t,n)}function CX(e,t,n){var r;const s=[],o={},a=(r=n.options.maxLeafRowFilterDepth)!=null?r:100,l=function(c,i){i===void 0&&(i=0);const d=[];for(let f=0;f<c.length;f++){var p;let h=c[f];const g=Yg(n,h.id,h.original,h.index,h.depth,void 0,h.parentId);if(g.columnFilters=h.columnFilters,(p=h.subRows)!=null&&p.length&&i<a){if(g.subRows=l(h.subRows,i+1),h=g,t(h)&&!g.subRows.length){d.push(h),o[h.id]=h,s.push(h);continue}if(t(h)||g.subRows.length){d.push(h),o[h.id]=h,s.push(h);continue}}else h=g,t(h)&&(d.push(h),o[h.id]=h,s.push(h))}return d};return{rows:l(e),flatRows:s,rowsById:o}}function EX(e,t,n){var r;const s=[],o={},a=(r=n.options.maxLeafRowFilterDepth)!=null?r:100,l=function(c,i){i===void 0&&(i=0);const d=[];for(let f=0;f<c.length;f++){let h=c[f];if(t(h)){var p;if((p=h.subRows)!=null&&p.length&&i<a){const m=Yg(n,h.id,h.original,h.index,h.depth,void 0,h.parentId);m.subRows=l(h.subRows,i+1),h=m}d.push(h),s.push(h),o[h.id]=h}}return d};return{rows:l(e),flatRows:s,rowsById:o}}function TX(){return e=>De(()=>[e.getPreFilteredRowModel(),e.getState().columnFilters,e.getState().globalFilter],(t,n,r)=>{if(!t.rows.length||!(n!=null&&n.length)&&!r){for(let f=0;f<t.flatRows.length;f++)t.flatRows[f].columnFilters={},t.flatRows[f].columnFiltersMeta={};return t}const s=[],o=[];(n??[]).forEach(f=>{var h;const g=e.getColumn(f.id);if(!g)return;const m=g.getFilterFn();m&&s.push({id:f.id,filterFn:m,resolvedValue:(h=m.resolveFilterValue==null?void 0:m.resolveFilterValue(f.value))!=null?h:f.value})});const a=(n??[]).map(f=>f.id),l=e.getGlobalFilterFn(),c=e.getAllLeafColumns().filter(f=>f.getCanGlobalFilter());r&&l&&c.length&&(a.push("__global__"),c.forEach(f=>{var h;o.push({id:f.id,filterFn:l,resolvedValue:(h=l.resolveFilterValue==null?void 0:l.resolveFilterValue(r))!=null?h:r})}));let i,d;for(let f=0;f<t.flatRows.length;f++){const h=t.flatRows[f];if(h.columnFilters={},s.length)for(let g=0;g<s.length;g++){i=s[g];const m=i.id;h.columnFilters[m]=i.filterFn(h,m,i.resolvedValue,x=>{h.columnFiltersMeta[m]=x})}if(o.length){for(let g=0;g<o.length;g++){d=o[g];const m=d.id;if(d.filterFn(h,m,d.resolvedValue,x=>{h.columnFiltersMeta[m]=x})){h.columnFilters.__global__=!0;break}}h.columnFilters.__global__!==!0&&(h.columnFilters.__global__=!1)}}const p=f=>{for(let h=0;h<a.length;h++)if(f.columnFilters[a[h]]===!1)return!1;return!0};return SX(t.rows,p,e)},Ae(e.options,"debugTable","getFilteredRowModel",()=>e._autoResetPageIndex()))}function kX(){return e=>De(()=>[e.getState().grouping,e.getPreGroupedRowModel()],(t,n)=>{if(!n.rows.length||!t.length)return n.rows.forEach(c=>{c.depth=0,c.parentId=void 0}),n;const r=t.filter(c=>e.getColumn(c)),s=[],o={},a=function(c,i,d){if(i===void 0&&(i=0),i>=r.length)return c.map(g=>(g.depth=i,s.push(g),o[g.id]=g,g.subRows&&(g.subRows=a(g.subRows,i+1,g.id)),g));const p=r[i],f=_X(c,p);return Array.from(f.entries()).map((g,m)=>{let[x,b]=g,y=`${p}:${x}`;y=d?`${d}>${y}`:y;const w=a(b,i+1,y);w.forEach(C=>{C.parentId=y});const S=i?fI(b,C=>C.subRows):b,E=Yg(e,y,S[0].original,m,i,void 0,d);return Object.assign(E,{groupingColumnId:p,groupingValue:x,subRows:w,leafRows:S,getValue:C=>{if(r.includes(C)){if(E._valuesCache.hasOwnProperty(C))return E._valuesCache[C];if(b[0]){var k;E._valuesCache[C]=(k=b[0].getValue(C))!=null?k:void 0}return E._valuesCache[C]}if(E._groupingValuesCache.hasOwnProperty(C))return E._groupingValuesCache[C];const T=e.getColumn(C),P=T==null?void 0:T.getAggregationFn();if(P)return E._groupingValuesCache[C]=P(C,S,b),E._groupingValuesCache[C]}}),w.forEach(C=>{s.push(C),o[C.id]=C}),E})},l=a(n.rows,0);return l.forEach(c=>{s.push(c),o[c.id]=c}),{rows:l,flatRows:s,rowsById:o}},Ae(e.options,"debugTable","getGroupedRowModel",()=>{e._queue(()=>{e._autoResetExpanded(),e._autoResetPageIndex()})}))}function _X(e,t){const n=new Map;return e.reduce((r,s)=>{const o=`${s.getGroupingValue(t)}`,a=r.get(o);return a?a.push(s):r.set(o,[s]),r},n)}function jX(){return e=>De(()=>[e.getState().sorting,e.getPreSortedRowModel()],(t,n)=>{if(!n.rows.length||!(t!=null&&t.length))return n;const r=e.getState().sorting,s=[],o=r.filter(c=>{var i;return(i=e.getColumn(c.id))==null?void 0:i.getCanSort()}),a={};o.forEach(c=>{const i=e.getColumn(c.id);i&&(a[c.id]={sortUndefined:i.columnDef.sortUndefined,invertSorting:i.columnDef.invertSorting,sortingFn:i.getSortingFn()})});const l=c=>{const i=c.map(d=>({...d}));return i.sort((d,p)=>{for(let h=0;h<o.length;h+=1){var f;const g=o[h],m=a[g.id],x=m.sortUndefined,b=(f=g==null?void 0:g.desc)!=null?f:!1;let y=0;if(x){const w=d.getValue(g.id),S=p.getValue(g.id),E=w===void 0,C=S===void 0;if(E||C){if(x==="first")return E?-1:1;if(x==="last")return E?1:-1;y=E&&C?0:E?x:-x}}if(y===0&&(y=m.sortingFn(d,p,g.id)),y!==0)return b&&(y*=-1),m.invertSorting&&(y*=-1),y}return d.index-p.index}),i.forEach(d=>{var p;s.push(d),(p=d.subRows)!=null&&p.length&&(d.subRows=l(d.subRows))}),i};return{rows:l(n.rows),flatRows:s,rowsById:n.rowsById}},Ae(e.options,"debugTable","getSortedRowModel",()=>e._autoResetPageIndex()))}/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */function tE(e,t){return e?RX(e)?v.createElement(e,t):e:null}function RX(e){return PX(e)||typeof e=="function"||MX(e)}function PX(e){return typeof e=="function"&&(()=>{const t=Object.getPrototypeOf(e);return t.prototype&&t.prototype.isReactComponent})()}function MX(e){return typeof e=="object"&&typeof e.$$typeof=="symbol"&&["react.memo","react.forward_ref"].includes(e.$$typeof.description)}function OX(e){const t={state:{},onStateChange:()=>{},renderFallbackValue:null,...e},[n]=v.useState(()=>({current:xX(t)})),[r,s]=v.useState(()=>n.current.initialState);return n.current.setOptions(o=>({...o,...e,state:{...r,...e.state},onStateChange:a=>{s(a),e.onStateChange==null||e.onStateChange(a)}})),n.current}const SI=v.forwardRef(({className:e,...t},n)=>u.jsx("div",{className:"relative w-full overflow-auto",children:u.jsx("table",{ref:n,className:ge("w-full caption-bottom text-sm",e),...t})}));SI.displayName="Table";const CI=v.forwardRef(({className:e,...t},n)=>u.jsx("thead",{ref:n,className:ge("[&_tr]:border-b",e),...t}));CI.displayName="TableHeader";const EI=v.forwardRef(({className:e,...t},n)=>u.jsx("tbody",{ref:n,className:ge("[&_tr:last-child]:border-0",e),...t}));EI.displayName="TableBody";const NX=v.forwardRef(({className:e,...t},n)=>u.jsx("tfoot",{ref:n,className:ge("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",e),...t}));NX.displayName="TableFooter";const vc=v.forwardRef(({className:e,...t},n)=>u.jsx("tr",{ref:n,className:ge("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",e),...t}));vc.displayName="TableRow";const TI=v.forwardRef(({className:e,...t},n)=>u.jsx("th",{ref:n,className:ge("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",e),...t}));TI.displayName="TableHead";const Ep=v.forwardRef(({className:e,...t},n)=>u.jsx("td",{ref:n,className:ge("p-4 align-middle [&:has([role=checkbox])]:pr-0",e),...t}));Ep.displayName="TableCell";const IX=v.forwardRef(({className:e,...t},n)=>u.jsx("caption",{ref:n,className:ge("mt-4 text-sm text-muted-foreground",e),...t}));IX.displayName="TableCaption";function Nu({columns:e,data:t,isLoading:n,loadingMessage:r,noResultsMessage:s,enableHeaders:o=!0,className:a,highlightedRows:l,...c}){var d;const i=OX({...c,data:t,columns:e,getCoreRowModel:wX(),getFilteredRowModel:TX(),getGroupedRowModel:kX(),getSortedRowModel:jX()});return u.jsx("div",{className:ge("rounded-md border",a),children:u.jsxs(SI,{children:[o&&u.jsx(CI,{children:i.getHeaderGroups().map(p=>u.jsx(vc,{children:p.headers.map(f=>u.jsx(TI,{children:f.isPlaceholder?null:tE(f.column.columnDef.header,f.getContext())},f.id))},p.id))}),u.jsx(EI,{children:n?u.jsx(vc,{children:u.jsx(Ep,{colSpan:e.length,className:"h-24 text-center text-muted-foreground",children:r??"Carregando..."})}):u.jsx(u.Fragment,{children:(d=i.getRowModel().rows)!=null&&d.length?i.getRowModel().rows.map(p=>u.jsx(vc,{"data-state":p.getIsSelected()?"selected":l!=null&&l.includes(p.id)?"highlighted":"",children:p.getVisibleCells().map(f=>u.jsx(Ep,{children:tE(f.column.columnDef.cell,f.getContext())},f.id))},p.id)):u.jsx(vc,{children:u.jsx(Ep,{colSpan:e.length,className:"h-24 text-center",children:s??"Nenhum resultado encontrado!"})})})})]})})}const DX=e=>["dify","fetchSessions",JSON.stringify(e)],AX=async({difyId:e,instanceName:t})=>(await he.get(`/dify/fetchSessions/${e}/${t}`)).data,FX=e=>{const{difyId:t,instanceName:n,...r}=e;return lt({...r,queryKey:DX({difyId:t,instanceName:n}),queryFn:()=>AX({difyId:t,instanceName:n}),enabled:!!n&&!!t&&(e.enabled??!0),staleTime:1e3*10})};function kI({difyId:e}){const{t}=ze(),{instance:n}=nt(),{changeStatusDify:r}=Qg(),[s,o]=v.useState([]),{data:a,refetch:l}=FX({difyId:e,instanceName:n==null?void 0:n.name}),[c,i]=v.useState(!1),[d,p]=v.useState("");function f(){l()}const h=async(m,x)=>{var b,y,w;try{if(!n)return;await r({instanceName:n.name,token:n.token,remoteJid:m,status:x}),X.success(t("dify.toast.success.status")),f()}catch(S){console.error("Error:",S),X.error(`Error : ${(w=(y=(b=S==null?void 0:S.response)==null?void 0:b.data)==null?void 0:y.response)==null?void 0:w.message}`)}},g=[{accessorKey:"remoteJid",header:()=>u.jsx("div",{className:"text-center",children:t("dify.sessions.table.remoteJid")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("remoteJid")})},{accessorKey:"pushName",header:()=>u.jsx("div",{className:"text-center",children:t("dify.sessions.table.pushName")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("pushName")})},{accessorKey:"sessionId",header:()=>u.jsx("div",{className:"text-center",children:t("dify.sessions.table.sessionId")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("sessionId")})},{accessorKey:"status",header:()=>u.jsx("div",{className:"text-center",children:t("dify.sessions.table.status")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("status")})},{id:"actions",enableHiding:!1,cell:({row:m})=>{const x=m.original;return u.jsxs(Eo,{children:[u.jsx(To,{asChild:!0,children:u.jsxs(q,{variant:"ghost",className:"h-8 w-8 p-0",children:[u.jsx("span",{className:"sr-only",children:t("dify.sessions.table.actions.title")}),u.jsx(vu,{className:"h-4 w-4"})]})}),u.jsxs(ps,{align:"end",children:[u.jsx(Ai,{children:t("dify.sessions.table.actions.title")}),u.jsx(Pa,{}),x.status!=="opened"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"opened"),children:[u.jsx(qd,{className:"mr-2 h-4 w-4"}),t("dify.sessions.table.actions.open")]}),x.status!=="paused"&&x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"paused"),children:[u.jsx(Kd,{className:"mr-2 h-4 w-4"}),t("dify.sessions.table.actions.pause")]}),x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"closed"),children:[u.jsx(Ud,{className:"mr-2 h-4 w-4"}),t("dify.sessions.table.actions.close")]}),u.jsxs(ft,{onClick:()=>h(x.remoteJid,"delete"),children:[u.jsx(Vd,{className:"mr-2 h-4 w-4"}),t("dify.sessions.table.actions.delete")]})]})]})}}];return u.jsxs(Tt,{open:c,onOpenChange:i,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Hd,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:t("dify.sessions.label")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-w-[950px]",onCloseAutoFocus:f,children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("dify.sessions.label")})}),u.jsxs("div",{children:[u.jsxs("div",{className:"flex items-center justify-between gap-6 p-5",children:[u.jsx(K,{placeholder:t("dify.sessions.search"),value:d,onChange:m=>p(m.target.value)}),u.jsx(q,{variant:"outline",onClick:f,size:"icon",children:u.jsx(Wd,{})})]}),u.jsx(Nu,{columns:g,data:a??[],onSortingChange:o,state:{sorting:s,globalFilter:d},onGlobalFilterChange:p,enableGlobalFilter:!0,noResultsMessage:t("dify.sessions.table.none")})]})]})]})}const LX=_.object({enabled:_.boolean(),description:_.string(),botType:_.string(),apiUrl:_.string(),apiKey:_.string(),triggerType:_.string(),triggerOperator:_.string().optional(),triggerValue:_.string().optional(),expire:_.coerce.number().optional(),keywordFinish:_.string().optional(),delayMessage:_.coerce.number().optional(),unknownMessage:_.string().optional(),listeningFromMe:_.boolean().optional(),stopBotFromMe:_.boolean().optional(),keepOpen:_.boolean().optional(),debounceTime:_.coerce.number().optional(),splitMessages:_.boolean().optional(),timePerChar:_.coerce.number().optional()});function _I({initialData:e,onSubmit:t,handleDelete:n,difyId:r,isModal:s=!1,isLoading:o=!1,openDeletionDialog:a=!1,setOpenDeletionDialog:l=()=>{}}){const{t:c}=ze(),i=sn({resolver:on(LX),defaultValues:e||{enabled:!0,description:"",botType:"chatBot",apiUrl:"",apiKey:"",triggerType:"keyword",triggerOperator:"contains",triggerValue:"",expire:0,keywordFinish:"",delayMessage:0,unknownMessage:"",listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:0,splitMessages:!1,timePerChar:0}}),d=i.watch("triggerType");return u.jsx(Tr,{...i,children:u.jsxs("form",{onSubmit:i.handleSubmit(t),className:"w-full space-y-6",children:[u.jsxs("div",{className:"space-y-4",children:[u.jsx(ke,{name:"enabled",label:c("dify.form.enabled.label"),reverse:!0}),u.jsx(G,{name:"description",label:c("dify.form.description.label"),required:!0,children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("dify.form.difySettings.label")}),u.jsx($t,{})]}),u.jsx(Qt,{name:"botType",label:c("dify.form.botType.label"),options:[{label:c("dify.form.botType.chatBot"),value:"chatBot"},{label:c("dify.form.botType.textGenerator"),value:"textGenerator"},{label:c("dify.form.botType.agent"),value:"agent"},{label:c("dify.form.botType.workflow"),value:"workflow"}]}),u.jsx(G,{name:"apiUrl",label:c("dify.form.apiUrl.label"),required:!0,children:u.jsx(K,{})}),u.jsx(G,{name:"apiKey",label:c("dify.form.apiKey.label"),required:!0,children:u.jsx(K,{type:"password"})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("dify.form.triggerSettings.label")}),u.jsx($t,{})]}),u.jsx(Qt,{name:"triggerType",label:c("dify.form.triggerType.label"),options:[{label:c("dify.form.triggerType.keyword"),value:"keyword"},{label:c("dify.form.triggerType.all"),value:"all"},{label:c("dify.form.triggerType.advanced"),value:"advanced"},{label:c("dify.form.triggerType.none"),value:"none"}]}),d==="keyword"&&u.jsxs(u.Fragment,{children:[u.jsx(Qt,{name:"triggerOperator",label:c("dify.form.triggerOperator.label"),options:[{label:c("dify.form.triggerOperator.contains"),value:"contains"},{label:c("dify.form.triggerOperator.equals"),value:"equals"},{label:c("dify.form.triggerOperator.startsWith"),value:"startsWith"},{label:c("dify.form.triggerOperator.endsWith"),value:"endsWith"},{label:c("dify.form.triggerOperator.regex"),value:"regex"}]}),u.jsx(G,{name:"triggerValue",label:c("dify.form.triggerValue.label"),children:u.jsx(K,{})})]}),d==="advanced"&&u.jsx(G,{name:"triggerValue",label:c("dify.form.triggerConditions.label"),children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("dify.form.generalSettings.label")}),u.jsx($t,{})]}),u.jsx(G,{name:"expire",label:c("dify.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:c("dify.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:c("dify.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:c("dify.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:c("dify.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:c("dify.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:c("dify.form.keepOpen.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:c("dify.form.debounceTime.label"),children:u.jsx(K,{type:"number"})}),u.jsx(ke,{name:"splitMessages",label:c("dify.form.splitMessages.label"),reverse:!0}),i.watch("splitMessages")&&u.jsx(G,{name:"timePerChar",label:c("dify.form.timePerChar.label"),children:u.jsx(K,{type:"number"})})]}),s&&u.jsx(rn,{children:u.jsx(q,{disabled:o,type:"submit",children:c(o?"dify.button.saving":"dify.button.save")})}),!s&&u.jsxs("div",{children:[u.jsx(kI,{difyId:r}),u.jsxs("div",{className:"mt-5 flex items-center gap-3",children:[u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsx(q,{variant:"destructive",size:"sm",children:c("dify.button.delete")})}),u.jsx(xt,{children:u.jsxs(wt,{children:[u.jsx(Ut,{children:c("modal.delete.title")}),u.jsx(Fi,{children:c("modal.delete.messageSingle")}),u.jsxs(rn,{children:[u.jsx(q,{size:"sm",variant:"outline",onClick:()=>l(!1),children:c("button.cancel")}),u.jsx(q,{variant:"destructive",onClick:n,children:c("button.delete")})]})]})})]}),u.jsx(q,{disabled:o,type:"submit",children:c(o?"dify.button.saving":"dify.button.update")})]})]})]})})}function $X({resetTable:e}){const{t}=ze(),{instance:n}=nt(),[r,s]=v.useState(!1),[o,a]=v.useState(!1),{createDify:l}=Qg(),c=async i=>{var d,p,f;try{if(!n||!n.name)throw new Error("instance not found");s(!0);const h={enabled:i.enabled,description:i.description,botType:i.botType,apiUrl:i.apiUrl,apiKey:i.apiKey,triggerType:i.triggerType,triggerOperator:i.triggerOperator||"",triggerValue:i.triggerValue||"",expire:i.expire||0,keywordFinish:i.keywordFinish||"",delayMessage:i.delayMessage||0,unknownMessage:i.unknownMessage||"",listeningFromMe:i.listeningFromMe||!1,stopBotFromMe:i.stopBotFromMe||!1,keepOpen:i.keepOpen||!1,debounceTime:i.debounceTime||0,splitMessages:i.splitMessages||!1,timePerChar:i.timePerChar||0};await l({instanceName:n.name,token:n.token,data:h}),X.success(t("dify.toast.success.create")),a(!1),e()}catch(h){console.error("Error:",h),X.error(`Error: ${(f=(p=(d=h==null?void 0:h.response)==null?void 0:d.data)==null?void 0:p.response)==null?void 0:f.message}`)}finally{s(!1)}};return u.jsxs(Tt,{open:o,onOpenChange:a,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{size:"sm",children:[u.jsx(Ni,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:t("dify.button.create")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("dify.form.title")})}),u.jsx(_I,{onSubmit:c,isModal:!0,isLoading:r})]})]})}const BX=e=>["dify","getDify",JSON.stringify(e)],zX=async({difyId:e,instanceName:t})=>(await he.get(`/dify/fetch/${e}/${t}`)).data,UX=e=>{const{difyId:t,instanceName:n,...r}=e;return lt({...r,queryKey:BX({difyId:t,instanceName:n}),queryFn:()=>zX({difyId:t,instanceName:n}),enabled:!!n&&!!t&&(e.enabled??!0)})};function VX({difyId:e,resetTable:t}){const{t:n}=ze(),{instance:r}=nt(),s=An(),[o,a]=v.useState(!1),{deleteDify:l,updateDify:c}=Qg(),{data:i,isLoading:d}=UX({difyId:e,instanceName:r==null?void 0:r.name}),p=v.useMemo(()=>({enabled:!!(i!=null&&i.enabled),description:(i==null?void 0:i.description)??"",botType:(i==null?void 0:i.botType)??"",apiUrl:(i==null?void 0:i.apiUrl)??"",apiKey:(i==null?void 0:i.apiKey)??"",triggerType:(i==null?void 0:i.triggerType)??"",triggerOperator:(i==null?void 0:i.triggerOperator)??"",triggerValue:(i==null?void 0:i.triggerValue)??"",expire:(i==null?void 0:i.expire)??0,keywordFinish:(i==null?void 0:i.keywordFinish)??"",delayMessage:(i==null?void 0:i.delayMessage)??0,unknownMessage:(i==null?void 0:i.unknownMessage)??"",listeningFromMe:!!(i!=null&&i.listeningFromMe),stopBotFromMe:!!(i!=null&&i.stopBotFromMe),keepOpen:!!(i!=null&&i.keepOpen),debounceTime:(i==null?void 0:i.debounceTime)??0,splitMessages:(i==null?void 0:i.splitMessages)??!1,timePerChar:(i==null?void 0:i.timePerChar)??0}),[i==null?void 0:i.apiKey,i==null?void 0:i.apiUrl,i==null?void 0:i.botType,i==null?void 0:i.debounceTime,i==null?void 0:i.delayMessage,i==null?void 0:i.description,i==null?void 0:i.enabled,i==null?void 0:i.expire,i==null?void 0:i.keepOpen,i==null?void 0:i.keywordFinish,i==null?void 0:i.listeningFromMe,i==null?void 0:i.stopBotFromMe,i==null?void 0:i.triggerOperator,i==null?void 0:i.triggerType,i==null?void 0:i.triggerValue,i==null?void 0:i.unknownMessage,i==null?void 0:i.splitMessages,i==null?void 0:i.timePerChar]),f=async g=>{var m,x,b;try{if(r&&r.name&&e){const y={enabled:g.enabled,description:g.description,botType:g.botType,apiUrl:g.apiUrl,apiKey:g.apiKey,triggerType:g.triggerType,triggerOperator:g.triggerOperator||"",triggerValue:g.triggerValue||"",expire:g.expire||0,keywordFinish:g.keywordFinish||"",delayMessage:g.delayMessage||1e3,unknownMessage:g.unknownMessage||"",listeningFromMe:g.listeningFromMe||!1,stopBotFromMe:g.stopBotFromMe||!1,keepOpen:g.keepOpen||!1,debounceTime:g.debounceTime||0,splitMessages:g.splitMessages||!1,timePerChar:g.timePerChar||0};await c({instanceName:r.name,difyId:e,data:y}),X.success(n("dify.toast.success.update")),t(),s(`/manager/instance/${r.id}/dify/${e}`)}else console.error("Token not found")}catch(y){console.error("Error:",y),X.error(`Error: ${(b=(x=(m=y==null?void 0:y.response)==null?void 0:m.data)==null?void 0:x.response)==null?void 0:b.message}`)}},h=async()=>{try{r&&r.name&&e?(await l({instanceName:r.name,difyId:e}),X.success(n("dify.toast.success.delete")),a(!1),t(),s(`/manager/instance/${r.id}/dify`)):console.error("instance not found")}catch(g){console.error("Erro ao excluir dify:",g)}};return d?u.jsx(wr,{}):u.jsx("div",{className:"m-4",children:u.jsx(_I,{initialData:p,onSubmit:f,difyId:e,handleDelete:h,isModal:!1,isLoading:d,openDeletionDialog:o,setOpenDeletionDialog:a})})}function nE(){const{t:e}=ze(),t=Ou("(min-width: 768px)"),{instance:n}=nt(),{difyId:r}=So(),{data:s,refetch:o,isLoading:a}=dI({instanceName:n==null?void 0:n.name}),l=An(),c=d=>{n&&l(`/manager/instance/${n.id}/dify/${d}`)},i=()=>{o()};return u.jsxs("main",{className:"pt-5",children:[u.jsxs("div",{className:"mb-1 flex items-center justify-between",children:[u.jsx("h3",{className:"text-lg font-medium",children:e("dify.title")}),u.jsxs("div",{className:"flex items-center justify-end gap-2",children:[u.jsx(kI,{}),u.jsx(FY,{}),u.jsx($X,{resetTable:i})]})]}),u.jsx($t,{className:"my-4"}),u.jsxs(Pu,{direction:t?"horizontal":"vertical",children:[u.jsx(Ur,{defaultSize:35,className:"pr-4",children:u.jsx("div",{className:"flex flex-col gap-3",children:a?u.jsx(wr,{}):u.jsx(u.Fragment,{children:s&&s.length>0&&Array.isArray(s)?s.map(d=>u.jsxs(q,{className:"flex h-auto flex-col items-start justify-start",onClick:()=>c(`${d.id}`),variant:r===d.id?"secondary":"outline",children:[u.jsx("h4",{className:"text-base",children:d.description||d.id}),u.jsx("p",{className:"text-sm font-normal text-muted-foreground",children:d.botType})]},d.id)):u.jsx(q,{variant:"link",children:e("dify.table.none")})})})}),r&&u.jsxs(u.Fragment,{children:[u.jsx(Mu,{withHandle:!0,className:"border border-border"}),u.jsx(Ur,{children:u.jsx(VX,{difyId:r,resetTable:i})})]})]})]})}const HX=e=>["evolutionBot","findEvolutionBot",JSON.stringify(e)],KX=async({instanceName:e,token:t})=>(await he.get(`/evolutionBot/find/${e}`,{headers:{apiKey:t}})).data,jI=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:HX({instanceName:t}),queryFn:()=>KX({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},qX=e=>["evolutionBot","fetchDefaultSettings",JSON.stringify(e)],WX=async({instanceName:e,token:t})=>{const n=await he.get(`/evolutionBot/fetchSettings/${e}`,{headers:{apiKey:t}});return Array.isArray(n.data)?n.data[0]:n.data},GX=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:qX({instanceName:t}),queryFn:()=>WX({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},JX=async({instanceName:e,token:t,data:n})=>(await he.post(`/evolutionBot/create/${e}`,n,{headers:{apikey:t}})).data,QX=async({instanceName:e,token:t,evolutionBotId:n,data:r})=>(await he.put(`/evolutionBot/update/${n}/${e}`,r,{headers:{apikey:t}})).data,ZX=async({instanceName:e,evolutionBotId:t})=>(await he.delete(`/evolutionBot/delete/${t}/${e}`)).data,YX=async({instanceName:e,token:t,data:n})=>(await he.post(`/evolutionBot/settings/${e}`,n,{headers:{apikey:t}})).data,XX=async({instanceName:e,token:t,remoteJid:n,status:r})=>(await he.post(`/evolutionBot/changeStatus/${e}`,{remoteJid:n,status:r},{headers:{apikey:t}})).data;function Xg(){const e=Ye(YX,{invalidateKeys:[["evolutionBot","fetchDefaultSettings"]]}),t=Ye(XX,{invalidateKeys:[["evolutionBot","getEvolutionBot"],["evolutionBot","fetchSessions"]]}),n=Ye(ZX,{invalidateKeys:[["evolutionBot","getEvolutionBot"],["evolutionBot","findEvolutionBot"],["evolutionBot","fetchSessions"]]}),r=Ye(QX,{invalidateKeys:[["evolutionBot","getEvolutionBot"],["evolutionBot","findEvolutionBot"],["evolutionBot","fetchSessions"]]}),s=Ye(JX,{invalidateKeys:[["evolutionBot","findEvolutionBot"]]});return{setDefaultSettingsEvolutionBot:e,changeStatusEvolutionBot:t,deleteEvolutionBot:n,updateEvolutionBot:r,createEvolutionBot:s}}const eee=_.object({expire:_.string(),keywordFinish:_.string(),delayMessage:_.string(),unknownMessage:_.string(),listeningFromMe:_.boolean(),stopBotFromMe:_.boolean(),keepOpen:_.boolean(),debounceTime:_.string(),ignoreJids:_.array(_.string()).default([]),botIdFallback:_.union([_.null(),_.string()]).optional(),splitMessages:_.boolean(),timePerChar:_.string()});function tee(){const{t:e}=ze(),{instance:t}=nt(),[n,r]=v.useState(!1),{data:s,refetch:o}=GX({instanceName:t==null?void 0:t.name,enabled:n}),{data:a,refetch:l}=jI({instanceName:t==null?void 0:t.name,enabled:n}),{setDefaultSettingsEvolutionBot:c}=Xg(),i=sn({resolver:on(eee),defaultValues:{expire:"0",keywordFinish:e("evolutionBot.form.examples.keywordFinish"),delayMessage:"1000",unknownMessage:e("evolutionBot.form.examples.unknownMessage"),listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:"0",ignoreJids:[],botIdFallback:void 0,splitMessages:!1,timePerChar:"0"}});v.useEffect(()=>{s&&i.reset({expire:s!=null&&s.expire?s.expire.toString():"0",keywordFinish:s.keywordFinish,delayMessage:s.delayMessage?s.delayMessage.toString():"0",unknownMessage:s.unknownMessage,listeningFromMe:s.listeningFromMe,stopBotFromMe:s.stopBotFromMe,keepOpen:s.keepOpen,debounceTime:s.debounceTime?s.debounceTime.toString():"0",ignoreJids:s.ignoreJids,botIdFallback:s.botIdFallback,splitMessages:s.splitMessages,timePerChar:s.timePerChar?s.timePerChar.toString():"0"})},[s]);const d=async f=>{var h,g,m;try{if(!t||!t.name)throw new Error("instance not found.");const x={expire:parseInt(f.expire),keywordFinish:f.keywordFinish,delayMessage:parseInt(f.delayMessage),unknownMessage:f.unknownMessage,listeningFromMe:f.listeningFromMe,stopBotFromMe:f.stopBotFromMe,keepOpen:f.keepOpen,debounceTime:parseInt(f.debounceTime),botIdFallback:f.botIdFallback||void 0,ignoreJids:f.ignoreJids,splitMessages:f.splitMessages,timePerChar:parseInt(f.timePerChar)};await c({instanceName:t.name,token:t.token,data:x}),X.success(e("evolutionBot.toast.defaultSettings.success"))}catch(x){console.error("Error:",x),X.error(`Error: ${(m=(g=(h=x==null?void 0:x.response)==null?void 0:h.data)==null?void 0:g.response)==null?void 0:m.message}`)}};function p(){o(),l()}return u.jsxs(Tt,{open:n,onOpenChange:r,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Oi,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:e("evolutionBot.defaultSettings")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",onCloseAutoFocus:p,children:[u.jsx(wt,{children:u.jsx(Ut,{children:e("evolutionBot.defaultSettings")})}),u.jsx(Tr,{...i,children:u.jsxs("form",{className:"w-full space-y-6",onSubmit:i.handleSubmit(d),children:[u.jsx("div",{children:u.jsxs("div",{className:"space-y-4",children:[u.jsx(Qt,{name:"botIdFallback",label:e("evolutionBot.form.botIdFallback.label"),options:(a==null?void 0:a.filter(f=>!!f.id).map(f=>({label:f.description,value:f.id})))??[]}),u.jsx(G,{name:"expire",label:e("evolutionBot.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:e("evolutionBot.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:e("evolutionBot.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:e("evolutionBot.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:e("evolutionBot.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:e("evolutionBot.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:e("evolutionBot.form.keepOpen.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:e("evolutionBot.form.debounceTime.label"),children:u.jsx(K,{type:"number"})}),u.jsx(ke,{name:"splitMessages",label:e("evolutionBot.form.splitMessages.label"),reverse:!0}),i.watch("splitMessages")&&u.jsx(G,{name:"timePerChar",label:e("evolutionBot.form.timePerChar.label"),children:u.jsx(K,{type:"number"})}),u.jsx(Ru,{name:"ignoreJids",label:e("evolutionBot.form.ignoreJids.label"),placeholder:e("evolutionBot.form.ignoreJids.placeholder")})]})}),u.jsx(rn,{children:u.jsx(q,{type:"submit",children:e("evolutionBot.button.save")})})]})})]})]})}const nee=e=>["evolutionBot","fetchSessions",JSON.stringify(e)],ree=async({instanceName:e,evolutionBotId:t,token:n})=>(await he.get(`/evolutionBot/fetchSessions/${t}/${e}`,{headers:{apiKey:n}})).data,see=e=>{const{instanceName:t,token:n,evolutionBotId:r,...s}=e;return lt({...s,queryKey:nee({instanceName:t}),queryFn:()=>ree({instanceName:t,token:n,evolutionBotId:r}),enabled:!!t&&!!r&&(e.enabled??!0)})};function RI({evolutionBotId:e}){const{t}=ze(),{instance:n}=nt(),[r,s]=v.useState([]),[o,a]=v.useState(!1),[l,c]=v.useState(""),{data:i,refetch:d}=see({instanceName:n==null?void 0:n.name,evolutionBotId:e,enabled:o}),{changeStatusEvolutionBot:p}=Xg();function f(){d()}const h=async(m,x)=>{var b,y,w;try{if(!n)return;await p({instanceName:n.name,token:n.token,remoteJid:m,status:x}),X.success(t("evolutionBot.toast.success.status")),f()}catch(S){console.error("Error:",S),X.error(`Error : ${(w=(y=(b=S==null?void 0:S.response)==null?void 0:b.data)==null?void 0:y.response)==null?void 0:w.message}`)}},g=[{accessorKey:"remoteJid",header:()=>u.jsx("div",{className:"text-center",children:t("evolutionBot.sessions.table.remoteJid")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("remoteJid")})},{accessorKey:"pushName",header:()=>u.jsx("div",{className:"text-center",children:t("evolutionBot.sessions.table.pushName")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("pushName")})},{accessorKey:"sessionId",header:()=>u.jsx("div",{className:"text-center",children:t("evolutionBot.sessions.table.sessionId")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("sessionId")})},{accessorKey:"status",header:()=>u.jsx("div",{className:"text-center",children:t("evolutionBot.sessions.table.status")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("status")})},{id:"actions",enableHiding:!1,cell:({row:m})=>{const x=m.original;return u.jsxs(Eo,{children:[u.jsx(To,{asChild:!0,children:u.jsxs(q,{variant:"ghost",className:"h-8 w-8 p-0",children:[u.jsx("span",{className:"sr-only",children:t("evolutionBot.sessions.table.actions.title")}),u.jsx(vu,{className:"h-4 w-4"})]})}),u.jsxs(ps,{align:"end",children:[u.jsx(Ai,{children:t("evolutionBot.sessions.table.actions.title")}),u.jsx(Pa,{}),x.status!=="opened"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"opened"),children:[u.jsx(qd,{className:"mr-2 h-4 w-4"}),t("evolutionBot.sessions.table.actions.open")]}),x.status!=="paused"&&x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"paused"),children:[u.jsx(Kd,{className:"mr-2 h-4 w-4"}),t("evolutionBot.sessions.table.actions.pause")]}),x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"closed"),children:[u.jsx(Ud,{className:"mr-2 h-4 w-4"}),t("evolutionBot.sessions.table.actions.close")]}),u.jsxs(ft,{onClick:()=>h(x.remoteJid,"delete"),children:[u.jsx(Vd,{className:"mr-2 h-4 w-4"}),t("evolutionBot.sessions.table.actions.delete")]})]})]})}}];return u.jsxs(Tt,{open:o,onOpenChange:a,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Hd,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:t("evolutionBot.sessions.label")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-w-[950px]",onCloseAutoFocus:f,children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("evolutionBot.sessions.label")})}),u.jsxs("div",{children:[u.jsxs("div",{className:"flex items-center justify-between gap-6 p-5",children:[u.jsx(K,{placeholder:t("evolutionBot.sessions.search"),value:l,onChange:m=>c(m.target.value)}),u.jsx(q,{variant:"outline",onClick:f,size:"icon",children:u.jsx(Wd,{})})]}),u.jsx(Nu,{columns:g,data:i??[],onSortingChange:s,state:{sorting:r,globalFilter:l},onGlobalFilterChange:c,enableGlobalFilter:!0,noResultsMessage:t("evolutionBot.sessions.table.none")})]})]})]})}const oee=_.object({enabled:_.boolean(),description:_.string(),apiUrl:_.string(),apiKey:_.string().optional(),triggerType:_.string(),triggerOperator:_.string().optional(),triggerValue:_.string().optional(),expire:_.coerce.number().optional(),keywordFinish:_.string().optional(),delayMessage:_.coerce.number().optional(),unknownMessage:_.string().optional(),listeningFromMe:_.boolean().optional(),stopBotFromMe:_.boolean().optional(),keepOpen:_.boolean().optional(),debounceTime:_.coerce.number().optional(),splitMessages:_.boolean().optional(),timePerChar:_.coerce.number().optional()});function PI({initialData:e,onSubmit:t,handleDelete:n,evolutionBotId:r,isModal:s=!1,isLoading:o=!1,openDeletionDialog:a=!1,setOpenDeletionDialog:l=()=>{}}){const{t:c}=ze(),i=sn({resolver:on(oee),defaultValues:e||{enabled:!0,description:"",apiUrl:"",apiKey:"",triggerType:"keyword",triggerOperator:"contains",triggerValue:"",expire:0,keywordFinish:"",delayMessage:0,unknownMessage:"",listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:0,splitMessages:!1,timePerChar:0}}),d=i.watch("triggerType");return u.jsx(Tr,{...i,children:u.jsxs("form",{onSubmit:i.handleSubmit(t),className:"w-full space-y-6",children:[u.jsxs("div",{className:"space-y-4",children:[u.jsx(ke,{name:"enabled",label:c("evolutionBot.form.enabled.label"),reverse:!0}),u.jsx(G,{name:"description",label:c("evolutionBot.form.description.label"),required:!0,children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("evolutionBot.form.evolutionBotSettings.label")}),u.jsx($t,{})]}),u.jsx(G,{name:"apiUrl",label:c("evolutionBot.form.apiUrl.label"),required:!0,children:u.jsx(K,{})}),u.jsx(G,{name:"apiKey",label:c("evolutionBot.form.apiKey.label"),children:u.jsx(K,{type:"password"})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("evolutionBot.form.triggerSettings.label")}),u.jsx($t,{})]}),u.jsx(Qt,{name:"triggerType",label:c("evolutionBot.form.triggerType.label"),options:[{label:c("evolutionBot.form.triggerType.keyword"),value:"keyword"},{label:c("evolutionBot.form.triggerType.all"),value:"all"},{label:c("evolutionBot.form.triggerType.advanced"),value:"advanced"},{label:c("evolutionBot.form.triggerType.none"),value:"none"}]}),d==="keyword"&&u.jsxs(u.Fragment,{children:[u.jsx(Qt,{name:"triggerOperator",label:c("evolutionBot.form.triggerOperator.label"),options:[{label:c("evolutionBot.form.triggerOperator.contains"),value:"contains"},{label:c("evolutionBot.form.triggerOperator.equals"),value:"equals"},{label:c("evolutionBot.form.triggerOperator.startsWith"),value:"startsWith"},{label:c("evolutionBot.form.triggerOperator.endsWith"),value:"endsWith"},{label:c("evolutionBot.form.triggerOperator.regex"),value:"regex"}]}),u.jsx(G,{name:"triggerValue",label:c("evolutionBot.form.triggerValue.label"),children:u.jsx(K,{})})]}),d==="advanced"&&u.jsx(G,{name:"triggerValue",label:c("evolutionBot.form.triggerConditions.label"),children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("evolutionBot.form.generalSettings.label")}),u.jsx($t,{})]}),u.jsx(G,{name:"expire",label:c("evolutionBot.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:c("evolutionBot.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:c("evolutionBot.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:c("evolutionBot.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:c("evolutionBot.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:c("evolutionBot.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:c("evolutionBot.form.keepOpen.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:c("evolutionBot.form.debounceTime.label"),children:u.jsx(K,{type:"number"})}),u.jsx(ke,{name:"splitMessages",label:c("evolutionBot.form.splitMessages.label"),reverse:!0}),i.watch("splitMessages")&&u.jsx(G,{name:"timePerChar",label:c("evolutionBot.form.timePerChar.label"),children:u.jsx(K,{type:"number"})})]}),s&&u.jsx(rn,{children:u.jsx(q,{disabled:o,type:"submit",children:c(o?"evolutionBot.button.saving":"evolutionBot.button.save")})}),!s&&u.jsxs("div",{children:[u.jsx(RI,{evolutionBotId:r}),u.jsxs("div",{className:"mt-5 flex items-center gap-3",children:[u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsx(q,{variant:"destructive",size:"sm",children:c("dify.button.delete")})}),u.jsx(xt,{children:u.jsxs(wt,{children:[u.jsx(Ut,{children:c("modal.delete.title")}),u.jsx(Fi,{children:c("modal.delete.messageSingle")}),u.jsxs(rn,{children:[u.jsx(q,{size:"sm",variant:"outline",onClick:()=>l(!1),children:c("button.cancel")}),u.jsx(q,{variant:"destructive",onClick:n,children:c("button.delete")})]})]})})]}),u.jsx(q,{disabled:o,type:"submit",children:c(o?"evolutionBot.button.saving":"evolutionBot.button.update")})]})]})]})})}function aee({resetTable:e}){const{t}=ze(),{instance:n}=nt(),[r,s]=v.useState(!1),[o,a]=v.useState(!1),{createEvolutionBot:l}=Xg(),c=async i=>{var d,p,f;try{if(!n||!n.name)throw new Error("instance not found");s(!0);const h={enabled:i.enabled,description:i.description,apiUrl:i.apiUrl,apiKey:i.apiKey,triggerType:i.triggerType,triggerOperator:i.triggerOperator||"",triggerValue:i.triggerValue||"",expire:i.expire||0,keywordFinish:i.keywordFinish||"",delayMessage:i.delayMessage||0,unknownMessage:i.unknownMessage||"",listeningFromMe:i.listeningFromMe||!1,stopBotFromMe:i.stopBotFromMe||!1,keepOpen:i.keepOpen||!1,debounceTime:i.debounceTime||0,splitMessages:i.splitMessages||!1,timePerChar:i.timePerChar?i.timePerChar:0};await l({instanceName:n.name,token:n.token,data:h}),X.success(t("evolutionBot.toast.success.create")),a(!1),e()}catch(h){console.error("Error:",h),X.error(`Error: ${(f=(p=(d=h==null?void 0:h.response)==null?void 0:d.data)==null?void 0:p.response)==null?void 0:f.message}`)}finally{s(!1)}};return u.jsxs(Tt,{open:o,onOpenChange:a,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{size:"sm",children:[u.jsx(Ni,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:t("evolutionBot.button.create")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("evolutionBot.form.title")})}),u.jsx(PI,{onSubmit:c,isModal:!0,isLoading:r})]})]})}const iee=e=>["evolutionBot","getEvolutionBot",JSON.stringify(e)],lee=async({instanceName:e,token:t,evolutionBotId:n})=>{const r=await he.get(`/evolutionBot/fetch/${n}/${e}`,{headers:{apiKey:t}});return Array.isArray(r.data)?r.data[0]:r.data},uee=e=>{const{instanceName:t,token:n,evolutionBotId:r,...s}=e;return lt({...s,queryKey:iee({instanceName:t}),queryFn:()=>lee({instanceName:t,token:n,evolutionBotId:r}),enabled:!!t&&!!r&&(e.enabled??!0)})};function cee({evolutionBotId:e,resetTable:t}){const{t:n}=ze(),{instance:r}=nt(),s=An(),[o,a]=v.useState(!1),{deleteEvolutionBot:l,updateEvolutionBot:c}=Xg(),{data:i,isLoading:d}=uee({instanceName:r==null?void 0:r.name,evolutionBotId:e}),p=v.useMemo(()=>({enabled:(i==null?void 0:i.enabled)??!0,description:(i==null?void 0:i.description)??"",apiUrl:(i==null?void 0:i.apiUrl)??"",apiKey:(i==null?void 0:i.apiKey)??"",triggerType:(i==null?void 0:i.triggerType)??"",triggerOperator:(i==null?void 0:i.triggerOperator)??"",triggerValue:i==null?void 0:i.triggerValue,expire:(i==null?void 0:i.expire)??0,keywordFinish:i==null?void 0:i.keywordFinish,delayMessage:(i==null?void 0:i.delayMessage)??0,unknownMessage:i==null?void 0:i.unknownMessage,listeningFromMe:i==null?void 0:i.listeningFromMe,stopBotFromMe:!!(i!=null&&i.stopBotFromMe),keepOpen:!!(i!=null&&i.keepOpen),debounceTime:(i==null?void 0:i.debounceTime)??0,splitMessages:(i==null?void 0:i.splitMessages)??!1,timePerChar:i!=null&&i.timePerChar?i==null?void 0:i.timePerChar:0}),[i==null?void 0:i.apiKey,i==null?void 0:i.apiUrl,i==null?void 0:i.debounceTime,i==null?void 0:i.delayMessage,i==null?void 0:i.description,i==null?void 0:i.enabled,i==null?void 0:i.expire,i==null?void 0:i.keepOpen,i==null?void 0:i.keywordFinish,i==null?void 0:i.listeningFromMe,i==null?void 0:i.stopBotFromMe,i==null?void 0:i.triggerOperator,i==null?void 0:i.triggerType,i==null?void 0:i.triggerValue,i==null?void 0:i.unknownMessage,i==null?void 0:i.splitMessages,i==null?void 0:i.timePerChar]),f=async g=>{var m,x,b;try{if(r&&r.name&&e){const y={enabled:g.enabled,description:g.description,apiUrl:g.apiUrl,apiKey:g.apiKey,triggerType:g.triggerType,triggerOperator:g.triggerOperator||"",triggerValue:g.triggerValue||"",expire:g.expire||0,keywordFinish:g.keywordFinish||"",delayMessage:g.delayMessage||1e3,unknownMessage:g.unknownMessage||"",listeningFromMe:g.listeningFromMe||!1,stopBotFromMe:g.stopBotFromMe||!1,keepOpen:g.keepOpen||!1,debounceTime:g.debounceTime||0,splitMessages:g.splitMessages||!1,timePerChar:g.timePerChar?g.timePerChar:0};await c({instanceName:r.name,evolutionBotId:e,data:y}),X.success(n("evolutionBot.toast.success.update")),t(),s(`/manager/instance/${r.id}/evolutionBot/${e}`)}else console.error("Token not found")}catch(y){console.error("Error:",y),X.error(`Error: ${(b=(x=(m=y==null?void 0:y.response)==null?void 0:m.data)==null?void 0:x.response)==null?void 0:b.message}`)}},h=async()=>{try{r&&r.name&&e?(await l({instanceName:r.name,evolutionBotId:e}),X.success(n("evolutionBot.toast.success.delete")),a(!1),t(),s(`/manager/instance/${r.id}/evolutionBot`)):console.error("instance not found")}catch(g){console.error("Erro ao excluir evolutionBot:",g)}};return d?u.jsx(wr,{}):u.jsx("div",{className:"m-4",children:u.jsx(PI,{initialData:p,onSubmit:f,evolutionBotId:e,handleDelete:h,isModal:!1,openDeletionDialog:o,setOpenDeletionDialog:a})})}function rE(){const{t:e}=ze(),t=Ou("(min-width: 768px)"),{instance:n}=nt(),{evolutionBotId:r}=So(),{data:s,isLoading:o,refetch:a}=jI({instanceName:n==null?void 0:n.name}),l=An(),c=d=>{n&&l(`/manager/instance/${n.id}/evolutionBot/${d}`)},i=()=>{a()};return u.jsxs("main",{className:"pt-5",children:[u.jsxs("div",{className:"mb-1 flex items-center justify-between",children:[u.jsx("h3",{className:"text-lg font-medium",children:e("evolutionBot.title")}),u.jsxs("div",{className:"flex items-center justify-end gap-2",children:[u.jsx(RI,{}),u.jsx(tee,{}),u.jsx(aee,{resetTable:i})]})]}),u.jsx($t,{className:"my-4"}),u.jsxs(Pu,{direction:t?"horizontal":"vertical",children:[u.jsx(Ur,{defaultSize:35,className:"pr-4",children:u.jsx("div",{className:"flex flex-col gap-3",children:o?u.jsx(wr,{}):u.jsx(u.Fragment,{children:s&&s.length>0&&Array.isArray(s)?s.map(d=>u.jsx(q,{className:"flex h-auto flex-col items-start justify-start",onClick:()=>c(`${d.id}`),variant:r===d.id?"secondary":"outline",children:u.jsx("h4",{className:"text-base",children:d.description||d.id})},d.id)):u.jsx(q,{variant:"link",children:e("evolutionBot.table.none")})})})}),r&&u.jsxs(u.Fragment,{children:[u.jsx(Mu,{withHandle:!0,className:"border border-border"}),u.jsx(Ur,{children:u.jsx(cee,{evolutionBotId:r,resetTable:i})})]})]})]})}const dee=e=>["flowise","findFlowise",JSON.stringify(e)],fee=async({instanceName:e,token:t})=>(await he.get(`/flowise/find/${e}`,{headers:{apiKey:t}})).data,MI=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:dee({instanceName:t}),queryFn:()=>fee({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},pee=e=>["flowise","fetchDefaultSettings",JSON.stringify(e)],hee=async({instanceName:e,token:t})=>{const n=await he.get(`/flowise/fetchSettings/${e}`,{headers:{apiKey:t}});return Array.isArray(n.data)?n.data[0]:n.data},gee=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:pee({instanceName:t}),queryFn:()=>hee({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},mee=async({instanceName:e,token:t,data:n})=>(await he.post(`/flowise/create/${e}`,n,{headers:{apikey:t}})).data,vee=async({instanceName:e,flowiseId:t,data:n})=>(await he.put(`/flowise/update/${t}/${e}`,n)).data,yee=async({instanceName:e,flowiseId:t})=>(await he.delete(`/flowise/delete/${t}/${e}`)).data,bee=async({instanceName:e,token:t,remoteJid:n,status:r})=>(await he.post(`/flowise/changeStatus/${e}`,{remoteJid:n,status:r},{headers:{apikey:t}})).data,xee=async({instanceName:e,token:t,data:n})=>(await he.post(`/flowise/settings/${e}`,n,{headers:{apikey:t}})).data;function em(){const e=Ye(xee,{invalidateKeys:[["flowise","fetchDefaultSettings"]]}),t=Ye(bee,{invalidateKeys:[["flowise","getFlowise"],["flowise","fetchSessions"]]}),n=Ye(yee,{invalidateKeys:[["flowise","getFlowise"],["flowise","findFlowise"],["flowise","fetchSessions"]]}),r=Ye(vee,{invalidateKeys:[["flowise","getFlowise"],["flowise","findFlowise"],["flowise","fetchSessions"]]}),s=Ye(mee,{invalidateKeys:[["flowise","findFlowise"]]});return{setDefaultSettingsFlowise:e,changeStatusFlowise:t,deleteFlowise:n,updateFlowise:r,createFlowise:s}}const wee=_.object({expire:_.string(),keywordFinish:_.string(),delayMessage:_.string(),unknownMessage:_.string(),listeningFromMe:_.boolean(),stopBotFromMe:_.boolean(),keepOpen:_.boolean(),debounceTime:_.string(),ignoreJids:_.array(_.string()).default([]),flowiseIdFallback:_.union([_.null(),_.string()]).optional(),splitMessages:_.boolean(),timePerChar:_.string()});function See(){const{t:e}=ze(),{instance:t}=nt(),{setDefaultSettingsFlowise:n}=em(),[r,s]=v.useState(!1),{data:o,refetch:a}=gee({instanceName:t==null?void 0:t.name,enabled:r}),{data:l,refetch:c}=MI({instanceName:t==null?void 0:t.name,enabled:r}),i=sn({resolver:on(wee),defaultValues:{expire:"0",keywordFinish:e("flowise.form.examples.keywordFinish"),delayMessage:"1000",unknownMessage:e("flowise.form.examples.unknownMessage"),listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:"0",ignoreJids:[],flowiseIdFallback:void 0,splitMessages:!1,timePerChar:"0"}});v.useEffect(()=>{o&&i.reset({expire:o!=null&&o.expire?o.expire.toString():"0",keywordFinish:o.keywordFinish,delayMessage:o.delayMessage?o.delayMessage.toString():"0",unknownMessage:o.unknownMessage,listeningFromMe:o.listeningFromMe,stopBotFromMe:o.stopBotFromMe,keepOpen:o.keepOpen,debounceTime:o.debounceTime?o.debounceTime.toString():"0",ignoreJids:o.ignoreJids,flowiseIdFallback:o.flowiseIdFallback,splitMessages:o.splitMessages,timePerChar:o.timePerChar?o.timePerChar.toString():"0"})},[o]);const d=async f=>{var h,g,m;try{if(!t||!t.name)throw new Error("instance not found.");const x={expire:parseInt(f.expire),keywordFinish:f.keywordFinish,delayMessage:parseInt(f.delayMessage),unknownMessage:f.unknownMessage,listeningFromMe:f.listeningFromMe,stopBotFromMe:f.stopBotFromMe,keepOpen:f.keepOpen,debounceTime:parseInt(f.debounceTime),flowiseIdFallback:f.flowiseIdFallback||void 0,ignoreJids:f.ignoreJids,splitMessages:f.splitMessages,timePerChar:parseInt(f.timePerChar)};await n({instanceName:t.name,token:t.token,data:x}),X.success(e("flowise.toast.defaultSettings.success"))}catch(x){console.error("Error:",x),X.error(`Error: ${(m=(g=(h=x==null?void 0:x.response)==null?void 0:h.data)==null?void 0:g.response)==null?void 0:m.message}`)}};function p(){a(),c()}return u.jsxs(Tt,{open:r,onOpenChange:s,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Oi,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:e("flowise.defaultSettings")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",onCloseAutoFocus:p,children:[u.jsx(wt,{children:u.jsx(Ut,{children:e("flowise.defaultSettings")})}),u.jsx(Tr,{...i,children:u.jsxs("form",{className:"w-full space-y-6",onSubmit:i.handleSubmit(d),children:[u.jsx("div",{children:u.jsxs("div",{className:"space-y-4",children:[u.jsx(Qt,{name:"flowiseIdFallback",label:e("flowise.form.flowiseIdFallback.label"),options:(l==null?void 0:l.filter(f=>!!f.id).map(f=>({label:f.description,value:f.id})))??[]}),u.jsx(G,{name:"expire",label:e("flowise.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:e("flowise.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:e("flowise.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:e("flowise.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:e("flowise.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:e("flowise.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:e("flowise.form.keepOpen.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:e("flowise.form.debounceTime.label"),children:u.jsx(K,{type:"number"})}),u.jsx(ke,{name:"splitMessages",label:e("flowise.form.splitMessages.label"),reverse:!0}),i.watch("splitMessages")&&u.jsx(G,{name:"timePerChar",label:e("flowise.form.timePerChar.label"),children:u.jsx(K,{type:"number"})}),u.jsx(Ru,{name:"ignoreJids",label:e("flowise.form.ignoreJids.label"),placeholder:e("flowise.form.ignoreJids.placeholder")})]})}),u.jsx(rn,{children:u.jsx(q,{type:"submit",children:e("flowise.button.save")})})]})})]})]})}const Cee=e=>["flowise","fetchSessions",JSON.stringify(e)],Eee=async({instanceName:e,flowiseId:t,token:n})=>(await he.get(`/flowise/fetchSessions/${t}/${e}`,{headers:{apiKey:n}})).data,Tee=e=>{const{instanceName:t,token:n,flowiseId:r,...s}=e;return lt({...s,queryKey:Cee({instanceName:t}),queryFn:()=>Eee({instanceName:t,token:n,flowiseId:r}),enabled:!!t&&!!r&&(e.enabled??!0)})};function OI({flowiseId:e}){const{t}=ze(),{instance:n}=nt(),{changeStatusFlowise:r}=em(),[s,o]=v.useState([]),[a,l]=v.useState(!1),[c,i]=v.useState(""),{data:d,refetch:p}=Tee({instanceName:n==null?void 0:n.name,flowiseId:e,enabled:a});function f(){p()}const h=async(m,x)=>{var b,y,w;try{if(!n)return;await r({instanceName:n.name,token:n.token,remoteJid:m,status:x}),X.success(t("flowise.toast.success.status")),f()}catch(S){console.error("Error:",S),X.error(`Error : ${(w=(y=(b=S==null?void 0:S.response)==null?void 0:b.data)==null?void 0:y.response)==null?void 0:w.message}`)}},g=[{accessorKey:"remoteJid",header:()=>u.jsx("div",{className:"text-center",children:t("flowise.sessions.table.remoteJid")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("remoteJid")})},{accessorKey:"pushName",header:()=>u.jsx("div",{className:"text-center",children:t("flowise.sessions.table.pushName")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("pushName")})},{accessorKey:"sessionId",header:()=>u.jsx("div",{className:"text-center",children:t("flowise.sessions.table.sessionId")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("sessionId")})},{accessorKey:"status",header:()=>u.jsx("div",{className:"text-center",children:t("flowise.sessions.table.status")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("status")})},{id:"actions",enableHiding:!1,cell:({row:m})=>{const x=m.original;return u.jsxs(Eo,{children:[u.jsx(To,{asChild:!0,children:u.jsxs(q,{variant:"ghost",className:"h-8 w-8 p-0",children:[u.jsx("span",{className:"sr-only",children:t("flowise.sessions.table.actions.title")}),u.jsx(vu,{className:"h-4 w-4"})]})}),u.jsxs(ps,{align:"end",children:[u.jsx(Ai,{children:t("flowise.sessions.table.actions.title")}),u.jsx(Pa,{}),x.status!=="opened"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"opened"),children:[u.jsx(qd,{className:"mr-2 h-4 w-4"}),t("flowise.sessions.table.actions.open")]}),x.status!=="paused"&&x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"paused"),children:[u.jsx(Kd,{className:"mr-2 h-4 w-4"}),t("flowise.sessions.table.actions.pause")]}),x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"closed"),children:[u.jsx(Ud,{className:"mr-2 h-4 w-4"}),t("flowise.sessions.table.actions.close")]}),u.jsxs(ft,{onClick:()=>h(x.remoteJid,"delete"),children:[u.jsx(Vd,{className:"mr-2 h-4 w-4"}),t("flowise.sessions.table.actions.delete")]})]})]})}}];return u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Hd,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:t("flowise.sessions.label")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-w-[950px]",onCloseAutoFocus:f,children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("flowise.sessions.label")})}),u.jsxs("div",{children:[u.jsxs("div",{className:"flex items-center justify-between gap-6 p-5",children:[u.jsx(K,{placeholder:t("flowise.sessions.search"),value:c,onChange:m=>i(m.target.value)}),u.jsx(q,{variant:"outline",onClick:f,size:"icon",children:u.jsx(Wd,{})})]}),u.jsx(Nu,{columns:g,data:d??[],onSortingChange:o,state:{sorting:s,globalFilter:c},onGlobalFilterChange:i,enableGlobalFilter:!0,noResultsMessage:t("flowise.sessions.table.none")})]})]})]})}const kee=_.object({enabled:_.boolean(),description:_.string(),apiUrl:_.string(),apiKey:_.string().optional(),triggerType:_.string(),triggerOperator:_.string().optional(),triggerValue:_.string().optional(),expire:_.coerce.number().optional(),keywordFinish:_.string().optional(),delayMessage:_.coerce.number().optional(),unknownMessage:_.string().optional(),listeningFromMe:_.boolean().optional(),stopBotFromMe:_.boolean().optional(),keepOpen:_.boolean().optional(),debounceTime:_.coerce.number().optional(),splitMessages:_.boolean().optional(),timePerChar:_.coerce.number().optional()});function NI({initialData:e,onSubmit:t,handleDelete:n,flowiseId:r,isModal:s=!1,isLoading:o=!1,openDeletionDialog:a=!1,setOpenDeletionDialog:l=()=>{}}){const{t:c}=ze(),i=sn({resolver:on(kee),defaultValues:e||{enabled:!0,description:"",apiUrl:"",apiKey:"",triggerType:"keyword",triggerOperator:"contains",triggerValue:"",expire:0,keywordFinish:"",delayMessage:0,unknownMessage:"",listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:0,splitMessages:!1,timePerChar:0}}),d=i.watch("triggerType");return u.jsx(Tr,{...i,children:u.jsxs("form",{onSubmit:i.handleSubmit(t),className:"w-full space-y-6",children:[u.jsxs("div",{className:"space-y-4",children:[u.jsx(ke,{name:"enabled",label:c("flowise.form.enabled.label"),reverse:!0}),u.jsx(G,{name:"description",label:c("flowise.form.description.label"),required:!0,children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("flowise.form.flowiseSettings.label")}),u.jsx($t,{})]}),u.jsx(G,{name:"apiUrl",label:c("flowise.form.apiUrl.label"),required:!0,children:u.jsx(K,{})}),u.jsx(G,{name:"apiKey",label:c("flowise.form.apiKey.label"),children:u.jsx(K,{type:"password"})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("flowise.form.triggerSettings.label")}),u.jsx($t,{})]}),u.jsx(Qt,{name:"triggerType",label:c("flowise.form.triggerType.label"),options:[{label:c("flowise.form.triggerType.keyword"),value:"keyword"},{label:c("flowise.form.triggerType.all"),value:"all"},{label:c("flowise.form.triggerType.advanced"),value:"advanced"},{label:c("flowise.form.triggerType.none"),value:"none"}]}),d==="keyword"&&u.jsxs(u.Fragment,{children:[u.jsx(Qt,{name:"triggerOperator",label:c("flowise.form.triggerOperator.label"),options:[{label:c("flowise.form.triggerOperator.contains"),value:"contains"},{label:c("flowise.form.triggerOperator.equals"),value:"equals"},{label:c("flowise.form.triggerOperator.startsWith"),value:"startsWith"},{label:c("flowise.form.triggerOperator.endsWith"),value:"endsWith"},{label:c("flowise.form.triggerOperator.regex"),value:"regex"}]}),u.jsx(G,{name:"triggerValue",label:c("flowise.form.triggerValue.label"),children:u.jsx(K,{})})]}),d==="advanced"&&u.jsx(G,{name:"triggerValue",label:c("flowise.form.triggerConditions.label"),children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("flowise.form.generalSettings.label")}),u.jsx($t,{})]}),u.jsx(G,{name:"expire",label:c("flowise.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:c("flowise.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:c("flowise.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:c("flowise.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:c("flowise.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:c("flowise.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:c("flowise.form.keepOpen.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:c("flowise.form.debounceTime.label"),children:u.jsx(K,{type:"number"})}),u.jsx(ke,{name:"splitMessages",label:c("flowise.form.splitMessages.label"),reverse:!0}),i.watch("splitMessages")&&u.jsx(G,{name:"timePerChar",label:c("flowise.form.timePerChar.label"),children:u.jsx(K,{type:"number"})})]}),s&&u.jsx(rn,{children:u.jsx(q,{disabled:o,type:"submit",children:c(o?"flowise.button.saving":"flowise.button.save")})}),!s&&u.jsxs("div",{children:[u.jsx(OI,{flowiseId:r}),u.jsxs("div",{className:"mt-5 flex items-center gap-3",children:[u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsx(q,{variant:"destructive",size:"sm",children:c("dify.button.delete")})}),u.jsx(xt,{children:u.jsxs(wt,{children:[u.jsx(Ut,{children:c("modal.delete.title")}),u.jsx(Fi,{children:c("modal.delete.messageSingle")}),u.jsxs(rn,{children:[u.jsx(q,{size:"sm",variant:"outline",onClick:()=>l(!1),children:c("button.cancel")}),u.jsx(q,{variant:"destructive",onClick:n,children:c("button.delete")})]})]})})]}),u.jsx(q,{disabled:o,type:"submit",children:c(o?"flowise.button.saving":"flowise.button.update")})]})]})]})})}function _ee({resetTable:e}){const{t}=ze(),{instance:n}=nt(),{createFlowise:r}=em(),[s,o]=v.useState(!1),[a,l]=v.useState(!1),c=async i=>{var d,p,f;try{if(!n||!n.name)throw new Error("instance not found");o(!0);const h={enabled:i.enabled,description:i.description,apiUrl:i.apiUrl,apiKey:i.apiKey,triggerType:i.triggerType,triggerOperator:i.triggerOperator||"",triggerValue:i.triggerValue||"",expire:i.expire||0,keywordFinish:i.keywordFinish||"",delayMessage:i.delayMessage||0,unknownMessage:i.unknownMessage||"",listeningFromMe:i.listeningFromMe||!1,stopBotFromMe:i.stopBotFromMe||!1,keepOpen:i.keepOpen||!1,debounceTime:i.debounceTime||0,splitMessages:i.splitMessages||!1,timePerChar:i.timePerChar||0};await r({instanceName:n.name,token:n.token,data:h}),X.success(t("flowise.toast.success.create")),l(!1),e()}catch(h){console.error("Error:",h),X.error(`Error: ${(f=(p=(d=h==null?void 0:h.response)==null?void 0:d.data)==null?void 0:p.response)==null?void 0:f.message}`)}finally{o(!1)}};return u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{size:"sm",children:[u.jsx(Ni,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:t("flowise.button.create")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("flowise.form.title")})}),u.jsx(NI,{onSubmit:c,isModal:!0,isLoading:s})]})]})}const jee=e=>["flowise","getFlowise",JSON.stringify(e)],Ree=async({instanceName:e,token:t,flowiseId:n})=>{const r=await he.get(`/flowise/fetch/${n}/${e}`,{headers:{apiKey:t}});return Array.isArray(r.data)?r.data[0]:r.data},Pee=e=>{const{instanceName:t,token:n,flowiseId:r,...s}=e;return lt({...s,queryKey:jee({instanceName:t}),queryFn:()=>Ree({instanceName:t,token:n,flowiseId:r}),enabled:!!t&&!!r&&(e.enabled??!0)})};function Mee({flowiseId:e,resetTable:t}){const{t:n}=ze(),{instance:r}=nt(),s=An(),[o,a]=v.useState(!1),{deleteFlowise:l,updateFlowise:c}=em(),{data:i,isLoading:d}=Pee({instanceName:r==null?void 0:r.name,flowiseId:e}),p=v.useMemo(()=>({enabled:(i==null?void 0:i.enabled)??!0,description:(i==null?void 0:i.description)??"",apiUrl:(i==null?void 0:i.apiUrl)??"",apiKey:(i==null?void 0:i.apiKey)??"",triggerType:(i==null?void 0:i.triggerType)??"",triggerOperator:(i==null?void 0:i.triggerOperator)??"",triggerValue:i==null?void 0:i.triggerValue,expire:(i==null?void 0:i.expire)??0,keywordFinish:i==null?void 0:i.keywordFinish,delayMessage:(i==null?void 0:i.delayMessage)??0,unknownMessage:i==null?void 0:i.unknownMessage,listeningFromMe:i==null?void 0:i.listeningFromMe,stopBotFromMe:i==null?void 0:i.stopBotFromMe,keepOpen:i==null?void 0:i.keepOpen,debounceTime:(i==null?void 0:i.debounceTime)??0,splitMessages:(i==null?void 0:i.splitMessages)??!1,timePerChar:(i==null?void 0:i.timePerChar)??0}),[i==null?void 0:i.apiKey,i==null?void 0:i.apiUrl,i==null?void 0:i.debounceTime,i==null?void 0:i.delayMessage,i==null?void 0:i.description,i==null?void 0:i.enabled,i==null?void 0:i.expire,i==null?void 0:i.keepOpen,i==null?void 0:i.keywordFinish,i==null?void 0:i.listeningFromMe,i==null?void 0:i.stopBotFromMe,i==null?void 0:i.triggerOperator,i==null?void 0:i.triggerType,i==null?void 0:i.triggerValue,i==null?void 0:i.unknownMessage,i==null?void 0:i.splitMessages,i==null?void 0:i.timePerChar]),f=async g=>{var m,x,b;try{if(r&&r.name&&e){const y={enabled:g.enabled,description:g.description,apiUrl:g.apiUrl,apiKey:g.apiKey,triggerType:g.triggerType,triggerOperator:g.triggerOperator||"",triggerValue:g.triggerValue||"",expire:g.expire||0,keywordFinish:g.keywordFinish||"",delayMessage:g.delayMessage||1e3,unknownMessage:g.unknownMessage||"",listeningFromMe:g.listeningFromMe||!1,stopBotFromMe:g.stopBotFromMe||!1,keepOpen:g.keepOpen||!1,debounceTime:g.debounceTime||0,splitMessages:g.splitMessages||!1,timePerChar:g.timePerChar||0};await c({instanceName:r.name,flowiseId:e,data:y}),X.success(n("flowise.toast.success.update")),t(),s(`/manager/instance/${r.id}/flowise/${e}`)}else console.error("Token not found")}catch(y){console.error("Error:",y),X.error(`Error: ${(b=(x=(m=y==null?void 0:y.response)==null?void 0:m.data)==null?void 0:x.response)==null?void 0:b.message}`)}},h=async()=>{try{r&&r.name&&e?(await l({instanceName:r.name,flowiseId:e}),X.success(n("flowise.toast.success.delete")),a(!1),t(),s(`/manager/instance/${r.id}/flowise`)):console.error("instance not found")}catch(g){console.error("Erro ao excluir dify:",g)}};return d?u.jsx(wr,{}):u.jsx("div",{className:"m-4",children:u.jsx(NI,{initialData:p,onSubmit:f,flowiseId:e,handleDelete:h,isModal:!1,isLoading:d,openDeletionDialog:o,setOpenDeletionDialog:a})})}function sE(){const{t:e}=ze(),t=Ou("(min-width: 768px)"),{instance:n}=nt(),{flowiseId:r}=So(),{data:s,isLoading:o,refetch:a}=MI({instanceName:n==null?void 0:n.name}),l=An(),c=d=>{n&&l(`/manager/instance/${n.id}/flowise/${d}`)},i=()=>{a()};return u.jsxs("main",{className:"pt-5",children:[u.jsxs("div",{className:"mb-1 flex items-center justify-between",children:[u.jsx("h3",{className:"text-lg font-medium",children:e("flowise.title")}),u.jsxs("div",{className:"flex items-center justify-end gap-2",children:[u.jsx(OI,{}),u.jsx(See,{}),u.jsx(_ee,{resetTable:i})]})]}),u.jsx($t,{className:"my-4"}),u.jsxs(Pu,{direction:t?"horizontal":"vertical",children:[u.jsx(Ur,{defaultSize:35,className:"pr-4",children:u.jsx("div",{className:"flex flex-col gap-3",children:o?u.jsx(wr,{}):u.jsx(u.Fragment,{children:s&&s.length>0&&Array.isArray(s)?s.map(d=>u.jsx(q,{className:"flex h-auto flex-col items-start justify-start",onClick:()=>c(`${d.id}`),variant:r===d.id?"secondary":"outline",children:u.jsx("h4",{className:"text-base",children:d.description||d.id})},d.id)):u.jsx(q,{variant:"link",children:e("flowise.table.none")})})})}),r&&u.jsxs(u.Fragment,{children:[u.jsx(Mu,{withHandle:!0,className:"border border-border"}),u.jsx(Ur,{children:u.jsx(Mee,{flowiseId:r,resetTable:i})})]})]})]})}const Oee=e=>["openai","findOpenai",JSON.stringify(e)],Nee=async({instanceName:e,token:t})=>(await he.get(`/openai/find/${e}`,{headers:{apiKey:t}})).data,II=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:Oee({instanceName:t}),queryFn:()=>Nee({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},Iee=e=>["openai","findOpenaiCreds",JSON.stringify(e)],Dee=async({instanceName:e,token:t})=>(await he.get(`/openai/creds/${e}`,{headers:{apiKey:t}})).data,Vw=e=>{const{instanceName:t,token:n,...r}=e;return lt({staleTime:1e3*60*60*6,...r,queryKey:Iee({instanceName:t}),queryFn:()=>Dee({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},Aee=async({instanceName:e,token:t,data:n})=>(await he.post(`/openai/creds/${e}`,n,{headers:{apikey:t}})).data,Fee=async({openaiCredsId:e,instanceName:t})=>(await he.delete(`/openai/creds/${e}/${t}`)).data,Lee=async({instanceName:e,token:t,data:n})=>(await he.post(`/openai/create/${e}`,n,{headers:{apikey:t}})).data,$ee=async({instanceName:e,token:t,openaiId:n,data:r})=>(await he.put(`/openai/update/${n}/${e}`,r,{headers:{apikey:t}})).data,Bee=async({instanceName:e,token:t,openaiId:n})=>(await he.delete(`/openai/delete/${n}/${e}`,{headers:{apikey:t}})).data,zee=async({instanceName:e,token:t,data:n})=>(await he.post(`/openai/settings/${e}`,n,{headers:{apikey:t}})).data,Uee=async({instanceName:e,token:t,remoteJid:n,status:r})=>(await he.post(`/openai/changeStatus/${e}`,{remoteJid:n,status:r},{headers:{apikey:t}})).data;function rf(){const e=Ye(zee,{invalidateKeys:[["openai","fetchDefaultSettings"]]}),t=Ye(Uee,{invalidateKeys:[["openai","getOpenai"],["openai","fetchSessions"]]}),n=Ye(Bee,{invalidateKeys:[["openai","getOpenai"],["openai","findOpenai"],["openai","fetchSessions"]]}),r=Ye($ee,{invalidateKeys:[["openai","getOpenai"],["openai","findOpenai"],["openai","fetchSessions"]]}),s=Ye(Lee,{invalidateKeys:[["openai","findOpenai"]]}),o=Ye(Aee,{invalidateKeys:[["openai","findOpenaiCreds"]]}),a=Ye(Fee,{invalidateKeys:[["openai","findOpenaiCreds"]]});return{setDefaultSettingsOpenai:e,changeStatusOpenai:t,deleteOpenai:n,updateOpenai:r,createOpenai:s,createOpenaiCreds:o,deleteOpenaiCreds:a}}const Vee=_.object({name:_.string(),apiKey:_.string()});function Hee(){const{t:e}=ze(),{instance:t}=nt(),{createOpenaiCreds:n,deleteOpenaiCreds:r}=rf(),[s,o]=v.useState(!1),[a,l]=v.useState([]),{data:c,refetch:i}=Vw({instanceName:t==null?void 0:t.name,enabled:s}),d=sn({resolver:on(Vee),defaultValues:{name:"",apiKey:""}}),p=async m=>{var x,b,y;try{if(!t||!t.name)throw new Error("instance not found.");const w={name:m.name,apiKey:m.apiKey};await n({instanceName:t.name,token:t.token,data:w}),X.success(e("openai.toast.success.credentialsCreate")),f()}catch(w){console.error("Error:",w),X.error(`Error: ${(y=(b=(x=w==null?void 0:w.response)==null?void 0:x.data)==null?void 0:b.response)==null?void 0:y.message}`)}};function f(){d.reset(),i()}const h=async m=>{var x,b,y;if(!(t!=null&&t.name)){X.error("Instance not found.");return}try{await r({openaiCredsId:m,instanceName:t==null?void 0:t.name}),X.success(e("openai.toast.success.credentialsDelete")),i()}catch(w){console.error("Error:",w),X.error(`Error: ${(y=(b=(x=w==null?void 0:w.response)==null?void 0:x.data)==null?void 0:b.response)==null?void 0:y.message}`)}},g=[{accessorKey:"name",header:({column:m})=>u.jsxs(q,{variant:"ghost",onClick:()=>m.toggleSorting(m.getIsSorted()==="asc"),children:[e("openai.credentials.table.name"),u.jsx(_3,{className:"ml-2 h-4 w-4"})]}),cell:({row:m})=>u.jsx("div",{children:m.getValue("name")})},{accessorKey:"apiKey",header:()=>u.jsx("div",{className:"text-right",children:e("openai.credentials.table.apiKey")}),cell:({row:m})=>u.jsxs("div",{children:[`${m.getValue("apiKey")}`.slice(0,20),"..."]})},{id:"actions",enableHiding:!1,cell:({row:m})=>{const x=m.original;return u.jsxs(Eo,{children:[u.jsx(To,{asChild:!0,children:u.jsxs(q,{variant:"ghost",className:"h-8 w-8 p-0",children:[u.jsx("span",{className:"sr-only",children:e("openai.credentials.table.actions.title")}),u.jsx(vu,{className:"h-4 w-4"})]})}),u.jsxs(ps,{align:"end",children:[u.jsx(Ai,{children:e("openai.credentials.table.actions.title")}),u.jsx(Pa,{}),u.jsx(ft,{onClick:()=>h(x.id),children:e("openai.credentials.table.actions.delete")})]})]})}}];return u.jsxs(Tt,{open:s,onOpenChange:o,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(H3,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden md:inline",children:e("openai.credentials.title")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",onCloseAutoFocus:f,children:[u.jsx(wt,{children:u.jsx(Ut,{children:e("openai.credentials.title")})}),u.jsx(Tr,{...d,children:u.jsxs("form",{onSubmit:d.handleSubmit(p),className:"w-full space-y-6",children:[u.jsx("div",{children:u.jsxs("div",{className:"grid gap-3 md:grid-cols-2",children:[u.jsx(G,{name:"name",label:e("openai.credentials.table.name"),children:u.jsx(K,{})}),u.jsx(G,{name:"apiKey",label:e("openai.credentials.table.apiKey"),children:u.jsx(K,{type:"password"})})]})}),u.jsx(rn,{children:u.jsx(q,{type:"submit",children:e("openai.button.save")})})]})}),u.jsx($t,{}),u.jsx("div",{children:u.jsx(Nu,{columns:g,data:c??[],onSortingChange:l,state:{sorting:a},noResultsMessage:e("openai.credentials.table.none")})})]})]})}const Kee=e=>["openai","fetchDefaultSettings",JSON.stringify(e)],qee=async({instanceName:e,token:t})=>{const n=await he.get(`/openai/fetchSettings/${e}`,{headers:{apiKey:t}});return Array.isArray(n.data)?n.data[0]:n.data},Wee=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:Kee({instanceName:t}),queryFn:()=>qee({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},Gee=_.object({openaiCredsId:_.string(),expire:_.coerce.number(),keywordFinish:_.string(),delayMessage:_.coerce.number().default(0),unknownMessage:_.string(),listeningFromMe:_.boolean(),stopBotFromMe:_.boolean(),keepOpen:_.boolean(),debounceTime:_.coerce.number(),speechToText:_.boolean(),ignoreJids:_.array(_.string()).default([]),openaiIdFallback:_.union([_.null(),_.string()]).optional(),splitMessages:_.boolean().optional(),timePerChar:_.coerce.number().optional()});function Jee(){const{t:e}=ze(),{instance:t}=nt(),{setDefaultSettingsOpenai:n}=rf(),[r,s]=v.useState(!1),{data:o,refetch:a}=Wee({instanceName:t==null?void 0:t.name,enabled:r}),{data:l,refetch:c}=II({instanceName:t==null?void 0:t.name,enabled:r}),{data:i}=Vw({instanceName:t==null?void 0:t.name,enabled:r}),d=sn({resolver:on(Gee),defaultValues:{openaiCredsId:"",expire:0,keywordFinish:e("openai.form.examples.keywordFinish"),delayMessage:1e3,unknownMessage:e("openai.form.examples.unknownMessage"),listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:0,speechToText:!1,ignoreJids:[],openaiIdFallback:void 0,splitMessages:!1,timePerChar:0}});v.useEffect(()=>{o&&d.reset({openaiCredsId:o.openaiCredsId,expire:(o==null?void 0:o.expire)??0,keywordFinish:o.keywordFinish,delayMessage:o.delayMessage??0,unknownMessage:o.unknownMessage,listeningFromMe:o.listeningFromMe,stopBotFromMe:o.stopBotFromMe,keepOpen:o.keepOpen,debounceTime:o.debounceTime??0,speechToText:o.speechToText,ignoreJids:o.ignoreJids,openaiIdFallback:o.openaiIdFallback,splitMessages:o.splitMessages,timePerChar:o.timePerChar??0})},[o]);const p=async h=>{var g,m,x;try{if(!t||!t.name)throw new Error("instance not found.");const b={openaiCredsId:h.openaiCredsId,expire:h.expire,keywordFinish:h.keywordFinish,delayMessage:h.delayMessage,unknownMessage:h.unknownMessage,listeningFromMe:h.listeningFromMe,stopBotFromMe:h.stopBotFromMe,keepOpen:h.keepOpen,debounceTime:h.debounceTime,speechToText:h.speechToText,openaiIdFallback:h.openaiIdFallback||void 0,ignoreJids:h.ignoreJids,splitMessages:h.splitMessages,timePerChar:h.timePerChar};await n({instanceName:t.name,token:t.token,data:b}),X.success(e("openai.toast.defaultSettings.success"))}catch(b){console.error("Error:",b),X.error(`Error: ${(x=(m=(g=b==null?void 0:b.response)==null?void 0:g.data)==null?void 0:m.response)==null?void 0:x.message}`)}};function f(){a(),c()}return u.jsxs(Tt,{open:r,onOpenChange:s,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Oi,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden md:inline",children:e("openai.defaultSettings")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",onCloseAutoFocus:f,children:[u.jsx(wt,{children:u.jsx(Ut,{children:e("openai.defaultSettings")})}),u.jsx(Tr,{...d,children:u.jsxs("form",{className:"w-full space-y-6",onSubmit:d.handleSubmit(p),children:[u.jsx("div",{children:u.jsxs("div",{className:"space-y-4",children:[u.jsx(Qt,{name:"openaiCredsId",label:e("openai.form.openaiCredsId.label"),options:(i==null?void 0:i.filter(h=>!!h.id).map(h=>({label:h.name?h.name:h.apiKey.substring(0,15)+"...",value:h.id})))||[]}),u.jsx(Qt,{name:"openaiIdFallback",label:e("openai.form.openaiIdFallback.label"),options:(l==null?void 0:l.filter(h=>!!h.id).map(h=>({label:h.description,value:h.id})))??[]}),u.jsx(G,{name:"expire",label:e("openai.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:e("openai.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:e("openai.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:e("openai.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:e("openai.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:e("openai.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:e("openai.form.keepOpen.label"),reverse:!0}),u.jsx(ke,{name:"speechToText",label:e("openai.form.speechToText.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:e("openai.form.debounceTime.label"),children:u.jsx(K,{type:"number"})}),u.jsx(ke,{name:"splitMessages",label:e("openai.form.splitMessages.label"),reverse:!0}),d.watch("splitMessages")&&u.jsx(G,{name:"timePerChar",label:e("openai.form.timePerChar.label"),children:u.jsx(K,{type:"number"})}),u.jsx(Ru,{name:"ignoreJids",label:e("openai.form.ignoreJids.label"),placeholder:e("openai.form.ignoreJids.placeholder")})]})}),u.jsx(rn,{children:u.jsx(q,{type:"submit",children:e("openai.button.save")})})]})})]})]})}const Qee=e=>["openai","getModels",JSON.stringify(e)],Zee=async({instanceName:e,token:t})=>(await he.get(`/openai/getModels/${e}`,{headers:{apiKey:t}})).data,Yee=e=>{const{instanceName:t,token:n,...r}=e;return lt({staleTime:1e3*60*60*6,...r,queryKey:Qee({instanceName:t}),queryFn:()=>Zee({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},Xee=e=>["openai","fetchSessions",JSON.stringify(e)],ete=async({instanceName:e,openaiId:t,token:n})=>(await he.get(`/openai/fetchSessions/${t}/${e}`,{headers:{apiKey:n}})).data,tte=e=>{const{instanceName:t,token:n,openaiId:r,...s}=e;return lt({...s,queryKey:Xee({instanceName:t}),queryFn:()=>ete({instanceName:t,token:n,openaiId:r}),enabled:!!t&&!!r&&(e.enabled??!0)})};function DI({openaiId:e}){const{t}=ze(),{instance:n}=nt(),{changeStatusOpenai:r}=rf(),[s,o]=v.useState([]),[a,l]=v.useState(!1),{data:c,refetch:i}=tte({instanceName:n==null?void 0:n.name,openaiId:e,enabled:a}),[d,p]=v.useState("");function f(){i()}const h=async(m,x)=>{var b,y,w;try{if(!n)return;await r({instanceName:n.name,token:n.token,remoteJid:m,status:x}),X.success(t("openai.toast.success.status")),f()}catch(S){console.error("Error:",S),X.error(`Error : ${(w=(y=(b=S==null?void 0:S.response)==null?void 0:b.data)==null?void 0:y.response)==null?void 0:w.message}`)}},g=[{accessorKey:"remoteJid",header:()=>u.jsx("div",{className:"text-center",children:t("openai.sessions.table.remoteJid")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("remoteJid")})},{accessorKey:"pushName",header:()=>u.jsx("div",{className:"text-center",children:t("openai.sessions.table.pushName")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("pushName")})},{accessorKey:"sessionId",header:()=>u.jsx("div",{className:"text-center",children:t("openai.sessions.table.sessionId")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("sessionId")})},{accessorKey:"status",header:()=>u.jsx("div",{className:"text-center",children:t("openai.sessions.table.status")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("status")})},{id:"actions",enableHiding:!1,cell:({row:m})=>{const x=m.original;return u.jsxs(Eo,{children:[u.jsx(To,{asChild:!0,children:u.jsxs(q,{variant:"ghost",size:"icon",children:[u.jsx("span",{className:"sr-only",children:t("openai.sessions.table.actions.title")}),u.jsx(vu,{className:"h-4 w-4"})]})}),u.jsxs(ps,{align:"end",children:[u.jsx(Ai,{children:t("openai.sessions.table.actions.title")}),u.jsx(Pa,{}),x.status!=="opened"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"opened"),children:[u.jsx(qd,{className:"mr-2 h-4 w-4"}),t("openai.sessions.table.actions.open")]}),x.status!=="paused"&&x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"paused"),children:[u.jsx(Kd,{className:"mr-2 h-4 w-4"}),t("openai.sessions.table.actions.pause")]}),x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"closed"),children:[u.jsx(Ud,{className:"mr-2 h-4 w-4"}),t("openai.sessions.table.actions.close")]}),u.jsxs(ft,{onClick:()=>h(x.remoteJid,"delete"),children:[u.jsx(Vd,{className:"mr-2 h-4 w-4"}),t("openai.sessions.table.actions.delete")]})]})]})}}];return u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Hd,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden md:inline",children:t("openai.sessions.label")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-w-[950px]",onCloseAutoFocus:f,children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("openai.sessions.label")})}),u.jsxs("div",{children:[u.jsxs("div",{className:"flex items-center justify-between gap-6 p-5",children:[u.jsx(K,{placeholder:t("openai.sessions.search"),value:d,onChange:m=>p(m.target.value)}),u.jsx(q,{variant:"outline",onClick:f,size:"icon",children:u.jsx(Wd,{size:16})})]}),u.jsx(Nu,{columns:g,data:c??[],onSortingChange:o,state:{sorting:s,globalFilter:d},onGlobalFilterChange:p,enableGlobalFilter:!0,noResultsMessage:t("openai.sessions.table.none")})]})]})]})}const nte=_.object({enabled:_.boolean(),description:_.string(),openaiCredsId:_.string(),botType:_.string(),assistantId:_.string().optional(),functionUrl:_.string().optional(),model:_.string().optional(),systemMessages:_.string().optional(),assistantMessages:_.string().optional(),userMessages:_.string().optional(),maxTokens:_.coerce.number().optional(),triggerType:_.string(),triggerOperator:_.string().optional(),triggerValue:_.string().optional(),expire:_.coerce.number().optional(),keywordFinish:_.string().optional(),delayMessage:_.coerce.number().optional(),unknownMessage:_.string().optional(),listeningFromMe:_.boolean().optional(),stopBotFromMe:_.boolean().optional(),keepOpen:_.boolean().optional(),debounceTime:_.coerce.number().optional(),splitMessages:_.boolean().optional(),timePerChar:_.coerce.number().optional()});function AI({initialData:e,onSubmit:t,handleDelete:n,openaiId:r,isModal:s=!1,isLoading:o=!1,openDeletionDialog:a=!1,setOpenDeletionDialog:l=()=>{},open:c}){const{t:i}=ze(),{instance:d}=nt(),{data:p}=Vw({instanceName:d==null?void 0:d.name,enabled:c}),{data:f}=Yee({instanceName:d==null?void 0:d.name,enabled:c}),h=sn({resolver:on(nte),defaultValues:e||{enabled:!0,description:"",openaiCredsId:"",botType:"assistant",assistantId:"",functionUrl:"",model:"",systemMessages:"",assistantMessages:"",userMessages:"",maxTokens:0,triggerType:"keyword",triggerOperator:"contains",triggerValue:"",expire:0,keywordFinish:"",delayMessage:0,unknownMessage:"",listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:0,splitMessages:!1,timePerChar:0}}),g=h.watch("botType"),m=h.watch("triggerType");return u.jsx(Tr,{...h,children:u.jsxs("form",{onSubmit:h.handleSubmit(t),className:"w-full space-y-6",children:[u.jsxs("div",{className:"space-y-4",children:[u.jsx(ke,{name:"enabled",label:i("openai.form.enabled.label"),reverse:!0}),u.jsx(G,{name:"description",label:i("openai.form.description.label"),required:!0,children:u.jsx(K,{})}),u.jsx(Qt,{name:"openaiCredsId",label:i("openai.form.openaiCredsId.label"),required:!0,options:(p==null?void 0:p.filter(x=>!!x.id).map(x=>({label:x.name?x.name:x.apiKey.substring(0,15)+"...",value:x.id})))??[]}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:i("openai.form.openaiSettings.label")}),u.jsx($t,{})]}),u.jsx(Qt,{name:"botType",label:i("openai.form.botType.label"),required:!0,options:[{label:i("openai.form.botType.assistant"),value:"assistant"},{label:i("openai.form.botType.chatCompletion"),value:"chatCompletion"}]}),g==="assistant"&&u.jsxs(u.Fragment,{children:[u.jsx(G,{name:"assistantId",label:i("openai.form.assistantId.label"),required:!0,children:u.jsx(K,{})}),u.jsx(G,{name:"functionUrl",label:i("openai.form.functionUrl.label"),required:!0,children:u.jsx(K,{})})]}),g==="chatCompletion"&&u.jsxs(u.Fragment,{children:[u.jsx(Qt,{name:"model",label:i("openai.form.model.label"),required:!0,options:(f==null?void 0:f.map(x=>({label:x.id,value:x.id})))??[]}),u.jsx(G,{name:"systemMessages",label:i("openai.form.systemMessages.label"),children:u.jsx(Ml,{})}),u.jsx(G,{name:"assistantMessages",label:i("openai.form.assistantMessages.label"),children:u.jsx(Ml,{})}),u.jsx(G,{name:"userMessages",label:i("openai.form.userMessages.label"),children:u.jsx(Ml,{})}),u.jsx(G,{name:"maxTokens",label:i("openai.form.maxTokens.label"),children:u.jsx(K,{type:"number"})})]}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:i("openai.form.triggerSettings.label")}),u.jsx($t,{})]}),u.jsx(Qt,{name:"triggerType",label:i("openai.form.triggerType.label"),required:!0,options:[{label:i("openai.form.triggerType.keyword"),value:"keyword"},{label:i("openai.form.triggerType.all"),value:"all"},{label:i("openai.form.triggerType.advanced"),value:"advanced"},{label:i("openai.form.triggerType.none"),value:"none"}]}),m==="keyword"&&u.jsxs(u.Fragment,{children:[u.jsx(Qt,{name:"triggerOperator",label:i("openai.form.triggerOperator.label"),required:!0,options:[{label:i("openai.form.triggerOperator.contains"),value:"contains"},{label:i("openai.form.triggerOperator.equals"),value:"equals"},{label:i("openai.form.triggerOperator.startsWith"),value:"startsWith"},{label:i("openai.form.triggerOperator.endsWith"),value:"endsWith"},{label:i("openai.form.triggerOperator.regex"),value:"regex"}]}),u.jsx(G,{name:"triggerValue",label:i("openai.form.triggerValue.label"),required:!0,children:u.jsx(K,{})})]}),m==="advanced"&&u.jsx(G,{name:"triggerValue",label:i("openai.form.triggerConditions.label"),required:!0,children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:i("openai.form.generalSettings.label")}),u.jsx($t,{})]}),u.jsx(G,{name:"expire",label:i("openai.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:i("openai.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:i("openai.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:i("openai.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:i("openai.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:i("openai.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:i("openai.form.keepOpen.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:i("openai.form.debounceTime.label"),children:u.jsx(K,{type:"number"})}),u.jsx(ke,{name:"splitMessages",label:i("openai.form.splitMessages.label"),reverse:!0}),h.watch("splitMessages")&&u.jsx(G,{name:"timePerChar",label:i("openai.form.timePerChar.label"),children:u.jsx(K,{type:"number"})})]}),s&&u.jsx(rn,{children:u.jsx(q,{disabled:o,type:"submit",children:i(o?"openai.button.saving":"openai.button.save")})}),!s&&u.jsxs("div",{children:[u.jsx(DI,{openaiId:r}),u.jsxs("div",{className:"mt-5 flex items-center gap-3",children:[u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsx(q,{variant:"destructive",size:"sm",children:i("dify.button.delete")})}),u.jsx(xt,{children:u.jsxs(wt,{children:[u.jsx(Ut,{children:i("modal.delete.title")}),u.jsx(Fi,{children:i("modal.delete.messageSingle")}),u.jsxs(rn,{children:[u.jsx(q,{size:"sm",variant:"outline",onClick:()=>l(!1),children:i("button.cancel")}),u.jsx(q,{variant:"destructive",onClick:n,children:i("button.delete")})]})]})})]}),u.jsx(q,{disabled:o,type:"submit",children:i(o?"openai.button.saving":"openai.button.update")})]})]})]})})}function rte({resetTable:e}){const{t}=ze(),{instance:n}=nt(),{createOpenai:r}=rf(),[s,o]=v.useState(!1),[a,l]=v.useState(!1),c=async i=>{var d,p,f;try{if(!n||!n.name)throw new Error("instance not found");o(!0);const h={enabled:i.enabled,description:i.description,openaiCredsId:i.openaiCredsId,botType:i.botType,assistantId:i.assistantId||"",functionUrl:i.functionUrl||"",model:i.model||"",systemMessages:[i.systemMessages||""],assistantMessages:[i.assistantMessages||""],userMessages:[i.userMessages||""],maxTokens:i.maxTokens||0,triggerType:i.triggerType,triggerOperator:i.triggerOperator||"",triggerValue:i.triggerValue||"",expire:i.expire||0,keywordFinish:i.keywordFinish||"",delayMessage:i.delayMessage||0,unknownMessage:i.unknownMessage||"",listeningFromMe:i.listeningFromMe||!1,stopBotFromMe:i.stopBotFromMe||!1,keepOpen:i.keepOpen||!1,debounceTime:i.debounceTime||0,splitMessages:i.splitMessages||!1,timePerChar:i.timePerChar||0};await r({instanceName:n.name,token:n.token,data:h}),X.success(t("openai.toast.success.create")),l(!1),e()}catch(h){console.error("Error:",h),X.error(`Error: ${(f=(p=(d=h==null?void 0:h.response)==null?void 0:d.data)==null?void 0:p.response)==null?void 0:f.message}`)}finally{o(!1)}};return u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{size:"sm",children:[u.jsx(Ni,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:t("openai.button.create")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("openai.form.title")})}),u.jsx(AI,{onSubmit:c,isModal:!0,isLoading:s,open:a})]})]})}const ste=e=>["openai","getOpenai",JSON.stringify(e)],ote=async({instanceName:e,token:t,openaiId:n})=>{const r=await he.get(`/openai/fetch/${n}/${e}`,{headers:{apiKey:t}});return Array.isArray(r.data)?r.data[0]:r.data},ate=e=>{const{instanceName:t,token:n,openaiId:r,...s}=e;return lt({...s,queryKey:ste({instanceName:t}),queryFn:()=>ote({instanceName:t,token:n,openaiId:r}),enabled:!!t&&!!r&&(e.enabled??!0)})};function ite({openaiId:e,resetTable:t}){const{t:n}=ze(),{instance:r}=nt(),s=An(),[o,a]=v.useState(!1),{deleteOpenai:l,updateOpenai:c}=rf(),{data:i,isLoading:d}=ate({instanceName:r==null?void 0:r.name,openaiId:e}),p=v.useMemo(()=>({enabled:(i==null?void 0:i.enabled)??!0,description:(i==null?void 0:i.description)??"",openaiCredsId:(i==null?void 0:i.openaiCredsId)??"",botType:(i==null?void 0:i.botType)??"",assistantId:(i==null?void 0:i.assistantId)||"",functionUrl:(i==null?void 0:i.functionUrl)||"",model:(i==null?void 0:i.model)||"",systemMessages:Array.isArray(i==null?void 0:i.systemMessages)?i==null?void 0:i.systemMessages.join(", "):(i==null?void 0:i.systemMessages)||"",assistantMessages:Array.isArray(i==null?void 0:i.assistantMessages)?i==null?void 0:i.assistantMessages.join(", "):(i==null?void 0:i.assistantMessages)||"",userMessages:Array.isArray(i==null?void 0:i.userMessages)?i==null?void 0:i.userMessages.join(", "):(i==null?void 0:i.userMessages)||"",maxTokens:(i==null?void 0:i.maxTokens)||0,triggerType:(i==null?void 0:i.triggerType)||"",triggerOperator:(i==null?void 0:i.triggerOperator)||"",triggerValue:i==null?void 0:i.triggerValue,expire:(i==null?void 0:i.expire)||0,keywordFinish:i==null?void 0:i.keywordFinish,delayMessage:(i==null?void 0:i.delayMessage)||0,unknownMessage:i==null?void 0:i.unknownMessage,listeningFromMe:i==null?void 0:i.listeningFromMe,stopBotFromMe:i==null?void 0:i.stopBotFromMe,keepOpen:i==null?void 0:i.keepOpen,debounceTime:(i==null?void 0:i.debounceTime)||0,splitMessages:(i==null?void 0:i.splitMessages)||!1,timePerChar:(i==null?void 0:i.timePerChar)||0}),[i==null?void 0:i.assistantId,i==null?void 0:i.assistantMessages,i==null?void 0:i.botType,i==null?void 0:i.debounceTime,i==null?void 0:i.delayMessage,i==null?void 0:i.description,i==null?void 0:i.enabled,i==null?void 0:i.expire,i==null?void 0:i.functionUrl,i==null?void 0:i.keepOpen,i==null?void 0:i.keywordFinish,i==null?void 0:i.listeningFromMe,i==null?void 0:i.maxTokens,i==null?void 0:i.model,i==null?void 0:i.openaiCredsId,i==null?void 0:i.stopBotFromMe,i==null?void 0:i.systemMessages,i==null?void 0:i.triggerOperator,i==null?void 0:i.triggerType,i==null?void 0:i.triggerValue,i==null?void 0:i.unknownMessage,i==null?void 0:i.userMessages,i==null?void 0:i.splitMessages,i==null?void 0:i.timePerChar]),f=async g=>{var m,x,b;try{if(r&&r.name&&e){const y={enabled:g.enabled,description:g.description,openaiCredsId:g.openaiCredsId,botType:g.botType,assistantId:g.assistantId||"",functionUrl:g.functionUrl||"",model:g.model||"",systemMessages:[g.systemMessages||""],assistantMessages:[g.assistantMessages||""],userMessages:[g.userMessages||""],maxTokens:g.maxTokens||0,triggerType:g.triggerType,triggerOperator:g.triggerOperator||"",triggerValue:g.triggerValue||"",expire:g.expire||0,keywordFinish:g.keywordFinish||"",delayMessage:g.delayMessage||1e3,unknownMessage:g.unknownMessage||"",listeningFromMe:g.listeningFromMe||!1,stopBotFromMe:g.stopBotFromMe||!1,keepOpen:g.keepOpen||!1,debounceTime:g.debounceTime||0,splitMessages:g.splitMessages||!1,timePerChar:g.timePerChar||0};await c({instanceName:r.name,openaiId:e,data:y}),X.success(n("openai.toast.success.update")),t(),s(`/manager/instance/${r.id}/openai/${e}`)}else console.error("Token not found")}catch(y){console.error("Error:",y),X.error(`Error: ${(b=(x=(m=y==null?void 0:y.response)==null?void 0:m.data)==null?void 0:x.response)==null?void 0:b.message}`)}},h=async()=>{try{r&&r.name&&e?(await l({instanceName:r.name,openaiId:e}),X.success(n("openai.toast.success.delete")),a(!1),t(),s(`/manager/instance/${r.id}/openai`)):console.error("instance not found")}catch(g){console.error("Erro ao excluir dify:",g)}};return d?u.jsx(wr,{}):u.jsx("div",{className:"m-4",children:u.jsx(AI,{initialData:p,onSubmit:f,openaiId:e,handleDelete:h,isModal:!1,isLoading:d,openDeletionDialog:o,setOpenDeletionDialog:a})})}function oE(){const{t:e}=ze(),t=Ou("(min-width: 768px)"),{instance:n}=nt(),{botId:r}=So(),{data:s,isLoading:o,refetch:a}=II({instanceName:n==null?void 0:n.name}),l=An(),c=d=>{n&&l(`/manager/instance/${n.id}/openai/${d}`)},i=()=>{a()};return u.jsxs("main",{className:"pt-5",children:[u.jsxs("div",{className:"mb-1 flex items-center justify-between",children:[u.jsx("h3",{className:"text-lg font-medium",children:e("openai.title")}),u.jsxs("div",{className:"flex items-center justify-end gap-2",children:[u.jsx(DI,{}),u.jsx(Jee,{}),u.jsx(Hee,{}),u.jsx(rte,{resetTable:i})]})]}),u.jsx($t,{className:"my-4"}),u.jsxs(Pu,{direction:t?"horizontal":"vertical",children:[u.jsx(Ur,{defaultSize:35,className:"pr-4",children:u.jsx("div",{className:"flex flex-col gap-3",children:o?u.jsx(wr,{}):u.jsx(u.Fragment,{children:s&&s.length>0&&Array.isArray(s)?s.map(d=>u.jsxs(q,{className:"flex h-auto flex-col items-start justify-start",onClick:()=>c(`${d.id}`),variant:r===d.id?"secondary":"outline",children:[u.jsx("h4",{className:"text-base",children:d.description||d.id}),u.jsx("p",{className:"text-sm font-normal text-muted-foreground",children:d.botType})]},d.id)):u.jsx(q,{variant:"link",children:e("openai.table.none")})})})}),r&&u.jsxs(u.Fragment,{children:[u.jsx(Mu,{withHandle:!0,className:"border border-border"}),u.jsx(Ur,{children:u.jsx(ite,{openaiId:r,resetTable:i})})]})]})]})}const lte=e=>["proxy","fetchProxy",JSON.stringify(e)],ute=async({instanceName:e,token:t})=>(await he.get(`/proxy/find/${e}`,{headers:{apiKey:t}})).data,cte=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:lte({instanceName:t,token:n}),queryFn:()=>ute({instanceName:t,token:n}),enabled:!!t})},dte=async({instanceName:e,token:t,data:n})=>(await he.post(`/proxy/set/${e}`,n,{headers:{apikey:t}})).data;function fte(){return{createProxy:Ye(dte,{invalidateKeys:[["proxy","fetchProxy"]]})}}const pte=_.object({enabled:_.boolean(),host:_.string(),port:_.string(),protocol:_.string(),username:_.string(),password:_.string()});function hte(){const{t:e}=ze(),{instance:t}=nt(),[n,r]=v.useState(!1),{createProxy:s}=fte(),{data:o}=cte({instanceName:t==null?void 0:t.name}),a=sn({resolver:on(pte),defaultValues:{enabled:!1,host:"",port:"",protocol:"http",username:"",password:""}});v.useEffect(()=>{o&&a.reset({enabled:o.enabled,host:o.host,port:o.port,protocol:o.protocol,username:o.username,password:o.password})},[o]);const l=async c=>{var i,d,p;if(t){r(!0);try{const f={enabled:c.enabled,host:c.host,port:c.port,protocol:c.protocol,username:c.username,password:c.password};await s({instanceName:t.name,token:t.token,data:f}),X.success(e("proxy.toast.success"))}catch(f){console.error(e("proxy.toast.error"),f),X.error(`Error : ${(p=(d=(i=f==null?void 0:f.response)==null?void 0:i.data)==null?void 0:d.response)==null?void 0:p.message}`)}finally{r(!1)}}};return u.jsx(u.Fragment,{children:u.jsx(Na,{...a,children:u.jsx("form",{onSubmit:a.handleSubmit(l),className:"w-full space-y-6",children:u.jsxs("div",{children:[u.jsx("h3",{className:"mb-1 text-lg font-medium",children:e("proxy.title")}),u.jsx(Ra,{className:"my-4"}),u.jsxs("div",{className:"mx-4 space-y-2 divide-y [&>*]:p-4",children:[u.jsx(ke,{name:"enabled",label:e("proxy.form.enabled.label"),className:"w-full justify-between",helper:e("proxy.form.enabled.description")}),u.jsxs("div",{className:"grid gap-4 sm:grid-cols-[10rem_1fr_10rem] md:gap-8",children:[u.jsx(G,{name:"protocol",label:e("proxy.form.protocol.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"host",label:e("proxy.form.host.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"port",label:e("proxy.form.port.label"),children:u.jsx(K,{type:"number"})})]}),u.jsxs("div",{className:"grid gap-4 sm:grid-cols-2 md:gap-8",children:[u.jsx(G,{name:"username",label:e("proxy.form.username.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"password",label:e("proxy.form.password.label"),children:u.jsx(K,{type:"password"})})]}),u.jsx("div",{className:"flex justify-end px-4 pt-6",children:u.jsx(q,{type:"submit",disabled:n,children:e(n?"proxy.button.saving":"proxy.button.save")})})]})]})})})})}const gte=e=>["rabbitmq","fetchRabbitmq",JSON.stringify(e)],mte=async({instanceName:e,token:t})=>(await he.get(`/rabbitmq/find/${e}`,{headers:{apiKey:t}})).data,vte=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:gte({instanceName:t,token:n}),queryFn:()=>mte({instanceName:t,token:n}),enabled:!!t})},yte=async({instanceName:e,token:t,data:n})=>(await he.post(`/rabbitmq/set/${e}`,{rabbitmq:n},{headers:{apikey:t}})).data;function bte(){return{createRabbitmq:Ye(yte,{invalidateKeys:[["rabbitmq","fetchRabbitmq"]]})}}const xte=_.object({enabled:_.boolean(),events:_.array(_.string())});function wte(){const{t:e}=ze(),{instance:t}=nt(),[n,r]=v.useState(!1),{createRabbitmq:s}=bte(),{data:o}=vte({instanceName:t==null?void 0:t.name,token:t==null?void 0:t.token}),a=sn({resolver:on(xte),defaultValues:{enabled:!1,events:[]}});v.useEffect(()=>{o&&a.reset({enabled:o.enabled,events:o.events})},[o]);const l=async p=>{var f,h,g;if(t){r(!0);try{const m={enabled:p.enabled,events:p.events};await s({instanceName:t.name,token:t.token,data:m}),X.success(e("rabbitmq.toast.success"))}catch(m){console.error(e("rabbitmq.toast.error"),m),X.error(`Error: ${(g=(h=(f=m==null?void 0:m.response)==null?void 0:f.data)==null?void 0:h.response)==null?void 0:g.message}`)}finally{r(!1)}}},c=["APPLICATION_STARTUP","QRCODE_UPDATED","MESSAGES_SET","MESSAGES_UPSERT","MESSAGES_UPDATE","MESSAGES_DELETE","SEND_MESSAGE","CONTACTS_SET","CONTACTS_UPSERT","CONTACTS_UPDATE","PRESENCE_UPDATE","CHATS_SET","CHATS_UPSERT","CHATS_UPDATE","CHATS_DELETE","GROUPS_UPSERT","GROUP_UPDATE","GROUP_PARTICIPANTS_UPDATE","CONNECTION_UPDATE","REMOVE_INSTANCE","LOGOUT_INSTANCE","LABELS_EDIT","LABELS_ASSOCIATION","CALL","TYPEBOT_START","TYPEBOT_CHANGE_STATUS"],i=()=>{a.setValue("events",c)},d=()=>{a.setValue("events",[])};return u.jsx(u.Fragment,{children:u.jsx(Na,{...a,children:u.jsx("form",{onSubmit:a.handleSubmit(l),className:"w-full space-y-6",children:u.jsxs("div",{children:[u.jsx("h3",{className:"mb-1 text-lg font-medium",children:e("rabbitmq.title")}),u.jsx(Ra,{className:"my-4"}),u.jsxs("div",{className:"mx-4 space-y-2 divide-y [&>*]:p-4",children:[u.jsx(ke,{name:"enabled",label:e("rabbitmq.form.enabled.label"),className:"w-full justify-between",helper:e("rabbitmq.form.enabled.description")}),u.jsxs("div",{className:"mb-4 flex justify-between",children:[u.jsx(q,{variant:"outline",type:"button",onClick:i,children:e("button.markAll")}),u.jsx(q,{variant:"outline",type:"button",onClick:d,children:e("button.unMarkAll")})]}),u.jsx(Ia,{control:a.control,name:"events",render:({field:p})=>u.jsxs(_o,{className:"flex flex-col",children:[u.jsx(xr,{className:"my-2 text-lg",children:e("rabbitmq.form.events.label")}),u.jsx(Vs,{children:u.jsx("div",{className:"flex flex-col gap-2 space-y-1 divide-y",children:c.sort((f,h)=>f.localeCompare(h)).map(f=>u.jsxs("div",{className:"flex items-center justify-between gap-3 pt-3",children:[u.jsx(xr,{className:ge("break-all",p.value.includes(f)?"text-foreground":"text-muted-foreground"),children:f}),u.jsx(ju,{checked:p.value.includes(f),onCheckedChange:h=>{h?p.onChange([...p.value,f]):p.onChange(p.value.filter(g=>g!==f))}})]},f))})})]})})]}),u.jsx("div",{className:"mx-4 flex justify-end pt-6",children:u.jsx(q,{type:"submit",disabled:n,children:e(n?"rabbitmq.button.saving":"rabbitmq.button.save")})})]})})})})}const Ste=e=>["instance","fetchSettings",JSON.stringify(e)],Cte=async({instanceName:e,token:t})=>(await he.get(`/settings/find/${e}`,{headers:{apikey:t}})).data,Ete=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:Ste({instanceName:t,token:n}),queryFn:()=>Cte({instanceName:t,token:n}),enabled:!!t})},Tte=_.object({rejectCall:_.boolean(),msgCall:_.string().optional(),groupsIgnore:_.boolean(),alwaysOnline:_.boolean(),readMessages:_.boolean(),syncFullHistory:_.boolean(),readStatus:_.boolean()});function kte(){const{t:e}=ze(),[t,n]=v.useState(!1),{instance:r}=nt(),{updateSettings:s}=_g(),{data:o,isLoading:a}=Ete({instanceName:r==null?void 0:r.name,token:r==null?void 0:r.token}),l=sn({resolver:on(Tte),defaultValues:{rejectCall:!1,msgCall:"",groupsIgnore:!1,alwaysOnline:!1,readMessages:!1,syncFullHistory:!1,readStatus:!1}});v.useEffect(()=>{o&&l.reset({rejectCall:o.rejectCall,msgCall:o.msgCall||"",groupsIgnore:o.groupsIgnore,alwaysOnline:o.alwaysOnline,readMessages:o.readMessages,syncFullHistory:o.syncFullHistory,readStatus:o.readStatus})},[l,o]);const c=async p=>{try{if(!r||!r.name)throw new Error("instance not found");n(!0);const f={rejectCall:p.rejectCall,msgCall:p.msgCall,groupsIgnore:p.groupsIgnore,alwaysOnline:p.alwaysOnline,readMessages:p.readMessages,syncFullHistory:p.syncFullHistory,readStatus:p.readStatus};await s({instanceName:r.name,token:r.token,data:f}),X.success(e("settings.toast.success"))}catch(f){console.error(e("settings.toast.success"),f),X.error(e("settings.toast.error"))}finally{n(!1)}},i=[{name:"groupsIgnore",label:e("settings.form.groupsIgnore.label"),description:e("settings.form.groupsIgnore.description")},{name:"alwaysOnline",label:e("settings.form.alwaysOnline.label"),description:e("settings.form.alwaysOnline.description")},{name:"readMessages",label:e("settings.form.readMessages.label"),description:e("settings.form.readMessages.description")},{name:"syncFullHistory",label:e("settings.form.syncFullHistory.label"),description:e("settings.form.syncFullHistory.description")},{name:"readStatus",label:e("settings.form.readStatus.label"),description:e("settings.form.readStatus.description")}],d=l.watch("rejectCall");return a?u.jsx(wr,{}):u.jsx(u.Fragment,{children:u.jsx(Na,{...l,children:u.jsx("form",{onSubmit:l.handleSubmit(c),className:"w-full space-y-6",children:u.jsxs("div",{children:[u.jsx("h3",{className:"mb-1 text-lg font-medium",children:e("settings.title")}),u.jsx($t,{className:"my-4"}),u.jsxs("div",{className:"mx-4 space-y-2 divide-y",children:[u.jsxs("div",{className:"flex flex-col p-4",children:[u.jsx(ke,{name:"rejectCall",label:e("settings.form.rejectCall.label"),className:"w-full justify-between",helper:e("settings.form.rejectCall.description")}),d&&u.jsx("div",{className:"mr-16 mt-2",children:u.jsx(G,{name:"msgCall",children:u.jsx(Ml,{placeholder:e("settings.form.msgCall.description")})})})]}),i.map(p=>u.jsx("div",{className:"flex p-4",children:u.jsx(ke,{name:p.name,label:p.label,className:"w-full justify-between",helper:p.description})},p.name)),u.jsx("div",{className:"flex justify-end pt-6",children:u.jsx(q,{type:"submit",disabled:t,children:e(t?"settings.button.saving":"settings.button.save")})})]})]})})})})}const _te=e=>["sqs","fetchSqs",JSON.stringify(e)],jte=async({instanceName:e,token:t})=>(await he.get(`/sqs/find/${e}`,{headers:{apiKey:t}})).data,Rte=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:_te({instanceName:t,token:n}),queryFn:()=>jte({instanceName:t,token:n}),enabled:!!t})},Pte=async({instanceName:e,token:t,data:n})=>(await he.post(`/sqs/set/${e}`,{sqs:n},{headers:{apikey:t}})).data;function Mte(){return{createSqs:Ye(Pte,{invalidateKeys:[["sqs","fetchSqs"]]})}}const Ote=_.object({enabled:_.boolean(),events:_.array(_.string())});function Nte(){const{t:e}=ze(),{instance:t}=nt(),[n,r]=v.useState(!1),{createSqs:s}=Mte(),{data:o}=Rte({instanceName:t==null?void 0:t.name,token:t==null?void 0:t.token}),a=sn({resolver:on(Ote),defaultValues:{enabled:!1,events:[]}});v.useEffect(()=>{o&&a.reset({enabled:o.enabled,events:o.events})},[o]);const l=async p=>{var f,h,g;if(t){r(!0);try{const m={enabled:p.enabled,events:p.events};await s({instanceName:t.name,token:t.token,data:m}),X.success(e("sqs.toast.success"))}catch(m){console.error(e("sqs.toast.error"),m),X.error(`Error: ${(g=(h=(f=m==null?void 0:m.response)==null?void 0:f.data)==null?void 0:h.response)==null?void 0:g.message}`)}finally{r(!1)}}},c=["APPLICATION_STARTUP","QRCODE_UPDATED","MESSAGES_SET","MESSAGES_UPSERT","MESSAGES_UPDATE","MESSAGES_DELETE","SEND_MESSAGE","CONTACTS_SET","CONTACTS_UPSERT","CONTACTS_UPDATE","PRESENCE_UPDATE","CHATS_SET","CHATS_UPSERT","CHATS_UPDATE","CHATS_DELETE","GROUPS_UPSERT","GROUP_UPDATE","GROUP_PARTICIPANTS_UPDATE","CONNECTION_UPDATE","REMOVE_INSTANCE","LOGOUT_INSTANCE","LABELS_EDIT","LABELS_ASSOCIATION","CALL","TYPEBOT_START","TYPEBOT_CHANGE_STATUS"],i=()=>{a.setValue("events",c)},d=()=>{a.setValue("events",[])};return u.jsx(u.Fragment,{children:u.jsx(Na,{...a,children:u.jsx("form",{onSubmit:a.handleSubmit(l),className:"w-full space-y-6",children:u.jsxs("div",{children:[u.jsx("h3",{className:"mb-1 text-lg font-medium",children:e("sqs.title")}),u.jsx(Ra,{className:"my-4"}),u.jsxs("div",{className:"mx-4 space-y-2 divide-y [&>*]:p-4",children:[u.jsx(ke,{name:"enabled",label:e("sqs.form.enabled.label"),className:"w-full justify-between",helper:e("sqs.form.enabled.description")}),u.jsxs("div",{className:"mb-4 flex justify-between",children:[u.jsx(q,{variant:"outline",type:"button",onClick:i,children:e("button.markAll")}),u.jsx(q,{variant:"outline",type:"button",onClick:d,children:e("button.unMarkAll")})]}),u.jsx(Ia,{control:a.control,name:"events",render:({field:p})=>u.jsxs(_o,{className:"flex flex-col",children:[u.jsx(xr,{className:"my-2 text-lg",children:e("sqs.form.events.label")}),u.jsx(Vs,{children:u.jsx("div",{className:"flex flex-col gap-2 space-y-1 divide-y",children:c.sort((f,h)=>f.localeCompare(h)).map(f=>u.jsxs("div",{className:"flex items-center justify-between gap-3 pt-3",children:[u.jsx(xr,{className:ge("break-all",p.value.includes(f)?"text-foreground":"text-muted-foreground"),children:f}),u.jsx(ju,{checked:p.value.includes(f),onCheckedChange:h=>{h?p.onChange([...p.value,f]):p.onChange(p.value.filter(g=>g!==f))}})]},f))})})]})})]}),u.jsx("div",{className:"mx-4 flex justify-end pt-6",children:u.jsx(q,{type:"submit",disabled:n,children:e(n?"sqs.button.saving":"sqs.button.save")})})]})})})})}const Ite=e=>["typebot","findTypebot",JSON.stringify(e)],Dte=async({instanceName:e,token:t})=>(await he.get(`/typebot/find/${e}`,{headers:{apiKey:t}})).data,FI=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:Ite({instanceName:t}),queryFn:()=>Dte({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},Ate=e=>["typebot","fetchDefaultSettings",JSON.stringify(e)],Fte=async({instanceName:e,token:t})=>{const n=await he.get(`/typebot/fetchSettings/${e}`,{headers:{apiKey:t}});return Array.isArray(n.data)?n.data[0]:n.data},Lte=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:Ate({instanceName:t}),queryFn:()=>Fte({instanceName:t,token:n}),enabled:!!t&&(e.enabled??!0)})},$te=async({instanceName:e,token:t,data:n})=>(await he.post(`/typebot/create/${e}`,n,{headers:{apikey:t}})).data,Bte=async({instanceName:e,token:t,typebotId:n,data:r})=>(await he.put(`/typebot/update/${n}/${e}`,r,{headers:{apikey:t}})).data,zte=async({instanceName:e,typebotId:t})=>(await he.delete(`/typebot/delete/${t}/${e}`)).data,Ute=async({instanceName:e,token:t,data:n})=>(await he.post(`/typebot/settings/${e}`,n,{headers:{apikey:t}})).data,Vte=async({instanceName:e,token:t,remoteJid:n,status:r})=>(await he.post(`/typebot/changeStatus/${e}`,{remoteJid:n,status:r},{headers:{apikey:t}})).data;function tm(){const e=Ye(Ute,{invalidateKeys:[["typebot","fetchDefaultSettings"]]}),t=Ye(Vte,{invalidateKeys:[["typebot","getTypebot"],["typebot","fetchSessions"]]}),n=Ye(zte,{invalidateKeys:[["typebot","getTypebot"],["typebot","findTypebot"],["typebot","fetchSessions"]]}),r=Ye(Bte,{invalidateKeys:[["typebot","getTypebot"],["typebot","findTypebot"],["typebot","fetchSessions"]]}),s=Ye($te,{invalidateKeys:[["typebot","findTypebot"]]});return{setDefaultSettingsTypebot:e,changeStatusTypebot:t,deleteTypebot:n,updateTypebot:r,createTypebot:s}}const Hte=_.object({expire:_.coerce.number(),keywordFinish:_.string(),delayMessage:_.coerce.number(),unknownMessage:_.string(),listeningFromMe:_.boolean(),stopBotFromMe:_.boolean(),keepOpen:_.boolean(),debounceTime:_.coerce.number()});function Kte(){const{t:e}=ze(),{instance:t}=nt(),[n,r]=v.useState(!1),{setDefaultSettingsTypebot:s}=tm(),{data:o,refetch:a}=Lte({instanceName:t==null?void 0:t.name,token:t==null?void 0:t.token,enabled:n}),{data:l,refetch:c}=FI({instanceName:t==null?void 0:t.name,token:t==null?void 0:t.token,enabled:n}),i=sn({resolver:on(Hte),defaultValues:{expire:0,keywordFinish:e("typebot.form.examples.keywordFinish"),delayMessage:1e3,unknownMessage:e("typebot.form.examples.unknownMessage"),listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:0}});v.useEffect(()=>{o&&i.reset({expire:(o==null?void 0:o.expire)??0,keywordFinish:o.keywordFinish,delayMessage:o.delayMessage??0,unknownMessage:o.unknownMessage,listeningFromMe:o.listeningFromMe,stopBotFromMe:o.stopBotFromMe,keepOpen:o.keepOpen,debounceTime:o.debounceTime??0})},[o]);const d=async f=>{var h,g,m;try{if(!t||!t.name)throw new Error("instance not found.");const x={expire:f.expire,keywordFinish:f.keywordFinish,delayMessage:f.delayMessage,unknownMessage:f.unknownMessage,listeningFromMe:f.listeningFromMe,stopBotFromMe:f.stopBotFromMe,keepOpen:f.keepOpen,debounceTime:f.debounceTime};await s({instanceName:t.name,token:t.token,data:x}),X.success(e("typebot.toast.defaultSettings.success"))}catch(x){console.error(e("typebot.toast.defaultSettings.error"),x),X.error(`Error: ${(m=(g=(h=x==null?void 0:x.response)==null?void 0:h.data)==null?void 0:g.response)==null?void 0:m.message}`)}};function p(){a(),c()}return u.jsxs(Tt,{open:n,onOpenChange:r,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Oi,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:e("typebot.button.defaultSettings")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",onCloseAutoFocus:p,children:[u.jsx(wt,{children:u.jsx(Ut,{children:e("typebot.modal.defaultSettings.title")})}),u.jsx(Tr,{...i,children:u.jsxs("form",{className:"w-full space-y-6",onSubmit:i.handleSubmit(d),children:[u.jsx("div",{children:u.jsxs("div",{className:"space-y-4",children:[u.jsx(Qt,{name:"typebotIdFallback",label:e("typebot.form.typebotIdFallback.label"),options:(l==null?void 0:l.filter(f=>!!f.id).map(f=>({label:f.typebot,value:f.description})))??[]}),u.jsx(G,{name:"expire",label:e("typebot.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:e("typebot.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:e("typebot.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:e("typebot.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:e("typebot.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:e("typebot.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:e("typebot.form.keepOpen.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:e("typebot.form.debounceTime.label"),children:u.jsx(K,{type:"number"})}),u.jsx(Ru,{name:"ignoreJids",label:e("typebot.form.ignoreJids.label"),placeholder:e("typebot.form.ignoreJids.placeholder")})]})}),u.jsx(rn,{children:u.jsx(q,{type:"submit",children:e("typebot.button.save")})})]})})]})]})}const qte=e=>["typebot","fetchSessions",JSON.stringify(e)],Wte=async({instanceName:e,typebotId:t,token:n})=>(await he.get(`/typebot/fetchSessions/${t}/${e}`,{headers:{apiKey:n}})).data,Gte=e=>{const{instanceName:t,token:n,typebotId:r,...s}=e;return lt({...s,queryKey:qte({instanceName:t}),queryFn:()=>Wte({instanceName:t,token:n,typebotId:r}),enabled:!!t&&!!r&&(e.enabled??!0)})};function LI({typebotId:e}){const{t}=ze(),{instance:n}=nt(),[r,s]=v.useState([]),[o,a]=v.useState(!1),[l,c]=v.useState(""),{changeStatusTypebot:i}=tm(),{data:d,refetch:p}=Gte({instanceName:n==null?void 0:n.name,token:n==null?void 0:n.token,typebotId:e});function f(){p()}const h=async(m,x)=>{var b,y,w;try{if(!n)return;await i({instanceName:n.name,token:n.token,remoteJid:m,status:x}),X.success(t("typebot.toast.success.status")),f()}catch(S){console.error("Error:",S),X.error(`Error : ${(w=(y=(b=S==null?void 0:S.response)==null?void 0:b.data)==null?void 0:y.response)==null?void 0:w.message}`)}},g=[{accessorKey:"remoteJid",header:()=>u.jsx("div",{className:"text-center",children:t("typebot.sessions.table.remoteJid")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("remoteJid")})},{accessorKey:"pushName",header:()=>u.jsx("div",{className:"text-center",children:t("typebot.sessions.table.pushName")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("pushName")})},{accessorKey:"sessionId",header:()=>u.jsx("div",{className:"text-center",children:t("typebot.sessions.table.sessionId")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("sessionId")})},{accessorKey:"status",header:()=>u.jsx("div",{className:"text-center",children:t("typebot.sessions.table.status")}),cell:({row:m})=>u.jsx("div",{children:m.getValue("status")})},{id:"actions",enableHiding:!1,cell:({row:m})=>{const x=m.original;return u.jsxs(Eo,{children:[u.jsx(To,{asChild:!0,children:u.jsxs(q,{variant:"ghost",className:"h-8 w-8 p-0",children:[u.jsx("span",{className:"sr-only",children:t("typebot.sessions.table.actions.title")}),u.jsx(vu,{className:"h-4 w-4"})]})}),u.jsxs(ps,{align:"end",children:[u.jsx(Ai,{children:"Actions"}),u.jsx(Pa,{}),x.status!=="opened"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"opened"),children:[u.jsx(qd,{className:"mr-2 h-4 w-4"}),t("typebot.sessions.table.actions.open")]}),x.status!=="paused"&&x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"paused"),children:[u.jsx(Kd,{className:"mr-2 h-4 w-4"}),t("typebot.sessions.table.actions.pause")]}),x.status!=="closed"&&u.jsxs(ft,{onClick:()=>h(x.remoteJid,"closed"),children:[u.jsx(Ud,{className:"mr-2 h-4 w-4"}),t("typebot.sessions.table.actions.close")]}),u.jsxs(ft,{onClick:()=>h(x.remoteJid,"delete"),children:[u.jsx(Vd,{className:"mr-2 h-4 w-4"}),t("typebot.sessions.table.actions.delete")]})]})]})}}];return u.jsxs(Tt,{open:o,onOpenChange:a,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{variant:"secondary",size:"sm",children:[u.jsx(Hd,{size:16,className:"mr-1"})," ",u.jsx("span",{className:"hidden sm:inline",children:t("typebot.sessions.label")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-w-[950px]",onCloseAutoFocus:f,children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("typebot.sessions.label")})}),u.jsxs("div",{children:[u.jsxs("div",{className:"flex items-center justify-between gap-6 p-5",children:[u.jsx(K,{placeholder:t("typebot.sessions.search"),value:l,onChange:m=>c(m.target.value)}),u.jsx(q,{variant:"outline",onClick:f,size:"icon",children:u.jsx(Wd,{size:16})})]}),u.jsx(Nu,{columns:g,data:d??[],onSortingChange:s,state:{sorting:r,globalFilter:l},onGlobalFilterChange:c,enableGlobalFilter:!0,noResultsMessage:t("typebot.sessions.table.none")})]})]})]})}const Jte=_.object({enabled:_.boolean(),description:_.string(),url:_.string(),typebot:_.string().optional(),triggerType:_.string(),triggerOperator:_.string().optional(),triggerValue:_.string().optional(),expire:_.coerce.number().optional(),keywordFinish:_.string().optional(),delayMessage:_.coerce.number().optional(),unknownMessage:_.string().optional(),listeningFromMe:_.boolean().optional(),stopBotFromMe:_.boolean().optional(),keepOpen:_.boolean().optional(),debounceTime:_.coerce.number().optional()});function $I({initialData:e,onSubmit:t,handleDelete:n,typebotId:r,isModal:s=!1,isLoading:o=!1,openDeletionDialog:a=!1,setOpenDeletionDialog:l=()=>{}}){const{t:c}=ze(),i=sn({resolver:on(Jte),defaultValues:e||{enabled:!0,description:"",url:"",typebot:"",triggerType:"keyword",triggerOperator:"contains",triggerValue:"",expire:0,keywordFinish:"",delayMessage:0,unknownMessage:"",listeningFromMe:!1,stopBotFromMe:!1,keepOpen:!1,debounceTime:0}}),d=i.watch("triggerType");return u.jsx(Tr,{...i,children:u.jsxs("form",{onSubmit:i.handleSubmit(t),className:"w-full space-y-6",children:[u.jsxs("div",{className:"space-y-4",children:[u.jsx(ke,{name:"enabled",label:c("typebot.form.enabled.label"),reverse:!0}),u.jsx(G,{name:"description",label:c("typebot.form.description.label"),required:!0,children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("typebot.form.typebotSettings.label")}),u.jsx($t,{})]}),u.jsx(G,{name:"url",label:c("typebot.form.url.label"),required:!0,children:u.jsx(K,{})}),u.jsx(G,{name:"typebot",label:c("typebot.form.typebot.label"),children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("typebot.form.triggerSettings.label")}),u.jsx($t,{})]}),u.jsx(Qt,{name:"triggerType",label:c("typebot.form.triggerType.label"),options:[{label:c("typebot.form.triggerType.keyword"),value:"keyword"},{label:c("typebot.form.triggerType.all"),value:"all"},{label:c("typebot.form.triggerType.advanced"),value:"advanced"},{label:c("typebot.form.triggerType.none"),value:"none"}]}),d==="keyword"&&u.jsxs(u.Fragment,{children:[u.jsx(Qt,{name:"triggerOperator",label:c("typebot.form.triggerOperator.label"),options:[{label:c("typebot.form.triggerOperator.contains"),value:"contains"},{label:c("typebot.form.triggerOperator.equals"),value:"equals"},{label:c("typebot.form.triggerOperator.startsWith"),value:"startsWith"},{label:c("typebot.form.triggerOperator.endsWith"),value:"endsWith"},{label:c("typebot.form.triggerOperator.regex"),value:"regex"}]}),u.jsx(G,{name:"triggerValue",label:c("typebot.form.triggerValue.label"),children:u.jsx(K,{})})]}),d==="advanced"&&u.jsx(G,{name:"triggerValue",label:c("typebot.form.triggerConditions.label"),children:u.jsx(K,{})}),u.jsxs("div",{className:"flex flex-col",children:[u.jsx("h3",{className:"my-4 text-lg font-medium",children:c("typebot.form.generalSettings.label")}),u.jsx($t,{})]}),u.jsx(G,{name:"expire",label:c("typebot.form.expire.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"keywordFinish",label:c("typebot.form.keywordFinish.label"),children:u.jsx(K,{})}),u.jsx(G,{name:"delayMessage",label:c("typebot.form.delayMessage.label"),children:u.jsx(K,{type:"number"})}),u.jsx(G,{name:"unknownMessage",label:c("typebot.form.unknownMessage.label"),children:u.jsx(K,{})}),u.jsx(ke,{name:"listeningFromMe",label:c("typebot.form.listeningFromMe.label"),reverse:!0}),u.jsx(ke,{name:"stopBotFromMe",label:c("typebot.form.stopBotFromMe.label"),reverse:!0}),u.jsx(ke,{name:"keepOpen",label:c("typebot.form.keepOpen.label"),reverse:!0}),u.jsx(G,{name:"debounceTime",label:c("typebot.form.debounceTime.label"),children:u.jsx(K,{type:"number"})})]}),s&&u.jsx(rn,{children:u.jsx(q,{disabled:o,type:"submit",children:c(o?"typebot.button.saving":"typebot.button.save")})}),!s&&u.jsxs("div",{children:[u.jsx(LI,{typebotId:r}),u.jsxs("div",{className:"mt-5 flex items-center gap-3",children:[u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsx(q,{variant:"destructive",size:"sm",children:c("dify.button.delete")})}),u.jsx(xt,{children:u.jsxs(wt,{children:[u.jsx(Ut,{children:c("modal.delete.title")}),u.jsx(Fi,{children:c("modal.delete.messageSingle")}),u.jsxs(rn,{children:[u.jsx(q,{size:"sm",variant:"outline",onClick:()=>l(!1),children:c("button.cancel")}),u.jsx(q,{variant:"destructive",onClick:n,children:c("button.delete")})]})]})})]}),u.jsx(q,{disabled:o,type:"submit",children:c(o?"typebot.button.saving":"typebot.button.update")})]})]})]})})}function Qte({resetTable:e}){const{t}=ze(),{instance:n}=nt(),{createTypebot:r}=tm(),[s,o]=v.useState(!1),[a,l]=v.useState(!1),c=async i=>{var d,p,f;try{if(!n||!n.name)throw new Error("instance not found");o(!0);const h={enabled:i.enabled,description:i.description,url:i.url,typebot:i.typebot||"",triggerType:i.triggerType,triggerOperator:i.triggerOperator||"",triggerValue:i.triggerValue||"",expire:i.expire||0,keywordFinish:i.keywordFinish||"",delayMessage:i.delayMessage||0,unknownMessage:i.unknownMessage||"",listeningFromMe:i.listeningFromMe||!1,stopBotFromMe:i.stopBotFromMe||!1,keepOpen:i.keepOpen||!1,debounceTime:i.debounceTime||0};await r({instanceName:n.name,token:n.token,data:h}),X.success(t("typebot.toast.success.create")),l(!1),e()}catch(h){console.error("Error:",h),X.error(`Error: ${(f=(p=(d=h==null?void 0:h.response)==null?void 0:d.data)==null?void 0:p.response)==null?void 0:f.message}`)}finally{o(!1)}};return u.jsxs(Tt,{open:a,onOpenChange:l,children:[u.jsx(Nt,{asChild:!0,children:u.jsxs(q,{size:"sm",children:[u.jsx(Ni,{size:16,className:"mr-1"}),u.jsx("span",{className:"hidden sm:inline",children:t("typebot.button.create")})]})}),u.jsxs(xt,{className:"overflow-y-auto sm:max-h-[600px] sm:max-w-[740px]",children:[u.jsx(wt,{children:u.jsx(Ut,{children:t("typebot.form.title")})}),u.jsx($I,{onSubmit:c,isModal:!0,isLoading:s})]})]})}const Zte=e=>["typebot","getTypebot",JSON.stringify(e)],Yte=async({instanceName:e,token:t,typebotId:n})=>{const r=await he.get(`/typebot/fetch/${n}/${e}`,{headers:{apiKey:t}});return Array.isArray(r.data)?r.data[0]:r.data},Xte=e=>{const{instanceName:t,token:n,typebotId:r,...s}=e;return lt({...s,queryKey:Zte({instanceName:t}),queryFn:()=>Yte({instanceName:t,token:n,typebotId:r}),enabled:!!t&&!!r&&(e.enabled??!0)})};function ene({typebotId:e,resetTable:t}){const{t:n}=ze(),{instance:r}=nt(),s=An(),[o,a]=v.useState(!1),{deleteTypebot:l,updateTypebot:c}=tm(),{data:i,isLoading:d}=Xte({instanceName:r==null?void 0:r.name,typebotId:e}),p=v.useMemo(()=>({enabled:!!(i!=null&&i.enabled),description:(i==null?void 0:i.description)??"",url:(i==null?void 0:i.url)??"",typebot:(i==null?void 0:i.typebot)??"",triggerType:(i==null?void 0:i.triggerType)??"",triggerOperator:(i==null?void 0:i.triggerOperator)??"",triggerValue:i==null?void 0:i.triggerValue,expire:(i==null?void 0:i.expire)??0,keywordFinish:i==null?void 0:i.keywordFinish,delayMessage:(i==null?void 0:i.delayMessage)??0,unknownMessage:i==null?void 0:i.unknownMessage,listeningFromMe:!!(i!=null&&i.listeningFromMe),stopBotFromMe:!!(i!=null&&i.stopBotFromMe),keepOpen:!!(i!=null&&i.keepOpen),debounceTime:(i==null?void 0:i.debounceTime)??0}),[i==null?void 0:i.debounceTime,i==null?void 0:i.delayMessage,i==null?void 0:i.description,i==null?void 0:i.enabled,i==null?void 0:i.expire,i==null?void 0:i.keepOpen,i==null?void 0:i.keywordFinish,i==null?void 0:i.listeningFromMe,i==null?void 0:i.stopBotFromMe,i==null?void 0:i.triggerOperator,i==null?void 0:i.triggerType,i==null?void 0:i.triggerValue,i==null?void 0:i.typebot,i==null?void 0:i.unknownMessage,i==null?void 0:i.url]),f=async g=>{var m,x,b;try{if(r&&r.name&&e){const y={enabled:g.enabled,description:g.description,url:g.url,typebot:g.typebot||"",triggerType:g.triggerType,triggerOperator:g.triggerOperator||"",triggerValue:g.triggerValue||"",expire:g.expire||0,keywordFinish:g.keywordFinish||"",delayMessage:g.delayMessage||1e3,unknownMessage:g.unknownMessage||"",listeningFromMe:g.listeningFromMe||!1,stopBotFromMe:g.stopBotFromMe||!1,keepOpen:g.keepOpen||!1,debounceTime:g.debounceTime||0};await c({instanceName:r.name,typebotId:e,data:y}),X.success(n("typebot.toast.success.update")),t(),s(`/manager/instance/${r.id}/typebot/${e}`)}else console.error("Token not found")}catch(y){console.error("Error:",y),X.error(`Error: ${(b=(x=(m=y==null?void 0:y.response)==null?void 0:m.data)==null?void 0:x.response)==null?void 0:b.message}`)}},h=async()=>{try{r&&r.name&&e?(await l({instanceName:r.name,typebotId:e}),X.success(n("typebot.toast.success.delete")),a(!1),t(),s(`/manager/instance/${r.id}/typebot`)):console.error("instance not found")}catch(g){console.error("Erro ao excluir dify:",g)}};return d?u.jsx(wr,{}):u.jsx("div",{className:"m-4",children:u.jsx($I,{initialData:p,onSubmit:f,typebotId:e,handleDelete:h,isModal:!1,isLoading:d,openDeletionDialog:o,setOpenDeletionDialog:a})})}function aE(){const{t:e}=ze(),t=Ou("(min-width: 768px)"),{instance:n}=nt(),{typebotId:r}=So(),{data:s,isLoading:o,refetch:a}=FI({instanceName:n==null?void 0:n.name,token:n==null?void 0:n.token}),l=An(),c=d=>{n&&l(`/manager/instance/${n.id}/typebot/${d}`)},i=()=>{a()};return u.jsxs("main",{className:"pt-5",children:[u.jsxs("div",{className:"mb-1 flex items-center justify-between",children:[u.jsx("h3",{className:"text-lg font-medium",children:e("typebot.title")}),u.jsxs("div",{className:"flex flex-wrap items-center justify-end gap-2",children:[u.jsx(LI,{}),u.jsx(Kte,{}),u.jsx(Qte,{resetTable:i})]})]}),u.jsx($t,{className:"my-4"}),u.jsxs(Pu,{direction:t?"horizontal":"vertical",children:[u.jsx(Ur,{defaultSize:35,className:"pr-4",children:u.jsx("div",{className:"flex flex-col gap-3",children:o?u.jsx(wr,{}):u.jsx(u.Fragment,{children:s&&s.length>0&&Array.isArray(s)?s.map(d=>u.jsx(q,{className:"flex h-auto flex-col items-start justify-start",onClick:()=>c(`${d.id}`),variant:r===d.id?"secondary":"outline",children:d.description?u.jsxs(u.Fragment,{children:[u.jsx("h4",{className:"text-base",children:d.description}),u.jsxs("p",{className:"text-wrap text-sm font-normal text-muted-foreground",children:[d.url," - ",d.typebot]})]}):u.jsxs(u.Fragment,{children:[u.jsx("h4",{className:"text-base",children:d.url}),u.jsx("p",{className:"text-wrap text-sm font-normal text-muted-foreground",children:d.typebot})]})},d.id)):u.jsx(q,{variant:"link",children:e("typebot.table.none")})})})}),r&&u.jsxs(u.Fragment,{children:[u.jsx(Mu,{withHandle:!0,className:"border border-black"}),u.jsx(Ur,{children:u.jsx(ene,{typebotId:r,resetTable:i})})]})]})]})}const tne=e=>["webhook","fetchWebhook",JSON.stringify(e)],nne=async({instanceName:e,token:t})=>(await he.get(`/webhook/find/${e}`,{headers:{apiKey:t}})).data,rne=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:tne({instanceName:t,token:n}),queryFn:()=>nne({instanceName:t,token:n}),enabled:!!t})},sne=async({instanceName:e,token:t,data:n})=>(await he.post(`/webhook/set/${e}`,{webhook:n},{headers:{apikey:t}})).data;function one(){return{createWebhook:Ye(sne,{invalidateKeys:[["webhook","fetchWebhook"]]})}}const ane=_.object({enabled:_.boolean(),url:_.string().url("Invalid URL format"),events:_.array(_.string()),base64:_.boolean(),byEvents:_.boolean()});function ine(){const{t:e}=ze(),{instance:t}=nt(),[n,r]=v.useState(!1),{createWebhook:s}=one(),{data:o}=rne({instanceName:t==null?void 0:t.name,token:t==null?void 0:t.token}),a=sn({resolver:on(ane),defaultValues:{enabled:!1,url:"",events:[],base64:!1,byEvents:!1}});v.useEffect(()=>{o&&a.reset({enabled:o.enabled,url:o.url,events:o.events,base64:o.webhookBase64,byEvents:o.webhookByEvents})},[o]);const l=async p=>{var f,h,g;if(t){r(!0);try{const m={enabled:p.enabled,url:p.url,events:p.events,base64:p.base64,byEvents:p.byEvents};await s({instanceName:t.name,token:t.token,data:m}),X.success(e("webhook.toast.success"))}catch(m){console.error(e("webhook.toast.error"),m),X.error(`Error: ${(g=(h=(f=m==null?void 0:m.response)==null?void 0:f.data)==null?void 0:h.response)==null?void 0:g.message}`)}finally{r(!1)}}},c=["APPLICATION_STARTUP","QRCODE_UPDATED","MESSAGES_SET","MESSAGES_UPSERT","MESSAGES_UPDATE","MESSAGES_DELETE","SEND_MESSAGE","CONTACTS_SET","CONTACTS_UPSERT","CONTACTS_UPDATE","PRESENCE_UPDATE","CHATS_SET","CHATS_UPSERT","CHATS_UPDATE","CHATS_DELETE","GROUPS_UPSERT","GROUP_UPDATE","GROUP_PARTICIPANTS_UPDATE","CONNECTION_UPDATE","REMOVE_INSTANCE","LOGOUT_INSTANCE","LABELS_EDIT","LABELS_ASSOCIATION","CALL","TYPEBOT_START","TYPEBOT_CHANGE_STATUS"],i=()=>{a.setValue("events",c)},d=()=>{a.setValue("events",[])};return u.jsx(u.Fragment,{children:u.jsx(Na,{...a,children:u.jsx("form",{onSubmit:a.handleSubmit(l),className:"w-full space-y-6",children:u.jsxs("div",{children:[u.jsx("h3",{className:"mb-1 text-lg font-medium",children:e("webhook.title")}),u.jsx(Ra,{className:"my-4"}),u.jsxs("div",{className:"mx-4 space-y-2 divide-y [&>*]:p-4",children:[u.jsx(ke,{name:"enabled",label:e("webhook.form.enabled.label"),className:"w-full justify-between",helper:e("webhook.form.enabled.description")}),u.jsx(G,{name:"url",label:"URL",children:u.jsx(K,{})}),u.jsx(ke,{name:"byEvents",label:e("webhook.form.byEvents.label"),className:"w-full justify-between",helper:e("webhook.form.byEvents.description")}),u.jsx(ke,{name:"base64",label:e("webhook.form.base64.label"),className:"w-full justify-between",helper:e("webhook.form.base64.description")}),u.jsxs("div",{className:"mb-4 flex justify-between",children:[u.jsx(q,{variant:"outline",type:"button",onClick:i,children:e("button.markAll")}),u.jsx(q,{variant:"outline",type:"button",onClick:d,children:e("button.unMarkAll")})]}),u.jsx(Ia,{control:a.control,name:"events",render:({field:p})=>u.jsxs(_o,{className:"flex flex-col",children:[u.jsx(xr,{className:"my-2 text-lg",children:e("webhook.form.events.label")}),u.jsx(Vs,{children:u.jsx("div",{className:"flex flex-col gap-2 space-y-1 divide-y",children:c.sort((f,h)=>f.localeCompare(h)).map(f=>u.jsxs("div",{className:"flex items-center justify-between gap-3 pt-3",children:[u.jsx(xr,{className:ge("break-all",p.value.includes(f)?"text-foreground":"text-muted-foreground"),children:f}),u.jsx(ju,{checked:p.value.includes(f),onCheckedChange:h=>{h?p.onChange([...p.value,f]):p.onChange(p.value.filter(g=>g!==f))}})]},f))})})]})})]}),u.jsx("div",{className:"mx-4 flex justify-end pt-6",children:u.jsx(q,{type:"submit",disabled:n,children:e(n?"webhook.button.saving":"webhook.button.save")})})]})})})})}const lne=e=>["websocket","fetchWebsocket",JSON.stringify(e)],une=async({instanceName:e,token:t})=>(await he.get(`/websocket/find/${e}`,{headers:{apiKey:t}})).data,cne=e=>{const{instanceName:t,token:n,...r}=e;return lt({...r,queryKey:lne({instanceName:t,token:n}),queryFn:()=>une({instanceName:t,token:n}),enabled:!!t})},dne=async({instanceName:e,token:t,data:n})=>(await he.post(`/websocket/set/${e}`,{websocket:n},{headers:{apikey:t}})).data;function fne(){return{createWebsocket:Ye(dne,{invalidateKeys:[["websocket","fetchWebsocket"]]})}}const pne=_.object({enabled:_.boolean(),events:_.array(_.string())});function hne(){const{t:e}=ze(),{instance:t}=nt(),[n,r]=v.useState(!1),{createWebsocket:s}=fne(),{data:o}=cne({instanceName:t==null?void 0:t.name,token:t==null?void 0:t.token}),a=sn({resolver:on(pne),defaultValues:{enabled:!1,events:[]}});v.useEffect(()=>{o&&a.reset({enabled:o.enabled,events:o.events})},[o]);const l=async p=>{var f,h,g;if(t){r(!0);try{const m={enabled:p.enabled,events:p.events};await s({instanceName:t.name,token:t.token,data:m}),X.success(e("websocket.toast.success"))}catch(m){console.error(e("websocket.toast.error"),m),X.error(`Error: ${(g=(h=(f=m==null?void 0:m.response)==null?void 0:f.data)==null?void 0:h.response)==null?void 0:g.message}`)}finally{r(!1)}}},c=["APPLICATION_STARTUP","QRCODE_UPDATED","MESSAGES_SET","MESSAGES_UPSERT","MESSAGES_UPDATE","MESSAGES_DELETE","SEND_MESSAGE","CONTACTS_SET","CONTACTS_UPSERT","CONTACTS_UPDATE","PRESENCE_UPDATE","CHATS_SET","CHATS_UPSERT","CHATS_UPDATE","CHATS_DELETE","GROUPS_UPSERT","GROUP_UPDATE","GROUP_PARTICIPANTS_UPDATE","CONNECTION_UPDATE","REMOVE_INSTANCE","LOGOUT_INSTANCE","LABELS_EDIT","LABELS_ASSOCIATION","CALL","TYPEBOT_START","TYPEBOT_CHANGE_STATUS"],i=()=>{a.setValue("events",c)},d=()=>{a.setValue("events",[])};return u.jsx(u.Fragment,{children:u.jsx(Na,{...a,children:u.jsx("form",{onSubmit:a.handleSubmit(l),className:"w-full space-y-6",children:u.jsxs("div",{children:[u.jsx("h3",{className:"mb-1 text-lg font-medium",children:e("websocket.title")}),u.jsx(Ra,{className:"my-4"}),u.jsxs("div",{className:"mx-4 space-y-2 divide-y [&>*]:p-4",children:[u.jsx(ke,{name:"enabled",label:e("websocket.form.enabled.label"),className:"w-full justify-between",helper:e("websocket.form.enabled.description")}),u.jsxs("div",{className:"mb-4 flex justify-between",children:[u.jsx(q,{variant:"outline",type:"button",onClick:i,children:e("button.markAll")}),u.jsx(q,{variant:"outline",type:"button",onClick:d,children:e("button.unMarkAll")})]}),u.jsx(Ia,{control:a.control,name:"events",render:({field:p})=>u.jsxs(_o,{className:"flex flex-col",children:[u.jsx(xr,{className:"my-2 text-lg",children:e("websocket.form.events.label")}),u.jsx(Vs,{children:u.jsx("div",{className:"flex flex-col gap-2 space-y-1 divide-y",children:c.sort((f,h)=>f.localeCompare(h)).map(f=>u.jsxs("div",{className:"flex items-center justify-between gap-3 pt-3",children:[u.jsx(xr,{className:ge("break-all",p.value.includes(f)?"text-foreground":"text-muted-foreground"),children:f}),u.jsx(ju,{checked:p.value.includes(f),onCheckedChange:h=>{h?p.onChange([...p.value,f]):p.onChange(p.value.filter(g=>g!==f))}})]},f))})})]})})]}),u.jsx("div",{className:"mx-4 flex justify-end pt-6",children:u.jsx(q,{type:"submit",disabled:n,children:e(n?"websocket.button.saving":"websocket.button.save")})})]})})})})}const gne=async({url:e,token:t})=>{try{const{data:n}=await zt.post(`${e}/verify-creds`,{},{headers:{apikey:t}});return P_({facebookAppId:n.facebookAppId,facebookConfigId:n.facebookConfigId,facebookUserToken:n.facebookUserToken}),n}catch{return null}},mne=_.object({serverUrl:_.string({required_error:"serverUrl is required"}).url("URL inválida"),apiKey:_.string({required_error:"ApiKey is required"})});function vne(){const{t:e}=ze(),t=An(),n=sn({resolver:on(mne),defaultValues:{serverUrl:window.location.protocol+"//"+window.location.host,apiKey:""}}),r=async s=>{const o=await nj({url:s.serverUrl});if(!o||!o.version){M_(),n.setError("serverUrl",{type:"manual",message:e("login.message.invalidServer")});return}if(!await gne({token:s.apiKey,url:s.serverUrl})){n.setError("apiKey",{type:"manual",message:e("login.message.invalidCredentials")});return}P_({version:o.version,clientName:o.clientName,url:s.serverUrl,token:s.apiKey}),t("/manager/")};return u.jsxs("div",{className:"flex min-h-screen flex-col",children:[u.jsx("div",{className:"flex items-center justify-center pt-2",children:u.jsx("img",{className:"h-10",src:"/assets/images/evolution-logo.png",alt:"logo"})}),u.jsx("div",{className:"flex flex-1 items-center justify-center p-8",children:u.jsxs(Ja,{className:"b-none w-[350px] shadow-none",children:[u.jsxs(Qa,{children:[u.jsx(jc,{className:"text-center",children:e("login.title")}),u.jsx(JP,{className:"text-center",children:e("login.description")})]}),u.jsx(Na,{...n,children:u.jsxs("form",{onSubmit:n.handleSubmit(r),children:[u.jsx(Za,{children:u.jsxs("div",{className:"grid w-full items-center gap-4",children:[u.jsx(G,{required:!0,name:"serverUrl",label:e("login.form.serverUrl"),children:u.jsx(K,{})}),u.jsx(G,{required:!0,name:"apiKey",label:e("login.form.apiKey"),children:u.jsx(K,{type:"password"})})]})}),u.jsx(kg,{className:"flex justify-center",children:u.jsx(q,{className:"w-full",type:"submit",children:e("login.button.login")})})]})})]})}),u.jsx(Ax,{})]})}const yne=OL([{path:"/manager/login",element:u.jsx(l$,{children:u.jsx(vne,{})})},{path:"/manager/",element:u.jsx(Gt,{children:u.jsx(SV,{children:u.jsx(GQ,{})})})},{path:"/manager/instance/:instanceId/dashboard",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(SY,{})})})},{path:"/manager/instance/:instanceId/chat",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(Q1,{})})})},{path:"/manager/instance/:instanceId/chat/:remoteJid",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(Q1,{})})})},{path:"/manager/instance/:instanceId/settings",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(kte,{})})})},{path:"/manager/instance/:instanceId/openai",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(oE,{})})})},{path:"/manager/instance/:instanceId/openai/:botId",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(oE,{})})})},{path:"/manager/instance/:instanceId/webhook",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(ine,{})})})},{path:"/manager/instance/:instanceId/websocket",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(hne,{})})})},{path:"/manager/instance/:instanceId/rabbitmq",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(wte,{})})})},{path:"/manager/instance/:instanceId/sqs",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(Nte,{})})})},{path:"/manager/instance/:instanceId/chatwoot",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(HZ,{})})})},{path:"/manager/instance/:instanceId/typebot",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(aE,{})})})},{path:"/manager/instance/:instanceId/typebot/:typebotId",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(aE,{})})})},{path:"/manager/instance/:instanceId/dify",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(nE,{})})})},{path:"/manager/instance/:instanceId/dify/:difyId",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(nE,{})})})},{path:"/manager/instance/:instanceId/evolutionBot",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(rE,{})})})},{path:"/manager/instance/:instanceId/evolutionBot/:evolutionBotId",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(rE,{})})})},{path:"/manager/instance/:instanceId/flowise",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(sE,{})})})},{path:"/manager/instance/:instanceId/flowise/:flowiseId",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(sE,{})})})},{path:"/manager/instance/:instanceId/proxy",element:u.jsx(Gt,{children:u.jsx(Xt,{children:u.jsx(hte,{})})})}]),bne={type:"logger",log(e){this.output("log",e)},warn(e){this.output("warn",e)},error(e){this.output("error",e)},output(e,t){console&&console[e]&&console[e].apply(console,t)}};class jh{constructor(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.init(t,n)}init(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.prefix=n.prefix||"i18next:",this.logger=t||bne,this.options=n,this.debug=n.debug}log(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return this.forward(n,"log","",!0)}warn(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return this.forward(n,"warn","",!0)}error(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return this.forward(n,"error","")}deprecate(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return this.forward(n,"warn","WARNING DEPRECATED: ",!0)}forward(t,n,r,s){return s&&!this.debug?null:(typeof t[0]=="string"&&(t[0]=`${r}${this.prefix} ${t[0]}`),this.logger[n](t))}create(t){return new jh(this.logger,{prefix:`${this.prefix}:${t}:`,...this.options})}clone(t){return t=t||this.options,t.prefix=t.prefix||this.prefix,new jh(this.logger,t)}}var Is=new jh;class nm{constructor(){this.observers={}}on(t,n){return t.split(" ").forEach(r=>{this.observers[r]||(this.observers[r]=new Map);const s=this.observers[r].get(n)||0;this.observers[r].set(n,s+1)}),this}off(t,n){if(this.observers[t]){if(!n){delete this.observers[t];return}this.observers[t].delete(n)}}emit(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];this.observers[t]&&Array.from(this.observers[t].entries()).forEach(a=>{let[l,c]=a;for(let i=0;i<c;i++)l(...r)}),this.observers["*"]&&Array.from(this.observers["*"].entries()).forEach(a=>{let[l,c]=a;for(let i=0;i<c;i++)l.apply(l,[t,...r])})}}const sc=()=>{let e,t;const n=new Promise((r,s)=>{e=r,t=s});return n.resolve=e,n.reject=t,n},iE=e=>e==null?"":""+e,xne=(e,t,n)=>{e.forEach(r=>{t[r]&&(n[r]=t[r])})},wne=/###/g,lE=e=>e&&e.indexOf("###")>-1?e.replace(wne,"."):e,uE=e=>!e||typeof e=="string",Ic=(e,t,n)=>{const r=typeof t!="string"?t:t.split(".");let s=0;for(;s<r.length-1;){if(uE(e))return{};const o=lE(r[s]);!e[o]&&n&&(e[o]=new n),Object.prototype.hasOwnProperty.call(e,o)?e=e[o]:e={},++s}return uE(e)?{}:{obj:e,k:lE(r[s])}},cE=(e,t,n)=>{const{obj:r,k:s}=Ic(e,t,Object);if(r!==void 0||t.length===1){r[s]=n;return}let o=t[t.length-1],a=t.slice(0,t.length-1),l=Ic(e,a,Object);for(;l.obj===void 0&&a.length;)o=`${a[a.length-1]}.${o}`,a=a.slice(0,a.length-1),l=Ic(e,a,Object),l&&l.obj&&typeof l.obj[`${l.k}.${o}`]<"u"&&(l.obj=void 0);l.obj[`${l.k}.${o}`]=n},Sne=(e,t,n,r)=>{const{obj:s,k:o}=Ic(e,t,Object);s[o]=s[o]||[],s[o].push(n)},Rh=(e,t)=>{const{obj:n,k:r}=Ic(e,t);if(n)return n[r]},Cne=(e,t,n)=>{const r=Rh(e,n);return r!==void 0?r:Rh(t,n)},BI=(e,t,n)=>{for(const r in t)r!=="__proto__"&&r!=="constructor"&&(r in e?typeof e[r]=="string"||e[r]instanceof String||typeof t[r]=="string"||t[r]instanceof String?n&&(e[r]=t[r]):BI(e[r],t[r],n):e[r]=t[r]);return e},Xi=e=>e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&");var Ene={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};const Tne=e=>typeof e=="string"?e.replace(/[&<>"'\/]/g,t=>Ene[t]):e;class kne{constructor(t){this.capacity=t,this.regExpMap=new Map,this.regExpQueue=[]}getRegExp(t){const n=this.regExpMap.get(t);if(n!==void 0)return n;const r=new RegExp(t);return this.regExpQueue.length===this.capacity&&this.regExpMap.delete(this.regExpQueue.shift()),this.regExpMap.set(t,r),this.regExpQueue.push(t),r}}const _ne=[" ",",","?","!",";"],jne=new kne(20),Rne=(e,t,n)=>{t=t||"",n=n||"";const r=_ne.filter(a=>t.indexOf(a)<0&&n.indexOf(a)<0);if(r.length===0)return!0;const s=jne.getRegExp(`(${r.map(a=>a==="?"?"\\?":a).join("|")})`);let o=!s.test(e);if(!o){const a=e.indexOf(n);a>0&&!s.test(e.substring(0,a))&&(o=!0)}return o},_b=function(e,t){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:".";if(!e)return;if(e[t])return e[t];const r=t.split(n);let s=e;for(let o=0;o<r.length;){if(!s||typeof s!="object")return;let a,l="";for(let c=o;c<r.length;++c)if(c!==o&&(l+=n),l+=r[c],a=s[l],a!==void 0){if(["string","number","boolean"].indexOf(typeof a)>-1&&c<r.length-1)continue;o+=c-o+1;break}s=a}return s},Ph=e=>e&&e.indexOf("_")>0?e.replace("_","-"):e;class dE extends nm{constructor(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{ns:["translation"],defaultNS:"translation"};super(),this.data=t||{},this.options=n,this.options.keySeparator===void 0&&(this.options.keySeparator="."),this.options.ignoreJSONStructure===void 0&&(this.options.ignoreJSONStructure=!0)}addNamespaces(t){this.options.ns.indexOf(t)<0&&this.options.ns.push(t)}removeNamespaces(t){const n=this.options.ns.indexOf(t);n>-1&&this.options.ns.splice(n,1)}getResource(t,n,r){let s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};const o=s.keySeparator!==void 0?s.keySeparator:this.options.keySeparator,a=s.ignoreJSONStructure!==void 0?s.ignoreJSONStructure:this.options.ignoreJSONStructure;let l;t.indexOf(".")>-1?l=t.split("."):(l=[t,n],r&&(Array.isArray(r)?l.push(...r):typeof r=="string"&&o?l.push(...r.split(o)):l.push(r)));const c=Rh(this.data,l);return!c&&!n&&!r&&t.indexOf(".")>-1&&(t=l[0],n=l[1],r=l.slice(2).join(".")),c||!a||typeof r!="string"?c:_b(this.data&&this.data[t]&&this.data[t][n],r,o)}addResource(t,n,r,s){let o=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{silent:!1};const a=o.keySeparator!==void 0?o.keySeparator:this.options.keySeparator;let l=[t,n];r&&(l=l.concat(a?r.split(a):r)),t.indexOf(".")>-1&&(l=t.split("."),s=n,n=l[1]),this.addNamespaces(n),cE(this.data,l,s),o.silent||this.emit("added",t,n,r,s)}addResources(t,n,r){let s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{silent:!1};for(const o in r)(typeof r[o]=="string"||Array.isArray(r[o]))&&this.addResource(t,n,o,r[o],{silent:!0});s.silent||this.emit("added",t,n,r)}addResourceBundle(t,n,r,s,o){let a=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{silent:!1,skipCopy:!1},l=[t,n];t.indexOf(".")>-1&&(l=t.split("."),s=r,r=n,n=l[1]),this.addNamespaces(n);let c=Rh(this.data,l)||{};a.skipCopy||(r=JSON.parse(JSON.stringify(r))),s?BI(c,r,o):c={...c,...r},cE(this.data,l,c),a.silent||this.emit("added",t,n,r)}removeResourceBundle(t,n){this.hasResourceBundle(t,n)&&delete this.data[t][n],this.removeNamespaces(n),this.emit("removed",t,n)}hasResourceBundle(t,n){return this.getResource(t,n)!==void 0}getResourceBundle(t,n){return n||(n=this.options.defaultNS),this.options.compatibilityAPI==="v1"?{...this.getResource(t,n)}:this.getResource(t,n)}getDataByLanguage(t){return this.data[t]}hasLanguageSomeTranslations(t){const n=this.getDataByLanguage(t);return!!(n&&Object.keys(n)||[]).find(s=>n[s]&&Object.keys(n[s]).length>0)}toJSON(){return this.data}}var zI={processors:{},addPostProcessor(e){this.processors[e.name]=e},handle(e,t,n,r,s){return e.forEach(o=>{this.processors[o]&&(t=this.processors[o].process(t,n,r,s))}),t}};const fE={};class Mh extends nm{constructor(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};super(),xne(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],t,this),this.options=n,this.options.keySeparator===void 0&&(this.options.keySeparator="."),this.logger=Is.create("translator")}changeLanguage(t){t&&(this.language=t)}exists(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{interpolation:{}};if(t==null)return!1;const r=this.resolve(t,n);return r&&r.res!==void 0}extractFromKey(t,n){let r=n.nsSeparator!==void 0?n.nsSeparator:this.options.nsSeparator;r===void 0&&(r=":");const s=n.keySeparator!==void 0?n.keySeparator:this.options.keySeparator;let o=n.ns||this.options.defaultNS||[];const a=r&&t.indexOf(r)>-1,l=!this.options.userDefinedKeySeparator&&!n.keySeparator&&!this.options.userDefinedNsSeparator&&!n.nsSeparator&&!Rne(t,r,s);if(a&&!l){const c=t.match(this.interpolator.nestingRegexp);if(c&&c.length>0)return{key:t,namespaces:o};const i=t.split(r);(r!==s||r===s&&this.options.ns.indexOf(i[0])>-1)&&(o=i.shift()),t=i.join(s)}return typeof o=="string"&&(o=[o]),{key:t,namespaces:o}}translate(t,n,r){if(typeof n!="object"&&this.options.overloadTranslationOptionHandler&&(n=this.options.overloadTranslationOptionHandler(arguments)),typeof n=="object"&&(n={...n}),n||(n={}),t==null)return"";Array.isArray(t)||(t=[String(t)]);const s=n.returnDetails!==void 0?n.returnDetails:this.options.returnDetails,o=n.keySeparator!==void 0?n.keySeparator:this.options.keySeparator,{key:a,namespaces:l}=this.extractFromKey(t[t.length-1],n),c=l[l.length-1],i=n.lng||this.language,d=n.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(i&&i.toLowerCase()==="cimode"){if(d){const S=n.nsSeparator||this.options.nsSeparator;return s?{res:`${c}${S}${a}`,usedKey:a,exactUsedKey:a,usedLng:i,usedNS:c,usedParams:this.getUsedParamsDetails(n)}:`${c}${S}${a}`}return s?{res:a,usedKey:a,exactUsedKey:a,usedLng:i,usedNS:c,usedParams:this.getUsedParamsDetails(n)}:a}const p=this.resolve(t,n);let f=p&&p.res;const h=p&&p.usedKey||a,g=p&&p.exactUsedKey||a,m=Object.prototype.toString.apply(f),x=["[object Number]","[object Function]","[object RegExp]"],b=n.joinArrays!==void 0?n.joinArrays:this.options.joinArrays,y=!this.i18nFormat||this.i18nFormat.handleAsObject;if(y&&f&&(typeof f!="string"&&typeof f!="boolean"&&typeof f!="number")&&x.indexOf(m)<0&&!(typeof b=="string"&&Array.isArray(f))){if(!n.returnObjects&&!this.options.returnObjects){this.options.returnedObjectHandler||this.logger.warn("accessing an object - but returnObjects options is not enabled!");const S=this.options.returnedObjectHandler?this.options.returnedObjectHandler(h,f,{...n,ns:l}):`key '${a} (${this.language})' returned an object instead of string.`;return s?(p.res=S,p.usedParams=this.getUsedParamsDetails(n),p):S}if(o){const S=Array.isArray(f),E=S?[]:{},C=S?g:h;for(const k in f)if(Object.prototype.hasOwnProperty.call(f,k)){const T=`${C}${o}${k}`;E[k]=this.translate(T,{...n,joinArrays:!1,ns:l}),E[k]===T&&(E[k]=f[k])}f=E}}else if(y&&typeof b=="string"&&Array.isArray(f))f=f.join(b),f&&(f=this.extendTranslation(f,t,n,r));else{let S=!1,E=!1;const C=n.count!==void 0&&typeof n.count!="string",k=Mh.hasDefaultValue(n),T=C?this.pluralResolver.getSuffix(i,n.count,n):"",P=n.ordinal&&C?this.pluralResolver.getSuffix(i,n.count,{ordinal:!1}):"",N=C&&!n.ordinal&&n.count===0&&this.pluralResolver.shouldUseIntlApi(),U=N&&n[`defaultValue${this.options.pluralSeparator}zero`]||n[`defaultValue${T}`]||n[`defaultValue${P}`]||n.defaultValue;!this.isValidLookup(f)&&k&&(S=!0,f=U),this.isValidLookup(f)||(E=!0,f=a);const Z=(n.missingKeyNoValueFallbackToKey||this.options.missingKeyNoValueFallbackToKey)&&E?void 0:f,V=k&&U!==f&&this.options.updateMissing;if(E||S||V){if(this.logger.log(V?"updateKey":"missingKey",i,c,a,V?U:f),o){const F=this.resolve(a,{...n,keySeparator:!1});F&&F.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}let Q=[];const ee=this.languageUtils.getFallbackCodes(this.options.fallbackLng,n.lng||this.language);if(this.options.saveMissingTo==="fallback"&&ee&&ee[0])for(let F=0;F<ee.length;F++)Q.push(ee[F]);else this.options.saveMissingTo==="all"?Q=this.languageUtils.toResolveHierarchy(n.lng||this.language):Q.push(n.lng||this.language);const W=(F,A,Y)=>{const de=k&&Y!==f?Y:Z;this.options.missingKeyHandler?this.options.missingKeyHandler(F,c,A,de,V,n):this.backendConnector&&this.backendConnector.saveMissing&&this.backendConnector.saveMissing(F,c,A,de,V,n),this.emit("missingKey",F,c,A,f)};this.options.saveMissing&&(this.options.saveMissingPlurals&&C?Q.forEach(F=>{const A=this.pluralResolver.getSuffixes(F,n);N&&n[`defaultValue${this.options.pluralSeparator}zero`]&&A.indexOf(`${this.options.pluralSeparator}zero`)<0&&A.push(`${this.options.pluralSeparator}zero`),A.forEach(Y=>{W([F],a+Y,n[`defaultValue${Y}`]||U)})}):W(Q,a,U))}f=this.extendTranslation(f,t,n,p,r),E&&f===a&&this.options.appendNamespaceToMissingKey&&(f=`${c}:${a}`),(E||S)&&this.options.parseMissingKeyHandler&&(this.options.compatibilityAPI!=="v1"?f=this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey?`${c}:${a}`:a,S?f:void 0):f=this.options.parseMissingKeyHandler(f))}return s?(p.res=f,p.usedParams=this.getUsedParamsDetails(n),p):f}extendTranslation(t,n,r,s,o){var a=this;if(this.i18nFormat&&this.i18nFormat.parse)t=this.i18nFormat.parse(t,{...this.options.interpolation.defaultVariables,...r},r.lng||this.language||s.usedLng,s.usedNS,s.usedKey,{resolved:s});else if(!r.skipInterpolation){r.interpolation&&this.interpolator.init({...r,interpolation:{...this.options.interpolation,...r.interpolation}});const i=typeof t=="string"&&(r&&r.interpolation&&r.interpolation.skipOnVariables!==void 0?r.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables);let d;if(i){const f=t.match(this.interpolator.nestingRegexp);d=f&&f.length}let p=r.replace&&typeof r.replace!="string"?r.replace:r;if(this.options.interpolation.defaultVariables&&(p={...this.options.interpolation.defaultVariables,...p}),t=this.interpolator.interpolate(t,p,r.lng||this.language||s.usedLng,r),i){const f=t.match(this.interpolator.nestingRegexp),h=f&&f.length;d<h&&(r.nest=!1)}!r.lng&&this.options.compatibilityAPI!=="v1"&&s&&s.res&&(r.lng=this.language||s.usedLng),r.nest!==!1&&(t=this.interpolator.nest(t,function(){for(var f=arguments.length,h=new Array(f),g=0;g<f;g++)h[g]=arguments[g];return o&&o[0]===h[0]&&!r.context?(a.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${n[0]}`),null):a.translate(...h,n)},r)),r.interpolation&&this.interpolator.reset()}const l=r.postProcess||this.options.postProcess,c=typeof l=="string"?[l]:l;return t!=null&&c&&c.length&&r.applyPostProcessor!==!1&&(t=zI.handle(c,t,n,this.options&&this.options.postProcessPassResolved?{i18nResolved:{...s,usedParams:this.getUsedParamsDetails(r)},...r}:r,this)),t}resolve(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r,s,o,a,l;return typeof t=="string"&&(t=[t]),t.forEach(c=>{if(this.isValidLookup(r))return;const i=this.extractFromKey(c,n),d=i.key;s=d;let p=i.namespaces;this.options.fallbackNS&&(p=p.concat(this.options.fallbackNS));const f=n.count!==void 0&&typeof n.count!="string",h=f&&!n.ordinal&&n.count===0&&this.pluralResolver.shouldUseIntlApi(),g=n.context!==void 0&&(typeof n.context=="string"||typeof n.context=="number")&&n.context!=="",m=n.lngs?n.lngs:this.languageUtils.toResolveHierarchy(n.lng||this.language,n.fallbackLng);p.forEach(x=>{this.isValidLookup(r)||(l=x,!fE[`${m[0]}-${x}`]&&this.utils&&this.utils.hasLoadedNamespace&&!this.utils.hasLoadedNamespace(l)&&(fE[`${m[0]}-${x}`]=!0,this.logger.warn(`key "${s}" for languages "${m.join(", ")}" won't get resolved as namespace "${l}" was not yet loaded`,"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),m.forEach(b=>{if(this.isValidLookup(r))return;a=b;const y=[d];if(this.i18nFormat&&this.i18nFormat.addLookupKeys)this.i18nFormat.addLookupKeys(y,d,b,x,n);else{let S;f&&(S=this.pluralResolver.getSuffix(b,n.count,n));const E=`${this.options.pluralSeparator}zero`,C=`${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;if(f&&(y.push(d+S),n.ordinal&&S.indexOf(C)===0&&y.push(d+S.replace(C,this.options.pluralSeparator)),h&&y.push(d+E)),g){const k=`${d}${this.options.contextSeparator}${n.context}`;y.push(k),f&&(y.push(k+S),n.ordinal&&S.indexOf(C)===0&&y.push(k+S.replace(C,this.options.pluralSeparator)),h&&y.push(k+E))}}let w;for(;w=y.pop();)this.isValidLookup(r)||(o=w,r=this.getResource(b,x,w,n))}))})}),{res:r,usedKey:s,exactUsedKey:o,usedLng:a,usedNS:l}}isValidLookup(t){return t!==void 0&&!(!this.options.returnNull&&t===null)&&!(!this.options.returnEmptyString&&t==="")}getResource(t,n,r){let s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(t,n,r,s):this.resourceStore.getResource(t,n,r,s)}getUsedParamsDetails(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const n=["defaultValue","ordinal","context","replace","lng","lngs","fallbackLng","ns","keySeparator","nsSeparator","returnObjects","returnDetails","joinArrays","postProcess","interpolation"],r=t.replace&&typeof t.replace!="string";let s=r?t.replace:t;if(r&&typeof t.count<"u"&&(s.count=t.count),this.options.interpolation.defaultVariables&&(s={...this.options.interpolation.defaultVariables,...s}),!r){s={...s};for(const o of n)delete s[o]}return s}static hasDefaultValue(t){const n="defaultValue";for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)&&n===r.substring(0,n.length)&&t[r]!==void 0)return!0;return!1}}const Cv=e=>e.charAt(0).toUpperCase()+e.slice(1);class pE{constructor(t){this.options=t,this.supportedLngs=this.options.supportedLngs||!1,this.logger=Is.create("languageUtils")}getScriptPartFromCode(t){if(t=Ph(t),!t||t.indexOf("-")<0)return null;const n=t.split("-");return n.length===2||(n.pop(),n[n.length-1].toLowerCase()==="x")?null:this.formatLanguageCode(n.join("-"))}getLanguagePartFromCode(t){if(t=Ph(t),!t||t.indexOf("-")<0)return t;const n=t.split("-");return this.formatLanguageCode(n[0])}formatLanguageCode(t){if(typeof t=="string"&&t.indexOf("-")>-1){const n=["hans","hant","latn","cyrl","cans","mong","arab"];let r=t.split("-");return this.options.lowerCaseLng?r=r.map(s=>s.toLowerCase()):r.length===2?(r[0]=r[0].toLowerCase(),r[1]=r[1].toUpperCase(),n.indexOf(r[1].toLowerCase())>-1&&(r[1]=Cv(r[1].toLowerCase()))):r.length===3&&(r[0]=r[0].toLowerCase(),r[1].length===2&&(r[1]=r[1].toUpperCase()),r[0]!=="sgn"&&r[2].length===2&&(r[2]=r[2].toUpperCase()),n.indexOf(r[1].toLowerCase())>-1&&(r[1]=Cv(r[1].toLowerCase())),n.indexOf(r[2].toLowerCase())>-1&&(r[2]=Cv(r[2].toLowerCase()))),r.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?t.toLowerCase():t}isSupportedCode(t){return(this.options.load==="languageOnly"||this.options.nonExplicitSupportedLngs)&&(t=this.getLanguagePartFromCode(t)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(t)>-1}getBestMatchFromCodes(t){if(!t)return null;let n;return t.forEach(r=>{if(n)return;const s=this.formatLanguageCode(r);(!this.options.supportedLngs||this.isSupportedCode(s))&&(n=s)}),!n&&this.options.supportedLngs&&t.forEach(r=>{if(n)return;const s=this.getLanguagePartFromCode(r);if(this.isSupportedCode(s))return n=s;n=this.options.supportedLngs.find(o=>{if(o===s)return o;if(!(o.indexOf("-")<0&&s.indexOf("-")<0)&&(o.indexOf("-")>0&&s.indexOf("-")<0&&o.substring(0,o.indexOf("-"))===s||o.indexOf(s)===0&&s.length>1))return o})}),n||(n=this.getFallbackCodes(this.options.fallbackLng)[0]),n}getFallbackCodes(t,n){if(!t)return[];if(typeof t=="function"&&(t=t(n)),typeof t=="string"&&(t=[t]),Array.isArray(t))return t;if(!n)return t.default||[];let r=t[n];return r||(r=t[this.getScriptPartFromCode(n)]),r||(r=t[this.formatLanguageCode(n)]),r||(r=t[this.getLanguagePartFromCode(n)]),r||(r=t.default),r||[]}toResolveHierarchy(t,n){const r=this.getFallbackCodes(n||this.options.fallbackLng||[],t),s=[],o=a=>{a&&(this.isSupportedCode(a)?s.push(a):this.logger.warn(`rejecting language code not found in supportedLngs: ${a}`))};return typeof t=="string"&&(t.indexOf("-")>-1||t.indexOf("_")>-1)?(this.options.load!=="languageOnly"&&o(this.formatLanguageCode(t)),this.options.load!=="languageOnly"&&this.options.load!=="currentOnly"&&o(this.getScriptPartFromCode(t)),this.options.load!=="currentOnly"&&o(this.getLanguagePartFromCode(t))):typeof t=="string"&&o(this.formatLanguageCode(t)),r.forEach(a=>{s.indexOf(a)<0&&o(this.formatLanguageCode(a))}),s}}let Pne=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","pt","pt-BR","tg","tl","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","et","eu","fi","fo","fur","fy","gl","gu","ha","hi","hu","hy","ia","it","kk","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt-PT","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","ht","id","ja","jbo","ka","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","cnr","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21},{lngs:["he","iw"],nr:[1,2,20,21],fc:22}],Mne={1:e=>+(e>1),2:e=>+(e!=1),3:e=>0,4:e=>e%10==1&&e%100!=11?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2,5:e=>e==0?0:e==1?1:e==2?2:e%100>=3&&e%100<=10?3:e%100>=11?4:5,6:e=>e==1?0:e>=2&&e<=4?1:2,7:e=>e==1?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2,8:e=>e==1?0:e==2?1:e!=8&&e!=11?2:3,9:e=>+(e>=2),10:e=>e==1?0:e==2?1:e<7?2:e<11?3:4,11:e=>e==1||e==11?0:e==2||e==12?1:e>2&&e<20?2:3,12:e=>+(e%10!=1||e%100==11),13:e=>+(e!==0),14:e=>e==1?0:e==2?1:e==3?2:3,15:e=>e%10==1&&e%100!=11?0:e%10>=2&&(e%100<10||e%100>=20)?1:2,16:e=>e%10==1&&e%100!=11?0:e!==0?1:2,17:e=>e==1||e%10==1&&e%100!=11?0:1,18:e=>e==0?0:e==1?1:2,19:e=>e==1?0:e==0||e%100>1&&e%100<11?1:e%100>10&&e%100<20?2:3,20:e=>e==1?0:e==0||e%100>0&&e%100<20?1:2,21:e=>e%100==1?1:e%100==2?2:e%100==3||e%100==4?3:0,22:e=>e==1?0:e==2?1:(e<0||e>10)&&e%10==0?2:3};const One=["v1","v2","v3"],Nne=["v4"],hE={zero:0,one:1,two:2,few:3,many:4,other:5},Ine=()=>{const e={};return Pne.forEach(t=>{t.lngs.forEach(n=>{e[n]={numbers:t.nr,plurals:Mne[t.fc]}})}),e};class Dne{constructor(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.languageUtils=t,this.options=n,this.logger=Is.create("pluralResolver"),(!this.options.compatibilityJSON||Nne.includes(this.options.compatibilityJSON))&&(typeof Intl>"u"||!Intl.PluralRules)&&(this.options.compatibilityJSON="v3",this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),this.rules=Ine(),this.pluralRulesCache={}}addRule(t,n){this.rules[t]=n}clearCache(){this.pluralRulesCache={}}getRule(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(this.shouldUseIntlApi())try{const r=Ph(t==="dev"?"en":t),s=n.ordinal?"ordinal":"cardinal",o=JSON.stringify({cleanedCode:r,type:s});if(o in this.pluralRulesCache)return this.pluralRulesCache[o];const a=new Intl.PluralRules(r,{type:s});return this.pluralRulesCache[o]=a,a}catch{return}return this.rules[t]||this.rules[this.languageUtils.getLanguagePartFromCode(t)]}needsPlural(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const r=this.getRule(t,n);return this.shouldUseIntlApi()?r&&r.resolvedOptions().pluralCategories.length>1:r&&r.numbers.length>1}getPluralFormsOfKey(t,n){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return this.getSuffixes(t,r).map(s=>`${n}${s}`)}getSuffixes(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const r=this.getRule(t,n);return r?this.shouldUseIntlApi()?r.resolvedOptions().pluralCategories.sort((s,o)=>hE[s]-hE[o]).map(s=>`${this.options.prepend}${n.ordinal?`ordinal${this.options.prepend}`:""}${s}`):r.numbers.map(s=>this.getSuffix(t,s,n)):[]}getSuffix(t,n){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};const s=this.getRule(t,r);return s?this.shouldUseIntlApi()?`${this.options.prepend}${r.ordinal?`ordinal${this.options.prepend}`:""}${s.select(n)}`:this.getSuffixRetroCompatible(s,n):(this.logger.warn(`no plural rule found for: ${t}`),"")}getSuffixRetroCompatible(t,n){const r=t.noAbs?t.plurals(n):t.plurals(Math.abs(n));let s=t.numbers[r];this.options.simplifyPluralSuffix&&t.numbers.length===2&&t.numbers[0]===1&&(s===2?s="plural":s===1&&(s=""));const o=()=>this.options.prepend&&s.toString()?this.options.prepend+s.toString():s.toString();return this.options.compatibilityJSON==="v1"?s===1?"":typeof s=="number"?`_plural_${s.toString()}`:o():this.options.compatibilityJSON==="v2"||this.options.simplifyPluralSuffix&&t.numbers.length===2&&t.numbers[0]===1?o():this.options.prepend&&r.toString()?this.options.prepend+r.toString():r.toString()}shouldUseIntlApi(){return!One.includes(this.options.compatibilityJSON)}}const gE=function(e,t,n){let r=arguments.length>3&&arguments[3]!==void 0?arguments[3]:".",s=arguments.length>4&&arguments[4]!==void 0?arguments[4]:!0,o=Cne(e,t,n);return!o&&s&&typeof n=="string"&&(o=_b(e,n,r),o===void 0&&(o=_b(t,n,r))),o},Ev=e=>e.replace(/\$/g,"$$$$");class Ane{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.logger=Is.create("interpolator"),this.options=t,this.format=t.interpolation&&t.interpolation.format||(n=>n),this.init(t)}init(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};t.interpolation||(t.interpolation={escapeValue:!0});const{escape:n,escapeValue:r,useRawValueToEscape:s,prefix:o,prefixEscaped:a,suffix:l,suffixEscaped:c,formatSeparator:i,unescapeSuffix:d,unescapePrefix:p,nestingPrefix:f,nestingPrefixEscaped:h,nestingSuffix:g,nestingSuffixEscaped:m,nestingOptionsSeparator:x,maxReplaces:b,alwaysFormat:y}=t.interpolation;this.escape=n!==void 0?n:Tne,this.escapeValue=r!==void 0?r:!0,this.useRawValueToEscape=s!==void 0?s:!1,this.prefix=o?Xi(o):a||"{{",this.suffix=l?Xi(l):c||"}}",this.formatSeparator=i||",",this.unescapePrefix=d?"":p||"-",this.unescapeSuffix=this.unescapePrefix?"":d||"",this.nestingPrefix=f?Xi(f):h||Xi("$t("),this.nestingSuffix=g?Xi(g):m||Xi(")"),this.nestingOptionsSeparator=x||",",this.maxReplaces=b||1e3,this.alwaysFormat=y!==void 0?y:!1,this.resetRegExp()}reset(){this.options&&this.init(this.options)}resetRegExp(){const t=(n,r)=>n&&n.source===r?(n.lastIndex=0,n):new RegExp(r,"g");this.regexp=t(this.regexp,`${this.prefix}(.+?)${this.suffix}`),this.regexpUnescape=t(this.regexpUnescape,`${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`),this.nestingRegexp=t(this.nestingRegexp,`${this.nestingPrefix}(.+?)${this.nestingSuffix}`)}interpolate(t,n,r,s){let o,a,l;const c=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{},i=h=>{if(h.indexOf(this.formatSeparator)<0){const b=gE(n,c,h,this.options.keySeparator,this.options.ignoreJSONStructure);return this.alwaysFormat?this.format(b,void 0,r,{...s,...n,interpolationkey:h}):b}const g=h.split(this.formatSeparator),m=g.shift().trim(),x=g.join(this.formatSeparator).trim();return this.format(gE(n,c,m,this.options.keySeparator,this.options.ignoreJSONStructure),x,r,{...s,...n,interpolationkey:m})};this.resetRegExp();const d=s&&s.missingInterpolationHandler||this.options.missingInterpolationHandler,p=s&&s.interpolation&&s.interpolation.skipOnVariables!==void 0?s.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:h=>Ev(h)},{regex:this.regexp,safeValue:h=>this.escapeValue?Ev(this.escape(h)):Ev(h)}].forEach(h=>{for(l=0;o=h.regex.exec(t);){const g=o[1].trim();if(a=i(g),a===void 0)if(typeof d=="function"){const x=d(t,o,s);a=typeof x=="string"?x:""}else if(s&&Object.prototype.hasOwnProperty.call(s,g))a="";else if(p){a=o[0];continue}else this.logger.warn(`missed to pass in variable ${g} for interpolating ${t}`),a="";else typeof a!="string"&&!this.useRawValueToEscape&&(a=iE(a));const m=h.safeValue(a);if(t=t.replace(o[0],m),p?(h.regex.lastIndex+=a.length,h.regex.lastIndex-=o[0].length):h.regex.lastIndex=0,l++,l>=this.maxReplaces)break}}),t}nest(t,n){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},s,o,a;const l=(c,i)=>{const d=this.nestingOptionsSeparator;if(c.indexOf(d)<0)return c;const p=c.split(new RegExp(`${d}[ ]*{`));let f=`{${p[1]}`;c=p[0],f=this.interpolate(f,a);const h=f.match(/'/g),g=f.match(/"/g);(h&&h.length%2===0&&!g||g.length%2!==0)&&(f=f.replace(/'/g,'"'));try{a=JSON.parse(f),i&&(a={...i,...a})}catch(m){return this.logger.warn(`failed parsing options string in nesting for key ${c}`,m),`${c}${d}${f}`}return a.defaultValue&&a.defaultValue.indexOf(this.prefix)>-1&&delete a.defaultValue,c};for(;s=this.nestingRegexp.exec(t);){let c=[];a={...r},a=a.replace&&typeof a.replace!="string"?a.replace:a,a.applyPostProcessor=!1,delete a.defaultValue;let i=!1;if(s[0].indexOf(this.formatSeparator)!==-1&&!/{.*}/.test(s[1])){const d=s[1].split(this.formatSeparator).map(p=>p.trim());s[1]=d.shift(),c=d,i=!0}if(o=n(l.call(this,s[1].trim(),a),a),o&&s[0]===t&&typeof o!="string")return o;typeof o!="string"&&(o=iE(o)),o||(this.logger.warn(`missed to resolve ${s[1]} for nesting ${t}`),o=""),i&&(o=c.reduce((d,p)=>this.format(d,p,r.lng,{...r,interpolationkey:s[1].trim()}),o.trim())),t=t.replace(s[0],o),this.regexp.lastIndex=0}return t}}const Fne=e=>{let t=e.toLowerCase().trim();const n={};if(e.indexOf("(")>-1){const r=e.split("(");t=r[0].toLowerCase().trim();const s=r[1].substring(0,r[1].length-1);t==="currency"&&s.indexOf(":")<0?n.currency||(n.currency=s.trim()):t==="relativetime"&&s.indexOf(":")<0?n.range||(n.range=s.trim()):s.split(";").forEach(a=>{if(a){const[l,...c]=a.split(":"),i=c.join(":").trim().replace(/^'+|'+$/g,""),d=l.trim();n[d]||(n[d]=i),i==="false"&&(n[d]=!1),i==="true"&&(n[d]=!0),isNaN(i)||(n[d]=parseInt(i,10))}})}return{formatName:t,formatOptions:n}},el=e=>{const t={};return(n,r,s)=>{let o=s;s&&s.interpolationkey&&s.formatParams&&s.formatParams[s.interpolationkey]&&s[s.interpolationkey]&&(o={...o,[s.interpolationkey]:void 0});const a=r+JSON.stringify(o);let l=t[a];return l||(l=e(Ph(r),s),t[a]=l),l(n)}};class Lne{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.logger=Is.create("formatter"),this.options=t,this.formats={number:el((n,r)=>{const s=new Intl.NumberFormat(n,{...r});return o=>s.format(o)}),currency:el((n,r)=>{const s=new Intl.NumberFormat(n,{...r,style:"currency"});return o=>s.format(o)}),datetime:el((n,r)=>{const s=new Intl.DateTimeFormat(n,{...r});return o=>s.format(o)}),relativetime:el((n,r)=>{const s=new Intl.RelativeTimeFormat(n,{...r});return o=>s.format(o,r.range||"day")}),list:el((n,r)=>{const s=new Intl.ListFormat(n,{...r});return o=>s.format(o)})},this.init(t)}init(t){const r=(arguments.length>1&&arguments[1]!==void 0?arguments[1]:{interpolation:{}}).interpolation;this.formatSeparator=r.formatSeparator?r.formatSeparator:r.formatSeparator||","}add(t,n){this.formats[t.toLowerCase().trim()]=n}addCached(t,n){this.formats[t.toLowerCase().trim()]=el(n)}format(t,n,r){let s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};const o=n.split(this.formatSeparator);if(o.length>1&&o[0].indexOf("(")>1&&o[0].indexOf(")")<0&&o.find(l=>l.indexOf(")")>-1)){const l=o.findIndex(c=>c.indexOf(")")>-1);o[0]=[o[0],...o.splice(1,l)].join(this.formatSeparator)}return o.reduce((l,c)=>{const{formatName:i,formatOptions:d}=Fne(c);if(this.formats[i]){let p=l;try{const f=s&&s.formatParams&&s.formatParams[s.interpolationkey]||{},h=f.locale||f.lng||s.locale||s.lng||r;p=this.formats[i](l,h,{...d,...s,...f})}catch(f){this.logger.warn(f)}return p}else this.logger.warn(`there was no format function for ${i}`);return l},t)}}const $ne=(e,t)=>{e.pending[t]!==void 0&&(delete e.pending[t],e.pendingCount--)};class Bne extends nm{constructor(t,n,r){let s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};super(),this.backend=t,this.store=n,this.services=r,this.languageUtils=r.languageUtils,this.options=s,this.logger=Is.create("backendConnector"),this.waitingReads=[],this.maxParallelReads=s.maxParallelReads||10,this.readingCalls=0,this.maxRetries=s.maxRetries>=0?s.maxRetries:5,this.retryTimeout=s.retryTimeout>=1?s.retryTimeout:350,this.state={},this.queue=[],this.backend&&this.backend.init&&this.backend.init(r,s.backend,s)}queueLoad(t,n,r,s){const o={},a={},l={},c={};return t.forEach(i=>{let d=!0;n.forEach(p=>{const f=`${i}|${p}`;!r.reload&&this.store.hasResourceBundle(i,p)?this.state[f]=2:this.state[f]<0||(this.state[f]===1?a[f]===void 0&&(a[f]=!0):(this.state[f]=1,d=!1,a[f]===void 0&&(a[f]=!0),o[f]===void 0&&(o[f]=!0),c[p]===void 0&&(c[p]=!0)))}),d||(l[i]=!0)}),(Object.keys(o).length||Object.keys(a).length)&&this.queue.push({pending:a,pendingCount:Object.keys(a).length,loaded:{},errors:[],callback:s}),{toLoad:Object.keys(o),pending:Object.keys(a),toLoadLanguages:Object.keys(l),toLoadNamespaces:Object.keys(c)}}loaded(t,n,r){const s=t.split("|"),o=s[0],a=s[1];n&&this.emit("failedLoading",o,a,n),!n&&r&&this.store.addResourceBundle(o,a,r,void 0,void 0,{skipCopy:!0}),this.state[t]=n?-1:2,n&&r&&(this.state[t]=0);const l={};this.queue.forEach(c=>{Sne(c.loaded,[o],a),$ne(c,t),n&&c.errors.push(n),c.pendingCount===0&&!c.done&&(Object.keys(c.loaded).forEach(i=>{l[i]||(l[i]={});const d=c.loaded[i];d.length&&d.forEach(p=>{l[i][p]===void 0&&(l[i][p]=!0)})}),c.done=!0,c.errors.length?c.callback(c.errors):c.callback())}),this.emit("loaded",l),this.queue=this.queue.filter(c=>!c.done)}read(t,n,r){let s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:0,o=arguments.length>4&&arguments[4]!==void 0?arguments[4]:this.retryTimeout,a=arguments.length>5?arguments[5]:void 0;if(!t.length)return a(null,{});if(this.readingCalls>=this.maxParallelReads){this.waitingReads.push({lng:t,ns:n,fcName:r,tried:s,wait:o,callback:a});return}this.readingCalls++;const l=(i,d)=>{if(this.readingCalls--,this.waitingReads.length>0){const p=this.waitingReads.shift();this.read(p.lng,p.ns,p.fcName,p.tried,p.wait,p.callback)}if(i&&d&&s<this.maxRetries){setTimeout(()=>{this.read.call(this,t,n,r,s+1,o*2,a)},o);return}a(i,d)},c=this.backend[r].bind(this.backend);if(c.length===2){try{const i=c(t,n);i&&typeof i.then=="function"?i.then(d=>l(null,d)).catch(l):l(null,i)}catch(i){l(i)}return}return c(t,n,l)}prepareLoading(t,n){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},s=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),s&&s();typeof t=="string"&&(t=this.languageUtils.toResolveHierarchy(t)),typeof n=="string"&&(n=[n]);const o=this.queueLoad(t,n,r,s);if(!o.toLoad.length)return o.pending.length||s(),null;o.toLoad.forEach(a=>{this.loadOne(a)})}load(t,n,r){this.prepareLoading(t,n,{},r)}reload(t,n,r){this.prepareLoading(t,n,{reload:!0},r)}loadOne(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"";const r=t.split("|"),s=r[0],o=r[1];this.read(s,o,"read",void 0,void 0,(a,l)=>{a&&this.logger.warn(`${n}loading namespace ${o} for language ${s} failed`,a),!a&&l&&this.logger.log(`${n}loaded namespace ${o} for language ${s}`,l),this.loaded(t,a,l)})}saveMissing(t,n,r,s,o){let a=arguments.length>5&&arguments[5]!==void 0?arguments[5]:{},l=arguments.length>6&&arguments[6]!==void 0?arguments[6]:()=>{};if(this.services.utils&&this.services.utils.hasLoadedNamespace&&!this.services.utils.hasLoadedNamespace(n)){this.logger.warn(`did not save key "${r}" as the namespace "${n}" was not yet loaded`,"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");return}if(!(r==null||r==="")){if(this.backend&&this.backend.create){const c={...a,isUpdate:o},i=this.backend.create.bind(this.backend);if(i.length<6)try{let d;i.length===5?d=i(t,n,r,s,c):d=i(t,n,r,s),d&&typeof d.then=="function"?d.then(p=>l(null,p)).catch(l):l(null,d)}catch(d){l(d)}else i(t,n,r,s,l,c)}!t||!t[0]||this.store.addResource(t[0],n,r,s)}}}const mE=()=>({debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!1,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:e=>{let t={};if(typeof e[1]=="object"&&(t=e[1]),typeof e[1]=="string"&&(t.defaultValue=e[1]),typeof e[2]=="string"&&(t.tDescription=e[2]),typeof e[2]=="object"||typeof e[3]=="object"){const n=e[3]||e[2];Object.keys(n).forEach(r=>{t[r]=n[r]})}return t},interpolation:{escapeValue:!0,format:e=>e,prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!0}}),vE=e=>(typeof e.ns=="string"&&(e.ns=[e.ns]),typeof e.fallbackLng=="string"&&(e.fallbackLng=[e.fallbackLng]),typeof e.fallbackNS=="string"&&(e.fallbackNS=[e.fallbackNS]),e.supportedLngs&&e.supportedLngs.indexOf("cimode")<0&&(e.supportedLngs=e.supportedLngs.concat(["cimode"])),e),Qf=()=>{},zne=e=>{Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach(n=>{typeof e[n]=="function"&&(e[n]=e[n].bind(e))})};class Pd extends nm{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;if(super(),this.options=vE(t),this.services={},this.logger=Is,this.modules={external:[]},zne(this),n&&!this.isInitialized&&!t.isClone){if(!this.options.initImmediate)return this.init(t,n),this;setTimeout(()=>{this.init(t,n)},0)}}init(){var t=this;let n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},r=arguments.length>1?arguments[1]:void 0;this.isInitializing=!0,typeof n=="function"&&(r=n,n={}),!n.defaultNS&&n.defaultNS!==!1&&n.ns&&(typeof n.ns=="string"?n.defaultNS=n.ns:n.ns.indexOf("translation")<0&&(n.defaultNS=n.ns[0]));const s=mE();this.options={...s,...this.options,...vE(n)},this.options.compatibilityAPI!=="v1"&&(this.options.interpolation={...s.interpolation,...this.options.interpolation}),n.keySeparator!==void 0&&(this.options.userDefinedKeySeparator=n.keySeparator),n.nsSeparator!==void 0&&(this.options.userDefinedNsSeparator=n.nsSeparator);const o=d=>d?typeof d=="function"?new d:d:null;if(!this.options.isClone){this.modules.logger?Is.init(o(this.modules.logger),this.options):Is.init(null,this.options);let d;this.modules.formatter?d=this.modules.formatter:typeof Intl<"u"&&(d=Lne);const p=new pE(this.options);this.store=new dE(this.options.resources,this.options);const f=this.services;f.logger=Is,f.resourceStore=this.store,f.languageUtils=p,f.pluralResolver=new Dne(p,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),d&&(!this.options.interpolation.format||this.options.interpolation.format===s.interpolation.format)&&(f.formatter=o(d),f.formatter.init(f,this.options),this.options.interpolation.format=f.formatter.format.bind(f.formatter)),f.interpolator=new Ane(this.options),f.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},f.backendConnector=new Bne(o(this.modules.backend),f.resourceStore,f,this.options),f.backendConnector.on("*",function(h){for(var g=arguments.length,m=new Array(g>1?g-1:0),x=1;x<g;x++)m[x-1]=arguments[x];t.emit(h,...m)}),this.modules.languageDetector&&(f.languageDetector=o(this.modules.languageDetector),f.languageDetector.init&&f.languageDetector.init(f,this.options.detection,this.options)),this.modules.i18nFormat&&(f.i18nFormat=o(this.modules.i18nFormat),f.i18nFormat.init&&f.i18nFormat.init(this)),this.translator=new Mh(this.services,this.options),this.translator.on("*",function(h){for(var g=arguments.length,m=new Array(g>1?g-1:0),x=1;x<g;x++)m[x-1]=arguments[x];t.emit(h,...m)}),this.modules.external.forEach(h=>{h.init&&h.init(this)})}if(this.format=this.options.interpolation.format,r||(r=Qf),this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){const d=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);d.length>0&&d[0]!=="dev"&&(this.options.lng=d[0])}!this.services.languageDetector&&!this.options.lng&&this.logger.warn("init: no languageDetector is used and no lng is defined"),["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"].forEach(d=>{this[d]=function(){return t.store[d](...arguments)}}),["addResource","addResources","addResourceBundle","removeResourceBundle"].forEach(d=>{this[d]=function(){return t.store[d](...arguments),t}});const c=sc(),i=()=>{const d=(p,f)=>{this.isInitializing=!1,this.isInitialized&&!this.initializedStoreOnce&&this.logger.warn("init: i18next is already initialized. You should call init just once!"),this.isInitialized=!0,this.options.isClone||this.logger.log("initialized",this.options),this.emit("initialized",this.options),c.resolve(f),r(p,f)};if(this.languages&&this.options.compatibilityAPI!=="v1"&&!this.isInitialized)return d(null,this.t.bind(this));this.changeLanguage(this.options.lng,d)};return this.options.resources||!this.options.initImmediate?i():setTimeout(i,0),c}loadResources(t){let r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Qf;const s=typeof t=="string"?t:this.language;if(typeof t=="function"&&(r=t),!this.options.resources||this.options.partialBundledLanguages){if(s&&s.toLowerCase()==="cimode"&&(!this.options.preload||this.options.preload.length===0))return r();const o=[],a=l=>{if(!l||l==="cimode")return;this.services.languageUtils.toResolveHierarchy(l).forEach(i=>{i!=="cimode"&&o.indexOf(i)<0&&o.push(i)})};s?a(s):this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(c=>a(c)),this.options.preload&&this.options.preload.forEach(l=>a(l)),this.services.backendConnector.load(o,this.options.ns,l=>{!l&&!this.resolvedLanguage&&this.language&&this.setResolvedLanguage(this.language),r(l)})}else r(null)}reloadResources(t,n,r){const s=sc();return typeof t=="function"&&(r=t,t=void 0),typeof n=="function"&&(r=n,n=void 0),t||(t=this.languages),n||(n=this.options.ns),r||(r=Qf),this.services.backendConnector.reload(t,n,o=>{s.resolve(),r(o)}),s}use(t){if(!t)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!t.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return t.type==="backend"&&(this.modules.backend=t),(t.type==="logger"||t.log&&t.warn&&t.error)&&(this.modules.logger=t),t.type==="languageDetector"&&(this.modules.languageDetector=t),t.type==="i18nFormat"&&(this.modules.i18nFormat=t),t.type==="postProcessor"&&zI.addPostProcessor(t),t.type==="formatter"&&(this.modules.formatter=t),t.type==="3rdParty"&&this.modules.external.push(t),this}setResolvedLanguage(t){if(!(!t||!this.languages)&&!(["cimode","dev"].indexOf(t)>-1))for(let n=0;n<this.languages.length;n++){const r=this.languages[n];if(!(["cimode","dev"].indexOf(r)>-1)&&this.store.hasLanguageSomeTranslations(r)){this.resolvedLanguage=r;break}}}changeLanguage(t,n){var r=this;this.isLanguageChangingTo=t;const s=sc();this.emit("languageChanging",t);const o=c=>{this.language=c,this.languages=this.services.languageUtils.toResolveHierarchy(c),this.resolvedLanguage=void 0,this.setResolvedLanguage(c)},a=(c,i)=>{i?(o(i),this.translator.changeLanguage(i),this.isLanguageChangingTo=void 0,this.emit("languageChanged",i),this.logger.log("languageChanged",i)):this.isLanguageChangingTo=void 0,s.resolve(function(){return r.t(...arguments)}),n&&n(c,function(){return r.t(...arguments)})},l=c=>{!t&&!c&&this.services.languageDetector&&(c=[]);const i=typeof c=="string"?c:this.services.languageUtils.getBestMatchFromCodes(c);i&&(this.language||o(i),this.translator.language||this.translator.changeLanguage(i),this.services.languageDetector&&this.services.languageDetector.cacheUserLanguage&&this.services.languageDetector.cacheUserLanguage(i)),this.loadResources(i,d=>{a(d,i)})};return!t&&this.services.languageDetector&&!this.services.languageDetector.async?l(this.services.languageDetector.detect()):!t&&this.services.languageDetector&&this.services.languageDetector.async?this.services.languageDetector.detect.length===0?this.services.languageDetector.detect().then(l):this.services.languageDetector.detect(l):l(t),s}getFixedT(t,n,r){var s=this;const o=function(a,l){let c;if(typeof l!="object"){for(var i=arguments.length,d=new Array(i>2?i-2:0),p=2;p<i;p++)d[p-2]=arguments[p];c=s.options.overloadTranslationOptionHandler([a,l].concat(d))}else c={...l};c.lng=c.lng||o.lng,c.lngs=c.lngs||o.lngs,c.ns=c.ns||o.ns,c.keyPrefix!==""&&(c.keyPrefix=c.keyPrefix||r||o.keyPrefix);const f=s.options.keySeparator||".";let h;return c.keyPrefix&&Array.isArray(a)?h=a.map(g=>`${c.keyPrefix}${f}${g}`):h=c.keyPrefix?`${c.keyPrefix}${f}${a}`:a,s.t(h,c)};return typeof t=="string"?o.lng=t:o.lngs=t,o.ns=n,o.keyPrefix=r,o}t(){return this.translator&&this.translator.translate(...arguments)}exists(){return this.translator&&this.translator.exists(...arguments)}setDefaultNamespace(t){this.options.defaultNS=t}hasLoadedNamespace(t){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;const r=n.lng||this.resolvedLanguage||this.languages[0],s=this.options?this.options.fallbackLng:!1,o=this.languages[this.languages.length-1];if(r.toLowerCase()==="cimode")return!0;const a=(l,c)=>{const i=this.services.backendConnector.state[`${l}|${c}`];return i===-1||i===0||i===2};if(n.precheck){const l=n.precheck(this,a);if(l!==void 0)return l}return!!(this.hasResourceBundle(r,t)||!this.services.backendConnector.backend||this.options.resources&&!this.options.partialBundledLanguages||a(r,t)&&(!s||a(o,t)))}loadNamespaces(t,n){const r=sc();return this.options.ns?(typeof t=="string"&&(t=[t]),t.forEach(s=>{this.options.ns.indexOf(s)<0&&this.options.ns.push(s)}),this.loadResources(s=>{r.resolve(),n&&n(s)}),r):(n&&n(),Promise.resolve())}loadLanguages(t,n){const r=sc();typeof t=="string"&&(t=[t]);const s=this.options.preload||[],o=t.filter(a=>s.indexOf(a)<0&&this.services.languageUtils.isSupportedCode(a));return o.length?(this.options.preload=s.concat(o),this.loadResources(a=>{r.resolve(),n&&n(a)}),r):(n&&n(),Promise.resolve())}dir(t){if(t||(t=this.resolvedLanguage||(this.languages&&this.languages.length>0?this.languages[0]:this.language)),!t)return"rtl";const n=["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam","ckb"],r=this.services&&this.services.languageUtils||new pE(mE());return n.indexOf(r.getLanguagePartFromCode(t))>-1||t.toLowerCase().indexOf("-arab")>1?"rtl":"ltr"}static createInstance(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;return new Pd(t,n)}cloneInstance(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Qf;const r=t.forkResourceStore;r&&delete t.forkResourceStore;const s={...this.options,...t,isClone:!0},o=new Pd(s);return(t.debug!==void 0||t.prefix!==void 0)&&(o.logger=o.logger.clone(t)),["store","services","language"].forEach(l=>{o[l]=this[l]}),o.services={...this.services},o.services.utils={hasLoadedNamespace:o.hasLoadedNamespace.bind(o)},r&&(o.store=new dE(this.store.data,s),o.services.resourceStore=o.store),o.translator=new Mh(o.services,s),o.translator.on("*",function(l){for(var c=arguments.length,i=new Array(c>1?c-1:0),d=1;d<c;d++)i[d-1]=arguments[d];o.emit(l,...i)}),o.init(s,n),o.translator.options=s,o.translator.backendConnector.services.utils={hasLoadedNamespace:o.hasLoadedNamespace.bind(o)},o}toJSON(){return{options:this.options,store:this.store,language:this.language,languages:this.languages,resolvedLanguage:this.resolvedLanguage}}}const kn=Pd.createInstance();kn.createInstance=Pd.createInstance;kn.createInstance;kn.dir;kn.init;kn.loadResources;kn.reloadResources;kn.use;kn.changeLanguage;kn.getFixedT;kn.t;kn.exists;kn.setDefaultNamespace;kn.hasLoadedNamespace;kn.loadNamespaces;kn.loadLanguages;const Une={title:"Instances",search:"Search",status:"Status"},Vne={delete:"Delete",deleting:"Deleting...",cancel:"Cancel",markAll:"Mark All",unMarkAll:"Unmark All"},Hne={delete:{title:"Delete Record",message:"You are about to delete the instance {{instanceName}}, Are you sure you want to continue?",messageSingle:"This action cannot be undone"}},Kne={all:"All",open:"Connected",connecting:"Connecting",closed:"Disconnected"},qne={clientName:"Client name",version:"Version"},Wne={theme:{label:"Toggle theme",light:"Light",dark:"Dark",system:"System"},language:{label:"Language",english:"English",portuguese:"Portuguese",spanish:"Spanish",french:"French"}},Gne={dashboard:"Dashboard",configurations:"Configurations",settings:"Settings",proxy:"Proxy",events:"Events",webhook:"Webhook",websocket:"WebSocket",rabbitmq:"RabbitMQ",sqs:"SQS",integrations:"Integrations",chatwoot:"Chatwoot",typebot:"Typebot",openai:"OpenAI",dify:"Dify",evolutionBot:"Evolution Bot",flowise:"Flowise",documentation:"Documentation",postman:"Postman",discord:"Discord",supportPremium:"Support Premium"},Jne={instance:{created:"Instance created successfully",deleted:"Instance deleted successfully",error:"An error occurred while creating the instance"}},Qne={title:"Evolution Manager",description:"Please enter your credentials to continue",form:{serverUrl:"Server URL",apiKey:"API Key Global"},message:{invalidServer:"Invalid server",invalidCredentials:"Invalid credentials"},button:{login:"Login"}},Zne={modal:{title:"New instance"},form:{name:"Name",integration:{label:"Channel",baileys:"Baileys",whatsapp:"WhatsApp Cloud API",facebook:"Facebook",instagram:"Instagram",evolution:"Evolution"},token:"Token",number:"Number",businessId:"Business ID"},button:{save:"Save",saving:"Saving...",create:"Instance",connecting:"Connecting...",facebook:"Connect with Facebook",instagram:"Connect with Instagram",whatsapp:"Connect with WhatsApp"},dashboard:{button:{qrcode:{label:"Get QR Code",title:"Scan the QR code with your WhatsApp Web"},pairingCode:{label:"Get Pairing Code",title:"Get the pairing code to connect with WhatsApp"},restart:"Restart",disconnect:"Disconnect"},alert:"To connect, scan the QR code with your WhatsApp Web",contacts:"Contacts",chats:"Chats",messages:"Messages"}},Yne={title:"Settings",toast:{success:"Settings applied successfully",error:"An error occurred while applying the settings"},form:{rejectCall:{label:"Reject Calls",description:"Reject all incoming calls"},msgCall:{label:"Message Reject Call",description:"Send a message when rejecting a call"},groupsIgnore:{label:"Ignore Groups",description:"Ignore all messages from groups"},alwaysOnline:{label:"Always Online",description:"Keep the whatsapp always online"},readMessages:{label:"Read Messages",description:"Mark all messages as read"},syncFullHistory:{label:"Sync Full History",description:"Sync all complete chat history on scan QR code"},readStatus:{label:"Read Status",description:"Mark all statuses as read"}},button:{save:"Save",saving:"Saving..."}},Xne={title:"Proxy",toast:{success:"Proxy applied successfully",error:"An error occurred while applying the proxy"},form:{enabled:{label:"Enabled",description:"Enable or disable the proxy"},protocol:{label:"Protocol"},host:{label:"Host"},port:{label:"Port"},username:{label:"Username"},password:{label:"Password"}},button:{save:"Save",saving:"Saving..."}},ere={title:"Webhook",toast:{success:"Webhook applied successfully",error:"An error occurred while applying the webhook"},form:{enabled:{label:"Enabled",description:"Enable or disable the webhook"},url:{label:"URL"},byEvents:{label:"Webhook by Events",description:"Create a route for each event by adding the event name to the end of the URL"},base64:{label:"Webhook Base64",description:"Send media base64 data in webhook"},events:{label:"Events"}},button:{save:"Save",saving:"Saving..."}},tre={title:"Websocket",toast:{success:"Websocket applied successfully",error:"An error occurred while applying the websocket"},form:{enabled:{label:"Enabled",description:"Enable or disable the websocket"},events:{label:"Events"}},button:{save:"Save",saving:"Saving..."}},nre={title:"RabbitMQ",toast:{success:"RabbitMQ applied successfully",error:"An error occurred while applying the rabbitmq"},form:{enabled:{label:"Enabled",description:"Enable or disable the rabbitmq"},events:{label:"Events"}},button:{save:"Save",saving:"Saving..."}},rre={title:"SQS",toast:{success:"SQS applied successfully",error:"An error occurred while applying the sqs"},form:{enabled:{label:"Enabled",description:"Enable or disable the sqs"},events:{label:"Events"}},button:{save:"Save",saving:"Saving..."}},sre={title:"Chatwoot",toast:{success:"Chatwoot applied successfully",error:"An error occurred while applying the Chatwoot"},form:{enabled:{label:"Enabled",description:"Enable or disable the sqs"},url:{label:"Chatwoot URL"},accountId:{label:"Account ID"},token:{label:"Token"},signMsg:{label:"Sign Messages",description:"Sign message with chatwoot username"},signDelimiter:{label:"Sign Delimiter"},nameInbox:{label:"Name Inbox"},organization:{label:"Organization"},logo:{label:"Logo"},conversationPending:{label:"Conversation Pending",description:"Conversations start as pending"},reopenConversation:{label:"Reopen Conversation",description:"Reopen conversation when receiving message"},importContacts:{label:"Import Contacts",description:"Import contacts from WhatsApp address book by connecting QR Code"},importMessages:{label:"Import Messages",description:"Import messages from WhatsApp by connecting QR Code"},daysLimitImportMessages:{label:"Days Limit Import Messages"},ignoreJids:{label:"Ignore Jids",placeholder:"Add JIDs ex: 1234567890@s.whatsapp.net and press enter"},autoCreate:{label:"Auto Create",description:"Automatically create chatwoot integration on save"}},button:{save:"Save",saving:"Saving..."}},ore={title:"Typebots",sessions:{label:"Sessions",search:"Search for remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Push Name",sessionId:"Session ID",status:"Status",actions:{title:"Actions",open:"Open",pause:"Pause",close:"Close",delete:"Delete"},none:"Nothing to show"}},defaultSettings:"Default Settings",toast:{defaultSettings:{success:"Default settings applied successfully",error:"An error occurred while applying the default settings"},success:{update:"Typebot updated successfully",create:"Typebot created successfully",delete:"Typebot deleted successfully",status:"Typebot status updated successfully"},error:"An error occurred while creating the Typebot"},table:{none:"Nothing to show"},form:{title:"New Typebot",examples:{keywordFinish:"#FINISH",unknownMessage:"I'm sorry, I didn't understand. Can you try again?"},enabled:{label:"Enabled"},description:{label:"Description"},typebotSettings:{label:"Typebot Settings"},url:{label:"Typebot API URL"},typebot:{label:"Typebot Public Name"},triggerSettings:{label:"Trigger Settings"},triggerType:{label:"Trigger Type",keyword:"Keyword",all:"All",advanced:"Advanced",none:"None"},triggerOperator:{label:"Trigger Operator",contains:"Contains",equals:"Equals",startsWith:"Starts With",endsWith:"Ends With",regex:"Regex"},triggerValue:{label:"Trigger"},triggerConditions:{label:"Conditions"},typebotIdFallback:{label:"Typebot Fallback"},generalSettings:{label:"General Settings"},expire:{label:"Expire in minutes"},keywordFinish:{label:"Keyword Finish"},delayMessage:{label:"Default Delay Message"},unknownMessage:{label:"Unknown Message"},listeningFromMe:{label:"Listening from me",description:"Listen to messages sent by me on the bot"},stopBotFromMe:{label:"Stop bot from me",description:"Pause the bot when I send a message"},keepOpen:{label:"Keep open",description:"Keep the bot open after the conversation ends"},debounceTime:{label:"Debounce Time"},splitMessages:{label:"Split Messages",description:"Split messages into multiple messages"},timePerChar:{label:"Time per character"},ignoreJids:{label:"Ignore Jids",placeholder:"Add JIDs ex: 1234567890@s.whatsapp.net and press enter"}},button:{create:"Typebot",save:"Save",saving:"Saving...",update:"Update",defaultSettings:"Default Settings",delete:"Delete"},modal:{defaultSettings:{title:"Default Settings"}}},are={title:"OpenAI",sessions:{label:"Sessions",search:"Search for remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Push Name",sessionId:"Session ID",status:"Status",actions:{title:"Actions",open:"Open",pause:"Pause",close:"Close",delete:"Delete"},none:"Nothing to show"}},credentials:{title:"Credentials",table:{name:"Name",apiKey:"API Key",actions:{title:"Actions",delete:"Delete"},none:"Nothing to show"}},defaultSettings:"Default Settings",toast:{defaultSettings:{success:"Default settings applied successfully",error:"An error occurred while applying the default settings"},success:{update:"OpenAI updated successfully",create:"OpenAI created successfully",delete:"OpenAI deleted successfully",status:"OpenAI status updated successfully",credentialsCreate:"OpenAI credentials created successfully",credentialsDelete:"OpenAI credentials deleted successfully"},error:"An error occurred while creating the OpenAI"},table:{none:"Nothing to show"},form:{title:"New OpenAI",examples:{keywordFinish:"#FINISH",unknownMessage:"I'm sorry, I didn't understand. Can you try again?"},openaiCredsId:{label:"OpenAI Credentials"},enabled:{label:"Enabled"},description:{label:"Description"},openaiSettings:{label:"OpenAI Settings"},botType:{label:"Bot Type",assistant:"Assistant",chatCompletion:"Chat Completion"},assistantId:{label:"Assistant ID"},functionUrl:{label:"Function URL"},model:{label:"Language Model"},systemMessages:{label:"System Messages",description:"Send system messages to OpenAI"},assystantMessages:{label:"Assistant Messages",description:"Send assistant messages to OpenAI"},userMessages:{label:"User Messages",description:"Send user messages to OpenAI"},maxTokens:{label:"Max Tokens"},triggerSettings:{label:"Trigger Settings"},triggerType:{label:"Trigger Type",keyword:"Keyword",all:"All",advanced:"Advanced",none:"None"},triggerOperator:{label:"Trigger Operator",contains:"Contains",equals:"Equals",startsWith:"Starts With",endsWith:"Ends With",regex:"Regex"},triggerValue:{label:"Trigger"},triggerConditions:{label:"Conditions"},openaiIdFallback:{label:"OpenAI Fallback"},generalSettings:{label:"General Settings"},expire:{label:"Expire in minutes"},keywordFinish:{label:"Keyword Finish"},delayMessage:{label:"Default Delay Message"},unknownMessage:{label:"Unknown Message"},listeningFromMe:{label:"Listening from me",description:"Listen to messages sent by me on the bot"},stopBotFromMe:{label:"Stop bot from me",description:"Pause the bot when I send a message"},keepOpen:{label:"Keep open",description:"Keep the bot open after the conversation ends"},speechToText:{label:"Speech to Text",description:"Convert voice messages to text"},debounceTime:{label:"Debounce Time"},splitMessages:{label:"Split Messages",description:"Split messages into multiple messages"},timePerChar:{label:"Time per character"},ignoreJids:{label:"Ignore Jids",placeholder:"Add JIDs ex: 1234567890@s.whatsapp.net and press enter"}},button:{create:"OpenAI",save:"Save",saving:"Saving...",update:"Update",defaultSettings:"Default Settings",delete:"Delete"},modal:{defaultSettings:{title:"Default Settings"}}},ire={title:"Dify",sessions:{label:"Sessions",search:"Search for remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Push Name",sessionId:"Session ID",status:"Status",actions:{title:"Actions",open:"Open",pause:"Pause",close:"Close",delete:"Delete"},none:"Nothing to show"}},defaultSettings:"Default Settings",toast:{defaultSettings:{success:"Default settings applied successfully",error:"An error occurred while applying the default settings"},success:{update:"Dify updated successfully",create:"Dify created successfully",delete:"Dify deleted successfully",status:"Dify status updated successfully"},error:"An error occurred while creating the Dify"},table:{none:"Nothing to show"},form:{title:"New Dify",examples:{keywordFinish:"#FINISH",unknownMessage:"I'm sorry, I didn't understand. Can you try again?"},enabled:{label:"Enabled"},description:{label:"Description"},difySettings:{label:"Dify Settings"},botType:{label:"Bot Type",chatBot:"Chat Bot",textGenerator:"Text Generator",agent:"Agent",workflow:"Workflow"},apiUrl:{label:"API URL"},apiKey:{label:"API Key"},triggerSettings:{label:"Trigger Settings"},triggerType:{label:"Trigger Type",keyword:"Keyword",all:"All",advanced:"Advanced",none:"None"},triggerOperator:{label:"Trigger Operator",contains:"Contains",equals:"Equals",startsWith:"Starts With",endsWith:"Ends With",regex:"Regex"},triggerValue:{label:"Trigger"},triggerConditions:{label:"Conditions"},difyIdFallback:{label:"Dify Fallback"},generalSettings:{label:"General Settings"},expire:{label:"Expire in minutes"},keywordFinish:{label:"Keyword Finish"},delayMessage:{label:"Default Delay Message"},unknownMessage:{label:"Unknown Message"},listeningFromMe:{label:"Listening from me",description:"Listen to messages sent by me on the bot"},stopBotFromMe:{label:"Stop bot from me",description:"Pause the bot when I send a message"},keepOpen:{label:"Keep open",description:"Keep the bot open after the conversation ends"},debounceTime:{label:"Debounce Time"},splitMessages:{label:"Split Messages",description:"Split messages into multiple messages"},timePerChar:{label:"Time per character"},ignoreJids:{label:"Ignore Jids",placeholder:"Add JIDs ex: 1234567890@s.whatsapp.net and press enter"}},button:{create:"Dify",save:"Save",saving:"Saving...",update:"Update",defaultSettings:"Default Settings",delete:"Delete"},modal:{defaultSettings:{title:"Default Settings"}}},lre={title:"Evolution Bot",sessions:{label:"Sessions",search:"Search for remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Push Name",sessionId:"Session ID",status:"Status",actions:{title:"Actions",open:"Open",pause:"Pause",close:"Close",delete:"Delete"},none:"Nothing to show"}},defaultSettings:"Default Settings",toast:{defaultSettings:{success:"Default settings applied successfully",error:"An error occurred while applying the default settings"},success:{update:"Evolution Bot updated successfully",create:"Evolution Bot created successfully",delete:"Evolution Bot deleted successfully",status:"Evolution Bot status updated successfully"},error:"An error occurred while creating the Evolution Bot"},table:{none:"Nothing to show"},form:{title:"New Evolution Bot",examples:{keywordFinish:"#FINISH",unknownMessage:"I'm sorry, I didn't understand. Can you try again?"},enabled:{label:"Enabled"},description:{label:"Description"},evolutionBotSettings:{label:"Evolution Bot Settings"},apiUrl:{label:"API URL"},apiKey:{label:"API Key"},triggerSettings:{label:"Trigger Settings"},triggerType:{label:"Trigger Type",keyword:"Keyword",all:"All",advanced:"Advanced",none:"None"},triggerOperator:{label:"Trigger Operator",contains:"Contains",equals:"Equals",startsWith:"Starts With",endsWith:"Ends With",regex:"Regex"},triggerValue:{label:"Trigger"},triggerConditions:{label:"Conditions"},botIdFallback:{label:"Evolution Bot Fallback"},generalSettings:{label:"General Settings"},expire:{label:"Expire in minutes"},keywordFinish:{label:"Keyword Finish"},delayMessage:{label:"Default Delay Message"},unknownMessage:{label:"Unknown Message"},listeningFromMe:{label:"Listening from me",description:"Listen to messages sent by me on the bot"},stopBotFromMe:{label:"Stop bot from me",description:"Pause the bot when I send a message"},keepOpen:{label:"Keep open",description:"Keep the bot open after the conversation ends"},debounceTime:{label:"Debounce Time"},splitMessages:{label:"Split Messages",description:"Split messages into multiple messages"},timePerChar:{label:"Time per character"},ignoreJids:{label:"Ignore Jids",placeholder:"Add JIDs ex: 1234567890@s.whatsapp.net and press enter"}},button:{create:"Evolution Bot",save:"Save",saving:"Saving...",update:"Update",defaultSettings:"Default Settings",delete:"Delete"},modal:{defaultSettings:{title:"Default Settings"}}},ure={title:"Flowise",sessions:{label:"Sessions",search:"Search for remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Push Name",sessionId:"Session ID",status:"Status",actions:{title:"Actions",open:"Open",pause:"Pause",close:"Close",delete:"Delete"},none:"Nothing to show"}},defaultSettings:"Default Settings",toast:{defaultSettings:{success:"Default settings applied successfully",error:"An error occurred while applying the default settings"},success:{update:"Flowise updated successfully",create:"Flowise created successfully",delete:"Flowise deleted successfully",status:"Flowise status updated successfully"},error:"An error occurred while creating the Flowise"},table:{none:"Nothing to show"},form:{title:"New Flowise",examples:{keywordFinish:"#FINISH",unknownMessage:"I'm sorry, I didn't understand. Can you try again?"},enabled:{label:"Enabled"},description:{label:"Description"},flowiseSettings:{label:"Flowise Settings"},apiUrl:{label:"API URL"},apiKey:{label:"API Key"},triggerSettings:{label:"Trigger Settings"},triggerType:{label:"Trigger Type",keyword:"Keyword",all:"All",advanced:"Advanced",none:"None"},triggerOperator:{label:"Trigger Operator",contains:"Contains",equals:"Equals",startsWith:"Starts With",endsWith:"Ends With",regex:"Regex"},triggerValue:{label:"Trigger"},triggerConditions:{label:"Conditions"},flowiseIdFallback:{label:"Flowise Fallback"},generalSettings:{label:"General Settings"},expire:{label:"Expire in minutes"},keywordFinish:{label:"Keyword Finish"},delayMessage:{label:"Default Delay Message"},unknownMessage:{label:"Unknown Message"},listeningFromMe:{label:"Listening from me",description:"Listen to messages sent by me on the bot"},stopBotFromMe:{label:"Stop bot from me",description:"Pause the bot when I send a message"},keepOpen:{label:"Keep open",description:"Keep the bot open after the conversation ends"},debounceTime:{label:"Debounce Time"},splitMessages:{label:"Split Messages",description:"Split messages into multiple messages"},timePerChar:{label:"Time per character"},ignoreJids:{label:"Ignore Jids",placeholder:"Add JIDs ex: 1234567890@s.whatsapp.net and press enter"}},button:{create:"Flowise",save:"Save",saving:"Saving...",update:"Update",defaultSettings:"Default Settings",delete:"Delete"},modal:{defaultSettings:{title:"Default Settings"}}},cre={dashboard:Une,button:Vne,modal:Hne,status:Kne,footer:qne,header:Wne,sidebar:Gne,toast:Jne,login:Qne,instance:Zne,settings:Yne,proxy:Xne,webhook:ere,websocket:tre,rabbitmq:nre,sqs:rre,chatwoot:sre,typebot:ore,openai:are,dify:ire,evolutionBot:lre,flowise:ure},dre={title:"Instancias",search:"Buscar",status:"Estado"},fre={delete:"Eliminar",deleting:"Eliminando...",cancel:"Cancelar",markAll:"Marcar Todos",unMarkAll:"Desmarcar Todos"},pre={delete:{title:"Eliminar Registro",message:"Estás eliminando la instancia {{instanceName}}. ¿Estás seguro de que deseas continuar?",messageSingle:"Esta acción no se puede deshacer."}},hre={all:"Todos",open:"Conectado",connecting:"Conectando",closed:"Desconectado"},gre={clientName:"Nombre del Cliente",version:"Versión"},mre={theme:{label:"Cambiar Tema",light:"Claro",dark:"Oscuro",system:"Sistema"},language:{label:"Idioma",english:"Inglés",portuguese:"Portugués",spanish:"Español",french:"Francés"}},vre={dashboard:"Visión General",configurations:"Configuraciones",settings:"Comportamiento",proxy:"Proxy",events:"Eventos",webhook:"Webhook",websocket:"WebSocket",rabbitmq:"RabbitMQ",sqs:"SQS",integrations:"Integraciones",chatwoot:"Chatwoot",typebot:"Typebot",openai:"OpenAI",dify:"Dify",evolutionBot:"Bot Evolution",flowise:"Flowise",documentation:"Documentación",postman:"Postman",discord:"Discord",supportPremium:"Soporte Premium"},yre={instance:{created:"Instancia creada con éxito",deleted:"Instancia eliminada con éxito",error:"Ocurrió un error al crear la instancia"}},bre={title:"Evolution Manager",description:"Por favor, inicia sesión para continuar",form:{serverUrl:"URL del Servidor",apiKey:"Clave API Global"},message:{invalidServer:"Servidor inválido",invalidCredentials:"Credenciales inválidas"},button:{login:"Conectar"}},xre={modal:{title:"Nueva Instancia"},form:{name:"Nombre",integration:{label:"Canal",baileys:"Baileys",whatsapp:"WhatsApp Cloud API",facebook:"Facebook",instagram:"Instagram",evolution:"Evolution"},token:"Token",number:"Número",businessId:"Business ID"},button:{save:"Guardar",saving:"Guardando...",create:"Instancia",connecting:"Conectando...",facebook:"Conectar con Facebook",instagram:"Conectar con Instagram",whatsapp:"Conectar con WhatsApp"},dashboard:{button:{qrcode:{label:"Generar Código QR",title:"Escanea el Código QR con WhatsApp"},pairingCode:{label:"Generar Código de Emparejamiento",title:"Emparejar con WhatsApp"},restart:"Reiniciar",disconnect:"Desconectar"},alert:"Para conectar, escanea el Código QR con WhatsApp",contacts:"Contactos",chats:"Chats",messages:"Mensajes"}},wre={title:"Comportamiento",toast:{success:"Comportamiento aplicado con éxito",error:"Ocurrió un error al aplicar el comportamiento"},form:{rejectCall:{label:"Rechazar Llamadas",description:"Rechazar todas las llamadas"},msgCall:{label:"Mensaje de Rechazo de Llamada",description:"Enviar mensaje de rechazo de llamada"},groupsIgnore:{label:"Ignorar Grupos",description:"Ignorar todos los mensajes de grupos"},alwaysOnline:{label:"Siempre Online",description:"Permanecer siempre en línea"},readMessages:{label:"Ver Mensajes",description:"Marcar todos los mensajes como leídos"},syncFullHistory:{label:"Sincronizar Historial Completo",description:"Sincronizar todo el historial al leer el Código QR"},readStatus:{label:"Ver Estado",description:"Marcar todos los estados como vistos"}},button:{save:"Guardar",saving:"Guardando..."}},Sre={title:"Proxy",toast:{success:"Proxy aplicado con éxito",error:"Ocurrió un error al aplicar el proxy"},form:{enabled:{label:"Activo",description:"Activar o desactivar el proxy"},protocol:{label:"Protocolo"},host:{label:"Host"},port:{label:"Puerto"},username:{label:"Usuario"},password:{label:"Contraseña"}},button:{save:"Guardar",saving:"Guardando..."}},Cre={title:"Webhook",toast:{success:"Webhook aplicado con éxito",error:"Ocurrió un error al aplicar el webhook"},form:{enabled:{label:"Activo",description:"Activar o desactivar el webhook"},url:{label:"URL"},byEvents:{label:"Webhook por Eventos",description:"Crear una ruta para cada evento agregando el nombre del evento al final de la URL"},base64:{label:"Webhook Base64",description:"Enviar datos de medios en base64 en el webhook"},events:{label:"Eventos"}},button:{save:"Guardar",saving:"Guardando..."}},Ere={title:"WebSocket",toast:{success:"WebSocket aplicado con éxito",error:"Ocurrió un error al aplicar el WebSocket"},form:{enabled:{label:"Activo",description:"Activar o desactivar el WebSocket"},events:{label:"Eventos"}},button:{save:"Guardar",saving:"Guardando..."}},Tre={title:"RabbitMQ",toast:{success:"RabbitMQ aplicado con éxito",error:"Ocurrió un error al aplicar el RabbitMQ"},form:{enabled:{label:"Activo",description:"Activar o desactivar el RabbitMQ"},events:{label:"Eventos"}},button:{save:"Guardar",saving:"Guardando..."}},kre={title:"SQS",toast:{success:"SQS aplicado con éxito",error:"Ocurrió un error al aplicar el SQS"},form:{enabled:{label:"Activo",description:"Activar o desactivar el SQS"},events:{label:"Eventos"}},button:{save:"Guardar",saving:"Guardando..."}},_re={title:"Chatwoot",toast:{success:"Chatwoot aplicado con éxito",error:"Ocurrió un error al aplicar el Chatwoot"},form:{enabled:{label:"Activo",description:"Activar o desactivar el Chatwoot"},url:{label:"URL de Chatwoot"},accountId:{label:"ID de la Cuenta"},token:{label:"Token"},signMsg:{label:"Firmar Mensajes",description:"Firmar mensajes con el nombre de usuario de Chatwoot"},signDelimiter:{label:"Delimitador de Firma"},nameInbox:{label:"Nombre de la Bandeja de Entrada"},organization:{label:"Organización"},logo:{label:"Logo"},conversationPending:{label:"Conversación Pendiente",description:"Las conversaciones comienzan como pendientes"},reopenConversation:{label:"Reabrir Conversación",description:"Reabrir la conversación al recibir un mensaje"},importContacts:{label:"Importar Contactos",description:"Importar contactos del libro de direcciones de WhatsApp al conectar el Código QR"},importMessages:{label:"Importar Mensajes",description:"Importar mensajes de WhatsApp al conectar el Código QR"},daysLimitImportMessages:{label:"Límite de Días para Importación de Mensajes"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Agregar JIDs ej: 1234567890@s.whatsapp.net y presiona enter"},autoCreate:{label:"Creación Automática",description:"Crear automáticamente la integración con Chatwoot al guardar"}},button:{save:"Guardar",saving:"Guardando..."}},jre={title:"Typebots",sessions:{label:"Sesiones",search:"Buscar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nombre Visible",sessionId:"ID de Sesión",status:"Estado",actions:{title:"Acciones",open:"Abrir",pause:"Pausar",close:"Cerrar",delete:"Eliminar"},none:"Nada que mostrar"}},defaultSettings:"Configuraciones Predeterminadas",toast:{defaultSettings:{success:"Configuraciones predeterminadas aplicadas con éxito",error:"Ocurrió un error al aplicar las configuraciones predeterminadas"},success:{update:"Typebot actualizado con éxito",create:"Typebot creado con éxito",delete:"Typebot eliminado con éxito",status:"Estado de Typebot actualizado con éxito"},error:"Ocurrió un error al crear el Typebot"},table:{none:"Nada que mostrar"},form:{title:"Nuevo Typebot",examples:{keywordFinish:"#FINISH",unknownMessage:"Lo siento, no entendí. ¿Puedes intentar de nuevo?"},enabled:{label:"Activo"},description:{label:"Descripción"},typebotSettings:{label:"Configuraciones de Typebot"},url:{label:"URL de la API de Typebot"},typebot:{label:"Nombre Público de Typebot"},triggerSettings:{label:"Configuraciones de Disparador"},triggerType:{label:"Tipo de Disparador",keyword:"Palabra clave",all:"Todos",advanced:"Avanzado",none:"Ninguno"},triggerOperator:{label:"Operador de Disparador",contains:"Contiene",equals:"Igual",startsWith:"Comienza Con",endsWith:"Termina Con",regex:"Regex"},triggerValue:{label:"Disparador"},triggerConditions:{label:"Condiciones"},typebotIdFallback:{label:"Fallback de Typebot"},generalSettings:{label:"Configuraciones Generales"},expire:{label:"Expirar en minutos"},keywordFinish:{label:"Palabra clave de Finalización"},delayMessage:{label:"Mensaje de Retraso Predeterminado"},unknownMessage:{label:"Mensaje Desconocido"},listeningFromMe:{label:"Escuchando de mí",description:"Escuchar los mensajes enviados por mí en el bot"},stopBotFromMe:{label:"Detener bot por mí",description:"Pausar el bot cuando yo envíe un mensaje"},keepOpen:{label:"Mantener abierto",description:"Mantener el bot abierto después de que termine la conversación"},debounceTime:{label:"Tiempo de Debounce"},splitMessages:{label:"Dividir Mensajes",description:"Dividir mensajes largos en múltiples mensajes"},timePerChar:{label:"Tiempo por Carácter"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Agregar JIDs ej: 1234567890@s.whatsapp.net y presiona enter"}},button:{create:"Typebot",save:"Guardar",saving:"Guardando...",update:"Actualizar",defaultSettings:"Configuraciones Predeterminadas",delete:"Eliminar"},modal:{defaultSettings:{title:"Configuraciones Predeterminadas"}}},Rre={title:"OpenAI",sessions:{label:"Sesiones",search:"Buscar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nombre Visible",sessionId:"ID de Sesión",status:"Estado",actions:{title:"Acciones",open:"Abrir",pause:"Pausar",close:"Cerrar",delete:"Eliminar"},none:"Nada que mostrar"}},credentials:{title:"Credenciales",table:{name:"Nombre",apiKey:"Clave API",actions:{title:"Acciones",delete:"Eliminar"},none:"Nada que mostrar"}},defaultSettings:"Configuraciones Predeterminadas",toast:{defaultSettings:{success:"Configuraciones predeterminadas aplicadas con éxito",error:"Ocurrió un error al aplicar las configuraciones predeterminadas"},success:{update:"OpenAI actualizado con éxito",create:"OpenAI creado con éxito",delete:"OpenAI eliminado con éxito",status:"Estado de OpenAI actualizado con éxito",credentialsCreate:"Credenciales de OpenAI creadas con éxito",credentialsDelete:"Credenciales de OpenAI eliminadas con éxito"},error:"Ocurrió un error al crear el OpenAI"},table:{none:"Nada que mostrar"},form:{title:"Nuevo OpenAI",examples:{keywordFinish:"#FINISH",unknownMessage:"Lo siento, no entendí. ¿Puedes intentar de nuevo?"},openaiCredsId:{label:"Credenciales de OpenAI"},enabled:{label:"Activo"},description:{label:"Descripción"},openaiSettings:{label:"Configuraciones de OpenAI"},botType:{label:"Tipo de Bot",assistant:"Asistente",chatCompletion:"Chat Completion"},assistantId:{label:"ID del Asistente"},functionUrl:{label:"URL de la Función"},model:{label:"Modelo de Lenguaje"},systemMessages:{label:"Mensajes del Sistema",description:"Enviar mensajes del sistema a OpenAI"},assystantMessages:{label:"Mensajes del Asistente",description:"Enviar mensajes del asistente a OpenAI"},userMessages:{label:"Mensajes del Usuario",description:"Enviar mensajes del usuario a OpenAI"},maxTokens:{label:"Máximo de Tokens"},triggerSettings:{label:"Configuraciones de Disparador"},triggerType:{label:"Tipo de Disparador",keyword:"Palabra clave",all:"Todos",advanced:"Avanzado",none:"Ninguno"},triggerOperator:{label:"Operador de Disparador",contains:"Contiene",equals:"Igual",startsWith:"Comienza Con",endsWith:"Termina Con",regex:"Regex"},triggerValue:{label:"Disparador"},triggerConditions:{label:"Condiciones"},openaiIdFallback:{label:"Fallback de OpenAI"},generalSettings:{label:"Configuraciones Generales"},expire:{label:"Expirar en minutos"},keywordFinish:{label:"Palabra clave de Finalización"},delayMessage:{label:"Mensaje de Retraso Predeterminado"},unknownMessage:{label:"Mensaje Desconocido"},listeningFromMe:{label:"Escuchando de mí",description:"Escuchar los mensajes enviados por mí en el bot"},stopBotFromMe:{label:"Detener bot por mí",description:"Pausar el bot cuando yo envíe un mensaje"},keepOpen:{label:"Mantener abierto",description:"Mantener el bot abierto después de que termine la conversación"},speechToText:{label:"Voz a Texto",description:"Convertir mensajes de voz en texto"},debounceTime:{label:"Tiempo de Debounce"},splitMessages:{label:"Dividir Mensajes",description:"Dividir mensajes largos en múltiples mensajes"},timePerChar:{label:"Tiempo por Carácter"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Agregar JIDs ej: 1234567890@s.whatsapp.net y presiona enter"}},button:{create:"OpenAI",save:"Guardar",saving:"Guardando...",update:"Actualizar",defaultSettings:"Configuraciones Predeterminadas",delete:"Eliminar"},modal:{defaultSettings:{title:"Configuraciones Predeterminadas"}}},Pre={title:"Dify",sessions:{label:"Sesiones",search:"Buscar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nombre Visible",sessionId:"ID de Sesión",status:"Estado",actions:{title:"Acciones",open:"Abrir",pause:"Pausar",close:"Cerrar",delete:"Eliminar"},none:"Nada que mostrar"}},defaultSettings:"Configuraciones Predeterminadas",toast:{defaultSettings:{success:"Configuraciones predeterminadas aplicadas con éxito",error:"Ocurrió un error al aplicar las configuraciones predeterminadas"},success:{update:"Dify actualizado con éxito",create:"Dify creado con éxito",delete:"Dify eliminado con éxito",status:"Estado de Dify actualizado con éxito"},error:"Ocurrió un error al crear el Dify"},table:{none:"Nada que mostrar"},form:{title:"Nuevo Dify",examples:{keywordFinish:"#FINISH",unknownMessage:"Lo siento, no entendí. ¿Puedes intentar de nuevo?"},enabled:{label:"Activo"},description:{label:"Descripción"},difySettings:{label:"Configuraciones de Dify"},botType:{label:"Tipo de Bot",chatBot:"Chat Bot",textGenerator:"Generador de Texto",agent:"Agente",workflow:"Flujo de Trabajo"},apiUrl:{label:"URL de la API"},apiKey:{label:"Clave API"},triggerSettings:{label:"Configuraciones de Disparador"},triggerType:{label:"Tipo de Disparador",keyword:"Palabra clave",all:"Todos",advanced:"Avanzado",none:"Ninguno"},triggerOperator:{label:"Operador de Disparador",contains:"Contiene",equals:"Igual",startsWith:"Comienza Con",endsWith:"Termina Con",regex:"Regex"},triggerValue:{label:"Disparador"},triggerConditions:{label:"Condiciones"},difyIdFallback:{label:"Fallback de Dify"},generalSettings:{label:"Configuraciones Generales"},expire:{label:"Expirar en minutos"},keywordFinish:{label:"Palabra clave de Finalización"},delayMessage:{label:"Mensaje de Retraso Predeterminado"},unknownMessage:{label:"Mensaje Desconocido"},listeningFromMe:{label:"Escuchando de mí",description:"Escuchar los mensajes enviados por mí en el bot"},stopBotFromMe:{label:"Detener bot por mí",description:"Pausar el bot cuando yo envíe un mensaje"},keepOpen:{label:"Mantener abierto",description:"Mantener el bot abierto después de que termine la conversación"},debounceTime:{label:"Tiempo de Debounce"},splitMessages:{label:"Dividir Mensajes",description:"Dividir mensajes largos en múltiples mensajes"},timePerChar:{label:"Tiempo por Carácter"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Agregar JIDs ej: 1234567890@s.whatsapp.net y presiona enter"}},button:{create:"Dify",save:"Guardar",saving:"Guardando...",update:"Actualizar",defaultSettings:"Configuraciones Predeterminadas",delete:"Eliminar"},modal:{defaultSettings:{title:"Configuraciones Predeterminadas"}}},Mre={title:"Bot Evolution",sessions:{label:"Sesiones",search:"Buscar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nombre Visible",sessionId:"ID de Sesión",status:"Estado",actions:{title:"Acciones",open:"Abrir",pause:"Pausar",close:"Cerrar",delete:"Eliminar"},none:"Nada que mostrar"}},defaultSettings:"Configuraciones Predeterminadas",toast:{defaultSettings:{success:"Configuraciones predeterminadas aplicadas con éxito",error:"Ocurrió un error al aplicar las configuraciones predeterminadas"},success:{update:"Bot Evolution actualizado con éxito",create:"Bot Evolution creado con éxito",delete:"Bot Evolution eliminado con éxito",status:"Estado de Bot Evolution actualizado con éxito"},error:"Ocurrió un error al crear el Bot Evolution"},table:{none:"Nada que mostrar"},form:{title:"Nuevo Bot Evolution",examples:{keywordFinish:"#FINISH",unknownMessage:"Lo siento, no entendí. ¿Puedes intentar de nuevo?"},enabled:{label:"Activo"},description:{label:"Descripción"},evolutionBotSettings:{label:"Configuraciones de Bot Evolution"},apiUrl:{label:"URL de la API"},apiKey:{label:"Clave API"},triggerSettings:{label:"Configuraciones de Disparador"},triggerType:{label:"Tipo de Disparador",keyword:"Palabra clave",all:"Todos",advanced:"Avanzado",none:"Ninguno"},triggerOperator:{label:"Operador de Disparador",contains:"Contiene",equals:"Igual",startsWith:"Comienza Con",endsWith:"Termina Con",regex:"Regex"},triggerValue:{label:"Disparador"},triggerConditions:{label:"Condiciones"},botIdFallback:{label:"Fallback de Bot Evolution"},generalSettings:{label:"Configuraciones Generales"},expire:{label:"Expirar en minutos"},keywordFinish:{label:"Palabra clave de Finalización"},delayMessage:{label:"Mensaje de Retraso Predeterminado"},unknownMessage:{label:"Mensaje Desconocido"},listeningFromMe:{label:"Escuchando de mí",description:"Escuchar los mensajes enviados por mí en el bot"},stopBotFromMe:{label:"Detener bot por mí",description:"Pausar el bot cuando yo envíe un mensaje"},keepOpen:{label:"Mantener abierto",description:"Mantener el bot abierto después de que termine la conversación"},debounceTime:{label:"Tiempo de Debounce"},splitMessages:{label:"Dividir Mensajes",description:"Dividir mensajes largos en múltiples mensajes"},timePerChar:{label:"Tiempo por Carácter"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Agregar JIDs ej: 1234567890@s.whatsapp.net y presiona enter"}},button:{create:"Bot Evolution",save:"Guardar",saving:"Guardando...",update:"Actualizar",defaultSettings:"Configuraciones Predeterminadas",delete:"Eliminar"},modal:{defaultSettings:{title:"Configuraciones Predeterminadas"}}},Ore={title:"Flowise",sessions:{label:"Sesiones",search:"Buscar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nombre Visible",sessionId:"ID de Sesión",status:"Estado",actions:{title:"Acciones",open:"Abrir",pause:"Pausar",close:"Cerrar",delete:"Eliminar"},none:"Nada que mostrar"}},defaultSettings:"Configuraciones Predeterminadas",toast:{defaultSettings:{success:"Configuraciones predeterminadas aplicadas con éxito",error:"Ocurrió un error al aplicar las configuraciones predeterminadas"},success:{update:"Flowise actualizado con éxito",create:"Flowise creado con éxito",delete:"Flowise eliminado con éxito",status:"Estado de Flowise actualizado con éxito"},error:"Ocurrió un error al crear el Flowise"},table:{none:"Nada que mostrar"},form:{title:"Nuevo Flowise",examples:{keywordFinish:"#FINISH",unknownMessage:"Lo siento, no entendí. ¿Puedes intentar de nuevo?"},enabled:{label:"Activo"},description:{label:"Descripción"},flowiseSettings:{label:"Configuraciones de Flowise"},apiUrl:{label:"URL de la API"},apiKey:{label:"Clave API"},triggerSettings:{label:"Configuraciones de Disparador"},triggerType:{label:"Tipo de Disparador",keyword:"Palabra clave",all:"Todos",advanced:"Avanzado",none:"Ninguno"},triggerOperator:{label:"Operador de Disparador",contains:"Contiene",equals:"Igual",startsWith:"Comienza Con",endsWith:"Termina Con",regex:"Regex"},triggerValue:{label:"Disparador"},triggerConditions:{label:"Condiciones"},flowiseIdFallback:{label:"Fallback de Flowise"},generalSettings:{label:"Configuraciones Generales"},expire:{label:"Expirar en minutos"},keywordFinish:{label:"Palabra clave de Finalización"},delayMessage:{label:"Mensaje de Retraso Predeterminado"},unknownMessage:{label:"Mensaje Desconocido"},listeningFromMe:{label:"Escuchando de mí",description:"Escuchar los mensajes enviados por mí en el bot"},stopBotFromMe:{label:"Detener bot por mí",description:"Pausar el bot cuando yo envíe un mensaje"},keepOpen:{label:"Mantener abierto",description:"Mantener el bot abierto después de que termine la conversación"},debounceTime:{label:"Tiempo de Debounce"},splitMessages:{label:"Dividir Mensajes",description:"Dividir mensajes largos en múltiples mensajes"},timePerChar:{label:"Tiempo por Carácter"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Agregar JIDs ej: 1234567890@s.whatsapp.net y presiona enter"}},button:{create:"Flowise",save:"Guardar",saving:"Guardando...",update:"Actualizar",defaultSettings:"Configuraciones Predeterminadas",delete:"Eliminar"},modal:{defaultSettings:{title:"Configuraciones Predeterminadas"}}},Nre={dashboard:dre,button:fre,modal:pre,status:hre,footer:gre,header:mre,sidebar:vre,toast:yre,login:bre,instance:xre,settings:wre,proxy:Sre,webhook:Cre,websocket:Ere,rabbitmq:Tre,sqs:kre,chatwoot:_re,typebot:jre,openai:Rre,dify:Pre,evolutionBot:Mre,flowise:Ore},Ire={title:"Instances",search:"Rechercher",status:"Statut"},Dre={delete:"Supprimer",deleting:"Suppression...",cancel:"Annuler",markAll:"Marquer Tous",unMarkAll:"Démarquer Tous"},Are={delete:{title:"Supprimer l'Enregistrement",message:"Vous êtes en train de supprimer l'instance {{instanceName}}. Êtes-vous sûr de vouloir continuer ?",messageSingle:"Cette action est irréversible."}},Fre={all:"Tous",open:"Connecté",connecting:"Connexion",closed:"Déconnecté"},Lre={clientName:"Nom du Client",version:"Version"},$re={theme:{label:"Changer de Thème",light:"Clair",dark:"Sombre",system:"Système"},language:{label:"Langue",english:"Anglais",portuguese:"Portugais",french:"Français"}},Bre={dashboard:"Vue d'ensemble",configurations:"Configurations",settings:"Comportement",proxy:"Proxy",events:"Evenements",webhook:"Webhook",websocket:"WebSocket",rabbitmq:"RabbitMQ",sqs:"SQS",integrations:"Intégrations",chatwoot:"Chatwoot",typebot:"Typebot",openai:"OpenAI",dify:"Dify",evolutionBot:"Bot Evolution",flowise:"Flowise",documentation:"Documentation",postman:"Postman",discord:"Discord",supportPremium:"Support Premium"},zre={instance:{created:"Instance créée avec succès",deleted:"Instance supprimée avec succès",error:"Une erreur est survenue lors de la création de l'instance"}},Ure={title:"Evolution Manager",description:"Veuillez vous connecter pour continuer",form:{serverUrl:"URL du Serveur",apiKey:"Clé API Globale"},message:{invalidServer:"Serveur invalide",invalidCredentials:"Identifiants invalides"},button:{login:"Se connecter"}},Vre={modal:{title:"Nouvelle Instance"},form:{name:"Nom",integration:{label:"Canal",baileys:"Baileys",whatsapp:"WhatsApp Cloud API",facebook:"Facebook",instagram:"Instagram",evolution:"Evolution"},token:"Token",number:"Numéro",businessId:"ID de l'Entreprise"},button:{save:"Enregistrer",saving:"Enregistrement...",create:"Instance",connecting:"Connexion...",facebook:"Se connecter avec Facebook",instagram:"Se connecter avec Instagram",whatsapp:"Se connecter avec WhatsApp"},dashboard:{button:{qrcode:{label:"Générer un Code QR",title:"Scannez le Code QR avec WhatsApp"},pairingCode:{label:"Générer un Code d'Appairage",title:"Appairez avec WhatsApp"},restart:"Redémarrer",disconnect:"Déconnecter"},alert:"Pour vous connecter, scannez le Code QR avec WhatsApp",contacts:"Contacts",chats:"Chats",messages:"Messages"}},Hre={title:"Comportement",toast:{success:"Comportement appliqué avec succès",error:"Une erreur est survenue lors de l'application du comportement"},form:{rejectCall:{label:"Rejeter les Appels",description:"Rejeter tous les appels"},msgCall:{label:"Message de Rejet d'Appel",description:"Envoyer un message de rejet d'appel"},groupsIgnore:{label:"Ignorer les Groupes",description:"Ignorer tous les messages de groupes"},alwaysOnline:{label:"Toujours En Ligne",description:"Rester toujours en ligne"},readMessages:{label:"Lire les Messages",description:"Marquer tous les messages comme lus"},syncFullHistory:{label:"Synchroniser l'Historique Complet",description:"Synchroniser l'historique complet lors de la lecture du Code QR"},readStatus:{label:"Lire le Statut",description:"Marquer tous les statuts comme vus"}},button:{save:"Enregistrer",saving:"Enregistrement..."}},Kre={title:"Proxy",toast:{success:"Proxy appliqué avec succès",error:"Une erreur est survenue lors de l'application du proxy"},form:{enabled:{label:"Activé",description:"Activer ou désactiver le proxy"},protocol:{label:"Protocole"},host:{label:"Hôte"},port:{label:"Port"},username:{label:"Utilisateur"},password:{label:"Mot de passe"}},button:{save:"Enregistrer",saving:"Enregistrement..."}},qre={title:"Webhook",toast:{success:"Webhook appliqué avec succès",error:"Une erreur est survenue lors de l'application du webhook"},form:{enabled:{label:"Activé",description:"Activer ou désactiver le webhook"},url:{label:"URL"},byEvents:{label:"Webhook par Événements",description:"Créer une route pour chaque événement en ajoutant le nom de l'événement à la fin de l'URL"},base64:{label:"Webhook Base64",description:"Envoyer des données médias en base64 dans le webhook"},events:{label:"Événements"}},button:{save:"Enregistrer",saving:"Enregistrement..."}},Wre={title:"WebSocket",toast:{success:"WebSocket appliqué avec succès",error:"Une erreur est survenue lors de l'application du WebSocket"},form:{enabled:{label:"Activé",description:"Activer ou désactiver le WebSocket"},events:{label:"Événements"}},button:{save:"Enregistrer",saving:"Enregistrement..."}},Gre={title:"RabbitMQ",toast:{success:"RabbitMQ appliqué avec succès",error:"Une erreur est survenue lors de l'application de RabbitMQ"},form:{enabled:{label:"Activé",description:"Activer ou désactiver RabbitMQ"},events:{label:"Événements"}},button:{save:"Enregistrer",saving:"Enregistrement..."}},Jre={title:"SQS",toast:{success:"SQS appliqué avec succès",error:"Une erreur est survenue lors de l'application de SQS"},form:{enabled:{label:"Activé",description:"Activer ou désactiver SQS"},events:{label:"Événements"}},button:{save:"Enregistrer",saving:"Enregistrement..."}},Qre={title:"Chatwoot",toast:{success:"Chatwoot appliqué avec succès",error:"Une erreur est survenue lors de l'application de Chatwoot"},form:{enabled:{label:"Activé",description:"Activer ou désactiver Chatwoot"},url:{label:"URL de Chatwoot"},accountId:{label:"ID du Compte"},token:{label:"Token"},signMsg:{label:"Signer les Messages",description:"Signer les messages avec le nom d'utilisateur Chatwoot"},signDelimiter:{label:"Délimiteur de Signature"},nameInbox:{label:"Nom de la Boîte de Réception"},organization:{label:"Organisation"},logo:{label:"Logo"},conversationPending:{label:"Conversation en Attente",description:"Les conversations commencent en attente"},reopenConversation:{label:"Rouvrir la Conversation",description:"Rouvrir la conversation lors de la réception d'un message"},importContacts:{label:"Importer les Contacts",description:"Importer les contacts du carnet d'adresses WhatsApp en scannant le Code QR"},importMessages:{label:"Importer les Messages",description:"Importer les messages WhatsApp en scannant le Code QR"},daysLimitImportMessages:{label:"Limite de Jours pour l'Importation de Messages"},ignoreJids:{label:"Ignorer les JIDs",placeholder:"Ajouter des JIDs ex: 1234567890@s.whatsapp.net et appuyez sur entrer"},autoCreate:{label:"Création Automatique",description:"Créer automatiquement l'intégration Chatwoot lors de l'enregistrement"}},button:{save:"Enregistrer",saving:"Enregistrement..."}},Zre={title:"Typebots",sessions:{label:"Sessions",search:"Rechercher par remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nom d'Affichage",sessionId:"ID de Session",status:"Statut",actions:{title:"Actions",open:"Ouvrir",pause:"Pause",close:"Fermer",delete:"Supprimer"},none:"Rien à afficher"}},defaultSettings:"Paramètres par Défaut",toast:{defaultSettings:{success:"Paramètres par défaut appliqués avec succès",error:"Une erreur est survenue lors de l'application des paramètres par défaut"},success:{update:"Typebot mis à jour avec succès",create:"Typebot créé avec succès",delete:"Typebot supprimé avec succès",status:"Statut de Typebot mis à jour avec succès"},error:"Une erreur est survenue lors de la création du Typebot"},table:{none:"Rien à afficher"},form:{title:"Nouveau Typebot",examples:{keywordFinish:"#FINISH",unknownMessage:"Désolé, je n'ai pas compris. Pouvez-vous réessayer ?"},enabled:{label:"Activé"},description:{label:"Description"},typebotSettings:{label:"Paramètres de Typebot"},url:{label:"URL de l'API de Typebot"},typebot:{label:"Nom Public de Typebot"},triggerSettings:{label:"Paramètres de Déclencheur"},triggerType:{label:"Type de Déclencheur",keyword:"Mot-clé",all:"Tous",advanced:"Avancé",none:"Aucun"},triggerOperator:{label:"Opérateur de Déclencheur",contains:"Contient",equals:"Égal",startsWith:"Commence Par",endsWith:"Se Termine Par",regex:"Regex"},triggerValue:{label:"Déclencheur"},triggerConditions:{label:"Conditions"},typebotIdFallback:{label:"Fallback de Typebot"},generalSettings:{label:"Paramètres Généraux"},expire:{label:"Expirer en minutes"},keywordFinish:{label:"Mot-clé de Fin"},delayMessage:{label:"Message de Délai par Défaut"},unknownMessage:{label:"Message Inconnu"},listeningFromMe:{label:"Écouter de Moi",description:"Écouter les messages envoyés par moi sur le bot"},stopBotFromMe:{label:"Arrêter le Bot de Moi",description:"Mettre en pause le bot quand j'envoie un message"},keepOpen:{label:"Garder Ouvert",description:"Garder le bot ouvert après la fin de la conversation"},debounceTime:{label:"Temps de Déclenchement"},splitMessages:{label:"Diviser les Messages",description:"Diviser les messages en plusieurs messages"},timePerChar:{label:"Temps par Caractère"},ignoreJids:{label:"Ignorer les JIDs",placeholder:"Ajouter des JIDs ex: 1234567890@s.whatsapp.net et appuyez sur entrer"}},button:{create:"Typebot",save:"Enregistrer",saving:"Enregistrement...",update:"Mettre à jour",defaultSettings:"Paramètres par Défaut",delete:"Supprimer"},modal:{defaultSettings:{title:"Paramètres par Défaut"}}},Yre={title:"OpenAI",sessions:{label:"Sessions",search:"Rechercher par remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nom d'Affichage",sessionId:"ID de Session",status:"Statut",actions:{title:"Actions",open:"Ouvrir",pause:"Pause",close:"Fermer",delete:"Supprimer"},none:"Rien à afficher"}},credentials:{title:"Identifiants",table:{name:"Nom",apiKey:"Clé API",actions:{title:"Actions",delete:"Supprimer"},none:"Rien à afficher"}},defaultSettings:"Paramètres par Défaut",toast:{defaultSettings:{success:"Paramètres par défaut appliqués avec succès",error:"Une erreur est survenue lors de l'application des paramètres par défaut"},success:{update:"OpenAI mis à jour avec succès",create:"OpenAI créé avec succès",delete:"OpenAI supprimé avec succès",status:"Statut de OpenAI mis à jour avec succès",credentialsCreate:"Identifiants OpenAI créés avec succès",credentialsDelete:"Identifiants OpenAI supprimés avec succès"},error:"Une erreur est survenue lors de la création de OpenAI"},table:{none:"Rien à afficher"},form:{title:"Nouveau OpenAI",examples:{keywordFinish:"#FINISH",unknownMessage:"Désolé, je n'ai pas compris. Pouvez-vous réessayer ?"},openaiCredsId:{label:"Identifiants OpenAI"},enabled:{label:"Activé"},description:{label:"Description"},openaiSettings:{label:"Paramètres OpenAI"},botType:{label:"Type de Bot",assistant:"Assistant",chatCompletion:"Chat Completion"},assistantId:{label:"ID de l'Assistant"},functionUrl:{label:"URL de la Fonction"},model:{label:"Modèle de Langage"},systemMessages:{label:"Messages Système",description:"Envoyer des messages système à OpenAI"},assystantMessages:{label:"Messages de l'Assistant",description:"Envoyer des messages de l'assistant à OpenAI"},userMessages:{label:"Messages de l'Utilisateur",description:"Envoyer des messages de l'utilisateur à OpenAI"},maxTokens:{label:"Nombre Maximum de Tokens"},triggerSettings:{label:"Paramètres de Déclencheur"},triggerType:{label:"Type de Déclencheur",keyword:"Mot-clé",all:"Tous",advanced:"Avancé",none:"Aucun"},triggerOperator:{label:"Opérateur de Déclencheur",contains:"Contient",equals:"Égal",startsWith:"Commence Par",endsWith:"Se Termine Par",regex:"Regex"},triggerValue:{label:"Déclencheur"},triggerConditions:{label:"Conditions"},openaiIdFallback:{label:"Fallback de OpenAI"},generalSettings:{label:"Paramètres Généraux"},expire:{label:"Expirer en minutes"},keywordFinish:{label:"Mot-clé de Fin"},delayMessage:{label:"Message de Délai par Défaut"},unknownMessage:{label:"Message Inconnu"},listeningFromMe:{label:"Écouter de Moi",description:"Écouter les messages envoyés par moi sur le bot"},stopBotFromMe:{label:"Arrêter le Bot de Moi",description:"Mettre en pause le bot quand j'envoie un message"},keepOpen:{label:"Garder Ouvert",description:"Garder le bot ouvert après la fin de la conversation"},speechToText:{label:"Parole en Texte",description:"Convertir les messages vocaux en texte"},debounceTime:{label:"Temps de Déclenchement"},splitMessages:{label:"Diviser les Messages",description:"Diviser les messages en plusieurs messages"},timePerChar:{label:"Temps par Caractère"},ignoreJids:{label:"Ignorer les JIDs",placeholder:"Ajouter des JIDs ex: 1234567890@s.whatsapp.net et appuyez sur entrer"}},button:{create:"OpenAI",save:"Enregistrer",saving:"Enregistrement...",update:"Mettre à jour",defaultSettings:"Paramètres par Défaut",delete:"Supprimer"},modal:{defaultSettings:{title:"Paramètres par Défaut"}}},Xre={title:"Dify",sessions:{label:"Sessions",search:"Rechercher par remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nom d'Affichage",sessionId:"ID de Session",status:"Statut",actions:{title:"Actions",open:"Ouvrir",pause:"Pause",close:"Fermer",delete:"Supprimer"},none:"Rien à afficher"}},defaultSettings:"Paramètres par Défaut",toast:{defaultSettings:{success:"Paramètres par défaut appliqués avec succès",error:"Une erreur est survenue lors de l'application des paramètres par défaut"},success:{update:"Dify mis à jour avec succès",create:"Dify créé avec succès",delete:"Dify supprimé avec succès",status:"Statut de Dify mis à jour avec succès"},error:"Une erreur est survenue lors de la création de Dify"},table:{none:"Rien à afficher"},form:{title:"Nouveau Dify",examples:{keywordFinish:"#FINISH",unknownMessage:"Désolé, je n'ai pas compris. Pouvez-vous réessayer ?"},enabled:{label:"Activé"},description:{label:"Description"},difySettings:{label:"Paramètres de Dify"},botType:{label:"Type de Bot",chatBot:"Chat Bot",textGenerator:"Générateur de Texte",agent:"Agent",workflow:"Flux de Travail"},apiUrl:{label:"URL de l'API"},apiKey:{label:"Clé API"},triggerSettings:{label:"Paramètres de Déclencheur"},triggerType:{label:"Type de Déclencheur",keyword:"Mot-clé",all:"Tous",advanced:"Avancé",none:"Aucun"},triggerOperator:{label:"Opérateur de Déclencheur",contains:"Contient",equals:"Égal",startsWith:"Commence Par",endsWith:"Se Termine Par",regex:"Regex"},triggerValue:{label:"Déclencheur"},triggerConditions:{label:"Conditions"},difyIdFallback:{label:"Fallback de Dify"},generalSettings:{label:"Paramètres Généraux"},expire:{label:"Expirer en minutes"},keywordFinish:{label:"Mot-clé de Fin"},delayMessage:{label:"Message de Délai par Défaut"},unknownMessage:{label:"Message Inconnu"},listeningFromMe:{label:"Écouter de Moi",description:"Écouter les messages envoyés par moi sur le bot"},stopBotFromMe:{label:"Arrêter le Bot de Moi",description:"Mettre en pause le bot quand j'envoie un message"},keepOpen:{label:"Garder Ouvert",description:"Garder le bot ouvert après la fin de la conversation"},debounceTime:{label:"Temps de Déclenchement"},splitMessages:{label:"Diviser les Messages",description:"Diviser les messages en plusieurs messages"},timePerChar:{label:"Temps par Caractère"},ignoreJids:{label:"Ignorer les JIDs",placeholder:"Ajouter des JIDs ex: 1234567890@s.whatsapp.net et appuyez sur entrer"}},button:{create:"Dify",save:"Enregistrer",saving:"Enregistrement...",update:"Mettre à jour",defaultSettings:"Paramètres par Défaut",delete:"Supprimer"},modal:{defaultSettings:{title:"Paramètres par Défaut"}}},ese={title:"Bots Evolution",sessions:{label:"Sessions",search:"Rechercher par remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nom d'Affichage",sessionId:"ID de Session",status:"Statut",actions:{title:"Actions",open:"Ouvrir",pause:"Pause",close:"Fermer",delete:"Supprimer"},none:"Rien à afficher"}},defaultSettings:"Paramètres par Défaut",toast:{defaultSettings:{success:"Paramètres par défaut appliqués avec succès",error:"Une erreur est survenue lors de l'application des paramètres par défaut"},success:{update:"Bots Evolution mis à jour avec succès",create:"Bots Evolution créé avec succès",delete:"Bots Evolution supprimé avec succès",status:"Statut de Bots Evolution mis à jour avec succès"},error:"Une erreur est survenue lors de la création de Bots Evolution"},table:{none:"Rien à afficher"},form:{title:"Nouveau Bots Evolution",examples:{keywordFinish:"#FINISH",unknownMessage:"Désolé, je n'ai pas compris. Pouvez-vous réessayer ?"},enabled:{label:"Activé"},description:{label:"Description"},evolutionBotSettings:{label:"Paramètres de Bots Evolution"},apiUrl:{label:"URL de l'API"},apiKey:{label:"Clé API"},triggerSettings:{label:"Paramètres de Déclencheur"},triggerType:{label:"Type de Déclencheur",keyword:"Mot-clé",all:"Tous",advanced:"Avancé",none:"Aucun"},triggerOperator:{label:"Opérateur de Déclencheur",contains:"Contient",equals:"Égal",startsWith:"Commence Par",endsWith:"Se Termine Par",regex:"Regex"},triggerValue:{label:"Déclencheur"},triggerConditions:{label:"Conditions"},botIdFallback:{label:"Fallback de Bots Evolution"},generalSettings:{label:"Paramètres Généraux"},expire:{label:"Expirer en minutes"},keywordFinish:{label:"Mot-clé de Fin"},delayMessage:{label:"Message de Délai par Défaut"},unknownMessage:{label:"Message Inconnu"},listeningFromMe:{label:"Écouter de Moi",description:"Écouter les messages envoyés par moi sur le bot"},stopBotFromMe:{label:"Arrêter le Bot de Moi",description:"Mettre en pause le bot quand j'envoie un message"},keepOpen:{label:"Garder Ouvert",description:"Garder le bot ouvert après la fin de la conversation"},debounceTime:{label:"Temps de Déclenchement"},splitMessages:{label:"Diviser les Messages",description:"Diviser les messages en plusieurs messages"},timePerChar:{label:"Temps par Caractère"},ignoreJids:{label:"Ignorer les JIDs",placeholder:"Ajouter des JIDs ex: 1234567890@s.whatsapp.net et appuyez sur entrer"}},button:{create:"Bots Evolution",save:"Enregistrer",saving:"Enregistrement...",update:"Mettre à jour",defaultSettings:"Paramètres par Défaut",delete:"Supprimer"},modal:{defaultSettings:{title:"Paramètres par Défaut"}}},tse={title:"Flowise",sessions:{label:"Sessions",search:"Rechercher par remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nom d'Affichage",sessionId:"ID de Session",status:"Statut",actions:{title:"Actions",open:"Ouvrir",pause:"Pause",close:"Fermer",delete:"Supprimer"},none:"Rien à afficher"}},defaultSettings:"Paramètres par Défaut",toast:{defaultSettings:{success:"Paramètres par défaut appliqués avec succès",error:"Une erreur est survenue lors de l'application des paramètres par défaut"},success:{update:"Flowise mis à jour avec succès",create:"Flowise créé avec succès",delete:"Flowise supprimé avec succès",status:"Statut de Flowise mis à jour avec succès"},error:"Une erreur est survenue lors de la création de Flowise"},table:{none:"Rien à afficher"},form:{title:"Nouveau Flowise",examples:{keywordFinish:"#FINISH",unknownMessage:"Désolé, je n'ai pas compris. Pouvez-vous réessayer ?"},enabled:{label:"Activé"},description:{label:"Description"},flowiseSettings:{label:"Paramètres de Flowise"},apiUrl:{label:"URL de l'API"},apiKey:{label:"Clé API"},triggerSettings:{label:"Paramètres de Déclencheur"},triggerType:{label:"Type de Déclencheur",keyword:"Mot-clé",all:"Tous",advanced:"Avancé",none:"Aucun"},triggerOperator:{label:"Opérateur de Déclencheur",contains:"Contient",equals:"Égal",startsWith:"Commence Par",endsWith:"Se Termine Par",regex:"Regex"},triggerValue:{label:"Déclencheur"},triggerConditions:{label:"Conditions"},flowiseIdFallback:{label:"Fallback de Flowise"},generalSettings:{label:"Paramètres Généraux"},expire:{label:"Expirer en minutes"},keywordFinish:{label:"Mot-clé de Fin"},delayMessage:{label:"Message de Délai par Défaut"},unknownMessage:{label:"Message Inconnu"},listeningFromMe:{label:"Écouter de Moi",description:"Écouter les messages envoyés par moi sur le bot"},stopBotFromMe:{label:"Arrêter le Bot de Moi",description:"Mettre en pause le bot quand j'envoie un message"},keepOpen:{label:"Garder Ouvert",description:"Garder le bot ouvert après la fin de la conversation"},debounceTime:{label:"Temps de Déclenchement"},splitMessages:{label:"Diviser les Messages",description:"Diviser les messages en plusieurs messages"},timePerChar:{label:"Temps par Caractère"},ignoreJids:{label:"Ignorer les JIDs",placeholder:"Ajouter des JIDs ex: 1234567890@s.whatsapp.net et appuyez sur entrer"}},button:{create:"Flowise",save:"Enregistrer",saving:"Enregistrement...",update:"Mettre à jour",defaultSettings:"Paramètres par Défaut",delete:"Supprimer"},modal:{defaultSettings:{title:"Paramètres par Défaut"}}},nse={dashboard:Ire,button:Dre,modal:Are,status:Fre,footer:Lre,header:$re,sidebar:Bre,toast:zre,login:Ure,instance:Vre,settings:Hre,proxy:Kre,webhook:qre,websocket:Wre,rabbitmq:Gre,sqs:Jre,chatwoot:Qre,typebot:Zre,openai:Yre,dify:Xre,evolutionBot:ese,flowise:tse},rse={title:"Instâncias",search:"Pesquisar",status:"Status"},sse={delete:"Excluir",deleting:"Excluindo...",cancel:"Cancelar",markAll:"Marcar Todos",unMarkAll:"Desmarcar Todos"},ose={delete:{title:"Excluir Registro",message:"Você está excluindo a instância {{instanceName}}. Tem certeza que deseja continuar?",messageSingle:"Esta ação não pode ser desfeita."}},ase={all:"Todos",open:"Conectado",connecting:"Conectando",closed:"Desconectado"},ise={clientName:"Nome do Cliente",version:"Versão"},lse={theme:{label:"Mudar Tema",light:"Claro",dark:"Escuro",system:"Sistema"},language:{label:"Idioma",english:"Inglês",portuguese:"Português",spanish:"Espanhol",french:"Francês"}},use={dashboard:"Visão Geral",configurations:"Configurações",settings:"Comportamento",proxy:"Proxy",events:"Eventos",webhook:"Webhook",websocket:"WebSocket",rabbitmq:"RabbitMQ",sqs:"SQS",integrations:"Integrações",chatwoot:"Chatwoot",typebot:"Typebot",openai:"OpenAI",dify:"Dify",evolutionBot:"Bot Evolution",flowise:"Flowise",documentation:"Documentação",postman:"Postman",discord:"Discord",supportPremium:"Suporte Premium"},cse={instance:{created:"Instância criada com sucesso",deleted:"Instância excluída com sucesso",error:"Ocorreu um erro ao criar a instância"}},dse={title:"Evolution Manager",description:"Por favor, faça login para continuar",form:{serverUrl:"URL do Servidor",apiKey:"Chave de API Global"},message:{invalidServer:"Servidor inválido",invalidCredentials:"Credenciais inválidas"},button:{login:"Conectar"}},fse={modal:{title:"Nova Instância"},form:{name:"Nome",integration:{label:"Canal",baileys:"Baileys",whatsapp:"WhatsApp Cloud API",facebook:"Facebook",instagram:"Instagram",evolution:"Evolution"},token:"Token",number:"Número",businessId:"Business ID"},button:{save:"Salvar",saving:"Salvando...",create:"Instância",connecting:"Conectando...",facebook:"Conectar com Facebook",instagram:"Conectar com Instagram",whatsapp:"Conectar com WhatsApp"},dashboard:{button:{qrcode:{label:"Gerar QR Code",title:"Scaneie o QR Code com o WhatsApp"},pairingCode:{label:"Gerar Código de Pareamento",title:"Faça o pareamento com o WhatsApp"},restart:"Reiniciar",disconnect:"Desconectar"},alert:"Para conectar, escaneie o QR Code com o WhatsApp",contacts:"Contatos",chats:"Chats",messages:"Mensagens"}},pse={title:"Comportamento",toast:{success:"Comportamento aplicado com sucesso",error:"Ocorreu um erro ao aplicar o comportamento"},form:{rejectCall:{label:"Rejeitar Chamadas",description:"Rejeitar todas as chamadas"},msgCall:{label:"Mensagem de Rejeição de Chamada",description:"Enviar mensagem de rejeição de chamada"},groupsIgnore:{label:"Ignorar Grupos",description:"Ignorar todas as mensagens de grupos"},alwaysOnline:{label:"Sempre Online",description:"Permanecer sempre online"},readMessages:{label:"Visualizar Mensagens",description:"Marcar todas as mensagens como lidas"},syncFullHistory:{label:"Sincronizar Histórico Completo",description:"Sincronizar o histórico completo ao ler o QR Code"},readStatus:{label:"Visualizar Status",description:"Marcar todos os status como visualizados"}},button:{save:"Salvar",saving:"Salvando..."}},hse={title:"Proxy",toast:{success:"Proxy aplicado com sucesso",error:"Ocorreu um erro ao aplicar o proxy"},form:{enabled:{label:"Ativo",description:"Ativar ou desativar o proxy"},protocol:{label:"Protocolo"},host:{label:"Host"},port:{label:"Porta"},username:{label:"Usuário"},password:{label:"Senha"}},button:{save:"Salvar",saving:"Salvando..."}},gse={title:"Webhook",toast:{success:"Webhook aplicado com sucesso",error:"Ocorreu um erro ao aplicar o webhook"},form:{enabled:{label:"Ativo",description:"Ativar ou desativar o webhook"},url:{label:"URL"},byEvents:{label:"Webhook por Eventos",description:"Criar uma rota para cada evento adicionando o nome do evento ao final da URL"},base64:{label:"Webhook Base64",description:"Enviar dados de mídia em base64 no webhook"},events:{label:"Eventos"}},button:{save:"Salvar",saving:"Salvando..."}},mse={title:"WebSocket",toast:{success:"WebSocket aplicado com sucesso",error:"Ocorreu um erro ao aplicar o WebSocket"},form:{enabled:{label:"Ativo",description:"Ativar ou desativar o WebSocket"},events:{label:"Eventos"}},button:{save:"Salvar",saving:"Salvando..."}},vse={title:"RabbitMQ",toast:{success:"RabbitMQ aplicado com sucesso",error:"Ocorreu um erro ao aplicar o RabbitMQ"},form:{enabled:{label:"Ativo",description:"Ativar ou desativar o RabbitMQ"},events:{label:"Eventos"}},button:{save:"Salvar",saving:"Salvando..."}},yse={title:"SQS",toast:{success:"SQS aplicado com sucesso",error:"Ocorreu um erro ao aplicar o SQS"},form:{enabled:{label:"Ativo",description:"Ativar ou desativar o SQS"},events:{label:"Eventos"}},button:{save:"Salvar",saving:"Salvando..."}},bse={title:"Chatwoot",toast:{success:"Chatwoot aplicado com sucesso",error:"Ocorreu um erro ao aplicar o Chatwoot"},form:{enabled:{label:"Ativo",description:"Ativar ou desativar o Chatwoot"},url:{label:"URL do Chatwoot"},accountId:{label:"ID da Conta"},token:{label:"Token"},signMsg:{label:"Assinar Mensagens",description:"Assinar mensagem com o nome de usuário do Chatwoot"},signDelimiter:{label:"Delimitador de Assinatura"},nameInbox:{label:"Nome da Caixa de Entrada"},organization:{label:"Organização"},logo:{label:"Logo"},conversationPending:{label:"Conversação Pendente",description:"Conversas começam como pendentes"},reopenConversation:{label:"Reabrir Conversa",description:"Reabrir a conversa ao receber uma mensagem"},importContacts:{label:"Importar Contatos",description:"Importar contatos da agenda do WhatsApp ao conectar o QR Code"},importMessages:{label:"Importar Mensagens",description:"Importar mensagens do WhatsApp ao conectar o QR Code"},daysLimitImportMessages:{label:"Limite de Dias para Importação de Mensagens"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Adicione JIDs ex: 1234567890@s.whatsapp.net e pressione enter"},autoCreate:{label:"Criação Automática",description:"Criar automaticamente a integração com o Chatwoot ao salvar"}},button:{save:"Salvar",saving:"Salvando..."}},xse={title:"Typebots",sessions:{label:"Sessões",search:"Pesquisar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nome de Exibição",sessionId:"ID da Sessão",status:"Status",actions:{title:"Ações",open:"Abrir",pause:"Pausar",close:"Fechar",delete:"Excluir"},none:"Nada para mostrar"}},defaultSettings:"Configurações Padrão",toast:{defaultSettings:{success:"Configurações padrão aplicadas com sucesso",error:"Ocorreu um erro ao aplicar as configurações padrão"},success:{update:"Typebot atualizado com sucesso",create:"Typebot criado com sucesso",delete:"Typebot excluído com sucesso",status:"Status do Typebot atualizado com sucesso"},error:"Ocorreu um erro ao criar o Typebot"},table:{none:"Nada para mostrar"},form:{title:"Novo Typebot",examples:{keywordFinish:"#FINISH",unknownMessage:"Desculpe, não entendi. Pode tentar novamente?"},enabled:{label:"Ativo"},description:{label:"Descrição"},typebotSettings:{label:"Configurações do Typebot"},url:{label:"URL da API do Typebot"},typebot:{label:"Nome Público do Typebot"},triggerSettings:{label:"Configurações de Gatilho"},triggerType:{label:"Tipo de Gatilho",keyword:"Palavra-chave",all:"Todos",advanced:"Avançado",none:"Nenhum"},triggerOperator:{label:"Operador do Gatilho",contains:"Contém",equals:"Igual",startsWith:"Começa Com",endsWith:"Termina Com",regex:"Regex"},triggerValue:{label:"Gatilho"},triggerConditions:{label:"Condições"},typebotIdFallback:{label:"Fallback do Typebot"},generalSettings:{label:"Configurações Gerais"},expire:{label:"Expirar em minutos"},keywordFinish:{label:"Palavra-chave de Finalização"},delayMessage:{label:"Mensagem de Atraso Padrão"},unknownMessage:{label:"Mensagem Desconhecida"},listeningFromMe:{label:"Ouvindo de mim",description:"Ouvir as mensagens enviadas por mim no bot"},stopBotFromMe:{label:"Parar bot por mim",description:"Pausar o bot quando eu enviar uma mensagem"},keepOpen:{label:"Manter aberto",description:"Manter o bot aberto após o término da conversa"},debounceTime:{label:"Tempo de Debounce"},splitMessages:{label:"Dividir Mensagens",description:"Dividir mensagens longas em várias mensagens"},timePerChar:{label:"Tempo por Caractere"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Adicione JIDs ex: 1234567890@s.whatsapp.net e pressione enter"}},button:{create:"Typebot",save:"Salvar",saving:"Salvando...",update:"Atualizar",defaultSettings:"Configurações Padrão",delete:"Excluir"},modal:{defaultSettings:{title:"Configurações Padrão"}}},wse={title:"OpenAI",sessions:{label:"Sessões",search:"Pesquisar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nome de Exibição",sessionId:"ID da Sessão",status:"Status",actions:{title:"Ações",open:"Abrir",pause:"Pausar",close:"Fechar",delete:"Excluir"},none:"Nada para mostrar"}},credentials:{title:"Credenciais",table:{name:"Nome",apiKey:"Chave de API",actions:{title:"Ações",delete:"Excluir"},none:"Nada para mostrar"}},defaultSettings:"Configurações Padrão",toast:{defaultSettings:{success:"Configurações padrão aplicadas com sucesso",error:"Ocorreu um erro ao aplicar as configurações padrão"},success:{update:"OpenAI atualizado com sucesso",create:"OpenAI criado com sucesso",delete:"OpenAI excluído com sucesso",status:"Status do OpenAI atualizado com sucesso",credentialsCreate:"Credenciais do OpenAI criadas com sucesso",credentialsDelete:"Credenciais do OpenAI excluídas com sucesso"},error:"Ocorreu um erro ao criar o OpenAI"},table:{none:"Nada para mostrar"},form:{title:"Novo OpenAI",examples:{keywordFinish:"#FINISH",unknownMessage:"Desculpe, não entendi. Pode tentar novamente?"},openaiCredsId:{label:"Credenciais do OpenAI"},enabled:{label:"Ativo"},description:{label:"Descrição"},openaiSettings:{label:"Configurações do OpenAI"},botType:{label:"Tipo de Bot",assistant:"Assistente",chatCompletion:"Chat Completion"},assistantId:{label:"ID do Assistente"},functionUrl:{label:"URL da Função"},model:{label:"Modelo de Linguagem"},systemMessages:{label:"Mensagens do Sistema",description:"Enviar mensagens do sistema para o OpenAI"},assystantMessages:{label:"Mensagens do Assistente",description:"Enviar mensagens do assistente para o OpenAI"},userMessages:{label:"Mensagens do Usuário",description:"Enviar mensagens do usuário para o OpenAI"},maxTokens:{label:"Máximo de Tokens"},triggerSettings:{label:"Configurações de Gatilho"},triggerType:{label:"Tipo de Gatilho",keyword:"Palavra-chave",all:"Todos",advanced:"Avançado",none:"Nenhum"},triggerOperator:{label:"Operador do Gatilho",contains:"Contém",equals:"Igual",startsWith:"Começa Com",endsWith:"Termina Com",regex:"Regex"},triggerValue:{label:"Gatilho"},triggerConditions:{label:"Condições"},openaiIdFallback:{label:"Fallback do OpenAI"},generalSettings:{label:"Configurações Gerais"},expire:{label:"Expirar em minutos"},keywordFinish:{label:"Palavra-chave de Finalização"},delayMessage:{label:"Mensagem de Atraso Padrão"},unknownMessage:{label:"Mensagem Desconhecida"},listeningFromMe:{label:"Ouvindo de mim",description:"Ouvir as mensagens enviadas por mim no bot"},stopBotFromMe:{label:"Parar bot por mim",description:"Pausar o bot quando eu enviar uma mensagem"},keepOpen:{label:"Manter aberto",description:"Manter o bot aberto após o término da conversa"},speechToText:{label:"Fala para Texto",description:"Converter mensagens de voz em texto"},debounceTime:{label:"Tempo de Debounce"},splitMessages:{label:"Dividir Mensagens",description:"Dividir mensagens longas em várias mensagens"},timePerChar:{label:"Tempo por Caractere"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Adicione JIDs ex: 1234567890@s.whatsapp.net e pressione enter"}},button:{create:"OpenAI",save:"Salvar",saving:"Salvando...",update:"Atualizar",defaultSettings:"Configurações Padrão",delete:"Excluir"},modal:{defaultSettings:{title:"Configurações Padrão"}}},Sse={title:"Dify",sessions:{label:"Sessões",search:"Pesquisar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nome de Exibição",sessionId:"ID da Sessão",status:"Status",actions:{title:"Ações",open:"Abrir",pause:"Pausar",close:"Fechar",delete:"Excluir"},none:"Nada para mostrar"}},defaultSettings:"Configurações Padrão",toast:{defaultSettings:{success:"Configurações padrão aplicadas com sucesso",error:"Ocorreu um erro ao aplicar as configurações padrão"},success:{update:"Dify atualizado com sucesso",create:"Dify criado com sucesso",delete:"Dify excluído com sucesso",status:"Status do Dify atualizado com sucesso"},error:"Ocorreu um erro ao criar o Dify"},table:{none:"Nada para mostrar"},form:{title:"Novo Dify",examples:{keywordFinish:"#FINISH",unknownMessage:"Desculpe, não entendi. Pode tentar novamente?"},enabled:{label:"Ativo"},description:{label:"Descrição"},difySettings:{label:"Configurações do Dify"},botType:{label:"Tipo de Bot",chatBot:"Bot de Chat",textGenerator:"Gerador de Texto",agent:"Agente",workflow:"Fluxo de Trabalho"},apiUrl:{label:"URL da API"},apiKey:{label:"Chave de API"},triggerSettings:{label:"Configurações de Gatilho"},triggerType:{label:"Tipo de Gatilho",keyword:"Palavra-chave",all:"Todos",advanced:"Avançado",none:"Nenhum"},triggerOperator:{label:"Operador do Gatilho",contains:"Contém",equals:"Igual",startsWith:"Começa Com",endsWith:"Termina Com",regex:"Regex"},triggerValue:{label:"Gatilho"},triggerConditions:{label:"Condições"},difyIdFallback:{label:"Fallback do Dify"},generalSettings:{label:"Configurações Gerais"},expire:{label:"Expirar em minutos"},keywordFinish:{label:"Palavra-chave de Finalização"},delayMessage:{label:"Mensagem de Atraso Padrão"},unknownMessage:{label:"Mensagem Desconhecida"},listeningFromMe:{label:"Ouvindo de mim",description:"Ouvir as mensagens enviadas por mim no bot"},stopBotFromMe:{label:"Parar bot por mim",description:"Pausar o bot quando eu enviar uma mensagem"},keepOpen:{label:"Manter aberto",description:"Manter o bot aberto após o término da conversa"},debounceTime:{label:"Tempo de Debounce"},splitMessages:{label:"Dividir Mensagens",description:"Dividir mensagens longas em várias mensagens"},timePerChar:{label:"Tempo por Caractere"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Adicione JIDs ex: 1234567890@s.whatsapp.net e pressione enter"}},button:{create:"Dify",save:"Salvar",saving:"Salvando...",update:"Atualizar",defaultSettings:"Configurações Padrão",delete:"Excluir"},modal:{defaultSettings:{title:"Configurações Padrão"}}},Cse={title:"Bot Evolution",sessions:{label:"Sessões",search:"Pesquisar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nome de Exibição",sessionId:"ID da Sessão",status:"Status",actions:{title:"Ações",open:"Abrir",pause:"Pausar",close:"Fechar",delete:"Excluir"},none:"Nada para mostrar"}},defaultSettings:"Configurações Padrão",toast:{defaultSettings:{success:"Configurações padrão aplicadas com sucesso",error:"Ocorreu um erro ao aplicar as configurações padrão"},success:{update:"Bot Evolution atualizado com sucesso",create:"Bot Evolution criado com sucesso",delete:"Bot Evolution excluído com sucesso",status:"Status do Bot Evolution atualizado com sucesso"},error:"Ocorreu um erro ao criar o Bot Evolution"},table:{none:"Nada para mostrar"},form:{title:"Novo Bot Evolution",examples:{keywordFinish:"#FINISH",unknownMessage:"Desculpe, não entendi. Pode tentar novamente?"},enabled:{label:"Ativo"},description:{label:"Descrição"},evolutionBotSettings:{label:"Configurações do Bot Evolution"},apiUrl:{label:"URL da API"},apiKey:{label:"Chave de API"},triggerSettings:{label:"Configurações de Gatilho"},triggerType:{label:"Tipo de Gatilho",keyword:"Palavra-chave",all:"Todos",advanced:"Avançado",none:"Nenhum"},triggerOperator:{label:"Operador do Gatilho",contains:"Contém",equals:"Igual",startsWith:"Começa Com",endsWith:"Termina Com",regex:"Regex"},triggerValue:{label:"Gatilho"},triggerConditions:{label:"Condições"},botIdFallback:{label:"Fallback do Bot Evolution"},generalSettings:{label:"Configurações Gerais"},expire:{label:"Expirar em minutos"},keywordFinish:{label:"Palavra-chave de Finalização"},delayMessage:{label:"Mensagem de Atraso Padrão"},unknownMessage:{label:"Mensagem Desconhecida"},listeningFromMe:{label:"Ouvindo de mim",description:"Ouvir as mensagens enviadas por mim no bot"},stopBotFromMe:{label:"Parar bot por mim",description:"Pausar o bot quando eu enviar uma mensagem"},keepOpen:{label:"Manter aberto",description:"Manter o bot aberto após o término da conversa"},debounceTime:{label:"Tempo de Debounce"},splitMessages:{label:"Dividir Mensagens",description:"Dividir mensagens longas em várias mensagens"},timePerChar:{label:"Tempo por Caractere"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Adicione JIDs ex: 1234567890@s.whatsapp.net e pressione enter"}},button:{create:"Bot Evolution",save:"Salvar",saving:"Salvando...",update:"Atualizar",defaultSettings:"Configurações Padrão",delete:"Excluir"},modal:{defaultSettings:{title:"Configurações Padrão"}}},Ese={title:"Flowise",sessions:{label:"Sessões",search:"Pesquisar por remoteJid...",table:{remoteJid:"RemoteJid",pushName:"Nome de Exibição",sessionId:"ID da Sessão",status:"Status",actions:{title:"Ações",open:"Abrir",pause:"Pausar",close:"Fechar",delete:"Excluir"},none:"Nada para mostrar"}},defaultSettings:"Configurações Padrão",toast:{defaultSettings:{success:"Configurações padrão aplicadas com sucesso",error:"Ocorreu um erro ao aplicar as configurações padrão"},success:{update:"Flowise atualizado com sucesso",create:"Flowise criado com sucesso",delete:"Flowise excluído com sucesso",status:"Status do Flowise atualizado com sucesso"},error:"Ocorreu um erro ao criar o Flowise"},table:{none:"Nada para mostrar"},form:{title:"Novo Flowise",examples:{keywordFinish:"#FINISH",unknownMessage:"Desculpe, não entendi. Pode tentar novamente?"},enabled:{label:"Ativo"},description:{label:"Descrição"},flowiseSettings:{label:"Configurações do Flowise"},apiUrl:{label:"URL da API"},apiKey:{label:"Chave de API"},triggerSettings:{label:"Configurações de Gatilho"},triggerType:{label:"Tipo de Gatilho",keyword:"Palavra-chave",all:"Todos",advanced:"Avançado",none:"Nenhum"},triggerOperator:{label:"Operador do Gatilho",contains:"Contém",equals:"Igual",startsWith:"Começa Com",endsWith:"Termina Com",regex:"Regex"},triggerValue:{label:"Gatilho"},triggerConditions:{label:"Condições"},flowiseIdFallback:{label:"Fallback do Flowise"},generalSettings:{label:"Configurações Gerais"},expire:{label:"Expirar em minutos"},keywordFinish:{label:"Palavra-chave de Finalização"},delayMessage:{label:"Mensagem de Atraso Padrão"},unknownMessage:{label:"Mensagem Desconhecida"},listeningFromMe:{label:"Ouvindo de mim",description:"Ouvir as mensagens enviadas por mim no bot"},stopBotFromMe:{label:"Parar bot por mim",description:"Pausar o bot quando eu enviar uma mensagem"},keepOpen:{label:"Manter aberto",description:"Manter o bot aberto após o término da conversa"},debounceTime:{label:"Tempo de Debounce"},splitMessages:{label:"Dividir Mensagens",description:"Dividir mensagens longas em várias mensagens"},timePerChar:{label:"Tempo por Caractere"},ignoreJids:{label:"Ignorar JIDs",placeholder:"Adicione JIDs ex: 1234567890@s.whatsapp.net e pressione enter"}},button:{create:"Flowise",save:"Salvar",saving:"Salvando...",update:"Atualizar",defaultSettings:"Configurações Padrão",delete:"Excluir"},modal:{defaultSettings:{title:"Configurações Padrão"}}},Tse={dashboard:rse,button:sse,modal:ose,status:ase,footer:ise,header:lse,sidebar:use,toast:cse,login:dse,instance:fse,settings:pse,proxy:hse,webhook:gse,websocket:mse,rabbitmq:vse,sqs:yse,chatwoot:bse,typebot:xse,openai:wse,dify:Sse,evolutionBot:Cse,flowise:Ese};kn.use(c2).init({resources:{"en-US":{translation:cre},"pt-BR":{translation:Tse},"es-ES":{translation:Nre},"fr-FR":{translation:nse}},lng:localStorage.getItem("i18nextLng")||"en-US",fallbackLng:"en-US",interpolation:{escapeValue:!1}});Fv.createRoot(document.getElementById("root")).render(u.jsxs(Te.StrictMode,{children:[u.jsx(h2,{i18n:kn,children:u.jsx(a$,{defaultTheme:"dark",storageKey:"vite-ui-theme",children:u.jsx(ID,{client:i$,children:u.jsx(zL,{router:yne})})})}),u.jsx(s$,{theme:"colored"})]}))});export default kse();



================================================
FILE: manager/dist/assets/index-DNOCacL_.css
================================================
@import"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap";*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}:root{--gradient: #093028;--background: 178 98.4% 98.22%;--foreground: 178 6.800000000000001% .44%;--muted: 178 6.800000000000001% 91.1%;--muted-foreground: 178 3.4000000000000004% 41.1%;--popover: 178 35.599999999999994% 91.1%;--popover-foreground: 178 6.800000000000001% .55%;--card: 178 35.599999999999994% 91.1%;--card-foreground: 178 6.800000000000001% .55%;--border: 178 11.8% 89.44%;--input: 178 11.8% 89.44%;--primary: 178 68% 11%;--primary-foreground: 178 1.36% 91.1%;--secondary: 178 3.4000000000000004% 95.55%;--secondary-foreground: 178 5.08% 11.1%;--accent: 178 3.4000000000000004% 95.55%;--accent-foreground: 178 5.08% 11.1%;--destructive: 0 84.2% 60.2%;--destructive-foreground: 0 0% 98%;--ring: 178 68% 11%;--radius: .5rem}.dark{--gradient: #189d68;--background: 166 47.449999999999996% 2.88%;--foreground: 166 7.3% 96.8%;--muted: 166 36.5% 10.799999999999999%;--muted-foreground: 166 7.3% 53.6%;--popover: 166 50.4% 4.68%;--popover-foreground: 166 7.3% 96.8%;--card: 166 50.4% 4.68%;--card-foreground: 166 7.3% 96.8%;--border: 166 36.5% 10.799999999999999%;--input: 166 36.5% 10.799999999999999%;--primary: 166 73% 36%;--primary-foreground: 166 7.3% 96.8%;--secondary: 166 36.5% 10.799999999999999%;--secondary-foreground: 166 7.3% 96.8%;--accent: 166 36.5% 10.799999999999999%;--accent-foreground: 166 7.3% 96.8%;--destructive: 0 62.8% 30.6%;--destructive-foreground: 166 7.3% 96.8%;--ring: 166 73% 36%}*{border-color:hsl(var(--border))}body{background-color:hsl(var(--background));color:hsl(var(--foreground));font-family:Inter,sans-serif;scrollbar-width:thin;scrollbar-color:transparent transparent}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.inset-0{top:0;right:0;bottom:0;left:0}.bottom-0{bottom:0}.bottom-3{bottom:.75rem}.left-2{left:.5rem}.left-3{left:.75rem}.right-3{right:.75rem}.right-4{right:1rem}.top-0{top:0}.top-4{top:1rem}.z-10{z-index:10}.z-50{z-index:50}.m-4{margin:1rem}.-mx-1{margin-left:-.25rem;margin-right:-.25rem}.mx-4{margin-left:1rem;margin-right:1rem}.mx-auto{margin-left:auto;margin-right:auto}.my-0\.5{margin-top:.125rem;margin-bottom:.125rem}.my-1{margin-top:.25rem;margin-bottom:.25rem}.my-2{margin-top:.5rem;margin-bottom:.5rem}.my-4{margin-top:1rem;margin-bottom:1rem}.my-6{margin-top:1.5rem;margin-bottom:1.5rem}.mb-1{margin-bottom:.25rem}.mb-4{margin-bottom:1rem}.ml-2{margin-left:.5rem}.ml-6{margin-left:1.5rem}.ml-auto{margin-left:auto}.mr-1{margin-right:.25rem}.mr-16{margin-right:4rem}.mr-2{margin-right:.5rem}.mt-2{margin-top:.5rem}.mt-4{margin-top:1rem}.mt-5{margin-top:1.25rem}.mt-auto{margin-top:auto}.block{display:block}.flex{display:flex}.inline-flex{display:inline-flex}.table{display:table}.grid{display:grid}.hidden{display:none}.aspect-square{aspect-ratio:1 / 1}.aspect-video{aspect-ratio:16 / 9}.h-10{height:2.5rem}.h-11{height:2.75rem}.h-12{height:3rem}.h-2{height:.5rem}.h-2\.5{height:.625rem}.h-24{height:6rem}.h-3\.5{height:.875rem}.h-4{height:1rem}.h-5{height:1.25rem}.h-6{height:1.5rem}.h-7{height:1.75rem}.h-8{height:2rem}.h-9{height:2.25rem}.h-\[1\.2rem\]{height:1.2rem}.h-\[1px\]{height:1px}.h-\[var\(--radix-select-trigger-height\)\]{height:var(--radix-select-trigger-height)}.h-auto{height:auto}.h-full{height:100%}.h-px{height:1px}.h-screen{height:100vh}.max-h-96{max-height:24rem}.max-h-\[240px\]{max-height:240px}.max-h-\[300px\]{max-height:300px}.min-h-\[48px\]{min-height:48px}.min-h-\[80px\]{min-height:80px}.min-h-\[calc\(100vh_-_56px\)\]{min-height:calc(100vh - 56px)}.min-h-screen{min-height:100vh}.w-0{width:0px}.w-1{width:.25rem}.w-10{width:2.5rem}.w-11{width:2.75rem}.w-2{width:.5rem}.w-2\.5{width:.625rem}.w-3{width:.75rem}.w-3\.5{width:.875rem}.w-4{width:1rem}.w-5{width:1.25rem}.w-7{width:1.75rem}.w-72{width:18rem}.w-8{width:2rem}.w-\[1\.2rem\]{width:1.2rem}.w-\[1px\]{width:1px}.w-\[350px\]{width:350px}.w-full{width:100%}.w-px{width:1px}.min-w-0{min-width:0px}.min-w-\[8rem\]{min-width:8rem}.min-w-\[var\(--radix-select-trigger-width\)\]{min-width:var(--radix-select-trigger-width)}.max-w-2xl{max-width:42rem}.max-w-4xl{max-width:56rem}.max-w-\[300px\]{max-width:300px}.max-w-lg{max-width:32rem}.flex-1{flex:1 1 0%}.shrink-0{flex-shrink:0}.grow{flex-grow:1}.caption-bottom{caption-side:bottom}.translate-y-1{--tw-translate-y: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.rotate-0{--tw-rotate: 0deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.rotate-90{--tw-rotate: 90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scale-0{--tw-scale-x: 0;--tw-scale-y: 0;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scale-100{--tw-scale-x: 1;--tw-scale-y: 1;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-default{cursor:default}.cursor-not-allowed{cursor:not-allowed}.cursor-pointer{cursor:pointer}.touch-none{touch-action:none}.select-none{-webkit-user-select:none;-moz-user-select:none;user-select:none}.resize-none{resize:none}.grid-cols-\[repeat\(auto-fit\,_minmax\(15rem\,_1fr\)\)\]{grid-template-columns:repeat(auto-fit,minmax(15rem,1fr))}.flex-row{flex-direction:row}.flex-row-reverse{flex-direction:row-reverse}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-wrap{flex-wrap:wrap}.place-items-center{place-items:center}.items-start{align-items:flex-start}.items-end{align-items:flex-end}.items-center{align-items:center}.items-stretch{align-items:stretch}.justify-start{justify-content:flex-start}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-1{gap:.25rem}.gap-1\.5{gap:.375rem}.gap-2{gap:.5rem}.gap-3{gap:.75rem}.gap-4{gap:1rem}.gap-6{gap:1.5rem}.gap-8{gap:2rem}.space-x-3>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.75rem * var(--tw-space-x-reverse));margin-left:calc(.75rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-1>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.25rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.25rem * var(--tw-space-y-reverse))}.space-y-1\.5>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.375rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.375rem * var(--tw-space-y-reverse))}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.space-y-4>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}.space-y-6>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.divide-x>:not([hidden])~:not([hidden]){--tw-divide-x-reverse: 0;border-right-width:calc(1px * var(--tw-divide-x-reverse));border-left-width:calc(1px * calc(1 - var(--tw-divide-x-reverse)))}.divide-y>:not([hidden])~:not([hidden]){--tw-divide-y-reverse: 0;border-top-width:calc(1px * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(1px * var(--tw-divide-y-reverse))}.self-end{align-self:flex-end}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-visible{overflow:visible}.overflow-y-auto{overflow-y:auto}.overflow-x-hidden{overflow-x:hidden}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.text-wrap{text-wrap:wrap}.break-all{word-break:break-all}.rounded-3xl{border-radius:1.5rem}.rounded-\[2px\]{border-radius:2px}.rounded-\[inherit\]{border-radius:inherit}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-xl{border-radius:.75rem}.border{border-width:1px}.border-2{border-width:2px}.border-\[1\.5px\]{border-width:1.5px}.border-b{border-bottom-width:1px}.border-l{border-left-width:1px}.border-r{border-right-width:1px}.border-t{border-top-width:1px}.border-dashed{border-style:dashed}.border-none{border-style:none}.border-\[--color-border\]{border-color:var(--color-border)}.border-amber-500\/20{border-color:#f59e0b33}.border-black{--tw-border-opacity: 1;border-color:rgb(0 0 0 / var(--tw-border-opacity))}.border-border{border-color:hsl(var(--border))}.border-border\/50{border-color:hsl(var(--border) / .5)}.border-emerald-500\/20{border-color:#10b98133}.border-gray-600\/50{border-color:#4b556380}.border-input{border-color:hsl(var(--input))}.border-muted{border-color:hsl(var(--muted))}.border-red-500\/20{border-color:#ef444433}.border-sky-500\/20{border-color:#0ea5e933}.border-transparent{border-color:transparent}.border-zinc-500\/20{border-color:#71717a33}.border-l-transparent{border-left-color:transparent}.border-t-transparent{border-top-color:transparent}.bg-\[--color-bg\]{background-color:var(--color-bg)}.bg-amber-50\/50{background-color:#fffbeb80}.bg-amber-600{--tw-bg-opacity: 1;background-color:rgb(217 119 6 / var(--tw-bg-opacity))}.bg-background{background-color:hsl(var(--background))}.bg-background\/80{background-color:hsl(var(--background) / .8)}.bg-border{background-color:hsl(var(--border))}.bg-card{background-color:hsl(var(--card))}.bg-destructive{background-color:hsl(var(--destructive))}.bg-emerald-50\/50{background-color:#ecfdf580}.bg-muted{background-color:hsl(var(--muted))}.bg-muted\/50{background-color:hsl(var(--muted) / .5)}.bg-popover{background-color:hsl(var(--popover))}.bg-primary{background-color:hsl(var(--primary))}.bg-primary\/20{background-color:hsl(var(--primary) / .2)}.bg-primary\/30{background-color:hsl(var(--primary) / .3)}.bg-red-50\/50{background-color:#fef2f280}.bg-secondary{background-color:hsl(var(--secondary))}.bg-sky-50\/50{background-color:#f0f9ff80}.bg-transparent{background-color:transparent}.bg-zinc-50\/50{background-color:#fafafa80}.fill-current{fill:currentColor}.p-0{padding:0}.p-1{padding:.25rem}.p-2{padding:.5rem}.p-4{padding:1rem}.p-5{padding:1.25rem}.p-6{padding:1.5rem}.p-8{padding:2rem}.p-\[1px\]{padding:1px}.px-1{padding-left:.25rem;padding-right:.25rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-2\.5{padding-left:.625rem;padding-right:.625rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-0\.5{padding-top:.125rem;padding-bottom:.125rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-1\.5{padding-top:.375rem;padding-bottom:.375rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.py-6{padding-top:1.5rem;padding-bottom:1.5rem}.pb-3{padding-bottom:.75rem}.pl-12{padding-left:3rem}.pl-2{padding-left:.5rem}.pl-3{padding-left:.75rem}.pl-8{padding-left:2rem}.pr-16{padding-right:4rem}.pr-2{padding-right:.5rem}.pr-4{padding-right:1rem}.pt-0{padding-top:0}.pt-2{padding-top:.5rem}.pt-3{padding-top:.75rem}.pt-5{padding-top:1.25rem}.pt-6{padding-top:1.5rem}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.align-middle{vertical-align:middle}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-2xl{font-size:1.5rem;line-height:2rem}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-normal{font-weight:400}.font-semibold{font-weight:600}.tabular-nums{--tw-numeric-spacing: tabular-nums;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.leading-none{line-height:1}.tracking-tight{letter-spacing:-.025em}.tracking-wide{letter-spacing:.025em}.tracking-widest{letter-spacing:.1em}.text-amber-100{--tw-text-opacity: 1;color:rgb(254 243 199 / var(--tw-text-opacity))}.text-amber-900{--tw-text-opacity: 1;color:rgb(120 53 15 / var(--tw-text-opacity))}.text-card-foreground{color:hsl(var(--card-foreground))}.text-destructive-foreground{color:hsl(var(--destructive-foreground))}.text-emerald-900{--tw-text-opacity: 1;color:rgb(6 78 59 / var(--tw-text-opacity))}.text-foreground{color:hsl(var(--foreground))}.text-gray-500{--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity))}.text-muted-foreground{color:hsl(var(--muted-foreground))}.text-muted-foreground\/80{color:hsl(var(--muted-foreground) / .8)}.text-popover-foreground{color:hsl(var(--popover-foreground))}.text-primary{color:hsl(var(--primary))}.text-primary-foreground{color:hsl(var(--primary-foreground))}.text-red-900{--tw-text-opacity: 1;color:rgb(127 29 29 / var(--tw-text-opacity))}.text-rose-600{--tw-text-opacity: 1;color:rgb(225 29 72 / var(--tw-text-opacity))}.text-secondary-foreground{color:hsl(var(--secondary-foreground))}.text-sky-900{--tw-text-opacity: 1;color:rgb(12 74 110 / var(--tw-text-opacity))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.text-zinc-900{--tw-text-opacity: 1;color:rgb(24 24 27 / var(--tw-text-opacity))}.underline-offset-4{text-underline-offset:4px}.caret-transparent{caret-color:transparent}.opacity-50{opacity:.5}.opacity-60{opacity:.6}.opacity-70{opacity:.7}.shadow-lg{--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-md{--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-none{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-sm{--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-xl{--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);--tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.outline{outline-style:solid}.ring-0{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.ring-2{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.ring-muted-foreground{--tw-ring-color: hsl(var(--muted-foreground))}.ring-offset-background{--tw-ring-offset-color: hsl(var(--background))}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop-blur-sm{--tw-backdrop-blur: blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.duration-200{transition-duration:.2s}@keyframes enter{0%{opacity:var(--tw-enter-opacity, 1);transform:translate3d(var(--tw-enter-translate-x, 0),var(--tw-enter-translate-y, 0),0) scale3d(var(--tw-enter-scale, 1),var(--tw-enter-scale, 1),var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity, 1);transform:translate3d(var(--tw-exit-translate-x, 0),var(--tw-exit-translate-y, 0),0) scale3d(var(--tw-exit-scale, 1),var(--tw-exit-scale, 1),var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))}}.duration-200{animation-duration:.2s}.paused{animation-play-state:paused}.file\:border-0::file-selector-button{border-width:0px}.file\:bg-transparent::file-selector-button{background-color:transparent}.file\:text-sm::file-selector-button{font-size:.875rem;line-height:1.25rem}.file\:font-medium::file-selector-button{font-weight:500}.placeholder\:text-muted-foreground::-moz-placeholder{color:hsl(var(--muted-foreground))}.placeholder\:text-muted-foreground::placeholder{color:hsl(var(--muted-foreground))}.after\:absolute:after{content:var(--tw-content);position:absolute}.after\:inset-y-0:after{content:var(--tw-content);top:0;bottom:0}.after\:left-1\/2:after{content:var(--tw-content);left:50%}.after\:w-1:after{content:var(--tw-content);width:.25rem}.after\:-translate-x-1\/2:after{content:var(--tw-content);--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.after\:bg-border:after{content:var(--tw-content);background-color:hsl(var(--border))}.hover\:bg-accent:hover{background-color:hsl(var(--accent))}.hover\:bg-amber-600\/80:hover{background-color:#d97706cc}.hover\:bg-amber-600\/90:hover{background-color:#d97706e6}.hover\:bg-destructive\/80:hover{background-color:hsl(var(--destructive) / .8)}.hover\:bg-destructive\/90:hover{background-color:hsl(var(--destructive) / .9)}.hover\:bg-muted\/50:hover{background-color:hsl(var(--muted) / .5)}.hover\:bg-primary\/80:hover{background-color:hsl(var(--primary) / .8)}.hover\:bg-primary\/90:hover{background-color:hsl(var(--primary) / .9)}.hover\:bg-secondary\/80:hover{background-color:hsl(var(--secondary) / .8)}.hover\:bg-transparent:hover{background-color:transparent}.hover\:stroke-destructive:hover{stroke:hsl(var(--destructive))}.hover\:text-accent-foreground:hover{color:hsl(var(--accent-foreground))}.hover\:underline:hover{text-decoration-line:underline}.hover\:opacity-100:hover{opacity:1}.focus\:bg-accent:focus{background-color:hsl(var(--accent))}.focus\:text-accent-foreground:focus{color:hsl(var(--accent-foreground))}.focus\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\:ring-ring:focus{--tw-ring-color: hsl(var(--ring))}.focus\:ring-offset-2:focus{--tw-ring-offset-width: 2px}.focus-visible\:outline-none:focus-visible{outline:2px solid transparent;outline-offset:2px}.focus-visible\:ring-1:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\:ring-2:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\:ring-ring:focus-visible{--tw-ring-color: hsl(var(--ring))}.focus-visible\:ring-offset-1:focus-visible{--tw-ring-offset-width: 1px}.focus-visible\:ring-offset-2:focus-visible{--tw-ring-offset-width: 2px}.focus-visible\:ring-offset-background:focus-visible{--tw-ring-offset-color: hsl(var(--background))}.disabled\:pointer-events-none:disabled{pointer-events:none}.disabled\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\:opacity-50:disabled{opacity:.5}.peer:disabled~.peer-disabled\:cursor-not-allowed{cursor:not-allowed}.peer:disabled~.peer-disabled\:opacity-70{opacity:.7}.aria-selected\:bg-accent[aria-selected=true]{background-color:hsl(var(--accent))}.aria-selected\:text-accent-foreground[aria-selected=true]{color:hsl(var(--accent-foreground))}.data-\[disabled\]\:pointer-events-none[data-disabled]{pointer-events:none}.data-\[panel-group-direction\=vertical\]\:h-px[data-panel-group-direction=vertical]{height:1px}.data-\[panel-group-direction\=vertical\]\:w-full[data-panel-group-direction=vertical]{width:100%}.data-\[side\=bottom\]\:translate-y-1[data-side=bottom]{--tw-translate-y: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[side\=left\]\:-translate-x-1[data-side=left]{--tw-translate-x: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[side\=right\]\:translate-x-1[data-side=right]{--tw-translate-x: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[side\=top\]\:-translate-y-1[data-side=top]{--tw-translate-y: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[state\=checked\]\:translate-x-5[data-state=checked]{--tw-translate-x: 1.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[state\=unchecked\]\:translate-x-0[data-state=unchecked]{--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[panel-group-direction\=vertical\]\:flex-col[data-panel-group-direction=vertical]{flex-direction:column}.data-\[state\=active\]\:bg-background[data-state=active]{background-color:hsl(var(--background))}.data-\[state\=checked\]\:bg-primary[data-state=checked]{background-color:hsl(var(--primary))}.data-\[state\=open\]\:bg-accent[data-state=open]{background-color:hsl(var(--accent))}.data-\[state\=open\]\:bg-muted[data-state=open],.data-\[state\=selected\]\:bg-muted[data-state=selected]{background-color:hsl(var(--muted))}.data-\[state\=unchecked\]\:bg-slate-400[data-state=unchecked]{--tw-bg-opacity: 1;background-color:rgb(148 163 184 / var(--tw-bg-opacity))}.data-\[state\=active\]\:text-foreground[data-state=active]{color:hsl(var(--foreground))}.data-\[state\=open\]\:text-muted-foreground[data-state=open]{color:hsl(var(--muted-foreground))}.data-\[disabled\]\:opacity-50[data-disabled]{opacity:.5}.data-\[state\=active\]\:shadow-sm[data-state=active]{--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.data-\[state\=open\]\:animate-in[data-state=open]{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.data-\[state\=closed\]\:animate-out[data-state=closed]{animation-name:exit;animation-duration:.15s;--tw-exit-opacity: initial;--tw-exit-scale: initial;--tw-exit-rotate: initial;--tw-exit-translate-x: initial;--tw-exit-translate-y: initial}.data-\[state\=closed\]\:fade-out-0[data-state=closed]{--tw-exit-opacity: 0}.data-\[state\=open\]\:fade-in-0[data-state=open]{--tw-enter-opacity: 0}.data-\[state\=closed\]\:zoom-out-95[data-state=closed]{--tw-exit-scale: .95}.data-\[state\=open\]\:zoom-in-95[data-state=open]{--tw-enter-scale: .95}.data-\[side\=bottom\]\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y: -.5rem}.data-\[side\=left\]\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x: .5rem}.data-\[side\=right\]\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x: -.5rem}.data-\[side\=top\]\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y: .5rem}.data-\[state\=closed\]\:slide-out-to-left-1\/2[data-state=closed]{--tw-exit-translate-x: -50%}.data-\[state\=closed\]\:slide-out-to-top-\[48\%\][data-state=closed]{--tw-exit-translate-y: -48%}.data-\[state\=open\]\:slide-in-from-left-1\/2[data-state=open]{--tw-enter-translate-x: -50%}.data-\[state\=open\]\:slide-in-from-top-\[48\%\][data-state=open]{--tw-enter-translate-y: -48%}.data-\[panel-group-direction\=vertical\]\:after\:left-0[data-panel-group-direction=vertical]:after{content:var(--tw-content);left:0}.data-\[panel-group-direction\=vertical\]\:after\:h-1[data-panel-group-direction=vertical]:after{content:var(--tw-content);height:.25rem}.data-\[panel-group-direction\=vertical\]\:after\:w-full[data-panel-group-direction=vertical]:after{content:var(--tw-content);width:100%}.data-\[panel-group-direction\=vertical\]\:after\:-translate-y-1\/2[data-panel-group-direction=vertical]:after{content:var(--tw-content);--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\[panel-group-direction\=vertical\]\:after\:translate-x-0[data-panel-group-direction=vertical]:after{content:var(--tw-content);--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.dark\:-rotate-90:is(.dark *){--tw-rotate: -90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.dark\:rotate-0:is(.dark *){--tw-rotate: 0deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.dark\:scale-0:is(.dark *){--tw-scale-x: 0;--tw-scale-y: 0;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.dark\:scale-100:is(.dark *){--tw-scale-x: 1;--tw-scale-y: 1;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.dark\:border-amber-500\/30:is(.dark *){border-color:#f59e0b4d}.dark\:border-emerald-500\/30:is(.dark *){border-color:#10b9814d}.dark\:border-red-500\/30:is(.dark *){border-color:#ef44444d}.dark\:border-sky-500\/30:is(.dark *){border-color:#0ea5e94d}.dark\:border-zinc-500\/30:is(.dark *){border-color:#71717a4d}.dark\:bg-amber-500\/10:is(.dark *){background-color:#f59e0b1a}.dark\:bg-emerald-500\/10:is(.dark *){background-color:#10b9811a}.dark\:bg-red-500\/10:is(.dark *){background-color:#ef44441a}.dark\:bg-sky-500\/10:is(.dark *){background-color:#0ea5e91a}.dark\:bg-zinc-500\/10:is(.dark *){background-color:#71717a1a}.dark\:text-amber-200:is(.dark *){--tw-text-opacity: 1;color:rgb(253 230 138 / var(--tw-text-opacity))}.dark\:text-emerald-200:is(.dark *){--tw-text-opacity: 1;color:rgb(167 243 208 / var(--tw-text-opacity))}.dark\:text-red-200:is(.dark *){--tw-text-opacity: 1;color:rgb(254 202 202 / var(--tw-text-opacity))}.dark\:text-sky-200:is(.dark *){--tw-text-opacity: 1;color:rgb(186 230 253 / var(--tw-text-opacity))}.dark\:text-zinc-300:is(.dark *){--tw-text-opacity: 1;color:rgb(212 212 216 / var(--tw-text-opacity))}@media (min-width: 640px){.sm\:m-4{margin:1rem}.sm\:inline{display:inline}.sm\:max-h-\[600px\]{max-height:600px}.sm\:max-w-\[650px\]{max-width:650px}.sm\:max-w-\[740px\]{max-width:740px}.sm\:max-w-\[950px\]{max-width:950px}.sm\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.sm\:grid-cols-\[10rem_1fr_10rem\]{grid-template-columns:10rem 1fr 10rem}.sm\:flex-row{flex-direction:row}.sm\:justify-end{justify-content:flex-end}.sm\:space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.sm\:rounded-lg{border-radius:var(--radius)}.sm\:text-left{text-align:left}}@media (min-width: 768px){.md\:inline{display:inline}.md\:flex{display:flex}.md\:w-64{width:16rem}.md\:w-full{width:100%}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}.md\:gap-8{gap:2rem}}@media (min-width: 1024px){.lg\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}}@media (min-width: 1280px){.xl\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}.\[\&\:has\(\[role\=checkbox\]\)\]\:pr-0:has([role=checkbox]){padding-right:0}.\[\&\>\*\]\:p-4>*{padding:1rem}.\[\&\>\*\]\:px-4>*{padding-left:1rem;padding-right:1rem}.\[\&\>\*\]\:py-2>*{padding-top:.5rem;padding-bottom:.5rem}.\[\&\>div\[style\]\]\:\!block>div[style]{display:block!important}.\[\&\>div\[style\]\]\:h-full>div[style]{height:100%}.\[\&\>span\]\:line-clamp-1>span{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.\[\&\>svg\+div\]\:translate-y-\[-3px\]>svg+div{--tw-translate-y: -3px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\[\&\>svg\]\:absolute>svg{position:absolute}.\[\&\>svg\]\:left-4>svg{left:1rem}.\[\&\>svg\]\:top-4>svg{top:1rem}.\[\&\>svg\]\:h-2\.5>svg{height:.625rem}.\[\&\>svg\]\:h-3>svg{height:.75rem}.\[\&\>svg\]\:w-2\.5>svg{width:.625rem}.\[\&\>svg\]\:w-3>svg{width:.75rem}.\[\&\>svg\]\:fill-rose-600>svg{fill:#e11d48}.\[\&\>svg\]\:text-amber-500>svg{--tw-text-opacity: 1;color:rgb(245 158 11 / var(--tw-text-opacity))}.\[\&\>svg\]\:text-emerald-600>svg{--tw-text-opacity: 1;color:rgb(5 150 105 / var(--tw-text-opacity))}.\[\&\>svg\]\:text-foreground>svg{color:hsl(var(--foreground))}.\[\&\>svg\]\:text-muted-foreground>svg{color:hsl(var(--muted-foreground))}.\[\&\>svg\]\:text-red-600>svg{--tw-text-opacity: 1;color:rgb(220 38 38 / var(--tw-text-opacity))}.\[\&\>svg\]\:text-sky-500>svg{--tw-text-opacity: 1;color:rgb(14 165 233 / var(--tw-text-opacity))}.\[\&\>svg\]\:text-zinc-400>svg{--tw-text-opacity: 1;color:rgb(161 161 170 / var(--tw-text-opacity))}.hover\:\[\&\>svg\]\:fill-rose-700>svg:hover{fill:#be123c}.dark\:\[\&\>svg\]\:text-emerald-400\/80>svg:is(.dark *){color:#34d399cc}.dark\:\[\&\>svg\]\:text-red-400\/80>svg:is(.dark *){color:#f87171cc}.dark\:\[\&\>svg\]\:text-zinc-300>svg:is(.dark *){--tw-text-opacity: 1;color:rgb(212 212 216 / var(--tw-text-opacity))}.\[\&\>svg\~\*\]\:pl-7>svg~*{padding-left:1.75rem}.\[\&\>tr\]\:last\:border-b-0:last-child>tr{border-bottom-width:0px}.\[\&\[data-panel-group-direction\=vertical\]\>div\]\:rotate-90[data-panel-group-direction=vertical]>div{--tw-rotate: 90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\[\&_\.recharts-cartesian-axis-tick_text\]\:fill-muted-foreground .recharts-cartesian-axis-tick text{fill:hsl(var(--muted-foreground))}.\[\&_\.recharts-cartesian-grid_line\[stroke\=\'\#ccc\'\]\]\:stroke-border\/50 .recharts-cartesian-grid line[stroke="#ccc"]{stroke:hsl(var(--border) / .5)}.\[\&_\.recharts-curve\.recharts-tooltip-cursor\]\:stroke-border .recharts-curve.recharts-tooltip-cursor{stroke:hsl(var(--border))}.\[\&_\.recharts-dot\[stroke\=\'\#fff\'\]\]\:stroke-transparent .recharts-dot[stroke="#fff"]{stroke:transparent}.\[\&_\.recharts-layer\]\:outline-none .recharts-layer{outline:2px solid transparent;outline-offset:2px}.\[\&_\.recharts-polar-grid_\[stroke\=\'\#ccc\'\]\]\:stroke-border .recharts-polar-grid [stroke="#ccc"]{stroke:hsl(var(--border))}.\[\&_\.recharts-radial-bar-background-sector\]\:fill-muted .recharts-radial-bar-background-sector,.\[\&_\.recharts-rectangle\.recharts-tooltip-cursor\]\:fill-muted .recharts-rectangle.recharts-tooltip-cursor{fill:hsl(var(--muted))}.\[\&_\.recharts-reference-line_\[stroke\=\'\#ccc\'\]\]\:stroke-border .recharts-reference-line [stroke="#ccc"]{stroke:hsl(var(--border))}.\[\&_\.recharts-sector\[stroke\=\'\#fff\'\]\]\:stroke-transparent .recharts-sector[stroke="#fff"]{stroke:transparent}.\[\&_\.recharts-sector\]\:outline-none .recharts-sector,.\[\&_\.recharts-surface\]\:outline-none .recharts-surface{outline:2px solid transparent;outline-offset:2px}.\[\&_\[cmdk-group-heading\]\]\:px-2 [cmdk-group-heading]{padding-left:.5rem;padding-right:.5rem}.\[\&_\[cmdk-group-heading\]\]\:py-1\.5 [cmdk-group-heading]{padding-top:.375rem;padding-bottom:.375rem}.\[\&_\[cmdk-group-heading\]\]\:text-xs [cmdk-group-heading]{font-size:.75rem;line-height:1rem}.\[\&_\[cmdk-group-heading\]\]\:font-medium [cmdk-group-heading]{font-weight:500}.\[\&_\[cmdk-group-heading\]\]\:text-muted-foreground [cmdk-group-heading]{color:hsl(var(--muted-foreground))}.\[\&_\[cmdk-group\]\:not\(\[hidden\]\)_\~\[cmdk-group\]\]\:pt-0 [cmdk-group]:not([hidden])~[cmdk-group]{padding-top:0}.\[\&_\[cmdk-group\]\]\:px-2 [cmdk-group]{padding-left:.5rem;padding-right:.5rem}.\[\&_\[cmdk-input-wrapper\]_svg\]\:h-5 [cmdk-input-wrapper] svg{height:1.25rem}.\[\&_\[cmdk-input-wrapper\]_svg\]\:w-5 [cmdk-input-wrapper] svg{width:1.25rem}.\[\&_\[cmdk-input\]\]\:h-12 [cmdk-input]{height:3rem}.\[\&_\[cmdk-item\]\]\:px-2 [cmdk-item]{padding-left:.5rem;padding-right:.5rem}.\[\&_\[cmdk-item\]\]\:py-3 [cmdk-item]{padding-top:.75rem;padding-bottom:.75rem}.\[\&_\[cmdk-item\]_svg\]\:h-5 [cmdk-item] svg{height:1.25rem}.\[\&_\[cmdk-item\]_svg\]\:w-5 [cmdk-item] svg{width:1.25rem}.\[\&_p\]\:leading-relaxed p{line-height:1.625}.\[\&_strong\]\:text-foreground strong{color:hsl(var(--foreground))}.\[\&_tr\:last-child\]\:border-0 tr:last-child{border-width:0px}.\[\&_tr\]\:border-b tr{border-bottom-width:1px}:root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: #e74c3c;--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-toast-width: 320px;--toastify-toast-offset: 16px;--toastify-toast-top: max(var(--toastify-toast-offset), env(safe-area-inset-top));--toastify-toast-right: max(var(--toastify-toast-offset), env(safe-area-inset-right));--toastify-toast-left: max(var(--toastify-toast-offset), env(safe-area-inset-left));--toastify-toast-bottom: max(var(--toastify-toast-offset), env(safe-area-inset-bottom));--toastify-toast-background: #fff;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-toast-bd-radius: 6px;--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient( to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55 );--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error);--toastify-color-progress-bgo: .2}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;padding:4px;width:var(--toastify-toast-width);box-sizing:border-box;color:#fff}.Toastify__toast-container--top-left{top:var(--toastify-toast-top);left:var(--toastify-toast-left)}.Toastify__toast-container--top-center{top:var(--toastify-toast-top);left:50%;transform:translate(-50%)}.Toastify__toast-container--top-right{top:var(--toastify-toast-top);right:var(--toastify-toast-right)}.Toastify__toast-container--bottom-left{bottom:var(--toastify-toast-bottom);left:var(--toastify-toast-left)}.Toastify__toast-container--bottom-center{bottom:var(--toastify-toast-bottom);left:50%;transform:translate(-50%)}.Toastify__toast-container--bottom-right{bottom:var(--toastify-toast-bottom);right:var(--toastify-toast-right)}@media only screen and (max-width : 480px){.Toastify__toast-container{width:100vw;padding:0;left:env(safe-area-inset-left);margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:env(safe-area-inset-top);transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:env(safe-area-inset-bottom);transform:translate(0)}.Toastify__toast-container--rtl{right:env(safe-area-inset-right);left:initial}}.Toastify__toast{--y: 0;position:relative;touch-action:none;min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:8px;border-radius:var(--toastify-toast-bd-radius);box-shadow:0 4px 12px #0000001a;display:flex;justify-content:space-between;max-height:var(--toastify-toast-max-height);font-family:var(--toastify-font-family);cursor:default;direction:ltr;z-index:0;overflow:hidden}.Toastify__toast--stacked{position:absolute;width:100%;transform:translate3d(0,var(--y),0) scale(var(--s));transition:transform .3s}.Toastify__toast--stacked[data-collapsed] .Toastify__toast-body,.Toastify__toast--stacked[data-collapsed] .Toastify__close-button{transition:opacity .1s}.Toastify__toast--stacked[data-collapsed=false]{overflow:visible}.Toastify__toast--stacked[data-collapsed=true]:not(:last-child)>*{opacity:0}.Toastify__toast--stacked:after{content:"";position:absolute;left:0;right:0;height:calc(var(--g) * 1px);bottom:100%}.Toastify__toast--stacked[data-pos=top]{top:0}.Toastify__toast--stacked[data-pos=bot]{bottom:0}.Toastify__toast--stacked[data-pos=bot].Toastify__toast--stacked:before{transform-origin:top}.Toastify__toast--stacked[data-pos=top].Toastify__toast--stacked:before{transform-origin:bottom}.Toastify__toast--stacked:before{content:"";position:absolute;left:0;right:0;bottom:0;height:100%;transform:scaleY(3);z-index:-1}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-body{margin:auto 0;flex:1 1 auto;padding:6px;display:flex;align-items:center}.Toastify__toast-body>div:last-child{word-break:break-word;flex:1}.Toastify__toast-icon{margin-inline-end:10px;width:20px;flex-shrink:0;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.5s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}@media only screen and (max-width : 480px){.Toastify__toast{margin-bottom:0;border-radius:0}}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;align-self:flex-start;z-index:1}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:100%;z-index:var(--toastify-z-index);opacity:.7;transform-origin:left;border-bottom-left-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right;border-bottom-left-radius:initial;border-bottom-right-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp{position:absolute;bottom:0;left:0;width:100%;height:5px;border-bottom-left-radius:var(--toastify-toast-bd-radius)}.Toastify__progress-bar--wrp[data-hidden=true]{opacity:0}.Toastify__progress-bar--bg{opacity:var(--toastify-color-progress-bgo);width:100%;height:100%}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,var(--y),0)}to{opacity:0;transform:translate3d(2000px,var(--y),0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,var(--y),0)}to{opacity:0;transform:translate3d(-2000px,var(--y),0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,calc(var(--y) - 10px),0)}40%,45%{opacity:1;transform:translate3d(0,calc(var(--y) + 20px),0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:translate3d(0,var(--y),0) scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:translate3d(0,var(--y),0) perspective(400px)}30%{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(-20deg);opacity:1}to{transform:translate3d(0,var(--y),0) perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translate3d(0,var(--y),0)}}@keyframes Toastify__slideOutRight{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(110%,var(--y),0)}}@keyframes Toastify__slideOutLeft{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(-110%,var(--y),0)}}@keyframes Toastify__slideOutDown{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translate3d(0,var(--y),0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp;animation-timing-function:ease-in;animation-duration:.3s}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown;animation-timing-function:ease-in;animation-duration:.3s}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.tabs-chat{background-color:transparent;width:100%;border-radius:0}.chat-item{display:flex;padding:10px;cursor:pointer;background-color:hsl(var(--background))}.chat-item:hover,.chat-item.active{background-color:#2f2f2f}.bubble{border-radius:16px;padding:12px;word-wrap:break-word}.bubble-right .bubble{background-color:#0a0a0a;text-align:right;max-width:100%}.bubble-left .bubble{background-color:#1b1b1b;max-width:100%}.bubble-right{align-self:flex-end;display:flex;justify-content:flex-end;width:80%}.bubble-left{align-self:flex-start;display:flex;justify-content:flex-start;width:80%}.input-message textarea{background-color:#2f2f2f;padding-left:48px}.input-message textarea:focus{outline:none;border:none;box-shadow:none}.message-container{flex:1;overflow-y:auto;max-height:calc(100vh - 110px);padding-top:50px}




================================================
FILE: prisma/mysql-schema.prisma
================================================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_CONNECTION_URI")
}

enum InstanceConnectionStatus {
  open
  close
  connecting
}

enum DeviceMessage {
  ios
  android
  web
  unknown
  desktop
}

enum SessionStatus {
  opened
  closed
  paused
}

enum TriggerType {
  all
  keyword
  none
  advanced
}

enum TriggerOperator {
  contains
  equals
  startsWith
  endsWith
  regex
}

enum OpenaiBotType {
  assistant
  chatCompletion
}

enum DifyBotType {
  chatBot
  textGenerator
  agent
  workflow
}

model Instance {
  id                      String                   @id @default(cuid())
  name                    String                   @unique @db.VarChar(255)
  connectionStatus        InstanceConnectionStatus @default(open)
  ownerJid                String?                  @db.VarChar(100)
  profileName             String?                  @db.VarChar(100)
  profilePicUrl           String?                  @db.VarChar(500)
  integration             String?                  @db.VarChar(100)
  number                  String?                  @db.VarChar(100)
  businessId              String?                  @db.VarChar(100)
  token                   String?                  @db.VarChar(255)
  clientName              String?                  @db.VarChar(100)
  disconnectionReasonCode Int?                     @db.Int
  disconnectionObject     Json?                    @db.Json
  disconnectionAt         DateTime?                @db.Timestamp
  createdAt               DateTime?                @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt               DateTime?                @updatedAt @db.Timestamp
  Chat                    Chat[]
  Contact                 Contact[]
  Message                 Message[]
  Webhook                 Webhook?
  Chatwoot                Chatwoot?
  Label                   Label[]
  Proxy                   Proxy?
  Setting                 Setting?
  Rabbitmq                Rabbitmq?
  Sqs                     Sqs?
  Websocket               Websocket?
  Typebot                 Typebot[]
  Session                 Session?
  MessageUpdate           MessageUpdate[]
  TypebotSetting          TypebotSetting?
  Media                   Media[]
  OpenaiCreds             OpenaiCreds[]
  OpenaiBot               OpenaiBot[]
  OpenaiSetting           OpenaiSetting?
  Template                Template[]
  Dify                    Dify[]
  DifySetting             DifySetting?
  integrationSessions     IntegrationSession[]
  EvolutionBot            EvolutionBot[]
  EvolutionBotSetting     EvolutionBotSetting?
  Flowise                 Flowise[]
  FlowiseSetting          FlowiseSetting?
  Pusher                  Pusher?
}

model Session {
  id        String   @id @default(cuid())
  sessionId String   @unique
  creds     String?  @db.Text
  createdAt DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  Instance  Instance @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}

model Chat {
  id         String    @id @default(cuid())
  remoteJid  String    @db.VarChar(100)
  name       String?   @db.VarChar(100)
  labels     Json?     @db.Json
  createdAt  DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt  DateTime? @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String
  unreadMessages Int       @default(0)
  @@index([instanceId])
  @@index([remoteJid])
  @@unique([instanceId, remoteJid])
}

model Contact {
  id            String    @id @default(cuid())
  remoteJid     String    @db.VarChar(100)
  pushName      String?   @db.VarChar(100)
  profilePicUrl String?   @db.VarChar(500)
  createdAt     DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt     DateTime? @updatedAt @db.Timestamp
  Instance      Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId    String

  @@unique([remoteJid, instanceId])
  @@index([remoteJid])
  @@index([instanceId])
}

model Message {
  id                           String          @id @default(cuid())
  key                          Json            @db.Json
  pushName                     String?         @db.VarChar(100)
  participant                  String?         @db.VarChar(100)
  messageType                  String          @db.VarChar(100)
  message                      Json            @db.Json
  contextInfo                  Json?           @db.Json
  source                       DeviceMessage
  messageTimestamp             Int             @db.Int
  chatwootMessageId            Int?            @db.Int
  chatwootInboxId              Int?            @db.Int
  chatwootConversationId       Int?            @db.Int
  chatwootContactInboxSourceId String?         @db.VarChar(100)
  chatwootIsRead               Boolean?        @default(false)
  Instance                     Instance        @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId                   String
  typebotSessionId             String?
  MessageUpdate                MessageUpdate[]
  Media                        Media?
  webhookUrl                   String?         @db.VarChar(500)
  status                       String?         @db.VarChar(30)

  sessionId String?
  session   IntegrationSession? @relation(fields: [sessionId], references: [id])
  @@index([instanceId])
}

model MessageUpdate {
  id          String   @id @default(cuid())
  keyId       String   @db.VarChar(100)
  remoteJid   String   @db.VarChar(100)
  fromMe      Boolean
  participant String?  @db.VarChar(100)
  pollUpdates Json?    @db.Json
  status      String   @db.VarChar(30)
  Message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId   String
  Instance    Instance @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId  String
  @@index([instanceId])
  @@index([messageId])
}

model Webhook {
  id              String    @id @default(cuid())
  url             String    @db.VarChar(500)
  headers         Json?     @db.Json
  enabled         Boolean?  @default(true)
  events          Json?     @db.Json
  webhookByEvents Boolean?  @default(false)
  webhookBase64   Boolean?  @default(false)
  createdAt       DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt       DateTime  @updatedAt @db.Timestamp
  Instance        Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String    @unique
  @@index([instanceId])
}

model Chatwoot {
  id                      String    @id @default(cuid())
  enabled                 Boolean?  @default(true)
  accountId               String?   @db.VarChar(100)
  token                   String?   @db.VarChar(100)
  url                     String?   @db.VarChar(500)
  nameInbox               String?   @db.VarChar(100)
  signMsg                 Boolean?  @default(false)
  signDelimiter           String?   @db.VarChar(100)
  number                  String?   @db.VarChar(100)
  reopenConversation      Boolean?  @default(false)
  conversationPending     Boolean?  @default(false)
  mergeBrazilContacts     Boolean?  @default(false)
  importContacts          Boolean?  @default(false)
  importMessages          Boolean?  @default(false)
  daysLimitImportMessages Int?      @db.Int
  organization            String?   @db.VarChar(100)
  logo                    String?   @db.VarChar(500)
  ignoreJids              Json?
  createdAt               DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt               DateTime  @updatedAt @db.Timestamp
  Instance                Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId              String    @unique
}

model Label {
  id           String    @id @default(cuid())
  labelId      String?   @db.VarChar(100)
  name         String    @db.VarChar(100)
  color        String    @db.VarChar(100)
  predefinedId String?   @db.VarChar(100)
  createdAt    DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt    DateTime  @updatedAt @db.Timestamp
  Instance     Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId   String
}

model Proxy {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false)
  host       String    @db.VarChar(100)
  port       String    @db.VarChar(100)
  protocol   String    @db.VarChar(100)
  username   String    @db.VarChar(100)
  password   String    @db.VarChar(100)
  createdAt  DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Setting {
  id              String    @id @default(cuid())
  rejectCall      Boolean   @default(false)
  msgCall         String?   @db.VarChar(100)
  groupsIgnore    Boolean   @default(false)
  alwaysOnline    Boolean   @default(false)
  readMessages    Boolean   @default(false)
  readStatus      Boolean   @default(false)
  syncFullHistory Boolean   @default(false)
  wavoipToken     String?   @db.VarChar(100)
  createdAt       DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt       DateTime  @updatedAt @db.Timestamp
  Instance        Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String    @unique
  @@index([instanceId])
}

model Rabbitmq {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false)
  events     Json      @db.Json
  createdAt  DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Sqs {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false)
  events     Json      @db.Json
  createdAt  DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Websocket {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false)
  events     Json      @db.Json
  createdAt  DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Pusher {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false)
  appId      String    @db.VarChar(100)
  key        String    @db.VarChar(100)
  secret     String    @db.VarChar(100)
  cluster    String    @db.VarChar(100)
  useTLS     Boolean   @default(false)
  events     Json      @db.Json
  createdAt  DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Typebot {
  id              String           @id @default(cuid())
  enabled         Boolean          @default(true)
  description     String?          @db.VarChar(255)
  url             String           @db.VarChar(500)
  typebot         String           @db.VarChar(100)
  expire          Int?             @default(0) @db.Int
  keywordFinish   String?          @db.VarChar(100)
  delayMessage    Int?             @db.Int
  unknownMessage  String?          @db.VarChar(100)
  listeningFromMe Boolean?         @default(false)
  stopBotFromMe   Boolean?         @default(false)
  keepOpen        Boolean?         @default(false)
  debounceTime    Int?             @db.Int
  createdAt       DateTime?        @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt       DateTime?        @updatedAt @db.Timestamp
  ignoreJids      Json?
  triggerType     TriggerType?
  triggerOperator TriggerOperator?
  triggerValue    String?
  Instance        Instance         @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String
  TypebotSetting  TypebotSetting[]
}

model TypebotSetting {
  id                String    @id @default(cuid())
  expire            Int?      @default(0) @db.Int
  keywordFinish     String?   @db.VarChar(100)
  delayMessage      Int?      @db.Int
  unknownMessage    String?   @db.VarChar(100)
  listeningFromMe   Boolean?  @default(false)
  stopBotFromMe     Boolean?  @default(false)
  keepOpen          Boolean?  @default(false)
  debounceTime      Int?      @db.Int
  typebotIdFallback String?   @db.VarChar(100)
  ignoreJids        Json?
  createdAt         DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt         DateTime  @updatedAt @db.Timestamp
  Fallback          Typebot?  @relation(fields: [typebotIdFallback], references: [id])
  Instance          Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId        String    @unique
}

model IntegrationSession {
  id         String        @id @default(cuid())
  sessionId  String        @db.VarChar(255)
  remoteJid  String        @db.VarChar(100)
  pushName   String?
  status     SessionStatus
  awaitUser  Boolean       @default(false)
  context    Json?
  type       String?       @db.VarChar(100)
  createdAt  DateTime?     @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt  DateTime      @updatedAt @db.Timestamp
  Message    Message[]
  Instance   Instance      @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String
  parameters Json?

  botId String?
}

model Media {
  id         String    @id @default(cuid())
  fileName   String    @unique @db.VarChar(500)
  type       String    @db.VarChar(100)
  mimetype   String    @db.VarChar(100)
  createdAt  DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  Message    Message   @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId  String    @unique
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String
}

model OpenaiCreds {
  id              String         @id @default(cuid())
  name            String?        @unique @db.VarChar(255)
  apiKey          String?        @unique @db.VarChar(255)
  createdAt       DateTime?      @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt       DateTime       @updatedAt @db.Timestamp
  Instance        Instance       @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String
  OpenaiAssistant OpenaiBot[]
  OpenaiSetting   OpenaiSetting?
}

model OpenaiBot {
  id                String           @id @default(cuid())
  enabled           Boolean          @default(true)
  description       String?          @db.VarChar(255)
  botType           OpenaiBotType
  assistantId       String?          @db.VarChar(255)
  functionUrl       String?          @db.VarChar(500)
  model             String?          @db.VarChar(100)
  systemMessages    Json?            @db.Json
  assistantMessages Json?            @db.Json
  userMessages      Json?            @db.Json
  maxTokens         Int?             @db.Int
  expire            Int?             @default(0) @db.Int
  keywordFinish     String?          @db.VarChar(100)
  delayMessage      Int?             @db.Int
  unknownMessage    String?          @db.VarChar(100)
  listeningFromMe   Boolean?         @default(false)
  stopBotFromMe     Boolean?         @default(false)
  keepOpen          Boolean?         @default(false)
  debounceTime      Int?             @db.Int
  ignoreJids        Json?
  splitMessages     Boolean?         @default(false)
  timePerChar       Int?             @default(50) @db.Int
  triggerType       TriggerType?
  triggerOperator   TriggerOperator?
  triggerValue      String?
  createdAt         DateTime?        @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt         DateTime         @updatedAt @db.Timestamp
  OpenaiCreds       OpenaiCreds      @relation(fields: [openaiCredsId], references: [id], onDelete: Cascade)
  openaiCredsId     String
  Instance          Instance         @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId        String
  OpenaiSetting     OpenaiSetting[]
}

model OpenaiSetting {
  id               String       @id @default(cuid())
  expire           Int?         @default(0) @db.Int
  keywordFinish    String?      @db.VarChar(100)
  delayMessage     Int?         @db.Int
  unknownMessage   String?      @db.VarChar(100)
  listeningFromMe  Boolean?     @default(false)
  stopBotFromMe    Boolean?     @default(false)
  keepOpen         Boolean?     @default(false)
  debounceTime     Int?         @db.Int
  ignoreJids       Json?
  splitMessages    Boolean?     @default(false)
  timePerChar      Int?         @default(50) @db.Int
  speechToText     Boolean?     @default(false)
  createdAt        DateTime?    @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt        DateTime     @updatedAt @db.Timestamp
  OpenaiCreds      OpenaiCreds? @relation(fields: [openaiCredsId], references: [id])
  openaiCredsId    String       @unique
  Fallback         OpenaiBot?   @relation(fields: [openaiIdFallback], references: [id])
  openaiIdFallback String?      @db.VarChar(100)
  Instance         Instance     @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId       String       @unique
}

model Template {
  id         String    @id @default(cuid())
  templateId String    @unique @db.VarChar(255)
  name       String    @unique @db.VarChar(255)
  template   Json      @db.Json
  webhookUrl String?   @db.VarChar(500)
  createdAt  DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String
}

model Dify {
  id              String           @id @default(cuid())
  enabled         Boolean          @default(true)
  description     String?          @db.VarChar(255)
  botType         DifyBotType
  apiUrl          String?          @db.VarChar(255)
  apiKey          String?          @db.VarChar(255)
  expire          Int?             @default(0) @db.Int
  keywordFinish   String?          @db.VarChar(100)
  delayMessage    Int?             @db.Int
  unknownMessage  String?          @db.VarChar(100)
  listeningFromMe Boolean?         @default(false)
  stopBotFromMe   Boolean?         @default(false)
  keepOpen        Boolean?         @default(false)
  debounceTime    Int?             @db.Int
  ignoreJids      Json?
  splitMessages   Boolean?         @default(false)
  timePerChar     Int?             @default(50) @db.Int
  triggerType     TriggerType?
  triggerOperator TriggerOperator?
  triggerValue    String?
  createdAt       DateTime?        @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt       DateTime         @updatedAt @db.Timestamp
  Instance        Instance         @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String
  DifySetting     DifySetting[]
}

model DifySetting {
  id              String    @id @default(cuid())
  expire          Int?      @default(0) @db.Int
  keywordFinish   String?   @db.VarChar(100)
  delayMessage    Int?      @db.Int
  unknownMessage  String?   @db.VarChar(100)
  listeningFromMe Boolean?  @default(false)
  stopBotFromMe   Boolean?  @default(false)
  keepOpen        Boolean?  @default(false)
  debounceTime    Int?      @db.Int
  ignoreJids      Json?
  splitMessages   Boolean?  @default(false)
  timePerChar     Int?      @default(50) @db.Int
  createdAt       DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt       DateTime  @updatedAt @db.Timestamp
  Fallback        Dify?     @relation(fields: [difyIdFallback], references: [id])
  difyIdFallback  String?   @db.VarChar(100)
  Instance        Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String    @unique
}

model EvolutionBot {
  id                  String                @id @default(cuid())
  enabled             Boolean               @default(true)
  description         String?               @db.VarChar(255)
  apiUrl              String?               @db.VarChar(255)
  apiKey              String?               @db.VarChar(255)
  expire              Int?                  @default(0) @db.Int
  keywordFinish       String?               @db.VarChar(100)
  delayMessage        Int?                  @db.Int
  unknownMessage      String?               @db.VarChar(100)
  listeningFromMe     Boolean?              @default(false)
  stopBotFromMe       Boolean?              @default(false)
  keepOpen            Boolean?              @default(false)
  debounceTime        Int?                  @db.Int
  ignoreJids          Json?
  splitMessages       Boolean?              @default(false)
  timePerChar         Int?                  @default(50) @db.Int
  triggerType         TriggerType?
  triggerOperator     TriggerOperator?
  triggerValue        String?
  createdAt           DateTime?             @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt           DateTime              @updatedAt @db.Timestamp
  Instance            Instance              @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId          String
  EvolutionBotSetting EvolutionBotSetting[]
}

model EvolutionBotSetting {
  id              String        @id @default(cuid())
  expire          Int?          @default(0) @db.Int
  keywordFinish   String?       @db.VarChar(100)
  delayMessage    Int?          @db.Int
  unknownMessage  String?       @db.VarChar(100)
  listeningFromMe Boolean?      @default(false)
  stopBotFromMe   Boolean?      @default(false)
  keepOpen        Boolean?      @default(false)
  debounceTime    Int?          @db.Int
  ignoreJids      Json?
  splitMessages   Boolean?      @default(false)
  timePerChar     Int?          @default(50) @db.Int
  createdAt       DateTime?     @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt       DateTime      @updatedAt @db.Timestamp
  Fallback        EvolutionBot? @relation(fields: [botIdFallback], references: [id])
  botIdFallback   String?       @db.VarChar(100)
  Instance        Instance      @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String        @unique
}

model Flowise {
  id              String           @id @default(cuid())
  enabled         Boolean          @default(true)
  description     String?          @db.VarChar(255)
  apiUrl          String?          @db.VarChar(255)
  apiKey          String?          @db.VarChar(255)
  expire          Int?             @default(0) @db.Int
  keywordFinish   String?          @db.VarChar(100)
  delayMessage    Int?             @db.Int
  unknownMessage  String?          @db.VarChar(100)
  listeningFromMe Boolean?         @default(false)
  stopBotFromMe   Boolean?         @default(false)
  keepOpen        Boolean?         @default(false)
  debounceTime    Int?             @db.Int
  ignoreJids      Json?
  splitMessages   Boolean?         @default(false)
  timePerChar     Int?             @default(50) @db.Int
  triggerType     TriggerType?
  triggerOperator TriggerOperator?
  triggerValue    String?
  createdAt       DateTime?        @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt       DateTime         @updatedAt @db.Timestamp
  Instance        Instance         @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String
  FlowiseSetting  FlowiseSetting[]
}

model FlowiseSetting {
  id                String    @id @default(cuid())
  expire            Int?      @default(0) @db.Int
  keywordFinish     String?   @db.VarChar(100)
  delayMessage      Int?      @db.Int
  unknownMessage    String?   @db.VarChar(100)
  listeningFromMe   Boolean?  @default(false)
  stopBotFromMe     Boolean?  @default(false)
  keepOpen          Boolean?  @default(false)
  debounceTime      Int?      @db.Int
  ignoreJids        Json?
  splitMessages     Boolean?  @default(false)
  timePerChar       Int?      @default(50) @db.Int
  createdAt         DateTime? @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt         DateTime  @updatedAt @db.Timestamp
  Fallback          Flowise?  @relation(fields: [flowiseIdFallback], references: [id])
  flowiseIdFallback String?   @db.VarChar(100)
  Instance          Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId        String    @unique
}

model IsOnWhatsapp {
  id         String   @id @default(cuid())
  remoteJid  String   @unique @db.VarChar(100)
  jidOptions String
  createdAt  DateTime @default(dbgenerated("CURRENT_TIMESTAMP")) @db.Timestamp
  updatedAt  DateTime @updatedAt @db.Timestamp
}



================================================
FILE: prisma/postgresql-schema.prisma
================================================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_CONNECTION_URI")
}

enum InstanceConnectionStatus {
  open
  close
  connecting
}

enum DeviceMessage {
  ios
  android
  web
  unknown
  desktop
}

enum SessionStatus {
  opened
  closed
  paused
}

enum TriggerType {
  all
  keyword
  none
  advanced
}

enum TriggerOperator {
  contains
  equals
  startsWith
  endsWith
  regex
}

enum OpenaiBotType {
  assistant
  chatCompletion
}

enum DifyBotType {
  chatBot
  textGenerator
  agent
  workflow
}

model Instance {
  id                      String                   @id @default(cuid())
  name                    String                   @unique @db.VarChar(255)
  connectionStatus        InstanceConnectionStatus @default(open)
  ownerJid                String?                  @db.VarChar(100)
  profileName             String?                  @db.VarChar(100)
  profilePicUrl           String?                  @db.VarChar(500)
  integration             String?                  @db.VarChar(100)
  number                  String?                  @db.VarChar(100)
  businessId              String?                  @db.VarChar(100)
  token                   String?                  @db.VarChar(255)
  clientName              String?                  @db.VarChar(100)
  disconnectionReasonCode Int?                     @db.Integer
  disconnectionObject     Json?                    @db.JsonB
  disconnectionAt         DateTime?                @db.Timestamp
  createdAt               DateTime?                @default(now()) @db.Timestamp
  updatedAt               DateTime?                @updatedAt @db.Timestamp
  Chat                    Chat[]
  Contact                 Contact[]
  Message                 Message[]
  Webhook                 Webhook?
  Chatwoot                Chatwoot?
  Label                   Label[]
  Proxy                   Proxy?
  Setting                 Setting?
  Rabbitmq                Rabbitmq?
  Sqs                     Sqs?
  Websocket               Websocket?
  Typebot                 Typebot[]
  Session                 Session?
  MessageUpdate           MessageUpdate[]
  TypebotSetting          TypebotSetting?
  Media                   Media[]
  OpenaiCreds             OpenaiCreds[]
  OpenaiBot               OpenaiBot[]
  OpenaiSetting           OpenaiSetting?
  Template                Template[]
  Dify                    Dify[]
  DifySetting             DifySetting?
  integrationSessions     IntegrationSession[]
  EvolutionBot            EvolutionBot[]
  EvolutionBotSetting     EvolutionBotSetting?
  Flowise                 Flowise[]
  FlowiseSetting          FlowiseSetting?
  Pusher                  Pusher?
}

model Session {
  id        String   @id @default(cuid())
  sessionId String   @unique
  creds     String?  @db.Text
  createdAt DateTime @default(now()) @db.Timestamp
  Instance  Instance @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}

model Chat {
  id             String    @id @default(cuid())
  remoteJid      String    @db.VarChar(100)
  name           String?   @db.VarChar(100)
  labels         Json?     @db.JsonB
  createdAt      DateTime? @default(now()) @db.Timestamp
  updatedAt      DateTime? @updatedAt @db.Timestamp
  Instance       Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId     String
  unreadMessages Int       @default(0)
  @@index([instanceId])
  @@index([remoteJid])
}

model Contact {
  id            String    @id @default(cuid())
  remoteJid     String    @db.VarChar(100)
  pushName      String?   @db.VarChar(100)
  profilePicUrl String?   @db.VarChar(500)
  createdAt     DateTime? @default(now()) @db.Timestamp
  updatedAt     DateTime? @updatedAt @db.Timestamp
  Instance      Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId    String

  @@unique([remoteJid, instanceId])
  @@index([remoteJid])
  @@index([instanceId])
}

model Message {
  id                           String          @id @default(cuid())
  key                          Json            @db.JsonB
  pushName                     String?         @db.VarChar(100)
  participant                  String?         @db.VarChar(100)
  messageType                  String          @db.VarChar(100)
  message                      Json            @db.JsonB
  contextInfo                  Json?           @db.JsonB
  source                       DeviceMessage
  messageTimestamp             Int             @db.Integer
  chatwootMessageId            Int?            @db.Integer
  chatwootInboxId              Int?            @db.Integer
  chatwootConversationId       Int?            @db.Integer
  chatwootContactInboxSourceId String?         @db.VarChar(100)
  chatwootIsRead               Boolean?        @db.Boolean
  Instance                     Instance        @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId                   String
  MessageUpdate                MessageUpdate[]
  Media                        Media?
  webhookUrl                   String?         @db.VarChar(500)
  status                       String?         @db.VarChar(30)

  sessionId String?
  session   IntegrationSession? @relation(fields: [sessionId], references: [id])
  @@index([instanceId])
}

model MessageUpdate {
  id          String   @id @default(cuid())
  keyId       String   @db.VarChar(100)
  remoteJid   String   @db.VarChar(100)
  fromMe      Boolean  @db.Boolean
  participant String?  @db.VarChar(100)
  pollUpdates Json?    @db.JsonB
  status      String   @db.VarChar(30)
  Message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId   String
  Instance    Instance @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId  String
  @@index([instanceId])
  @@index([messageId])
}

model Webhook {
  id              String    @id @default(cuid())
  url             String    @db.VarChar(500)
  headers         Json?     @db.JsonB
  enabled         Boolean?  @default(true) @db.Boolean
  events          Json?     @db.JsonB
  webhookByEvents Boolean?  @default(false) @db.Boolean
  webhookBase64   Boolean?  @default(false) @db.Boolean
  createdAt       DateTime? @default(now()) @db.Timestamp
  updatedAt       DateTime  @updatedAt @db.Timestamp
  Instance        Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String    @unique
  @@index([instanceId])
}

model Chatwoot {
  id                      String    @id @default(cuid())
  enabled                 Boolean?  @default(true) @db.Boolean
  accountId               String?   @db.VarChar(100)
  token                   String?   @db.VarChar(100)
  url                     String?   @db.VarChar(500)
  nameInbox               String?   @db.VarChar(100)
  signMsg                 Boolean?  @default(false) @db.Boolean
  signDelimiter           String?   @db.VarChar(100)
  number                  String?   @db.VarChar(100)
  reopenConversation      Boolean?  @default(false) @db.Boolean
  conversationPending     Boolean?  @default(false) @db.Boolean
  mergeBrazilContacts     Boolean?  @default(false) @db.Boolean
  importContacts          Boolean?  @default(false) @db.Boolean
  importMessages          Boolean?  @default(false) @db.Boolean
  daysLimitImportMessages Int?      @db.Integer
  organization            String?   @db.VarChar(100)
  logo                    String?   @db.VarChar(500)
  ignoreJids              Json?
  createdAt               DateTime? @default(now()) @db.Timestamp
  updatedAt               DateTime  @updatedAt @db.Timestamp
  Instance                Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId              String    @unique
}

model Label {
  id           String    @id @default(cuid())
  labelId      String?   @db.VarChar(100)
  name         String    @db.VarChar(100)
  color        String    @db.VarChar(100)
  predefinedId String?   @db.VarChar(100)
  createdAt    DateTime? @default(now()) @db.Timestamp
  updatedAt    DateTime  @updatedAt @db.Timestamp
  Instance     Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId   String

  @@unique([labelId, instanceId])
}

model Proxy {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false) @db.Boolean
  host       String    @db.VarChar(100)
  port       String    @db.VarChar(100)
  protocol   String    @db.VarChar(100)
  username   String    @db.VarChar(100)
  password   String    @db.VarChar(100)
  createdAt  DateTime? @default(now()) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Setting {
  id              String    @id @default(cuid())
  rejectCall      Boolean   @default(false) @db.Boolean
  msgCall         String?   @db.VarChar(100)
  groupsIgnore    Boolean   @default(false) @db.Boolean
  alwaysOnline    Boolean   @default(false) @db.Boolean
  readMessages    Boolean   @default(false) @db.Boolean
  readStatus      Boolean   @default(false) @db.Boolean
  syncFullHistory Boolean   @default(false) @db.Boolean
  wavoipToken     String?   @db.VarChar(100)
  createdAt       DateTime? @default(now()) @db.Timestamp
  updatedAt       DateTime  @updatedAt @db.Timestamp
  Instance        Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String    @unique
  @@index([instanceId])
}

model Rabbitmq {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false) @db.Boolean
  events     Json      @db.JsonB
  createdAt  DateTime? @default(now()) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Sqs {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false) @db.Boolean
  events     Json      @db.JsonB
  createdAt  DateTime? @default(now()) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Websocket {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false) @db.Boolean
  events     Json      @db.JsonB
  createdAt  DateTime? @default(now()) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Pusher {
  id         String    @id @default(cuid())
  enabled    Boolean   @default(false) @db.Boolean
  appId      String    @db.VarChar(100)
  key        String    @db.VarChar(100)
  secret     String    @db.VarChar(100)
  cluster    String    @db.VarChar(100)
  useTLS     Boolean   @default(false) @db.Boolean
  events     Json      @db.JsonB
  createdAt  DateTime? @default(now()) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String    @unique
}

model Typebot {
  id              String           @id @default(cuid())
  enabled         Boolean          @default(true) @db.Boolean
  description     String?          @db.VarChar(255)
  url             String           @db.VarChar(500)
  typebot         String           @db.VarChar(100)
  expire          Int?             @default(0) @db.Integer
  keywordFinish   String?          @db.VarChar(100)
  delayMessage    Int?             @db.Integer
  unknownMessage  String?          @db.VarChar(100)
  listeningFromMe Boolean?         @default(false) @db.Boolean
  stopBotFromMe   Boolean?         @default(false) @db.Boolean
  keepOpen        Boolean?         @default(false) @db.Boolean
  debounceTime    Int?             @db.Integer
  createdAt       DateTime?        @default(now()) @db.Timestamp
  updatedAt       DateTime?        @updatedAt @db.Timestamp
  ignoreJids      Json?
  triggerType     TriggerType?
  triggerOperator TriggerOperator?
  triggerValue    String?
  Instance        Instance         @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String
  TypebotSetting  TypebotSetting[]
}

model TypebotSetting {
  id                String    @id @default(cuid())
  expire            Int?      @default(0) @db.Integer
  keywordFinish     String?   @db.VarChar(100)
  delayMessage      Int?      @db.Integer
  unknownMessage    String?   @db.VarChar(100)
  listeningFromMe   Boolean?  @default(false) @db.Boolean
  stopBotFromMe     Boolean?  @default(false) @db.Boolean
  keepOpen          Boolean?  @default(false) @db.Boolean
  debounceTime      Int?      @db.Integer
  typebotIdFallback String?   @db.VarChar(100)
  ignoreJids        Json?
  createdAt         DateTime? @default(now()) @db.Timestamp
  updatedAt         DateTime  @updatedAt @db.Timestamp
  Fallback          Typebot?  @relation(fields: [typebotIdFallback], references: [id])
  Instance          Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId        String    @unique
}

model Media {
  id         String    @id @default(cuid())
  fileName   String    @unique @db.VarChar(500)
  type       String    @db.VarChar(100)
  mimetype   String    @db.VarChar(100)
  createdAt  DateTime? @default(now()) @db.Date
  Message    Message   @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId  String    @unique
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String
}

model OpenaiCreds {
  id              String         @id @default(cuid())
  name            String?        @unique @db.VarChar(255)
  apiKey          String?        @unique @db.VarChar(255)
  createdAt       DateTime?      @default(now()) @db.Timestamp
  updatedAt       DateTime       @updatedAt @db.Timestamp
  Instance        Instance       @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String
  OpenaiAssistant OpenaiBot[]
  OpenaiSetting   OpenaiSetting?
}

model OpenaiBot {
  id                String           @id @default(cuid())
  enabled           Boolean          @default(true) @db.Boolean
  description       String?          @db.VarChar(255)
  botType           OpenaiBotType
  assistantId       String?          @db.VarChar(255)
  functionUrl       String?          @db.VarChar(500)
  model             String?          @db.VarChar(100)
  systemMessages    Json?            @db.JsonB
  assistantMessages Json?            @db.JsonB
  userMessages      Json?            @db.JsonB
  maxTokens         Int?             @db.Integer
  expire            Int?             @default(0) @db.Integer
  keywordFinish     String?          @db.VarChar(100)
  delayMessage      Int?             @db.Integer
  unknownMessage    String?          @db.VarChar(100)
  listeningFromMe   Boolean?         @default(false) @db.Boolean
  stopBotFromMe     Boolean?         @default(false) @db.Boolean
  keepOpen          Boolean?         @default(false) @db.Boolean
  debounceTime      Int?             @db.Integer
  splitMessages     Boolean?         @default(false) @db.Boolean
  timePerChar       Int?             @default(50) @db.Integer
  ignoreJids        Json?
  triggerType       TriggerType?
  triggerOperator   TriggerOperator?
  triggerValue      String?
  createdAt         DateTime?        @default(now()) @db.Timestamp
  updatedAt         DateTime         @updatedAt @db.Timestamp
  OpenaiCreds       OpenaiCreds      @relation(fields: [openaiCredsId], references: [id], onDelete: Cascade)
  openaiCredsId     String
  Instance          Instance         @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId        String
  OpenaiSetting     OpenaiSetting[]
}

model IntegrationSession {
  id         String        @id @default(cuid())
  sessionId  String        @db.VarChar(255)
  remoteJid  String        @db.VarChar(100)
  pushName   String?
  status     SessionStatus
  awaitUser  Boolean       @default(false) @db.Boolean
  context    Json?
  type       String?       @db.VarChar(100)
  createdAt  DateTime?     @default(now()) @db.Timestamp
  updatedAt  DateTime      @updatedAt @db.Timestamp
  Message    Message[]
  Instance   Instance      @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String
  parameters Json?         @db.JsonB

  botId String?
}

model OpenaiSetting {
  id               String       @id @default(cuid())
  expire           Int?         @default(0) @db.Integer
  keywordFinish    String?      @db.VarChar(100)
  delayMessage     Int?         @db.Integer
  unknownMessage   String?      @db.VarChar(100)
  listeningFromMe  Boolean?     @default(false) @db.Boolean
  stopBotFromMe    Boolean?     @default(false) @db.Boolean
  keepOpen         Boolean?     @default(false) @db.Boolean
  debounceTime     Int?         @db.Integer
  ignoreJids       Json?
  splitMessages    Boolean?     @default(false) @db.Boolean
  timePerChar      Int?         @default(50) @db.Integer
  speechToText     Boolean?     @default(false) @db.Boolean
  createdAt        DateTime?    @default(now()) @db.Timestamp
  updatedAt        DateTime     @updatedAt @db.Timestamp
  OpenaiCreds      OpenaiCreds? @relation(fields: [openaiCredsId], references: [id])
  openaiCredsId    String       @unique
  Fallback         OpenaiBot?   @relation(fields: [openaiIdFallback], references: [id])
  openaiIdFallback String?      @db.VarChar(100)
  Instance         Instance     @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId       String       @unique
}

model Template {
  id         String    @id @default(cuid())
  templateId String    @unique @db.VarChar(255)
  name       String    @unique @db.VarChar(255)
  template   Json      @db.JsonB
  webhookUrl String?   @db.VarChar(500)
  createdAt  DateTime? @default(now()) @db.Timestamp
  updatedAt  DateTime  @updatedAt @db.Timestamp
  Instance   Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String
}

model Dify {
  id              String           @id @default(cuid())
  enabled         Boolean          @default(true) @db.Boolean
  description     String?          @db.VarChar(255)
  botType         DifyBotType
  apiUrl          String?          @db.VarChar(255)
  apiKey          String?          @db.VarChar(255)
  expire          Int?             @default(0) @db.Integer
  keywordFinish   String?          @db.VarChar(100)
  delayMessage    Int?             @db.Integer
  unknownMessage  String?          @db.VarChar(100)
  listeningFromMe Boolean?         @default(false) @db.Boolean
  stopBotFromMe   Boolean?         @default(false) @db.Boolean
  keepOpen        Boolean?         @default(false) @db.Boolean
  debounceTime    Int?             @db.Integer
  ignoreJids      Json?
  splitMessages   Boolean?         @default(false) @db.Boolean
  timePerChar     Int?             @default(50) @db.Integer
  triggerType     TriggerType?
  triggerOperator TriggerOperator?
  triggerValue    String?
  createdAt       DateTime?        @default(now()) @db.Timestamp
  updatedAt       DateTime         @updatedAt @db.Timestamp
  Instance        Instance         @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String
  DifySetting     DifySetting[]
}

model DifySetting {
  id              String    @id @default(cuid())
  expire          Int?      @default(0) @db.Integer
  keywordFinish   String?   @db.VarChar(100)
  delayMessage    Int?      @db.Integer
  unknownMessage  String?   @db.VarChar(100)
  listeningFromMe Boolean?  @default(false) @db.Boolean
  stopBotFromMe   Boolean?  @default(false) @db.Boolean
  keepOpen        Boolean?  @default(false) @db.Boolean
  debounceTime    Int?      @db.Integer
  ignoreJids      Json?
  splitMessages   Boolean?  @default(false) @db.Boolean
  timePerChar     Int?      @default(50) @db.Integer
  createdAt       DateTime? @default(now()) @db.Timestamp
  updatedAt       DateTime  @updatedAt @db.Timestamp
  Fallback        Dify?     @relation(fields: [difyIdFallback], references: [id])
  difyIdFallback  String?   @db.VarChar(100)
  Instance        Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String    @unique
}

model EvolutionBot {
  id                  String                @id @default(cuid())
  enabled             Boolean               @default(true) @db.Boolean
  description         String?               @db.VarChar(255)
  apiUrl              String?               @db.VarChar(255)
  apiKey              String?               @db.VarChar(255)
  expire              Int?                  @default(0) @db.Integer
  keywordFinish       String?               @db.VarChar(100)
  delayMessage        Int?                  @db.Integer
  unknownMessage      String?               @db.VarChar(100)
  listeningFromMe     Boolean?              @default(false) @db.Boolean
  stopBotFromMe       Boolean?              @default(false) @db.Boolean
  keepOpen            Boolean?              @default(false) @db.Boolean
  debounceTime        Int?                  @db.Integer
  ignoreJids          Json?
  splitMessages       Boolean?              @default(false) @db.Boolean
  timePerChar         Int?                  @default(50) @db.Integer
  triggerType         TriggerType?
  triggerOperator     TriggerOperator?
  triggerValue        String?
  createdAt           DateTime?             @default(now()) @db.Timestamp
  updatedAt           DateTime              @updatedAt @db.Timestamp
  Instance            Instance              @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId          String
  EvolutionBotSetting EvolutionBotSetting[]
}

model EvolutionBotSetting {
  id              String        @id @default(cuid())
  expire          Int?          @default(0) @db.Integer
  keywordFinish   String?       @db.VarChar(100)
  delayMessage    Int?          @db.Integer
  unknownMessage  String?       @db.VarChar(100)
  listeningFromMe Boolean?      @default(false) @db.Boolean
  stopBotFromMe   Boolean?      @default(false) @db.Boolean
  keepOpen        Boolean?      @default(false) @db.Boolean
  debounceTime    Int?          @db.Integer
  ignoreJids      Json?
  splitMessages   Boolean?      @default(false) @db.Boolean
  timePerChar     Int?          @default(50) @db.Integer
  createdAt       DateTime?     @default(now()) @db.Timestamp
  updatedAt       DateTime      @updatedAt @db.Timestamp
  Fallback        EvolutionBot? @relation(fields: [botIdFallback], references: [id])
  botIdFallback   String?       @db.VarChar(100)
  Instance        Instance      @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String        @unique
}

model Flowise {
  id              String           @id @default(cuid())
  enabled         Boolean          @default(true) @db.Boolean
  description     String?          @db.VarChar(255)
  apiUrl          String?          @db.VarChar(255)
  apiKey          String?          @db.VarChar(255)
  expire          Int?             @default(0) @db.Integer
  keywordFinish   String?          @db.VarChar(100)
  delayMessage    Int?             @db.Integer
  unknownMessage  String?          @db.VarChar(100)
  listeningFromMe Boolean?         @default(false) @db.Boolean
  stopBotFromMe   Boolean?         @default(false) @db.Boolean
  keepOpen        Boolean?         @default(false) @db.Boolean
  debounceTime    Int?             @db.Integer
  ignoreJids      Json?
  splitMessages   Boolean?         @default(false) @db.Boolean
  timePerChar     Int?             @default(50) @db.Integer
  triggerType     TriggerType?
  triggerOperator TriggerOperator?
  triggerValue    String?
  createdAt       DateTime?        @default(now()) @db.Timestamp
  updatedAt       DateTime         @updatedAt @db.Timestamp
  Instance        Instance         @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId      String
  FlowiseSetting  FlowiseSetting[]
}

model FlowiseSetting {
  id                String    @id @default(cuid())
  expire            Int?      @default(0) @db.Integer
  keywordFinish     String?   @db.VarChar(100)
  delayMessage      Int?      @db.Integer
  unknownMessage    String?   @db.VarChar(100)
  listeningFromMe   Boolean?  @default(false) @db.Boolean
  stopBotFromMe     Boolean?  @default(false) @db.Boolean
  keepOpen          Boolean?  @default(false) @db.Boolean
  debounceTime      Int?      @db.Integer
  ignoreJids        Json?
  splitMessages     Boolean?  @default(false) @db.Boolean
  timePerChar       Int?      @default(50) @db.Integer
  createdAt         DateTime? @default(now()) @db.Timestamp
  updatedAt         DateTime  @updatedAt @db.Timestamp
  Fallback          Flowise?  @relation(fields: [flowiseIdFallback], references: [id])
  flowiseIdFallback String?   @db.VarChar(100)
  Instance          Instance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId        String    @unique
}

model IsOnWhatsapp {
  id         String   @id @default(cuid())
  remoteJid  String   @unique @db.VarChar(100)
  jidOptions String
  createdAt  DateTime @default(now()) @db.Timestamp
  updatedAt  DateTime @updatedAt @db.Timestamp
}



================================================
FILE: prisma/mysql-migrations/migration_lock.toml
================================================
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "mysql"


================================================
FILE: prisma/mysql-migrations/20240809105427_init/migration.sql
================================================
-- CreateTable
CREATE TABLE `Instance` (
    `id` VARCHAR(191) NOT NULL,
    `name` VARCHAR(255) NOT NULL,
    `connectionStatus` ENUM('open', 'close', 'connecting') NOT NULL DEFAULT 'open',
    `ownerJid` VARCHAR(100) NULL,
    `profileName` VARCHAR(100) NULL,
    `profilePicUrl` VARCHAR(500) NULL,
    `integration` VARCHAR(100) NULL,
    `number` VARCHAR(100) NULL,
    `businessId` VARCHAR(100) NULL,
    `token` VARCHAR(255) NULL,
    `clientName` VARCHAR(100) NULL,
    `disconnectionReasonCode` INTEGER NULL,
    `disconnectionObject` JSON NULL,
    `disconnectionAt` TIMESTAMP NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NULL,

    UNIQUE INDEX `Instance_name_key`(`name`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Session` (
    `id` VARCHAR(191) NOT NULL,
    `sessionId` VARCHAR(191) NOT NULL,
    `creds` TEXT NULL,
    `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    UNIQUE INDEX `Session_sessionId_key`(`sessionId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Chat` (
    `id` VARCHAR(191) NOT NULL,
    `remoteJid` VARCHAR(100) NOT NULL,
    `labels` JSON NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Contact` (
    `id` VARCHAR(191) NOT NULL,
    `remoteJid` VARCHAR(100) NOT NULL,
    `pushName` VARCHAR(100) NULL,
    `profilePicUrl` VARCHAR(500) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Message` (
    `id` VARCHAR(191) NOT NULL,
    `key` JSON NOT NULL,
    `pushName` VARCHAR(100) NULL,
    `participant` VARCHAR(100) NULL,
    `messageType` VARCHAR(100) NOT NULL,
    `message` JSON NOT NULL,
    `contextInfo` JSON NULL,
    `source` ENUM('ios', 'android', 'web', 'unknown', 'desktop') NOT NULL,
    `messageTimestamp` INTEGER NOT NULL,
    `chatwootMessageId` INTEGER NULL,
    `chatwootInboxId` INTEGER NULL,
    `chatwootConversationId` INTEGER NULL,
    `chatwootContactInboxSourceId` VARCHAR(100) NULL,
    `chatwootIsRead` BOOLEAN NULL DEFAULT false,
    `instanceId` VARCHAR(191) NOT NULL,
    `typebotSessionId` VARCHAR(191) NULL,
    `openaiSessionId` VARCHAR(191) NULL,
    `webhookUrl` VARCHAR(500) NULL,
    `difySessionId` VARCHAR(191) NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `MessageUpdate` (
    `id` VARCHAR(191) NOT NULL,
    `keyId` VARCHAR(100) NOT NULL,
    `remoteJid` VARCHAR(100) NOT NULL,
    `fromMe` BOOLEAN NOT NULL,
    `participant` VARCHAR(100) NULL,
    `pollUpdates` JSON NULL,
    `status` VARCHAR(30) NOT NULL,
    `messageId` VARCHAR(191) NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Webhook` (
    `id` VARCHAR(191) NOT NULL,
    `url` VARCHAR(500) NOT NULL,
    `enabled` BOOLEAN NULL DEFAULT true,
    `events` JSON NULL,
    `webhookByEvents` BOOLEAN NULL DEFAULT false,
    `webhookBase64` BOOLEAN NULL DEFAULT false,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Webhook_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Chatwoot` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NULL DEFAULT true,
    `accountId` VARCHAR(100) NULL,
    `token` VARCHAR(100) NULL,
    `url` VARCHAR(500) NULL,
    `nameInbox` VARCHAR(100) NULL,
    `signMsg` BOOLEAN NULL DEFAULT false,
    `signDelimiter` VARCHAR(100) NULL,
    `number` VARCHAR(100) NULL,
    `reopenConversation` BOOLEAN NULL DEFAULT false,
    `conversationPending` BOOLEAN NULL DEFAULT false,
    `mergeBrazilContacts` BOOLEAN NULL DEFAULT false,
    `importContacts` BOOLEAN NULL DEFAULT false,
    `importMessages` BOOLEAN NULL DEFAULT false,
    `daysLimitImportMessages` INTEGER NULL,
    `organization` VARCHAR(100) NULL,
    `logo` VARCHAR(500) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Chatwoot_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Label` (
    `id` VARCHAR(191) NOT NULL,
    `labelId` VARCHAR(100) NULL,
    `name` VARCHAR(100) NOT NULL,
    `color` VARCHAR(100) NOT NULL,
    `predefinedId` VARCHAR(100) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Label_labelId_key`(`labelId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Proxy` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT false,
    `host` VARCHAR(100) NOT NULL,
    `port` VARCHAR(100) NOT NULL,
    `protocol` VARCHAR(100) NOT NULL,
    `username` VARCHAR(100) NOT NULL,
    `password` VARCHAR(100) NOT NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Proxy_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Setting` (
    `id` VARCHAR(191) NOT NULL,
    `rejectCall` BOOLEAN NOT NULL DEFAULT false,
    `msgCall` VARCHAR(100) NULL,
    `groupsIgnore` BOOLEAN NOT NULL DEFAULT false,
    `alwaysOnline` BOOLEAN NOT NULL DEFAULT false,
    `readMessages` BOOLEAN NOT NULL DEFAULT false,
    `readStatus` BOOLEAN NOT NULL DEFAULT false,
    `syncFullHistory` BOOLEAN NOT NULL DEFAULT false,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Setting_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Rabbitmq` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT false,
    `events` JSON NOT NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Rabbitmq_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Sqs` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT false,
    `events` JSON NOT NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Sqs_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Websocket` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT false,
    `events` JSON NOT NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Websocket_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Typebot` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT true,
    `description` VARCHAR(255) NULL,
    `url` VARCHAR(500) NOT NULL,
    `typebot` VARCHAR(100) NOT NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NULL,
    `ignoreJids` JSON NULL,
    `triggerType` ENUM('all', 'keyword', 'none') NULL,
    `triggerOperator` ENUM('contains', 'equals', 'startsWith', 'endsWith', 'regex') NULL,
    `triggerValue` VARCHAR(191) NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `TypebotSession` (
    `id` VARCHAR(191) NOT NULL,
    `remoteJid` VARCHAR(100) NOT NULL,
    `pushName` VARCHAR(100) NULL,
    `sessionId` VARCHAR(100) NOT NULL,
    `status` ENUM('opened', 'closed', 'paused') NOT NULL,
    `prefilledVariables` JSON NULL,
    `awaitUser` BOOLEAN NOT NULL DEFAULT false,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `typebotId` VARCHAR(191) NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `TypebotSetting` (
    `id` VARCHAR(191) NOT NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `typebotIdFallback` VARCHAR(100) NULL,
    `ignoreJids` JSON NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `TypebotSetting_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Media` (
    `id` VARCHAR(191) NOT NULL,
    `fileName` VARCHAR(500) NOT NULL,
    `type` VARCHAR(100) NOT NULL,
    `mimetype` VARCHAR(100) NOT NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `messageId` VARCHAR(191) NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Media_fileName_key`(`fileName`),
    UNIQUE INDEX `Media_messageId_key`(`messageId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `OpenaiCreds` (
    `id` VARCHAR(191) NOT NULL,
    `name` VARCHAR(255) NULL,
    `apiKey` VARCHAR(255) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `OpenaiCreds_name_key`(`name`),
    UNIQUE INDEX `OpenaiCreds_apiKey_key`(`apiKey`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `OpenaiBot` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT true,
    `description` VARCHAR(255) NULL,
    `botType` ENUM('assistant', 'chatCompletion') NOT NULL,
    `assistantId` VARCHAR(255) NULL,
    `functionUrl` VARCHAR(500) NULL,
    `model` VARCHAR(100) NULL,
    `systemMessages` JSON NULL,
    `assistantMessages` JSON NULL,
    `userMessages` JSON NULL,
    `maxTokens` INTEGER NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `triggerType` ENUM('all', 'keyword', 'none') NULL,
    `triggerOperator` ENUM('contains', 'equals', 'startsWith', 'endsWith', 'regex') NULL,
    `triggerValue` VARCHAR(191) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `openaiCredsId` VARCHAR(191) NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `OpenaiSession` (
    `id` VARCHAR(191) NOT NULL,
    `sessionId` VARCHAR(255) NOT NULL,
    `remoteJid` VARCHAR(100) NOT NULL,
    `status` ENUM('opened', 'closed', 'paused') NOT NULL,
    `awaitUser` BOOLEAN NOT NULL DEFAULT false,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `openaiBotId` VARCHAR(191) NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `OpenaiSetting` (
    `id` VARCHAR(191) NOT NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `speechToText` BOOLEAN NULL DEFAULT false,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `openaiCredsId` VARCHAR(191) NOT NULL,
    `openaiIdFallback` VARCHAR(100) NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `OpenaiSetting_openaiCredsId_key`(`openaiCredsId`),
    UNIQUE INDEX `OpenaiSetting_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Template` (
    `id` VARCHAR(191) NOT NULL,
    `templateId` VARCHAR(255) NOT NULL,
    `name` VARCHAR(255) NOT NULL,
    `template` JSON NOT NULL,
    `webhookUrl` VARCHAR(500) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Template_templateId_key`(`templateId`),
    UNIQUE INDEX `Template_name_key`(`name`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Dify` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT true,
    `description` VARCHAR(255) NULL,
    `botType` ENUM('chatBot', 'textGenerator', 'agent', 'workflow') NOT NULL,
    `apiUrl` VARCHAR(255) NULL,
    `apiKey` VARCHAR(255) NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `triggerType` ENUM('all', 'keyword', 'none') NULL,
    `triggerOperator` ENUM('contains', 'equals', 'startsWith', 'endsWith', 'regex') NULL,
    `triggerValue` VARCHAR(191) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `DifySession` (
    `id` VARCHAR(191) NOT NULL,
    `sessionId` VARCHAR(255) NOT NULL,
    `remoteJid` VARCHAR(100) NOT NULL,
    `status` ENUM('opened', 'closed', 'paused') NOT NULL,
    `awaitUser` BOOLEAN NOT NULL DEFAULT false,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `difyId` VARCHAR(191) NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `DifySetting` (
    `id` VARCHAR(191) NOT NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `difyIdFallback` VARCHAR(100) NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `DifySetting_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `Session` ADD CONSTRAINT `Session_sessionId_fkey` FOREIGN KEY (`sessionId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Chat` ADD CONSTRAINT `Chat_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Contact` ADD CONSTRAINT `Contact_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Message` ADD CONSTRAINT `Message_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Message` ADD CONSTRAINT `Message_typebotSessionId_fkey` FOREIGN KEY (`typebotSessionId`) REFERENCES `TypebotSession`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Message` ADD CONSTRAINT `Message_openaiSessionId_fkey` FOREIGN KEY (`openaiSessionId`) REFERENCES `OpenaiSession`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Message` ADD CONSTRAINT `Message_difySessionId_fkey` FOREIGN KEY (`difySessionId`) REFERENCES `DifySession`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `MessageUpdate` ADD CONSTRAINT `MessageUpdate_messageId_fkey` FOREIGN KEY (`messageId`) REFERENCES `Message`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `MessageUpdate` ADD CONSTRAINT `MessageUpdate_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Webhook` ADD CONSTRAINT `Webhook_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Chatwoot` ADD CONSTRAINT `Chatwoot_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Label` ADD CONSTRAINT `Label_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Proxy` ADD CONSTRAINT `Proxy_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Setting` ADD CONSTRAINT `Setting_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Rabbitmq` ADD CONSTRAINT `Rabbitmq_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Sqs` ADD CONSTRAINT `Sqs_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Websocket` ADD CONSTRAINT `Websocket_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Typebot` ADD CONSTRAINT `Typebot_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `TypebotSession` ADD CONSTRAINT `TypebotSession_typebotId_fkey` FOREIGN KEY (`typebotId`) REFERENCES `Typebot`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `TypebotSession` ADD CONSTRAINT `TypebotSession_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `TypebotSetting` ADD CONSTRAINT `TypebotSetting_typebotIdFallback_fkey` FOREIGN KEY (`typebotIdFallback`) REFERENCES `Typebot`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `TypebotSetting` ADD CONSTRAINT `TypebotSetting_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Media` ADD CONSTRAINT `Media_messageId_fkey` FOREIGN KEY (`messageId`) REFERENCES `Message`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Media` ADD CONSTRAINT `Media_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `OpenaiCreds` ADD CONSTRAINT `OpenaiCreds_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `OpenaiBot` ADD CONSTRAINT `OpenaiBot_openaiCredsId_fkey` FOREIGN KEY (`openaiCredsId`) REFERENCES `OpenaiCreds`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `OpenaiBot` ADD CONSTRAINT `OpenaiBot_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `OpenaiSession` ADD CONSTRAINT `OpenaiSession_openaiBotId_fkey` FOREIGN KEY (`openaiBotId`) REFERENCES `OpenaiBot`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `OpenaiSession` ADD CONSTRAINT `OpenaiSession_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `OpenaiSetting` ADD CONSTRAINT `OpenaiSetting_openaiCredsId_fkey` FOREIGN KEY (`openaiCredsId`) REFERENCES `OpenaiCreds`(`id`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `OpenaiSetting` ADD CONSTRAINT `OpenaiSetting_openaiIdFallback_fkey` FOREIGN KEY (`openaiIdFallback`) REFERENCES `OpenaiBot`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `OpenaiSetting` ADD CONSTRAINT `OpenaiSetting_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Template` ADD CONSTRAINT `Template_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Dify` ADD CONSTRAINT `Dify_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `DifySession` ADD CONSTRAINT `DifySession_difyId_fkey` FOREIGN KEY (`difyId`) REFERENCES `Dify`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `DifySession` ADD CONSTRAINT `DifySession_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `DifySetting` ADD CONSTRAINT `DifySetting_difyIdFallback_fkey` FOREIGN KEY (`difyIdFallback`) REFERENCES `Dify`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `DifySetting` ADD CONSTRAINT `DifySetting_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/mysql-migrations/20240813153900_add_unique_index_for_remoted_jid_and_instance_in_contacts/migration.sql
================================================
/*
Warnings:
- You are about to alter the column `createdAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `DifySession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `DifySession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `disconnectionAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Media` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `OpenaiSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `OpenaiSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Session` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `TypebotSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `TypebotSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `createdAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- You are about to alter the column `updatedAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
- A unique constraint covering the columns `[remoteJid,instanceId]` on the table `Contact` will be added. If there are existing duplicate values, this will fail.
*/
-- AlterTable
ALTER TABLE `Chat`
ADD COLUMN `name` VARCHAR(100) NULL,
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Chatwoot`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Contact`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Dify`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySession`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySetting`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Instance`
MODIFY `disconnectionAt` TIMESTAMP NULL,
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Label`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Media`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `OpenaiBot`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiCreds`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSession`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSetting`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Proxy`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Rabbitmq`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Session`
MODIFY `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Setting`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Sqs`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Template`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Typebot`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `TypebotSession`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `TypebotSetting`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Webhook`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Websocket`
MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- CreateIndex
CREATE UNIQUE INDEX `Contact_remoteJid_instanceId_key` ON `Contact` (`remoteJid`, `instanceId`);


================================================
FILE: prisma/mysql-migrations/20240814173138_add_ignore_jids_chatwoot/migration.sql
================================================
/*
  Warnings:

  - You are about to alter the column `createdAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `DifySession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `DifySession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `disconnectionAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Media` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Session` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `TypebotSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `TypebotSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.

*/
-- DropIndex
DROP INDEX `Label_labelId_key` ON `Label`;

-- AlterTable
ALTER TABLE `Chat` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Chatwoot` ADD COLUMN `ignoreJids` JSON NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Contact` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Dify` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySession` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Instance` MODIFY `disconnectionAt` TIMESTAMP NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Label` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Media` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `OpenaiBot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiCreds` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSession` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Proxy` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Rabbitmq` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Session` MODIFY `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Setting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Sqs` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Template` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Typebot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `TypebotSession` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `TypebotSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Webhook` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Websocket` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;



================================================
FILE: prisma/mysql-migrations/20240814214314_integrations_unification/migration.sql
================================================
/*
  Warnings:

  - You are about to alter the column `createdAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `disconnectionAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Media` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to drop the column `difySessionId` on the `Message` table. All the data in the column will be lost.
  - You are about to drop the column `openaiSessionId` on the `Message` table. All the data in the column will be lost.
  - You are about to alter the column `createdAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Session` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to drop the `DifySession` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `OpenaiSession` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `TypebotSession` table. If the table is not empty, all the data it contains will be lost.

*/
-- DropForeignKey
ALTER TABLE `DifySession` DROP FOREIGN KEY `DifySession_difyId_fkey`;

-- DropForeignKey
ALTER TABLE `DifySession` DROP FOREIGN KEY `DifySession_instanceId_fkey`;

-- DropForeignKey
ALTER TABLE `Message` DROP FOREIGN KEY `Message_difySessionId_fkey`;

-- DropForeignKey
ALTER TABLE `Message` DROP FOREIGN KEY `Message_openaiSessionId_fkey`;

-- DropForeignKey
ALTER TABLE `Message` DROP FOREIGN KEY `Message_typebotSessionId_fkey`;

-- DropForeignKey
ALTER TABLE `OpenaiSession` DROP FOREIGN KEY `OpenaiSession_instanceId_fkey`;

-- DropForeignKey
ALTER TABLE `OpenaiSession` DROP FOREIGN KEY `OpenaiSession_openaiBotId_fkey`;

-- DropForeignKey
ALTER TABLE `TypebotSession` DROP FOREIGN KEY `TypebotSession_instanceId_fkey`;

-- DropForeignKey
ALTER TABLE `TypebotSession` DROP FOREIGN KEY `TypebotSession_typebotId_fkey`;

-- AlterTable
ALTER TABLE `Chat` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Chatwoot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Contact` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Dify` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Instance` MODIFY `disconnectionAt` TIMESTAMP NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Label` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Media` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Message` DROP COLUMN `difySessionId`,
    DROP COLUMN `openaiSessionId`,
    ADD COLUMN `sessionId` VARCHAR(191) NULL;

-- AlterTable
ALTER TABLE `OpenaiBot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiCreds` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Proxy` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Rabbitmq` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Session` MODIFY `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Setting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Sqs` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Template` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Typebot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `TypebotSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Webhook` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Websocket` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- DropTable
DROP TABLE `DifySession`;

-- DropTable
DROP TABLE `OpenaiSession`;

-- DropTable
DROP TABLE `TypebotSession`;

-- CreateTable
CREATE TABLE `IntegrationSession` (
    `id` VARCHAR(191) NOT NULL,
    `sessionId` VARCHAR(255) NOT NULL,
    `remoteJid` VARCHAR(100) NOT NULL,
    `pushName` VARCHAR(191) NULL,
    `status` ENUM('opened', 'closed', 'paused') NOT NULL,
    `awaitUser` BOOLEAN NOT NULL DEFAULT false,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,
    `parameters` JSON NULL,
    `openaiBotId` VARCHAR(191) NULL,
    `difyId` VARCHAR(191) NULL,
    `typebotId` VARCHAR(191) NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `Message` ADD CONSTRAINT `Message_sessionId_fkey` FOREIGN KEY (`sessionId`) REFERENCES `IntegrationSession`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `IntegrationSession` ADD CONSTRAINT `IntegrationSession_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `IntegrationSession` ADD CONSTRAINT `IntegrationSession_openaiBotId_fkey` FOREIGN KEY (`openaiBotId`) REFERENCES `OpenaiBot`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `IntegrationSession` ADD CONSTRAINT `IntegrationSession_difyId_fkey` FOREIGN KEY (`difyId`) REFERENCES `Dify`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `IntegrationSession` ADD CONSTRAINT `IntegrationSession_typebotId_fkey` FOREIGN KEY (`typebotId`) REFERENCES `Typebot`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/mysql-migrations/20240821203259_add_postgres_migrations/migration.sql
================================================
/*
  Warnings:

  - You are about to alter the column `createdAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `disconnectionAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to drop the column `difyId` on the `IntegrationSession` table. All the data in the column will be lost.
  - You are about to drop the column `openaiBotId` on the `IntegrationSession` table. All the data in the column will be lost.
  - You are about to drop the column `typebotId` on the `IntegrationSession` table. All the data in the column will be lost.
  - You are about to alter the column `createdAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Media` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Session` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.

*/
-- DropForeignKey
ALTER TABLE `IntegrationSession` DROP FOREIGN KEY `IntegrationSession_difyId_fkey`;

-- DropForeignKey
ALTER TABLE `IntegrationSession` DROP FOREIGN KEY `IntegrationSession_openaiBotId_fkey`;

-- DropForeignKey
ALTER TABLE `IntegrationSession` DROP FOREIGN KEY `IntegrationSession_typebotId_fkey`;

-- DropIndex
DROP INDEX `Message_typebotSessionId_fkey` ON `Message`;

-- AlterTable
ALTER TABLE `Chat` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Chatwoot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Contact` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Dify` MODIFY `triggerType` ENUM('all', 'keyword', 'none', 'advanced') NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Instance` MODIFY `disconnectionAt` TIMESTAMP NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `IntegrationSession` DROP COLUMN `difyId`,
    DROP COLUMN `openaiBotId`,
    DROP COLUMN `typebotId`,
    ADD COLUMN `botId` VARCHAR(191) NULL,
    ADD COLUMN `context` JSON NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Label` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Media` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `OpenaiBot` MODIFY `triggerType` ENUM('all', 'keyword', 'none', 'advanced') NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiCreds` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Proxy` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Rabbitmq` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Session` MODIFY `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Setting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Sqs` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Template` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Typebot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL,
    MODIFY `triggerType` ENUM('all', 'keyword', 'none', 'advanced') NULL;

-- AlterTable
ALTER TABLE `TypebotSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Webhook` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Websocket` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- CreateTable
CREATE TABLE `GenericBot` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT true,
    `description` VARCHAR(255) NULL,
    `apiUrl` VARCHAR(255) NULL,
    `apiKey` VARCHAR(255) NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `triggerType` ENUM('all', 'keyword', 'none', 'advanced') NULL,
    `triggerOperator` ENUM('contains', 'equals', 'startsWith', 'endsWith', 'regex') NULL,
    `triggerValue` VARCHAR(191) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `GenericSetting` (
    `id` VARCHAR(191) NOT NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `botIdFallback` VARCHAR(100) NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `GenericSetting_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Flowise` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT true,
    `description` VARCHAR(255) NULL,
    `apiUrl` VARCHAR(255) NULL,
    `apiKey` VARCHAR(255) NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `triggerType` ENUM('all', 'keyword', 'none', 'advanced') NULL,
    `triggerOperator` ENUM('contains', 'equals', 'startsWith', 'endsWith', 'regex') NULL,
    `triggerValue` VARCHAR(191) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `FlowiseSetting` (
    `id` VARCHAR(191) NOT NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `flowiseIdFallback` VARCHAR(100) NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `FlowiseSetting_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `GenericBot` ADD CONSTRAINT `GenericBot_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `GenericSetting` ADD CONSTRAINT `GenericSetting_botIdFallback_fkey` FOREIGN KEY (`botIdFallback`) REFERENCES `GenericBot`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `GenericSetting` ADD CONSTRAINT `GenericSetting_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Flowise` ADD CONSTRAINT `Flowise_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `FlowiseSetting` ADD CONSTRAINT `FlowiseSetting_flowiseIdFallback_fkey` FOREIGN KEY (`flowiseIdFallback`) REFERENCES `Flowise`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `FlowiseSetting` ADD CONSTRAINT `FlowiseSetting_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/mysql-migrations/20240824162012_add_type_on_integration_sessions/migration.sql
================================================
/*
  Warnings:

  - You are about to alter the column `createdAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Flowise` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Flowise` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `FlowiseSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `FlowiseSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `GenericBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `GenericBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `GenericSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `GenericSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `disconnectionAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Media` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Session` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.

*/
-- AlterTable
ALTER TABLE `Chat` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Chatwoot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Contact` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Dify` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Flowise` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `FlowiseSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `GenericBot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `GenericSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Instance` MODIFY `disconnectionAt` TIMESTAMP NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `IntegrationSession` ADD COLUMN `type` VARCHAR(100) NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Label` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Media` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `OpenaiBot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiCreds` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Proxy` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Rabbitmq` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Session` MODIFY `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Setting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Sqs` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Template` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Typebot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `TypebotSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Webhook` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Websocket` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;



================================================
FILE: prisma/mysql-migrations/20240825131301_change_to_evolution_bot/migration.sql
================================================
/*
  Warnings:

  - You are about to alter the column `createdAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Flowise` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Flowise` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `FlowiseSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `FlowiseSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `disconnectionAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Media` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Session` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to drop the `GenericBot` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `GenericSetting` table. If the table is not empty, all the data it contains will be lost.

*/
-- DropForeignKey
ALTER TABLE `GenericBot` DROP FOREIGN KEY `GenericBot_instanceId_fkey`;

-- DropForeignKey
ALTER TABLE `GenericSetting` DROP FOREIGN KEY `GenericSetting_botIdFallback_fkey`;

-- DropForeignKey
ALTER TABLE `GenericSetting` DROP FOREIGN KEY `GenericSetting_instanceId_fkey`;

-- AlterTable
ALTER TABLE `Chat` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Chatwoot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Contact` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Dify` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Flowise` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `FlowiseSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Instance` MODIFY `disconnectionAt` TIMESTAMP NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `IntegrationSession` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Label` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Media` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `OpenaiBot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiCreds` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Proxy` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Rabbitmq` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Session` MODIFY `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Setting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Sqs` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Template` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Typebot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `TypebotSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Webhook` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Websocket` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- DropTable
DROP TABLE `GenericBot`;

-- DropTable
DROP TABLE `GenericSetting`;

-- CreateTable
CREATE TABLE `EvolutionBot` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT true,
    `description` VARCHAR(255) NULL,
    `apiUrl` VARCHAR(255) NULL,
    `apiKey` VARCHAR(255) NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `triggerType` ENUM('all', 'keyword', 'none', 'advanced') NULL,
    `triggerOperator` ENUM('contains', 'equals', 'startsWith', 'endsWith', 'regex') NULL,
    `triggerValue` VARCHAR(191) NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `EvolutionBotSetting` (
    `id` VARCHAR(191) NOT NULL,
    `expire` INTEGER NULL DEFAULT 0,
    `keywordFinish` VARCHAR(100) NULL,
    `delayMessage` INTEGER NULL,
    `unknownMessage` VARCHAR(100) NULL,
    `listeningFromMe` BOOLEAN NULL DEFAULT false,
    `stopBotFromMe` BOOLEAN NULL DEFAULT false,
    `keepOpen` BOOLEAN NULL DEFAULT false,
    `debounceTime` INTEGER NULL,
    `ignoreJids` JSON NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `botIdFallback` VARCHAR(100) NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `EvolutionBotSetting_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `EvolutionBot` ADD CONSTRAINT `EvolutionBot_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `EvolutionBotSetting` ADD CONSTRAINT `EvolutionBotSetting_botIdFallback_fkey` FOREIGN KEY (`botIdFallback`) REFERENCES `EvolutionBot`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `EvolutionBotSetting` ADD CONSTRAINT `EvolutionBotSetting_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/mysql-migrations/20241001172800_add_message_status/migration.sql
================================================
/*
  Warnings:

  - You are about to alter the column `createdAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `EvolutionBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `EvolutionBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `EvolutionBotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `EvolutionBotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Flowise` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Flowise` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `FlowiseSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `FlowiseSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `disconnectionAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Media` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Session` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.

*/
-- AlterTable
ALTER TABLE `Chat` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Chatwoot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Contact` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Dify` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `EvolutionBot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `EvolutionBotSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Flowise` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `FlowiseSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Instance` MODIFY `disconnectionAt` TIMESTAMP NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `IntegrationSession` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Label` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Media` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Message` ADD COLUMN `status` INTEGER NULL;

-- AlterTable
ALTER TABLE `OpenaiBot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiCreds` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Proxy` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Rabbitmq` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Session` MODIFY `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Setting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Sqs` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Template` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Typebot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `TypebotSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Webhook` ADD COLUMN `headers` JSON NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Websocket` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- CreateTable
CREATE TABLE `IsOnWhatsapp` (
    `id` VARCHAR(191) NOT NULL,
    `remoteJid` VARCHAR(100) NOT NULL,
    `jidOptions` VARCHAR(191) NOT NULL,
    `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,

    UNIQUE INDEX `IsOnWhatsapp_remoteJid_key`(`remoteJid`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;



================================================
FILE: prisma/mysql-migrations/20241108101333_fix_message_status_as_string/migration.sql
================================================
/*
  Warnings:

  - You are about to alter the column `createdAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chat` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Chatwoot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Contact` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Dify` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `DifySetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `EvolutionBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `EvolutionBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `EvolutionBotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `EvolutionBotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Flowise` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Flowise` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `FlowiseSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `FlowiseSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `disconnectionAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Instance` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `IntegrationSession` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `IsOnWhatsapp` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `IsOnWhatsapp` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Label` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Media` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiBot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiCreds` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `OpenaiSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Proxy` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Rabbitmq` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Session` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Setting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Sqs` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Template` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Typebot` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `TypebotSetting` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Webhook` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `createdAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.
  - You are about to alter the column `updatedAt` on the `Websocket` table. The data in that column could be lost. The data in that column will be cast from `Timestamp(0)` to `Timestamp`.

*/
-- AlterTable
ALTER TABLE `Chat` ADD COLUMN `unreadMessages` INTEGER NOT NULL DEFAULT 0,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Chatwoot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Contact` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `Dify` ADD COLUMN `splitMessages` BOOLEAN NULL DEFAULT false,
    ADD COLUMN `timePerChar` INTEGER NULL DEFAULT 50,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `DifySetting` ADD COLUMN `splitMessages` BOOLEAN NULL DEFAULT false,
    ADD COLUMN `timePerChar` INTEGER NULL DEFAULT 50,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `EvolutionBot` ADD COLUMN `splitMessages` BOOLEAN NULL DEFAULT false,
    ADD COLUMN `timePerChar` INTEGER NULL DEFAULT 50,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `EvolutionBotSetting` ADD COLUMN `splitMessages` BOOLEAN NULL DEFAULT false,
    ADD COLUMN `timePerChar` INTEGER NULL DEFAULT 50,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Flowise` ADD COLUMN `splitMessages` BOOLEAN NULL DEFAULT false,
    ADD COLUMN `timePerChar` INTEGER NULL DEFAULT 50,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `FlowiseSetting` ADD COLUMN `splitMessages` BOOLEAN NULL DEFAULT false,
    ADD COLUMN `timePerChar` INTEGER NULL DEFAULT 50,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Instance` MODIFY `disconnectionAt` TIMESTAMP NULL,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `IntegrationSession` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `IsOnWhatsapp` MODIFY `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Label` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Media` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Message` MODIFY `status` VARCHAR(30) NULL;

-- AlterTable
ALTER TABLE `OpenaiBot` ADD COLUMN `splitMessages` BOOLEAN NULL DEFAULT false,
    ADD COLUMN `timePerChar` INTEGER NULL DEFAULT 50,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiCreds` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `OpenaiSetting` ADD COLUMN `splitMessages` BOOLEAN NULL DEFAULT false,
    ADD COLUMN `timePerChar` INTEGER NULL DEFAULT 50,
    MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Proxy` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Rabbitmq` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Session` MODIFY `createdAt` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE `Setting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Sqs` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Template` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Typebot` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NULL;

-- AlterTable
ALTER TABLE `TypebotSetting` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Webhook` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- AlterTable
ALTER TABLE `Websocket` MODIFY `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    MODIFY `updatedAt` TIMESTAMP NOT NULL;

-- CreateTable
CREATE TABLE `Pusher` (
    `id` VARCHAR(191) NOT NULL,
    `enabled` BOOLEAN NOT NULL DEFAULT false,
    `appId` VARCHAR(100) NOT NULL,
    `key` VARCHAR(100) NOT NULL,
    `secret` VARCHAR(100) NOT NULL,
    `cluster` VARCHAR(100) NOT NULL,
    `useTLS` BOOLEAN NOT NULL DEFAULT false,
    `events` JSON NOT NULL,
    `createdAt` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP,
    `updatedAt` TIMESTAMP NOT NULL,
    `instanceId` VARCHAR(191) NOT NULL,

    UNIQUE INDEX `Pusher_instanceId_key`(`instanceId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateIndex
CREATE INDEX `Chat_remoteJid_idx` ON `Chat`(`remoteJid`);

-- CreateIndex
CREATE INDEX `Contact_remoteJid_idx` ON `Contact`(`remoteJid`);

-- CreateIndex
CREATE INDEX `Setting_instanceId_idx` ON `Setting`(`instanceId`);

-- CreateIndex
CREATE INDEX `Webhook_instanceId_idx` ON `Webhook`(`instanceId`);

-- AddForeignKey
ALTER TABLE `Pusher` ADD CONSTRAINT `Pusher_instanceId_fkey` FOREIGN KEY (`instanceId`) REFERENCES `Instance`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- RenameIndex
ALTER TABLE `Chat` RENAME INDEX `Chat_instanceId_fkey` TO `Chat_instanceId_idx`;

-- RenameIndex
ALTER TABLE `Contact` RENAME INDEX `Contact_instanceId_fkey` TO `Contact_instanceId_idx`;

-- RenameIndex
ALTER TABLE `Message` RENAME INDEX `Message_instanceId_fkey` TO `Message_instanceId_idx`;

-- RenameIndex
ALTER TABLE `MessageUpdate` RENAME INDEX `MessageUpdate_instanceId_fkey` TO `MessageUpdate_instanceId_idx`;

-- RenameIndex
ALTER TABLE `MessageUpdate` RENAME INDEX `MessageUpdate_messageId_fkey` TO `MessageUpdate_messageId_idx`;



================================================
FILE: prisma/postgresql-migrations/migration_lock.toml
================================================
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"


================================================
FILE: prisma/postgresql-migrations/20240609181238_init/migration.sql
================================================
-- CreateEnum
CREATE TYPE "InstanceConnectionStatus" AS ENUM ('open', 'close', 'connecting');

-- CreateEnum
CREATE TYPE "DeviceMessage" AS ENUM ('ios', 'android', 'web', 'unknown', 'desktop');

-- CreateEnum
CREATE TYPE "TypebotSessionStatus" AS ENUM ('open', 'closed', 'paused');

-- CreateEnum
CREATE TYPE "TriggerType" AS ENUM ('all', 'keyword');

-- CreateEnum
CREATE TYPE "TriggerOperator" AS ENUM ('contains', 'equals', 'startsWith', 'endsWith');

-- CreateTable
CREATE TABLE "Instance" (
    "id" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "connectionStatus" "InstanceConnectionStatus" NOT NULL DEFAULT 'open',
    "ownerJid" VARCHAR(100),
    "profilePicUrl" VARCHAR(500),
    "integration" VARCHAR(100),
    "number" VARCHAR(100),
    "token" VARCHAR(255),
    "clientName" VARCHAR(100),
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP,

    CONSTRAINT "Instance_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Session" (
    "id" TEXT NOT NULL,
    "sessionId" TEXT NOT NULL,
    "creds" TEXT,
    "createdAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Chat" (
    "id" TEXT NOT NULL,
    "remoteJid" VARCHAR(100) NOT NULL,
    "labels" JSONB,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Chat_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Contact" (
    "id" TEXT NOT NULL,
    "remoteJid" VARCHAR(100) NOT NULL,
    "pushName" VARCHAR(100),
    "profilePicUrl" VARCHAR(500),
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Contact_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Message" (
    "id" TEXT NOT NULL,
    "key" JSONB NOT NULL,
    "pushName" VARCHAR(100),
    "participant" VARCHAR(100),
    "messageType" VARCHAR(100) NOT NULL,
    "message" JSONB NOT NULL,
    "contextInfo" JSONB,
    "source" "DeviceMessage" NOT NULL,
    "messageTimestamp" INTEGER NOT NULL,
    "chatwootMessageId" INTEGER,
    "chatwootInboxId" INTEGER,
    "chatwootConversationId" INTEGER,
    "chatwootContactInboxSourceId" VARCHAR(100),
    "chatwootIsRead" BOOLEAN,
    "instanceId" TEXT NOT NULL,
    "typebotSessionId" TEXT,

    CONSTRAINT "Message_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "MessageUpdate" (
    "id" TEXT NOT NULL,
    "keyId" VARCHAR(100) NOT NULL,
    "remoteJid" VARCHAR(100) NOT NULL,
    "fromMe" BOOLEAN NOT NULL,
    "participant" VARCHAR(100),
    "pollUpdates" JSONB,
    "status" VARCHAR(30) NOT NULL,
    "messageId" TEXT NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "MessageUpdate_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Webhook" (
    "id" TEXT NOT NULL,
    "url" VARCHAR(500) NOT NULL,
    "enabled" BOOLEAN DEFAULT true,
    "events" JSONB,
    "webhookByEvents" BOOLEAN DEFAULT false,
    "webhookBase64" BOOLEAN DEFAULT false,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Webhook_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Chatwoot" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN DEFAULT true,
    "accountId" VARCHAR(100),
    "token" VARCHAR(100),
    "url" VARCHAR(500),
    "nameInbox" VARCHAR(100),
    "signMsg" BOOLEAN DEFAULT false,
    "signDelimiter" VARCHAR(100),
    "number" VARCHAR(100),
    "reopenConversation" BOOLEAN DEFAULT false,
    "conversationPending" BOOLEAN DEFAULT false,
    "mergeBrazilContacts" BOOLEAN DEFAULT false,
    "importContacts" BOOLEAN DEFAULT false,
    "importMessages" BOOLEAN DEFAULT false,
    "daysLimitImportMessages" INTEGER,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Chatwoot_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Label" (
    "id" TEXT NOT NULL,
    "labelId" VARCHAR(100),
    "name" VARCHAR(100) NOT NULL,
    "color" VARCHAR(100) NOT NULL,
    "predefinedId" VARCHAR(100),
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Label_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Proxy" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT false,
    "host" VARCHAR(100) NOT NULL,
    "port" VARCHAR(100) NOT NULL,
    "protocol" VARCHAR(100) NOT NULL,
    "username" VARCHAR(100) NOT NULL,
    "password" VARCHAR(100) NOT NULL,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Proxy_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Setting" (
    "id" TEXT NOT NULL,
    "rejectCall" BOOLEAN NOT NULL DEFAULT false,
    "msgCall" VARCHAR(100),
    "groupsIgnore" BOOLEAN NOT NULL DEFAULT false,
    "alwaysOnline" BOOLEAN NOT NULL DEFAULT false,
    "readMessages" BOOLEAN NOT NULL DEFAULT false,
    "readStatus" BOOLEAN NOT NULL DEFAULT false,
    "syncFullHistory" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Setting_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Rabbitmq" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT false,
    "events" JSONB NOT NULL,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Rabbitmq_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Sqs" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT false,
    "events" JSONB NOT NULL,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Sqs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Websocket" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT false,
    "events" JSONB NOT NULL,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Websocket_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Typebot" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT true,
    "url" VARCHAR(500) NOT NULL,
    "typebot" VARCHAR(100) NOT NULL,
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP,
    "triggerType" "TriggerType",
    "triggerOperator" "TriggerOperator",
    "triggerValue" TEXT,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Typebot_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "TypebotSession" (
    "id" TEXT NOT NULL,
    "remoteJid" VARCHAR(100) NOT NULL,
    "pushName" VARCHAR(100),
    "sessionId" VARCHAR(100) NOT NULL,
    "status" VARCHAR(100) NOT NULL,
    "prefilledVariables" JSONB,
    "awaitUser" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "typebotId" TEXT NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "TypebotSession_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "TypebotSetting" (
    "id" TEXT NOT NULL,
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "TypebotSetting_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Instance_name_key" ON "Instance"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Instance_token_key" ON "Instance"("token");

-- CreateIndex
CREATE UNIQUE INDEX "Session_sessionId_key" ON "Session"("sessionId");

-- CreateIndex
CREATE UNIQUE INDEX "Webhook_instanceId_key" ON "Webhook"("instanceId");

-- CreateIndex
CREATE UNIQUE INDEX "Chatwoot_instanceId_key" ON "Chatwoot"("instanceId");

-- CreateIndex
CREATE UNIQUE INDEX "Label_labelId_key" ON "Label"("labelId");

-- CreateIndex
CREATE UNIQUE INDEX "Proxy_instanceId_key" ON "Proxy"("instanceId");

-- CreateIndex
CREATE UNIQUE INDEX "Setting_instanceId_key" ON "Setting"("instanceId");

-- CreateIndex
CREATE UNIQUE INDEX "Rabbitmq_instanceId_key" ON "Rabbitmq"("instanceId");

-- CreateIndex
CREATE UNIQUE INDEX "Sqs_instanceId_key" ON "Sqs"("instanceId");

-- CreateIndex
CREATE UNIQUE INDEX "Websocket_instanceId_key" ON "Websocket"("instanceId");

-- CreateIndex
CREATE UNIQUE INDEX "TypebotSetting_instanceId_key" ON "TypebotSetting"("instanceId");

-- AddForeignKey
ALTER TABLE "Session" ADD CONSTRAINT "Session_sessionId_fkey" FOREIGN KEY ("sessionId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Chat" ADD CONSTRAINT "Chat_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Contact" ADD CONSTRAINT "Contact_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Message" ADD CONSTRAINT "Message_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Message" ADD CONSTRAINT "Message_typebotSessionId_fkey" FOREIGN KEY ("typebotSessionId") REFERENCES "TypebotSession"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "MessageUpdate" ADD CONSTRAINT "MessageUpdate_messageId_fkey" FOREIGN KEY ("messageId") REFERENCES "Message"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "MessageUpdate" ADD CONSTRAINT "MessageUpdate_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Webhook" ADD CONSTRAINT "Webhook_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Chatwoot" ADD CONSTRAINT "Chatwoot_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Label" ADD CONSTRAINT "Label_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Proxy" ADD CONSTRAINT "Proxy_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Setting" ADD CONSTRAINT "Setting_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Rabbitmq" ADD CONSTRAINT "Rabbitmq_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Sqs" ADD CONSTRAINT "Sqs_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Websocket" ADD CONSTRAINT "Websocket_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Typebot" ADD CONSTRAINT "Typebot_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "TypebotSession" ADD CONSTRAINT "TypebotSession_typebotId_fkey" FOREIGN KEY ("typebotId") REFERENCES "Typebot"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "TypebotSession" ADD CONSTRAINT "TypebotSession_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "TypebotSetting" ADD CONSTRAINT "TypebotSetting_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240610144159_create_column_profile_name_instance/migration.sql
================================================
-- AlterTable
ALTER TABLE "Instance" ADD COLUMN     "profileName" VARCHAR(100);



================================================
FILE: prisma/postgresql-migrations/20240611125754_create_columns_whitelabel_chatwoot/migration.sql
================================================
-- AlterTable
ALTER TABLE "Chatwoot" ADD COLUMN     "logo" VARCHAR(500),
ADD COLUMN     "organization" VARCHAR(100);



================================================
FILE: prisma/postgresql-migrations/20240611202817_create_columns_debounce_time_typebot/migration.sql
================================================
-- AlterTable
ALTER TABLE "Typebot" ADD COLUMN     "debounceTime" INTEGER;

-- AlterTable
ALTER TABLE "TypebotSetting" ADD COLUMN     "debounceTime" INTEGER;



================================================
FILE: prisma/postgresql-migrations/20240712144948_add_business_id_column_to_instances/migration.sql
================================================
-- AlterTable
ALTER TABLE "Instance" ADD COLUMN     "businessId" VARCHAR(100);



================================================
FILE: prisma/postgresql-migrations/20240712150256_create_templates_table/migration.sql
================================================
-- CreateTable
CREATE TABLE "Template" (
    "id" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "language" VARCHAR(255) NOT NULL,
    "templateId" VARCHAR(255) NOT NULL,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Template_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Template_templateId_key" ON "Template"("templateId");

-- CreateIndex
CREATE UNIQUE INDEX "Template_instanceId_key" ON "Template"("instanceId");

-- AddForeignKey
ALTER TABLE "Template" ADD CONSTRAINT "Template_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240712155950_adjusts_in_templates_table/migration.sql
================================================
-- DropIndex
DROP INDEX "Template_instanceId_key";



================================================
FILE: prisma/postgresql-migrations/20240712162206_remove_templates_table/migration.sql
================================================
/*
  Warnings:

  - You are about to drop the `Template` table. If the table is not empty, all the data it contains will be lost.

*/
-- DropForeignKey
ALTER TABLE "Template" DROP CONSTRAINT "Template_instanceId_fkey";

-- DropTable
DROP TABLE "Template";



================================================
FILE: prisma/postgresql-migrations/20240712223655_column_fallback_typebot/migration.sql
================================================
-- AlterEnum
ALTER TYPE "TriggerOperator" ADD VALUE 'regex';

-- AlterTable
ALTER TABLE "TypebotSetting" ADD COLUMN     "typebotIdFallback" VARCHAR(100);

-- AddForeignKey
ALTER TABLE "TypebotSetting" ADD CONSTRAINT "TypebotSetting_typebotIdFallback_fkey" FOREIGN KEY ("typebotIdFallback") REFERENCES "Typebot"("id") ON DELETE SET NULL ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240712230631_column_ignore_jids_typebot/migration.sql
================================================
-- AlterTable
ALTER TABLE "Typebot" ADD COLUMN     "ignoreJids" JSONB;

-- AlterTable
ALTER TABLE "TypebotSetting" ADD COLUMN     "ignoreJids" JSONB;



================================================
FILE: prisma/postgresql-migrations/20240713184337_add_media_table/migration.sql
================================================
-- CreateTable
CREATE TABLE "Media" (
    "id" TEXT NOT NULL,
    "fileName" VARCHAR(500) NOT NULL,
    "type" VARCHAR(100) NOT NULL,
    "mimetype" VARCHAR(100) NOT NULL,
    "createdAt" DATE DEFAULT CURRENT_TIMESTAMP,
    "messageId" TEXT NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Media_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Media_fileName_key" ON "Media"("fileName");

-- CreateIndex
CREATE UNIQUE INDEX "Media_messageId_key" ON "Media"("messageId");

-- AddForeignKey
ALTER TABLE "Media" ADD CONSTRAINT "Media_messageId_fkey" FOREIGN KEY ("messageId") REFERENCES "Message"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Media" ADD CONSTRAINT "Media_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240718121437_add_openai_tables/migration.sql
================================================
-- AlterTable
ALTER TABLE "Message" ADD COLUMN     "openaiSessionId" TEXT;

-- CreateTable
CREATE TABLE "OpenaiCreds" (
    "id" TEXT NOT NULL,
    "apiKey" VARCHAR(255) NOT NULL,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "OpenaiCreds_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "OpenaiBot" (
    "id" TEXT NOT NULL,
    "botType" VARCHAR(100) NOT NULL,
    "assistantId" VARCHAR(255),
    "model" VARCHAR(100),
    "systemMessages" JSONB,
    "assistantMessages" JSONB,
    "userMessages" JSONB,
    "maxTokens" INTEGER,
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "triggerType" "TriggerType",
    "triggerOperator" "TriggerOperator",
    "triggerValue" TEXT,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "openaiCredsId" TEXT NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "OpenaiBot_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "OpenaiSession" (
    "id" TEXT NOT NULL,
    "sessionId" VARCHAR(255) NOT NULL,
    "remoteJid" VARCHAR(100) NOT NULL,
    "status" "TypebotSessionStatus" NOT NULL,
    "awaitUser" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "openaiBotId" TEXT NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "OpenaiSession_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "OpenaiSetting" (
    "id" TEXT NOT NULL,
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "openaiCredsId" TEXT NOT NULL,
    "openaiIdFallback" VARCHAR(100),
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "OpenaiSetting_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "OpenaiCreds_apiKey_key" ON "OpenaiCreds"("apiKey");

-- CreateIndex
CREATE UNIQUE INDEX "OpenaiCreds_instanceId_key" ON "OpenaiCreds"("instanceId");

-- CreateIndex
CREATE UNIQUE INDEX "OpenaiBot_assistantId_key" ON "OpenaiBot"("assistantId");

-- CreateIndex
CREATE UNIQUE INDEX "OpenaiSetting_instanceId_key" ON "OpenaiSetting"("instanceId");

-- AddForeignKey
ALTER TABLE "Message" ADD CONSTRAINT "Message_openaiSessionId_fkey" FOREIGN KEY ("openaiSessionId") REFERENCES "OpenaiSession"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OpenaiCreds" ADD CONSTRAINT "OpenaiCreds_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OpenaiBot" ADD CONSTRAINT "OpenaiBot_openaiCredsId_fkey" FOREIGN KEY ("openaiCredsId") REFERENCES "OpenaiCreds"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OpenaiBot" ADD CONSTRAINT "OpenaiBot_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OpenaiSession" ADD CONSTRAINT "OpenaiSession_openaiBotId_fkey" FOREIGN KEY ("openaiBotId") REFERENCES "OpenaiBot"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OpenaiSession" ADD CONSTRAINT "OpenaiSession_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OpenaiSetting" ADD CONSTRAINT "OpenaiSetting_openaiCredsId_fkey" FOREIGN KEY ("openaiCredsId") REFERENCES "OpenaiCreds"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OpenaiSetting" ADD CONSTRAINT "OpenaiSetting_openaiIdFallback_fkey" FOREIGN KEY ("openaiIdFallback") REFERENCES "OpenaiBot"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "OpenaiSetting" ADD CONSTRAINT "OpenaiSetting_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240718123923_adjusts_openai_tables/migration.sql
================================================
-- AlterTable
ALTER TABLE "OpenaiBot" ADD COLUMN     "enabled" BOOLEAN NOT NULL DEFAULT true;



================================================
FILE: prisma/postgresql-migrations/20240722173259_add_name_column_to_openai_creds/migration.sql
================================================
/*
  Warnings:

  - A unique constraint covering the columns `[name]` on the table `OpenaiCreds` will be added. If there are existing duplicate values, this will fail.

*/
-- AlterTable
ALTER TABLE "OpenaiCreds" ADD COLUMN     "name" VARCHAR(255),
ALTER COLUMN "apiKey" DROP NOT NULL;

-- CreateIndex
CREATE UNIQUE INDEX "OpenaiCreds_name_key" ON "OpenaiCreds"("name");



================================================
FILE: prisma/postgresql-migrations/20240722173518_add_name_column_to_openai_creds/migration.sql
================================================
-- DropIndex
DROP INDEX "OpenaiCreds_instanceId_key";



================================================
FILE: prisma/postgresql-migrations/20240723152648_adjusts_in_column_openai_creds/migration.sql
================================================
/*
  Warnings:

  - A unique constraint covering the columns `[openaiCredsId]` on the table `OpenaiSetting` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateIndex
CREATE UNIQUE INDEX "OpenaiSetting_openaiCredsId_key" ON "OpenaiSetting"("openaiCredsId");



================================================
FILE: prisma/postgresql-migrations/20240723200254_add_webhookurl_on_message/migration.sql
================================================
-- AlterTable
ALTER TABLE "Message" ADD COLUMN     "webhookUrl" VARCHAR(500);



================================================
FILE: prisma/postgresql-migrations/20240725184147_create_template_table/migration.sql
================================================
-- CreateTable
CREATE TABLE "Template" (
    "id" TEXT NOT NULL,
    "templateId" VARCHAR(255) NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "template" JSONB NOT NULL,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Template_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Template_templateId_key" ON "Template"("templateId");

-- CreateIndex
CREATE UNIQUE INDEX "Template_name_key" ON "Template"("name");

-- AddForeignKey
ALTER TABLE "Template" ADD CONSTRAINT "Template_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240725202651_add_webhook_url_template_table/migration.sql
================================================
-- AlterTable
ALTER TABLE "Template" ADD COLUMN     "webhookUrl" VARCHAR(500);



================================================
FILE: prisma/postgresql-migrations/20240725221646_modify_token_instance_table/migration.sql
================================================
-- DropIndex
DROP INDEX "Instance_token_key";



================================================
FILE: prisma/postgresql-migrations/20240729115127_modify_trigger_type_openai_typebot_table/migration.sql
================================================
-- AlterEnum
ALTER TYPE "TriggerType" ADD VALUE 'none';



================================================
FILE: prisma/postgresql-migrations/20240729180347_modify_typebot_session_status_openai_typebot_table/migration.sql
================================================
/*
  Warnings:

  - The values [open] on the enum `TypebotSessionStatus` will be removed. If these variants are still used in the database, this will fail.
  - Changed the type of `status` on the `TypebotSession` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.

*/
-- AlterEnum
BEGIN;
CREATE TYPE "TypebotSessionStatus_new" AS ENUM ('opened', 'closed', 'paused');
ALTER TABLE "TypebotSession" ALTER COLUMN "status" TYPE "TypebotSessionStatus_new" USING ("status"::text::"TypebotSessionStatus_new");
ALTER TABLE "OpenaiSession" ALTER COLUMN "status" TYPE "TypebotSessionStatus_new" USING ("status"::text::"TypebotSessionStatus_new");
ALTER TYPE "TypebotSessionStatus" RENAME TO "TypebotSessionStatus_old";
ALTER TYPE "TypebotSessionStatus_new" RENAME TO "TypebotSessionStatus";
DROP TYPE "TypebotSessionStatus_old";
COMMIT;

-- AlterTable
ALTER TABLE "TypebotSession" DROP COLUMN "status",
ADD COLUMN     "status" "TypebotSessionStatus" NOT NULL;



================================================
FILE: prisma/postgresql-migrations/20240730152156_create_dify_tables/migration.sql
================================================
/*
  Warnings:

  - Changed the type of `botType` on the `OpenaiBot` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.

*/
-- CreateEnum
CREATE TYPE "OpenaiBotType" AS ENUM ('assistant', 'chatCompletion');

-- CreateEnum
CREATE TYPE "DifyBotType" AS ENUM ('chatBot', 'textGenerator', 'agent', 'workflow');

-- DropIndex
DROP INDEX "OpenaiBot_assistantId_key";

-- AlterTable
ALTER TABLE "Message" ADD COLUMN     "difySessionId" TEXT;

-- AlterTable
ALTER TABLE "OpenaiBot" DROP COLUMN "botType",
ADD COLUMN     "botType" "OpenaiBotType" NOT NULL;

-- CreateTable
CREATE TABLE "Dify" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT true,
    "botType" "DifyBotType" NOT NULL,
    "apiUrl" VARCHAR(255),
    "apiKey" VARCHAR(255),
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "triggerType" "TriggerType",
    "triggerOperator" "TriggerOperator",
    "triggerValue" TEXT,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Dify_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "DifySession" (
    "id" TEXT NOT NULL,
    "sessionId" VARCHAR(255) NOT NULL,
    "remoteJid" VARCHAR(100) NOT NULL,
    "status" "TypebotSessionStatus" NOT NULL,
    "awaitUser" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "difyId" TEXT NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "DifySession_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "DifySetting" (
    "id" TEXT NOT NULL,
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "difyIdFallback" VARCHAR(100),
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "DifySetting_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "DifySetting_instanceId_key" ON "DifySetting"("instanceId");

-- AddForeignKey
ALTER TABLE "Message" ADD CONSTRAINT "Message_difySessionId_fkey" FOREIGN KEY ("difySessionId") REFERENCES "DifySession"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Dify" ADD CONSTRAINT "Dify_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DifySession" ADD CONSTRAINT "DifySession_difyId_fkey" FOREIGN KEY ("difyId") REFERENCES "Dify"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DifySession" ADD CONSTRAINT "DifySession_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DifySetting" ADD CONSTRAINT "DifySetting_difyIdFallback_fkey" FOREIGN KEY ("difyIdFallback") REFERENCES "Dify"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "DifySetting" ADD CONSTRAINT "DifySetting_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240801193907_add_column_speech_to_text_openai_setting_table/migration.sql
================================================
-- AlterTable
ALTER TABLE "OpenaiSetting" ADD COLUMN     "speechToText" BOOLEAN DEFAULT false;



================================================
FILE: prisma/postgresql-migrations/20240803163908_add_column_description_on_integrations_table/migration.sql
================================================
-- AlterTable
ALTER TABLE "Dify" ADD COLUMN     "description" VARCHAR(255);

-- AlterTable
ALTER TABLE "OpenaiBot" ADD COLUMN     "description" VARCHAR(255);

-- AlterTable
ALTER TABLE "Typebot" ADD COLUMN     "description" VARCHAR(255);



================================================
FILE: prisma/postgresql-migrations/20240808210239_add_column_function_url_openaibot_table/migration.sql
================================================
-- AlterTable
ALTER TABLE "Instance" ADD COLUMN     "disconnectionAt" TIMESTAMP,
ADD COLUMN     "disconnectionObject" JSONB,
ADD COLUMN     "disconnectionReasonCode" INTEGER;

-- AlterTable
ALTER TABLE "OpenaiBot" ADD COLUMN     "functionUrl" VARCHAR(500);



================================================
FILE: prisma/postgresql-migrations/20240811021156_add_chat_name_column/migration.sql
================================================
-- AlterTable
ALTER TABLE "Chat" ADD COLUMN     "name" VARCHAR(100);



================================================
FILE: prisma/postgresql-migrations/20240811183328_add_unique_index_for_remoted_jid_and_instance_in_contacts/migration.sql
================================================
/*
  Warnings:

  - A unique constraint covering the columns `[remoteJid,instanceId]` on the table `Contact` will be added. If there are existing duplicate values, this will fail.

*/
-- Remove the duplicates
DELETE FROM "Contact"
WHERE ctid NOT IN (
  SELECT min(ctid)
  FROM "Contact"
  GROUP BY "remoteJid", "instanceId"
);


-- CreateIndex
CREATE UNIQUE INDEX "Contact_remoteJid_instanceId_key" ON "Contact"("remoteJid", "instanceId");



================================================
FILE: prisma/postgresql-migrations/20240813003116_make_label_unique_for_instance/migration.sql
================================================
/*
  Warnings:

  - A unique constraint covering the columns `[labelId,instanceId]` on the table `Label` will be added. If there are existing duplicate values, this will fail.

*/
-- DropIndex
DROP INDEX "Label_labelId_key";

-- CreateIndex
CREATE UNIQUE INDEX "Label_labelId_instanceId_key" ON "Label"("labelId", "instanceId");



================================================
FILE: prisma/postgresql-migrations/20240814173033_add_ignore_jids_chatwoot/migration.sql
================================================
-- AlterTable
ALTER TABLE "Chatwoot" ADD COLUMN     "ignoreJids" JSONB;



================================================
FILE: prisma/postgresql-migrations/20240814202359_integrations_unification/migration.sql
================================================
/*
  Warnings:

  - You are about to drop the column `difySessionId` on the `Message` table. All the data in the column will be lost.
  - You are about to drop the column `openaiSessionId` on the `Message` table. All the data in the column will be lost.
  - You are about to drop the column `typebotSessionId` on the `Message` table. All the data in the column will be lost.
  - You are about to drop the `DifySession` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `OpenaiSession` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `TypebotSession` table. If the table is not empty, all the data it contains will be lost.

*/
-- CreateEnum
CREATE TYPE "SessionStatus" AS ENUM ('opened', 'closed', 'paused');

-- DropForeignKey
ALTER TABLE "DifySession" DROP CONSTRAINT "DifySession_difyId_fkey";

-- DropForeignKey
ALTER TABLE "DifySession" DROP CONSTRAINT "DifySession_instanceId_fkey";

-- DropForeignKey
ALTER TABLE "Message" DROP CONSTRAINT "Message_difySessionId_fkey";

-- DropForeignKey
ALTER TABLE "Message" DROP CONSTRAINT "Message_openaiSessionId_fkey";

-- DropForeignKey
ALTER TABLE "Message" DROP CONSTRAINT "Message_typebotSessionId_fkey";

-- DropForeignKey
ALTER TABLE "OpenaiSession" DROP CONSTRAINT "OpenaiSession_instanceId_fkey";

-- DropForeignKey
ALTER TABLE "OpenaiSession" DROP CONSTRAINT "OpenaiSession_openaiBotId_fkey";

-- DropForeignKey
ALTER TABLE "TypebotSession" DROP CONSTRAINT "TypebotSession_instanceId_fkey";

-- DropForeignKey
ALTER TABLE "TypebotSession" DROP CONSTRAINT "TypebotSession_typebotId_fkey";

-- AlterTable
ALTER TABLE "Message" DROP COLUMN "difySessionId",
DROP COLUMN "openaiSessionId",
DROP COLUMN "typebotSessionId",
ADD COLUMN     "sessionId" TEXT;

-- DropTable
DROP TABLE "DifySession";

-- DropTable
DROP TABLE "OpenaiSession";

-- DropTable
DROP TABLE "TypebotSession";

-- DropEnum
DROP TYPE "TypebotSessionStatus";

-- CreateTable
CREATE TABLE "IntegrationSession" (
    "id" TEXT NOT NULL,
    "sessionId" VARCHAR(255) NOT NULL,
    "remoteJid" VARCHAR(100) NOT NULL,
    "pushName" TEXT,
    "status" "SessionStatus" NOT NULL,
    "awaitUser" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,
    "parameters" JSONB,
    "openaiBotId" TEXT,
    "difyId" TEXT,
    "typebotId" TEXT,

    CONSTRAINT "IntegrationSession_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "Message" ADD CONSTRAINT "Message_sessionId_fkey" FOREIGN KEY ("sessionId") REFERENCES "IntegrationSession"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "IntegrationSession" ADD CONSTRAINT "IntegrationSession_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "IntegrationSession" ADD CONSTRAINT "IntegrationSession_openaiBotId_fkey" FOREIGN KEY ("openaiBotId") REFERENCES "OpenaiBot"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "IntegrationSession" ADD CONSTRAINT "IntegrationSession_difyId_fkey" FOREIGN KEY ("difyId") REFERENCES "Dify"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "IntegrationSession" ADD CONSTRAINT "IntegrationSession_typebotId_fkey" FOREIGN KEY ("typebotId") REFERENCES "Typebot"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240817110155_add_trigger_type_advanced/migration.sql
================================================
-- AlterEnum
ALTER TYPE "TriggerType" ADD VALUE 'advanced';



================================================
FILE: prisma/postgresql-migrations/20240819154941_add_context_to_integration_session/migration.sql
================================================
-- AlterTable
ALTER TABLE "IntegrationSession" ADD COLUMN     "context" JSONB;



================================================
FILE: prisma/postgresql-migrations/20240821120816_bot_id_integration_session/migration.sql
================================================
/*
  Warnings:

  - You are about to drop the column `difyId` on the `IntegrationSession` table. All the data in the column will be lost.
  - You are about to drop the column `openaiBotId` on the `IntegrationSession` table. All the data in the column will be lost.
  - You are about to drop the column `typebotId` on the `IntegrationSession` table. All the data in the column will be lost.

*/
-- DropForeignKey
ALTER TABLE "IntegrationSession" DROP CONSTRAINT "IntegrationSession_difyId_fkey";

-- DropForeignKey
ALTER TABLE "IntegrationSession" DROP CONSTRAINT "IntegrationSession_openaiBotId_fkey";

-- DropForeignKey
ALTER TABLE "IntegrationSession" DROP CONSTRAINT "IntegrationSession_typebotId_fkey";

-- AlterTable
ALTER TABLE "IntegrationSession" DROP COLUMN "difyId",
DROP COLUMN "openaiBotId",
DROP COLUMN "typebotId",
ADD COLUMN     "botId" TEXT;



================================================
FILE: prisma/postgresql-migrations/20240821171327_add_generic_bot_table/migration.sql
================================================
-- CreateTable
CREATE TABLE "GenericBot" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT true,
    "description" VARCHAR(255),
    "apiUrl" VARCHAR(255),
    "apiKey" VARCHAR(255),
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "triggerType" "TriggerType",
    "triggerOperator" "TriggerOperator",
    "triggerValue" TEXT,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "GenericBot_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "GenericSetting" (
    "id" TEXT NOT NULL,
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "botIdFallback" VARCHAR(100),
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "GenericSetting_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "GenericSetting_instanceId_key" ON "GenericSetting"("instanceId");

-- AddForeignKey
ALTER TABLE "GenericBot" ADD CONSTRAINT "GenericBot_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "GenericSetting" ADD CONSTRAINT "GenericSetting_botIdFallback_fkey" FOREIGN KEY ("botIdFallback") REFERENCES "GenericBot"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "GenericSetting" ADD CONSTRAINT "GenericSetting_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240821194524_add_flowise_table/migration.sql
================================================
-- CreateTable
CREATE TABLE "Flowise" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT true,
    "description" VARCHAR(255),
    "apiUrl" VARCHAR(255),
    "apiKey" VARCHAR(255),
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "triggerType" "TriggerType",
    "triggerOperator" "TriggerOperator",
    "triggerValue" TEXT,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Flowise_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "FlowiseSetting" (
    "id" TEXT NOT NULL,
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "flowiseIdFallback" VARCHAR(100),
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "FlowiseSetting_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "FlowiseSetting_instanceId_key" ON "FlowiseSetting"("instanceId");

-- AddForeignKey
ALTER TABLE "Flowise" ADD CONSTRAINT "Flowise_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "FlowiseSetting" ADD CONSTRAINT "FlowiseSetting_flowiseIdFallback_fkey" FOREIGN KEY ("flowiseIdFallback") REFERENCES "Flowise"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "FlowiseSetting" ADD CONSTRAINT "FlowiseSetting_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240824161333_add_type_on_integration_sessions/migration.sql
================================================
-- AlterTable
ALTER TABLE "IntegrationSession" ADD COLUMN     "type" VARCHAR(100);



================================================
FILE: prisma/postgresql-migrations/20240825130616_change_to_evolution_bot/migration.sql
================================================
/*
  Warnings:

  - You are about to drop the `GenericBot` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `GenericSetting` table. If the table is not empty, all the data it contains will be lost.

*/
-- DropForeignKey
ALTER TABLE "GenericBot" DROP CONSTRAINT "GenericBot_instanceId_fkey";

-- DropForeignKey
ALTER TABLE "GenericSetting" DROP CONSTRAINT "GenericSetting_botIdFallback_fkey";

-- DropForeignKey
ALTER TABLE "GenericSetting" DROP CONSTRAINT "GenericSetting_instanceId_fkey";

-- DropTable
DROP TABLE "GenericBot";

-- DropTable
DROP TABLE "GenericSetting";

-- CreateTable
CREATE TABLE "EvolutionBot" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT true,
    "description" VARCHAR(255),
    "apiUrl" VARCHAR(255),
    "apiKey" VARCHAR(255),
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "triggerType" "TriggerType",
    "triggerOperator" "TriggerOperator",
    "triggerValue" TEXT,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "EvolutionBot_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "EvolutionBotSetting" (
    "id" TEXT NOT NULL,
    "expire" INTEGER DEFAULT 0,
    "keywordFinish" VARCHAR(100),
    "delayMessage" INTEGER,
    "unknownMessage" VARCHAR(100),
    "listeningFromMe" BOOLEAN DEFAULT false,
    "stopBotFromMe" BOOLEAN DEFAULT false,
    "keepOpen" BOOLEAN DEFAULT false,
    "debounceTime" INTEGER,
    "ignoreJids" JSONB,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "botIdFallback" VARCHAR(100),
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "EvolutionBotSetting_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "EvolutionBotSetting_instanceId_key" ON "EvolutionBotSetting"("instanceId");

-- AddForeignKey
ALTER TABLE "EvolutionBot" ADD CONSTRAINT "EvolutionBot_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "EvolutionBotSetting" ADD CONSTRAINT "EvolutionBotSetting_botIdFallback_fkey" FOREIGN KEY ("botIdFallback") REFERENCES "EvolutionBot"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "EvolutionBotSetting" ADD CONSTRAINT "EvolutionBotSetting_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20240828140837_add_is_on_whatsapp_table/migration.sql
================================================
-- CreateTable
CREATE TABLE "is_on_whatsapp" (
    "id" TEXT NOT NULL,
    "remote_jid" VARCHAR(100) NOT NULL,
    "name" TEXT,
    "jid_options" TEXT NOT NULL,
    "created_at" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP NOT NULL,

    CONSTRAINT "is_on_whatsapp_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "is_on_whatsapp_remote_jid_key" ON "is_on_whatsapp"("remote_jid");



================================================
FILE: prisma/postgresql-migrations/20240828141556_remove_name_column_from_on_whatsapp_table/migration.sql
================================================
/*
  Warnings:

  - You are about to drop the column `name` on the `is_on_whatsapp` table. All the data in the column will be lost.

*/
-- AlterTable
ALTER TABLE "is_on_whatsapp" DROP COLUMN "name";



================================================
FILE: prisma/postgresql-migrations/20240830193533_changed_table_case/migration.sql
================================================
/*
  Warnings:

  - You are about to drop the `is_on_whatsapp` table. If the table is not empty, all the data it contains will be lost.

*/
-- DropTable
DROP TABLE "is_on_whatsapp";

-- CreateTable
CREATE TABLE "IsOnWhatsapp" (
    "id" TEXT NOT NULL,
    "remoteJid" VARCHAR(100) NOT NULL,
    "jidOptions" TEXT NOT NULL,
    "createdAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,

    CONSTRAINT "IsOnWhatsapp_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "IsOnWhatsapp_remoteJid_key" ON "IsOnWhatsapp"("remoteJid");



================================================
FILE: prisma/postgresql-migrations/20240906202019_add_headers_on_webhook_config/migration.sql
================================================
-- AlterTable
ALTER TABLE "Webhook" ADD COLUMN     "headers" JSONB;



================================================
FILE: prisma/postgresql-migrations/20241001180457_add_message_status/migration.sql
================================================
-- AlterTable
ALTER TABLE "Message" ADD COLUMN     "status" INTEGER;



================================================
FILE: prisma/postgresql-migrations/20241006130306_alter_status_on_message_table/migration.sql
================================================
-- AlterTable
ALTER TABLE "Message"
ALTER COLUMN "status"
SET
    DATA TYPE VARCHAR(30);

UPDATE "Message" SET "status" = 'PENDING';


================================================
FILE: prisma/postgresql-migrations/20241007164026_add_unread_messages_on_chat_table/migration.sql
================================================
-- AlterTable
ALTER TABLE "Chat" ADD COLUMN     "unreadMessages" INTEGER NOT NULL DEFAULT 0;



================================================
FILE: prisma/postgresql-migrations/20241011085129_create_pusher_table/migration.sql
================================================
-- CreateTable
CREATE TABLE "Pusher" (
    "id" TEXT NOT NULL,
    "enabled" BOOLEAN NOT NULL DEFAULT false,
    "appId" VARCHAR(100) NOT NULL,
    "key" VARCHAR(100) NOT NULL,
    "secret" VARCHAR(100) NOT NULL,
    "cluster" VARCHAR(100) NOT NULL,
    "useTLS" BOOLEAN NOT NULL DEFAULT false,
    "events" JSONB NOT NULL,
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL,
    "instanceId" TEXT NOT NULL,

    CONSTRAINT "Pusher_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Pusher_instanceId_key" ON "Pusher"("instanceId");

-- AddForeignKey
ALTER TABLE "Pusher" ADD CONSTRAINT "Pusher_instanceId_fkey" FOREIGN KEY ("instanceId") REFERENCES "Instance"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
FILE: prisma/postgresql-migrations/20241011100803_split_messages_and_time_per_char_integrations/migration.sql
================================================
-- AlterTable
ALTER TABLE "Dify" ADD COLUMN     "splitMessages" BOOLEAN DEFAULT false,
ADD COLUMN     "timePerChar" INTEGER DEFAULT 50;

-- AlterTable
ALTER TABLE "DifySetting" ADD COLUMN     "splitMessages" BOOLEAN DEFAULT false,
ADD COLUMN     "timePerChar" INTEGER DEFAULT 50;

-- AlterTable
ALTER TABLE "EvolutionBot" ADD COLUMN     "splitMessages" BOOLEAN DEFAULT false,
ADD COLUMN     "timePerChar" INTEGER DEFAULT 50;

-- AlterTable
ALTER TABLE "EvolutionBotSetting" ADD COLUMN     "splitMessages" BOOLEAN DEFAULT false,
ADD COLUMN     "timePerChar" INTEGER DEFAULT 50;

-- AlterTable
ALTER TABLE "Flowise" ADD COLUMN     "splitMessages" BOOLEAN DEFAULT false,
ADD COLUMN     "timePerChar" INTEGER DEFAULT 50;

-- AlterTable
ALTER TABLE "FlowiseSetting" ADD COLUMN     "splitMessages" BOOLEAN DEFAULT false,
ADD COLUMN     "timePerChar" INTEGER DEFAULT 50;

-- AlterTable
ALTER TABLE "OpenaiBot" ADD COLUMN     "splitMessages" BOOLEAN DEFAULT false,
ADD COLUMN     "timePerChar" INTEGER DEFAULT 50;

-- AlterTable
ALTER TABLE "OpenaiSetting" ADD COLUMN     "splitMessages" BOOLEAN DEFAULT false,
ADD COLUMN     "timePerChar" INTEGER DEFAULT 50;



================================================
FILE: prisma/postgresql-migrations/20241017144950_create_index/migration.sql
================================================
-- CreateIndex
CREATE INDEX "Chat_instanceId_idx" ON "Chat"("instanceId");

-- CreateIndex
CREATE INDEX "Chat_remoteJid_idx" ON "Chat"("remoteJid");

-- CreateIndex
CREATE INDEX "Contact_remoteJid_idx" ON "Contact"("remoteJid");

-- CreateIndex
CREATE INDEX "Contact_instanceId_idx" ON "Contact"("instanceId");

-- CreateIndex
CREATE INDEX "Message_instanceId_idx" ON "Message"("instanceId");

-- CreateIndex
CREATE INDEX "MessageUpdate_instanceId_idx" ON "MessageUpdate"("instanceId");

-- CreateIndex
CREATE INDEX "MessageUpdate_messageId_idx" ON "MessageUpdate"("messageId");

-- CreateIndex
CREATE INDEX "Setting_instanceId_idx" ON "Setting"("instanceId");

-- CreateIndex
CREATE INDEX "Webhook_instanceId_idx" ON "Webhook"("instanceId");



================================================
FILE: prisma/postgresql-migrations/20250116001415_add_wavoip_token_to_settings_table/migration.sql
================================================
/*
Warnings:

- A unique constraint covering the columns `[remoteJid,instanceId]` on the table `Chat` will be added. If there are existing duplicate values, this will fail.

*/

-- AlterTable
DO $$ 
BEGIN 
    IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_name = 'Setting'
        AND column_name = 'wavoipToken'
    ) THEN
        ALTER TABLE "Setting" ADD COLUMN "wavoipToken" VARCHAR(100);
    END IF;
END $$;



================================================
FILE: src/main.ts
================================================
// Import this first from sentry instrument!
import '@utils/instrumentSentry';

// Now import other modules
import { ProviderFiles } from '@api/provider/sessions';
import { PrismaRepository } from '@api/repository/repository.service';
import { HttpStatus, router } from '@api/routes/index.router';
import { eventManager, waMonitor } from '@api/server.module';
import { Auth, configService, Cors, HttpServer, ProviderSession, Webhook } from '@config/env.config';
import { onUnexpectedError } from '@config/error.config';
import { Logger } from '@config/logger.config';
import { ROOT_DIR } from '@config/path.config';
import * as Sentry from '@sentry/node';
import { ServerUP } from '@utils/server-up';
import axios from 'axios';
import compression from 'compression';
import cors from 'cors';
import express, { json, NextFunction, Request, Response, urlencoded } from 'express';
import { join } from 'path';

function initWA() {
  waMonitor.loadInstance();
}

async function bootstrap() {
  const logger = new Logger('SERVER');
  const app = express();

  let providerFiles: ProviderFiles = null;
  if (configService.get<ProviderSession>('PROVIDER').ENABLED) {
    providerFiles = new ProviderFiles(configService);
    await providerFiles.onModuleInit();
    logger.info('Provider:Files - ON');
  }

  const prismaRepository = new PrismaRepository(configService);
  await prismaRepository.onModuleInit();

  app.use(
    cors({
      origin(requestOrigin, callback) {
        const { ORIGIN } = configService.get<Cors>('CORS');
        if (ORIGIN.includes('*')) {
          return callback(null, true);
        }
        if (ORIGIN.indexOf(requestOrigin) !== -1) {
          return callback(null, true);
        }
        return callback(new Error('Not allowed by CORS'));
      },
      methods: [...configService.get<Cors>('CORS').METHODS],
      credentials: configService.get<Cors>('CORS').CREDENTIALS,
    }),
    urlencoded({ extended: true, limit: '136mb' }),
    json({ limit: '136mb' }),
    compression(),
  );

  app.set('view engine', 'hbs');
  app.set('views', join(ROOT_DIR, 'views'));
  app.use(express.static(join(ROOT_DIR, 'public')));

  app.use('/store', express.static(join(ROOT_DIR, 'store')));

  app.use('/', router);

  app.use(
    (err: Error, req: Request, res: Response, next: NextFunction) => {
      if (err) {
        const webhook = configService.get<Webhook>('WEBHOOK');

        if (webhook.EVENTS.ERRORS_WEBHOOK && webhook.EVENTS.ERRORS_WEBHOOK != '' && webhook.EVENTS.ERRORS) {
          const tzoffset = new Date().getTimezoneOffset() * 60000; //offset in milliseconds
          const localISOTime = new Date(Date.now() - tzoffset).toISOString();
          const now = localISOTime;
          const globalApiKey = configService.get<Auth>('AUTHENTICATION').API_KEY.KEY;
          const serverUrl = configService.get<HttpServer>('SERVER').URL;

          const errorData = {
            event: 'error',
            data: {
              error: err['error'] || 'Internal Server Error',
              message: err['message'] || 'Internal Server Error',
              status: err['status'] || 500,
              response: {
                message: err['message'] || 'Internal Server Error',
              },
            },
            date_time: now,
            api_key: globalApiKey,
            server_url: serverUrl,
          };

          logger.error(errorData);

          const baseURL = webhook.EVENTS.ERRORS_WEBHOOK;
          const httpService = axios.create({ baseURL });

          httpService.post('', errorData);
        }

        return res.status(err['status'] || 500).json({
          status: err['status'] || 500,
          error: err['error'] || 'Internal Server Error',
          response: {
            message: err['message'] || 'Internal Server Error',
          },
        });
      }

      next();
    },
    (req: Request, res: Response, next: NextFunction) => {
      const { method, url } = req;

      res.status(HttpStatus.NOT_FOUND).json({
        status: HttpStatus.NOT_FOUND,
        error: 'Not Found',
        response: {
          message: [`Cannot ${method.toUpperCase()} ${url}`],
        },
      });

      next();
    },
  );

  const httpServer = configService.get<HttpServer>('SERVER');

  ServerUP.app = app;
  const server = ServerUP[httpServer.TYPE];

  eventManager.init(server);

  if (process.env.SENTRY_DSN) {
    logger.info('Sentry - ON');

    // Add this after all routes,
    // but before any and other error-handling middlewares are defined
    Sentry.setupExpressErrorHandler(app);
  }

  server.listen(httpServer.PORT, () => logger.log(httpServer.TYPE.toUpperCase() + ' - ON: ' + httpServer.PORT));

  initWA();

  onUnexpectedError();
}

bootstrap();



================================================
FILE: src/@types/express.d.ts
================================================
import { Multer } from 'multer';

declare global {
  namespace Express {
    interface Request {
      file?: Multer.File;
    }
  }
}



================================================
FILE: src/api/server.module.ts
================================================
import { CacheEngine } from '@cache/cacheengine';
import { Chatwoot, configService, ProviderSession } from '@config/env.config';
import { eventEmitter } from '@config/event.config';
import { Logger } from '@config/logger.config';

import { CallController } from './controllers/call.controller';
import { ChatController } from './controllers/chat.controller';
import { GroupController } from './controllers/group.controller';
import { InstanceController } from './controllers/instance.controller';
import { LabelController } from './controllers/label.controller';
import { ProxyController } from './controllers/proxy.controller';
import { SendMessageController } from './controllers/sendMessage.controller';
import { SettingsController } from './controllers/settings.controller';
import { TemplateController } from './controllers/template.controller';
import { ChannelController } from './integrations/channel/channel.controller';
import { EvolutionController } from './integrations/channel/evolution/evolution.controller';
import { MetaController } from './integrations/channel/meta/meta.controller';
import { BaileysController } from './integrations/channel/whatsapp/baileys.controller';
import { ChatbotController } from './integrations/chatbot/chatbot.controller';
import { ChatwootController } from './integrations/chatbot/chatwoot/controllers/chatwoot.controller';
import { ChatwootService } from './integrations/chatbot/chatwoot/services/chatwoot.service';
import { DifyController } from './integrations/chatbot/dify/controllers/dify.controller';
import { DifyService } from './integrations/chatbot/dify/services/dify.service';
import { EvolutionBotController } from './integrations/chatbot/evolutionBot/controllers/evolutionBot.controller';
import { EvolutionBotService } from './integrations/chatbot/evolutionBot/services/evolutionBot.service';
import { FlowiseController } from './integrations/chatbot/flowise/controllers/flowise.controller';
import { FlowiseService } from './integrations/chatbot/flowise/services/flowise.service';
import { OpenaiController } from './integrations/chatbot/openai/controllers/openai.controller';
import { OpenaiService } from './integrations/chatbot/openai/services/openai.service';
import { TypebotController } from './integrations/chatbot/typebot/controllers/typebot.controller';
import { TypebotService } from './integrations/chatbot/typebot/services/typebot.service';
import { EventManager } from './integrations/event/event.manager';
import { S3Controller } from './integrations/storage/s3/controllers/s3.controller';
import { S3Service } from './integrations/storage/s3/services/s3.service';
import { ProviderFiles } from './provider/sessions';
import { PrismaRepository } from './repository/repository.service';
import { CacheService } from './services/cache.service';
import { WAMonitoringService } from './services/monitor.service';
import { ProxyService } from './services/proxy.service';
import { SettingsService } from './services/settings.service';
import { TemplateService } from './services/template.service';

const logger = new Logger('WA MODULE');

let chatwootCache: CacheService = null;
if (configService.get<Chatwoot>('CHATWOOT').ENABLED) {
  chatwootCache = new CacheService(new CacheEngine(configService, ChatwootService.name).getEngine());
}

export const cache = new CacheService(new CacheEngine(configService, 'instance').getEngine());
const baileysCache = new CacheService(new CacheEngine(configService, 'baileys').getEngine());

let providerFiles: ProviderFiles = null;
if (configService.get<ProviderSession>('PROVIDER').ENABLED) {
  providerFiles = new ProviderFiles(configService);
}

export const prismaRepository = new PrismaRepository(configService);

export const waMonitor = new WAMonitoringService(
  eventEmitter,
  configService,
  prismaRepository,
  providerFiles,
  cache,
  chatwootCache,
  baileysCache,
);

const s3Service = new S3Service(prismaRepository);
export const s3Controller = new S3Controller(s3Service);

const templateService = new TemplateService(waMonitor, prismaRepository, configService);
export const templateController = new TemplateController(templateService);

const proxyService = new ProxyService(waMonitor);
export const proxyController = new ProxyController(proxyService, waMonitor);

const chatwootService = new ChatwootService(waMonitor, configService, prismaRepository, chatwootCache);
export const chatwootController = new ChatwootController(chatwootService, configService, prismaRepository);

const settingsService = new SettingsService(waMonitor);
export const settingsController = new SettingsController(settingsService);

export const instanceController = new InstanceController(
  waMonitor,
  configService,
  prismaRepository,
  eventEmitter,
  chatwootService,
  settingsService,
  proxyController,
  cache,
  chatwootCache,
  baileysCache,
  providerFiles,
);
export const sendMessageController = new SendMessageController(waMonitor);
export const callController = new CallController(waMonitor);
export const chatController = new ChatController(waMonitor);
export const groupController = new GroupController(waMonitor);
export const labelController = new LabelController(waMonitor);

export const eventManager = new EventManager(prismaRepository, waMonitor);
export const chatbotController = new ChatbotController(prismaRepository, waMonitor);
export const channelController = new ChannelController(prismaRepository, waMonitor);

// channels
export const evolutionController = new EvolutionController(prismaRepository, waMonitor);
export const metaController = new MetaController(prismaRepository, waMonitor);
export const baileysController = new BaileysController(waMonitor);
// chatbots
const typebotService = new TypebotService(waMonitor, configService, prismaRepository);
export const typebotController = new TypebotController(typebotService, prismaRepository, waMonitor);

const openaiService = new OpenaiService(waMonitor, configService, prismaRepository);
export const openaiController = new OpenaiController(openaiService, prismaRepository, waMonitor);

const difyService = new DifyService(waMonitor, configService, prismaRepository);
export const difyController = new DifyController(difyService, prismaRepository, waMonitor);

const evolutionBotService = new EvolutionBotService(waMonitor, configService, prismaRepository);
export const evolutionBotController = new EvolutionBotController(evolutionBotService, prismaRepository, waMonitor);

const flowiseService = new FlowiseService(waMonitor, configService, prismaRepository);
export const flowiseController = new FlowiseController(flowiseService, prismaRepository, waMonitor);

logger.info('Module - ON');



================================================
FILE: src/api/abstract/abstract.cache.ts
================================================
export interface ICache {
  get(key: string): Promise<any>;

  hGet(key: string, field: string): Promise<any>;

  set(key: string, value: any, ttl?: number): void;

  hSet(key: string, field: string, value: any): Promise<void>;

  has(key: string): Promise<boolean>;

  keys(appendCriteria?: string): Promise<string[]>;

  delete(key: string | string[]): Promise<number>;

  hDelete(key: string, field: string): Promise<any>;

  deleteAll(appendCriteria?: string): Promise<number>;
}



================================================
FILE: src/api/abstract/abstract.repository.ts
================================================
import { ConfigService, Database } from '@config/env.config';
import { ROOT_DIR } from '@config/path.config';
import { existsSync, mkdirSync, writeFileSync } from 'fs';
import { join } from 'path';

export type IInsert = { insertCount: number };

export interface IRepository {
  insert(data: any, instanceName: string, saveDb?: boolean): Promise<IInsert>;
  update(data: any, instanceName: string, saveDb?: boolean): Promise<IInsert>;
  find(query: any): Promise<any>;
  delete(query: any, force?: boolean): Promise<any>;

  dbSettings: Database;
  readonly storePath: string;
}

type WriteStore<U> = {
  path: string;
  fileName: string;
  data: U;
};

export abstract class Repository implements IRepository {
  constructor(configService: ConfigService) {
    this.dbSettings = configService.get<Database>('DATABASE');
  }

  dbSettings: Database;
  readonly storePath = join(ROOT_DIR, 'store');

  public writeStore = <T = any>(create: WriteStore<T>) => {
    if (!existsSync(create.path)) {
      mkdirSync(create.path, { recursive: true });
    }
    try {
      writeFileSync(join(create.path, create.fileName + '.json'), JSON.stringify({ ...create.data }), {
        encoding: 'utf-8',
      });

      return { message: 'create - success' };
    } finally {
      create.data = undefined;
    }
  };

  // eslint-disable-next-line
    public insert(data: any, instanceName: string, saveDb = false): Promise<IInsert> {
    throw new Error('Method not implemented.');
  }

  // eslint-disable-next-line
    public update(data: any, instanceName: string, saveDb = false): Promise<IInsert> {
    throw new Error('Method not implemented.');
  }

  // eslint-disable-next-line
    public find(query: any): Promise<any> {
    throw new Error('Method not implemented.');
  }

  // eslint-disable-next-line
    delete(query: any, force?: boolean): Promise<any> {
    throw new Error('Method not implemented.');
  }
}



================================================
FILE: src/api/abstract/abstract.router.ts
================================================
import 'express-async-errors';

import { GetParticipant, GroupInvite } from '@api/dto/group.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { Logger } from '@config/logger.config';
import { BadRequestException } from '@exceptions';
import { Request } from 'express';
import { JSONSchema7 } from 'json-schema';
import { validate } from 'jsonschema';

type DataValidate<T> = {
  request: Request;
  schema: JSONSchema7;
  ClassRef: any;
  execute: (instance: InstanceDto, data: T) => Promise<any>;
};

const logger = new Logger('Validate');

export abstract class RouterBroker {
  constructor() {}
  public routerPath(path: string, param = true) {
    let route = '/' + path;
    param ? (route += '/:instanceName') : null;

    return route;
  }

  public async dataValidate<T>(args: DataValidate<T>) {
    const { request, schema, ClassRef, execute } = args;

    const ref = new ClassRef();
    const body = request.body;
    const instance = request.params as unknown as InstanceDto;

    if (request?.query && Object.keys(request.query).length > 0) {
      Object.assign(instance, request.query);
    }

    if (request.originalUrl.includes('/instance/create')) {
      Object.assign(instance, body);
    }

    Object.assign(ref, body);

    const v = schema ? validate(ref, schema) : { valid: true, errors: [] };

    if (!v.valid) {
      const message: any[] = v.errors.map(({ stack, schema }) => {
        let message: string;
        if (schema['description']) {
          message = schema['description'];
        } else {
          message = stack.replace('instance.', '');
        }
        return message;
      });
      logger.error(message);
      throw new BadRequestException(message);
    }

    return await execute(instance, ref);
  }

  public async groupNoValidate<T>(args: DataValidate<T>) {
    const { request, ClassRef, schema, execute } = args;

    const instance = request.params as unknown as InstanceDto;

    const ref = new ClassRef();

    Object.assign(ref, request.body);

    const v = validate(ref, schema);

    if (!v.valid) {
      const message: any[] = v.errors.map(({ property, stack, schema }) => {
        let message: string;
        if (schema['description']) {
          message = schema['description'];
        } else {
          message = stack.replace('instance.', '');
        }
        return {
          property: property.replace('instance.', ''),
          message,
        };
      });
      logger.error([...message]);
      throw new BadRequestException(...message);
    }

    return await execute(instance, ref);
  }

  public async groupValidate<T>(args: DataValidate<T>) {
    const { request, ClassRef, schema, execute } = args;

    const instance = request.params as unknown as InstanceDto;
    const body = request.body;

    let groupJid = body?.groupJid;

    if (!groupJid) {
      if (request.query?.groupJid) {
        groupJid = request.query.groupJid;
      } else {
        throw new BadRequestException('The group id needs to be informed in the query', 'ex: "groupJid=120362@g.us"');
      }
    }

    if (!groupJid.endsWith('@g.us')) {
      groupJid = groupJid + '@g.us';
    }

    Object.assign(body, {
      groupJid: groupJid,
    });

    const ref = new ClassRef();

    Object.assign(ref, body);

    const v = validate(ref, schema);

    if (!v.valid) {
      const message: any[] = v.errors.map(({ property, stack, schema }) => {
        let message: string;
        if (schema['description']) {
          message = schema['description'];
        } else {
          message = stack.replace('instance.', '');
        }
        return {
          property: property.replace('instance.', ''),
          message,
        };
      });
      logger.error([...message]);
      throw new BadRequestException(...message);
    }

    return await execute(instance, ref);
  }

  public async inviteCodeValidate<T>(args: DataValidate<T>) {
    const { request, ClassRef, schema, execute } = args;

    const inviteCode = request.query as unknown as GroupInvite;

    if (!inviteCode?.inviteCode) {
      throw new BadRequestException(
        'The group invite code id needs to be informed in the query',
        'ex: "inviteCode=F1EX5QZxO181L3TMVP31gY" (Obtained from group join link)',
      );
    }

    const instance = request.params as unknown as InstanceDto;
    const body = request.body;

    const ref = new ClassRef();

    Object.assign(body, inviteCode);
    Object.assign(ref, body);

    const v = validate(ref, schema);

    if (!v.valid) {
      const message: any[] = v.errors.map(({ property, stack, schema }) => {
        let message: string;
        if (schema['description']) {
          message = schema['description'];
        } else {
          message = stack.replace('instance.', '');
        }
        return {
          property: property.replace('instance.', ''),
          message,
        };
      });
      logger.error([...message]);
      throw new BadRequestException(...message);
    }

    return await execute(instance, ref);
  }

  public async getParticipantsValidate<T>(args: DataValidate<T>) {
    const { request, ClassRef, schema, execute } = args;

    const getParticipants = request.query as unknown as GetParticipant;

    if (!getParticipants?.getParticipants) {
      throw new BadRequestException('The getParticipants needs to be informed in the query');
    }

    const instance = request.params as unknown as InstanceDto;
    const body = request.body;

    const ref = new ClassRef();

    Object.assign(body, getParticipants);
    Object.assign(ref, body);

    const v = validate(ref, schema);

    if (!v.valid) {
      const message: any[] = v.errors.map(({ property, stack, schema }) => {
        let message: string;
        if (schema['description']) {
          message = schema['description'];
        } else {
          message = stack.replace('instance.', '');
        }
        return {
          property: property.replace('instance.', ''),
          message,
        };
      });
      logger.error([...message]);
      throw new BadRequestException(...message);
    }

    return await execute(instance, ref);
  }
}



================================================
FILE: src/api/controllers/call.controller.ts
================================================
import { OfferCallDto } from '@api/dto/call.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { WAMonitoringService } from '@api/services/monitor.service';

export class CallController {
  constructor(private readonly waMonitor: WAMonitoringService) {}

  public async offerCall({ instanceName }: InstanceDto, data: OfferCallDto) {
    return await this.waMonitor.waInstances[instanceName].offerCall(data);
  }
}



================================================
FILE: src/api/controllers/chat.controller.ts
================================================
import {
  ArchiveChatDto,
  BlockUserDto,
  DeleteMessage,
  getBase64FromMediaMessageDto,
  MarkChatUnreadDto,
  NumberDto,
  PrivacySettingDto,
  ProfileNameDto,
  ProfilePictureDto,
  ProfileStatusDto,
  ReadMessageDto,
  SendPresenceDto,
  UpdateMessageDto,
  WhatsAppNumberDto,
} from '@api/dto/chat.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { Query } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Contact, Message, MessageUpdate } from '@prisma/client';

export class ChatController {
  constructor(private readonly waMonitor: WAMonitoringService) {}

  public async whatsappNumber({ instanceName }: InstanceDto, data: WhatsAppNumberDto) {
    return await this.waMonitor.waInstances[instanceName].whatsappNumber(data);
  }

  public async readMessage({ instanceName }: InstanceDto, data: ReadMessageDto) {
    return await this.waMonitor.waInstances[instanceName].markMessageAsRead(data);
  }

  public async archiveChat({ instanceName }: InstanceDto, data: ArchiveChatDto) {
    return await this.waMonitor.waInstances[instanceName].archiveChat(data);
  }

  public async markChatUnread({ instanceName }: InstanceDto, data: MarkChatUnreadDto) {
    return await this.waMonitor.waInstances[instanceName].markChatUnread(data);
  }

  public async deleteMessage({ instanceName }: InstanceDto, data: DeleteMessage) {
    return await this.waMonitor.waInstances[instanceName].deleteMessage(data);
  }

  public async fetchProfilePicture({ instanceName }: InstanceDto, data: NumberDto) {
    return await this.waMonitor.waInstances[instanceName].profilePicture(data.number);
  }

  public async fetchProfile({ instanceName }: InstanceDto, data: NumberDto) {
    return await this.waMonitor.waInstances[instanceName].fetchProfile(instanceName, data.number);
  }

  public async fetchContacts({ instanceName }: InstanceDto, query: Query<Contact>) {
    return await this.waMonitor.waInstances[instanceName].fetchContacts(query);
  }

  public async getBase64FromMediaMessage({ instanceName }: InstanceDto, data: getBase64FromMediaMessageDto) {
    return await this.waMonitor.waInstances[instanceName].getBase64FromMediaMessage(data);
  }

  public async fetchMessages({ instanceName }: InstanceDto, query: Query<Message>) {
    return await this.waMonitor.waInstances[instanceName].fetchMessages(query);
  }

  public async fetchStatusMessage({ instanceName }: InstanceDto, query: Query<MessageUpdate>) {
    return await this.waMonitor.waInstances[instanceName].fetchStatusMessage(query);
  }

  public async fetchChats({ instanceName }: InstanceDto, query: Query<Contact>) {
    return await this.waMonitor.waInstances[instanceName].fetchChats(query);
  }

  public async sendPresence({ instanceName }: InstanceDto, data: SendPresenceDto) {
    return await this.waMonitor.waInstances[instanceName].sendPresence(data);
  }

  public async fetchPrivacySettings({ instanceName }: InstanceDto) {
    return await this.waMonitor.waInstances[instanceName].fetchPrivacySettings();
  }

  public async updatePrivacySettings({ instanceName }: InstanceDto, data: PrivacySettingDto) {
    return await this.waMonitor.waInstances[instanceName].updatePrivacySettings(data);
  }

  public async fetchBusinessProfile({ instanceName }: InstanceDto, data: ProfilePictureDto) {
    return await this.waMonitor.waInstances[instanceName].fetchBusinessProfile(data.number);
  }

  public async updateProfileName({ instanceName }: InstanceDto, data: ProfileNameDto) {
    return await this.waMonitor.waInstances[instanceName].updateProfileName(data.name);
  }

  public async updateProfileStatus({ instanceName }: InstanceDto, data: ProfileStatusDto) {
    return await this.waMonitor.waInstances[instanceName].updateProfileStatus(data.status);
  }

  public async updateProfilePicture({ instanceName }: InstanceDto, data: ProfilePictureDto) {
    return await this.waMonitor.waInstances[instanceName].updateProfilePicture(data.picture);
  }

  public async removeProfilePicture({ instanceName }: InstanceDto) {
    return await this.waMonitor.waInstances[instanceName].removeProfilePicture();
  }

  public async updateMessage({ instanceName }: InstanceDto, data: UpdateMessageDto) {
    return await this.waMonitor.waInstances[instanceName].updateMessage(data);
  }

  public async blockUser({ instanceName }: InstanceDto, data: BlockUserDto) {
    return await this.waMonitor.waInstances[instanceName].blockUser(data);
  }
}



================================================
FILE: src/api/controllers/group.controller.ts
================================================
import {
  AcceptGroupInvite,
  CreateGroupDto,
  GetParticipant,
  GroupDescriptionDto,
  GroupInvite,
  GroupJid,
  GroupPictureDto,
  GroupSendInvite,
  GroupSubjectDto,
  GroupToggleEphemeralDto,
  GroupUpdateParticipantDto,
  GroupUpdateSettingDto,
} from '@api/dto/group.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { WAMonitoringService } from '@api/services/monitor.service';

export class GroupController {
  constructor(private readonly waMonitor: WAMonitoringService) {}

  public async createGroup(instance: InstanceDto, create: CreateGroupDto) {
    return await this.waMonitor.waInstances[instance.instanceName].createGroup(create);
  }

  public async updateGroupPicture(instance: InstanceDto, update: GroupPictureDto) {
    return await this.waMonitor.waInstances[instance.instanceName].updateGroupPicture(update);
  }

  public async updateGroupSubject(instance: InstanceDto, update: GroupSubjectDto) {
    return await this.waMonitor.waInstances[instance.instanceName].updateGroupSubject(update);
  }

  public async updateGroupDescription(instance: InstanceDto, update: GroupDescriptionDto) {
    return await this.waMonitor.waInstances[instance.instanceName].updateGroupDescription(update);
  }

  public async findGroupInfo(instance: InstanceDto, groupJid: GroupJid) {
    return await this.waMonitor.waInstances[instance.instanceName].findGroup(groupJid);
  }

  public async fetchAllGroups(instance: InstanceDto, getPaticipants: GetParticipant) {
    return await this.waMonitor.waInstances[instance.instanceName].fetchAllGroups(getPaticipants);
  }

  public async inviteCode(instance: InstanceDto, groupJid: GroupJid) {
    return await this.waMonitor.waInstances[instance.instanceName].inviteCode(groupJid);
  }

  public async inviteInfo(instance: InstanceDto, inviteCode: GroupInvite) {
    return await this.waMonitor.waInstances[instance.instanceName].inviteInfo(inviteCode);
  }

  public async sendInvite(instance: InstanceDto, data: GroupSendInvite) {
    return await this.waMonitor.waInstances[instance.instanceName].sendInvite(data);
  }

  public async acceptInviteCode(instance: InstanceDto, inviteCode: AcceptGroupInvite) {
    return await this.waMonitor.waInstances[instance.instanceName].acceptInviteCode(inviteCode);
  }

  public async revokeInviteCode(instance: InstanceDto, groupJid: GroupJid) {
    return await this.waMonitor.waInstances[instance.instanceName].revokeInviteCode(groupJid);
  }

  public async findParticipants(instance: InstanceDto, groupJid: GroupJid) {
    return await this.waMonitor.waInstances[instance.instanceName].findParticipants(groupJid);
  }

  public async updateGParticipate(instance: InstanceDto, update: GroupUpdateParticipantDto) {
    return await this.waMonitor.waInstances[instance.instanceName].updateGParticipant(update);
  }

  public async updateGSetting(instance: InstanceDto, update: GroupUpdateSettingDto) {
    return await this.waMonitor.waInstances[instance.instanceName].updateGSetting(update);
  }

  public async toggleEphemeral(instance: InstanceDto, update: GroupToggleEphemeralDto) {
    return await this.waMonitor.waInstances[instance.instanceName].toggleEphemeral(update);
  }

  public async leaveGroup(instance: InstanceDto, groupJid: GroupJid) {
    return await this.waMonitor.waInstances[instance.instanceName].leaveGroup(groupJid);
  }
}



================================================
FILE: src/api/controllers/instance.controller.ts
================================================
import { InstanceDto, SetPresenceDto } from '@api/dto/instance.dto';
import { ChatwootService } from '@api/integrations/chatbot/chatwoot/services/chatwoot.service';
import { ProviderFiles } from '@api/provider/sessions';
import { PrismaRepository } from '@api/repository/repository.service';
import { channelController, eventManager } from '@api/server.module';
import { CacheService } from '@api/services/cache.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { SettingsService } from '@api/services/settings.service';
import { Events, Integration, wa } from '@api/types/wa.types';
import { Auth, Chatwoot, ConfigService, HttpServer, WaBusiness } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { BadRequestException, InternalServerErrorException, UnauthorizedException } from '@exceptions';
import { delay } from 'baileys';
import { isArray, isURL } from 'class-validator';
import EventEmitter2 from 'eventemitter2';
import { v4 } from 'uuid';

import { ProxyController } from './proxy.controller';

export class InstanceController {
  constructor(
    private readonly waMonitor: WAMonitoringService,
    private readonly configService: ConfigService,
    private readonly prismaRepository: PrismaRepository,
    private readonly eventEmitter: EventEmitter2,
    private readonly chatwootService: ChatwootService,
    private readonly settingsService: SettingsService,
    private readonly proxyService: ProxyController,
    private readonly cache: CacheService,
    private readonly chatwootCache: CacheService,
    private readonly baileysCache: CacheService,
    private readonly providerFiles: ProviderFiles,
  ) {}

  private readonly logger = new Logger('InstanceController');

  public async createInstance(instanceData: InstanceDto) {
    try {
      const instance = channelController.init(instanceData, {
        configService: this.configService,
        eventEmitter: this.eventEmitter,
        prismaRepository: this.prismaRepository,
        cache: this.cache,
        chatwootCache: this.chatwootCache,
        baileysCache: this.baileysCache,
        providerFiles: this.providerFiles,
      });

      if (!instance) {
        throw new BadRequestException('Invalid integration');
      }

      const instanceId = v4();

      instanceData.instanceId = instanceId;

      let hash: string;

      if (!instanceData.token) hash = v4().toUpperCase();
      else hash = instanceData.token;

      await this.waMonitor.saveInstance({
        instanceId,
        integration: instanceData.integration,
        instanceName: instanceData.instanceName,
        ownerJid: instanceData.ownerJid,
        profileName: instanceData.profileName,
        profilePicUrl: instanceData.profilePicUrl,
        hash,
        number: instanceData.number,
        businessId: instanceData.businessId,
        status: instanceData.status,
      });

      instance.setInstance({
        instanceName: instanceData.instanceName,
        instanceId,
        integration: instanceData.integration,
        token: hash,
        number: instanceData.number,
        businessId: instanceData.businessId,
      });

      this.waMonitor.waInstances[instance.instanceName] = instance;
      this.waMonitor.delInstanceTime(instance.instanceName);

      // set events
      await eventManager.setInstance(instance.instanceName, instanceData);

      instance.sendDataWebhook(Events.INSTANCE_CREATE, {
        instanceName: instanceData.instanceName,
        instanceId: instanceId,
      });

      if (instanceData.proxyHost && instanceData.proxyPort && instanceData.proxyProtocol) {
        const testProxy = await this.proxyService.testProxy({
          host: instanceData.proxyHost,
          port: instanceData.proxyPort,
          protocol: instanceData.proxyProtocol,
          username: instanceData.proxyUsername,
          password: instanceData.proxyPassword,
        });
        if (!testProxy) {
          throw new BadRequestException('Invalid proxy');
        }

        await this.proxyService.createProxy(instance, {
          enabled: true,
          host: instanceData.proxyHost,
          port: instanceData.proxyPort,
          protocol: instanceData.proxyProtocol,
          username: instanceData.proxyUsername,
          password: instanceData.proxyPassword,
        });
      }

      const settings: wa.LocalSettings = {
        rejectCall: instanceData.rejectCall === true,
        msgCall: instanceData.msgCall || '',
        groupsIgnore: instanceData.groupsIgnore === true,
        alwaysOnline: instanceData.alwaysOnline === true,
        readMessages: instanceData.readMessages === true,
        readStatus: instanceData.readStatus === true,
        syncFullHistory: instanceData.syncFullHistory === true,
        wavoipToken: instanceData.wavoipToken || '',
      };

      await this.settingsService.create(instance, settings);

      let webhookWaBusiness = null,
        accessTokenWaBusiness = '';

      if (instanceData.integration === Integration.WHATSAPP_BUSINESS) {
        if (!instanceData.number) {
          throw new BadRequestException('number is required');
        }
        const urlServer = this.configService.get<HttpServer>('SERVER').URL;
        webhookWaBusiness = `${urlServer}/webhook/meta`;
        accessTokenWaBusiness = this.configService.get<WaBusiness>('WA_BUSINESS').TOKEN_WEBHOOK;
      }

      if (!instanceData.chatwootAccountId || !instanceData.chatwootToken || !instanceData.chatwootUrl) {
        let getQrcode: wa.QrCode;

        if (instanceData.qrcode && instanceData.integration === Integration.WHATSAPP_BAILEYS) {
          await instance.connectToWhatsapp(instanceData.number);
          await delay(5000);
          getQrcode = instance.qrCode;
        }

        const result = {
          instance: {
            instanceName: instance.instanceName,
            instanceId: instanceId,
            integration: instanceData.integration,
            webhookWaBusiness,
            accessTokenWaBusiness,
            status: instance.connectionStatus.state,
          },
          hash,
          webhook: {
            webhookUrl: instanceData?.webhook?.url,
            webhookHeaders: instanceData?.webhook?.headers,
            webhookByEvents: instanceData?.webhook?.byEvents,
            webhookBase64: instanceData?.webhook?.base64,
          },
          websocket: {
            enabled: instanceData?.websocket?.enabled,
          },
          rabbitmq: {
            enabled: instanceData?.rabbitmq?.enabled,
          },
          sqs: {
            enabled: instanceData?.sqs?.enabled,
          },
          settings,
          qrcode: getQrcode,
        };

        return result;
      }

      if (!this.configService.get<Chatwoot>('CHATWOOT').ENABLED)
        throw new BadRequestException('Chatwoot is not enabled');

      if (!instanceData.chatwootAccountId) {
        throw new BadRequestException('accountId is required');
      }

      if (!instanceData.chatwootToken) {
        throw new BadRequestException('token is required');
      }

      if (!instanceData.chatwootUrl) {
        throw new BadRequestException('url is required');
      }

      if (!isURL(instanceData.chatwootUrl, { require_tld: false })) {
        throw new BadRequestException('Invalid "url" property in chatwoot');
      }

      if (instanceData.chatwootSignMsg !== true && instanceData.chatwootSignMsg !== false) {
        throw new BadRequestException('signMsg is required');
      }

      if (instanceData.chatwootReopenConversation !== true && instanceData.chatwootReopenConversation !== false) {
        throw new BadRequestException('reopenConversation is required');
      }

      if (instanceData.chatwootConversationPending !== true && instanceData.chatwootConversationPending !== false) {
        throw new BadRequestException('conversationPending is required');
      }

      const urlServer = this.configService.get<HttpServer>('SERVER').URL;

      try {
        this.chatwootService.create(instance, {
          enabled: true,
          accountId: instanceData.chatwootAccountId,
          token: instanceData.chatwootToken,
          url: instanceData.chatwootUrl,
          signMsg: instanceData.chatwootSignMsg || false,
          nameInbox: instanceData.chatwootNameInbox ?? instance.instanceName.split('-cwId-')[0],
          number: instanceData.number,
          reopenConversation: instanceData.chatwootReopenConversation || false,
          conversationPending: instanceData.chatwootConversationPending || false,
          importContacts: instanceData.chatwootImportContacts ?? true,
          mergeBrazilContacts: instanceData.chatwootMergeBrazilContacts ?? false,
          importMessages: instanceData.chatwootImportMessages ?? true,
          daysLimitImportMessages: instanceData.chatwootDaysLimitImportMessages ?? 60,
          organization: instanceData.chatwootOrganization,
          logo: instanceData.chatwootLogo,
          autoCreate: instanceData.chatwootAutoCreate !== false,
        });
      } catch (error) {
        this.logger.log(error);
      }

      return {
        instance: {
          instanceName: instance.instanceName,
          instanceId: instanceId,
          integration: instanceData.integration,
          webhookWaBusiness,
          accessTokenWaBusiness,
          status: instance.connectionStatus.state,
        },
        hash,
        webhook: {
          webhookUrl: instanceData?.webhook?.url,
          webhookHeaders: instanceData?.webhook?.headers,
          webhookByEvents: instanceData?.webhook?.byEvents,
          webhookBase64: instanceData?.webhook?.base64,
        },
        websocket: {
          enabled: instanceData?.websocket?.enabled,
        },
        rabbitmq: {
          enabled: instanceData?.rabbitmq?.enabled,
        },
        sqs: {
          enabled: instanceData?.sqs?.enabled,
        },
        settings,
        chatwoot: {
          enabled: true,
          accountId: instanceData.chatwootAccountId,
          token: instanceData.chatwootToken,
          url: instanceData.chatwootUrl,
          signMsg: instanceData.chatwootSignMsg || false,
          reopenConversation: instanceData.chatwootReopenConversation || false,
          conversationPending: instanceData.chatwootConversationPending || false,
          mergeBrazilContacts: instanceData.chatwootMergeBrazilContacts ?? false,
          importContacts: instanceData.chatwootImportContacts ?? true,
          importMessages: instanceData.chatwootImportMessages ?? true,
          daysLimitImportMessages: instanceData.chatwootDaysLimitImportMessages || 60,
          number: instanceData.number,
          nameInbox: instanceData.chatwootNameInbox ?? instance.instanceName,
          webhookUrl: `${urlServer}/chatwoot/webhook/${encodeURIComponent(instance.instanceName)}`,
        },
      };
    } catch (error) {
      this.waMonitor.deleteInstance(instanceData.instanceName);
      this.logger.error(isArray(error.message) ? error.message[0] : error.message);
      throw new BadRequestException(isArray(error.message) ? error.message[0] : error.message);
    }
  }

  public async connectToWhatsapp({ instanceName, number = null }: InstanceDto) {
    try {
      const instance = this.waMonitor.waInstances[instanceName];
      const state = instance?.connectionStatus?.state;

      if (!state) {
        throw new BadRequestException('The "' + instanceName + '" instance does not exist');
      }

      if (state == 'open') {
        return await this.connectionState({ instanceName });
      }

      if (state == 'connecting') {
        return instance.qrCode;
      }

      if (state == 'close') {
        await instance.connectToWhatsapp(number);

        await delay(2000);
        return instance.qrCode;
      }

      return {
        instance: {
          instanceName: instanceName,
          status: state,
        },
        qrcode: instance?.qrCode,
      };
    } catch (error) {
      this.logger.error(error);
      return { error: true, message: error.toString() };
    }
  }

  public async restartInstance({ instanceName }: InstanceDto) {
    try {
      const instance = this.waMonitor.waInstances[instanceName];
      const state = instance?.connectionStatus?.state;

      if (!state) {
        throw new BadRequestException('The "' + instanceName + '" instance does not exist');
      }

      if (state == 'close') {
        throw new BadRequestException('The "' + instanceName + '" instance is not connected');
      } else if (state == 'open') {
        if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED) instance.clearCacheChatwoot();
        this.logger.info('restarting instance' + instanceName);

        instance.client?.ws?.close();
        instance.client?.end(new Error('restart'));
        return await this.connectToWhatsapp({ instanceName });
      } else if (state == 'connecting') {
        instance.client?.ws?.close();
        instance.client?.end(new Error('restart'));
        return await this.connectToWhatsapp({ instanceName });
      }
    } catch (error) {
      this.logger.error(error);
      return { error: true, message: error.toString() };
    }
  }

  public async connectionState({ instanceName }: InstanceDto) {
    return {
      instance: {
        instanceName: instanceName,
        state: this.waMonitor.waInstances[instanceName]?.connectionStatus?.state,
      },
    };
  }

  public async fetchInstances({ instanceName, instanceId, number }: InstanceDto, key: string) {
    const env = this.configService.get<Auth>('AUTHENTICATION').API_KEY;

    if (env.KEY !== key) {
      const instancesByKey = await this.prismaRepository.instance.findMany({
        where: {
          token: key,
          name: instanceName || undefined,
          id: instanceId || undefined,
        },
      });

      if (instancesByKey.length > 0) {
        const names = instancesByKey.map((instance) => instance.name);

        return this.waMonitor.instanceInfo(names);
      } else {
        throw new UnauthorizedException();
      }
    }

    if (instanceId || number) {
      return this.waMonitor.instanceInfoById(instanceId, number);
    }

    const instanceNames = instanceName ? [instanceName] : null;

    return this.waMonitor.instanceInfo(instanceNames);
  }

  public async setPresence({ instanceName }: InstanceDto, data: SetPresenceDto) {
    return await this.waMonitor.waInstances[instanceName].setPresence(data);
  }

  public async logout({ instanceName }: InstanceDto) {
    const { instance } = await this.connectionState({ instanceName });

    if (instance.state === 'close') {
      throw new BadRequestException('The "' + instanceName + '" instance is not connected');
    }

    try {
      this.waMonitor.waInstances[instanceName]?.logoutInstance();

      return { status: 'SUCCESS', error: false, response: { message: 'Instance logged out' } };
    } catch (error) {
      throw new InternalServerErrorException(error.toString());
    }
  }

  public async deleteInstance({ instanceName }: InstanceDto) {
    const { instance } = await this.connectionState({ instanceName });
    try {
      const waInstances = this.waMonitor.waInstances[instanceName];
      if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED) waInstances?.clearCacheChatwoot();

      if (instance.state === 'connecting' || instance.state === 'open') {
        await this.logout({ instanceName });
      }

      try {
        waInstances?.sendDataWebhook(Events.INSTANCE_DELETE, {
          instanceName,
          instanceId: waInstances.instanceId,
        });
      } catch (error) {
        this.logger.error(error);
      }

      this.eventEmitter.emit('remove.instance', instanceName, 'inner');
      return { status: 'SUCCESS', error: false, response: { message: 'Instance deleted' } };
    } catch (error) {
      throw new BadRequestException(error.toString());
    }
  }
}



================================================
FILE: src/api/controllers/label.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { HandleLabelDto } from '@api/dto/label.dto';
import { WAMonitoringService } from '@api/services/monitor.service';

export class LabelController {
  constructor(private readonly waMonitor: WAMonitoringService) {}

  public async fetchLabels({ instanceName }: InstanceDto) {
    return await this.waMonitor.waInstances[instanceName].fetchLabels();
  }

  public async handleLabel({ instanceName }: InstanceDto, data: HandleLabelDto) {
    return await this.waMonitor.waInstances[instanceName].handleLabel(data);
  }
}



================================================
FILE: src/api/controllers/proxy.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { ProxyDto } from '@api/dto/proxy.dto';
import { WAMonitoringService } from '@api/services/monitor.service';
import { ProxyService } from '@api/services/proxy.service';
import { Logger } from '@config/logger.config';
import { BadRequestException, NotFoundException } from '@exceptions';
import { makeProxyAgent } from '@utils/makeProxyAgent';
import axios from 'axios';

const logger = new Logger('ProxyController');

export class ProxyController {
  constructor(
    private readonly proxyService: ProxyService,
    private readonly waMonitor: WAMonitoringService,
  ) {}

  public async createProxy(instance: InstanceDto, data: ProxyDto) {
    if (!this.waMonitor.waInstances[instance.instanceName]) {
      throw new NotFoundException(`The "${instance.instanceName}" instance does not exist`);
    }

    if (!data?.enabled) {
      data.host = '';
      data.port = '';
      data.protocol = '';
      data.username = '';
      data.password = '';
    }

    if (data.host) {
      const testProxy = await this.testProxy(data);
      if (!testProxy) {
        throw new BadRequestException('Invalid proxy');
      }
    }

    return this.proxyService.create(instance, data);
  }

  public async findProxy(instance: InstanceDto) {
    if (!this.waMonitor.waInstances[instance.instanceName]) {
      throw new NotFoundException(`The "${instance.instanceName}" instance does not exist`);
    }

    return this.proxyService.find(instance);
  }

  public async testProxy(proxy: ProxyDto) {
    try {
      const serverIp = await axios.get('https://icanhazip.com/');
      const response = await axios.get('https://icanhazip.com/', {
        httpsAgent: makeProxyAgent(proxy),
      });

      return response?.data !== serverIp?.data;
    } catch (error) {
      if (axios.isAxiosError(error) && error.response?.data) {
        logger.error('testProxy error: ' + error.response.data);
      } else if (axios.isAxiosError(error)) {
        logger.error('testProxy error: ');
      } else {
        logger.error('testProxy error: ');
      }
      return false;
    }
  }
}



================================================
FILE: src/api/controllers/sendMessage.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import {
  SendAudioDto,
  SendButtonsDto,
  SendContactDto,
  SendListDto,
  SendLocationDto,
  SendMediaDto,
  SendPollDto,
  SendPtvDto,
  SendReactionDto,
  SendStatusDto,
  SendStickerDto,
  SendTemplateDto,
  SendTextDto,
} from '@api/dto/sendMessage.dto';
import { WAMonitoringService } from '@api/services/monitor.service';
import { BadRequestException } from '@exceptions';
import { isBase64, isURL } from 'class-validator';

export class SendMessageController {
  constructor(private readonly waMonitor: WAMonitoringService) {}

  public async sendTemplate({ instanceName }: InstanceDto, data: SendTemplateDto) {
    return await this.waMonitor.waInstances[instanceName].templateMessage(data);
  }

  public async sendText({ instanceName }: InstanceDto, data: SendTextDto) {
    return await this.waMonitor.waInstances[instanceName].textMessage(data);
  }

  public async sendMedia({ instanceName }: InstanceDto, data: SendMediaDto, file?: any) {
    if (isBase64(data?.media) && !data?.fileName && data?.mediatype === 'document') {
      throw new BadRequestException('For base64 the file name must be informed.');
    }

    if (file || isURL(data?.media) || isBase64(data?.media)) {
      return await this.waMonitor.waInstances[instanceName].mediaMessage(data, file);
    }
    throw new BadRequestException('Owned media must be a url or base64');
  }

  public async sendPtv({ instanceName }: InstanceDto, data: SendPtvDto, file?: any) {
    if (file || isURL(data?.video) || isBase64(data?.video)) {
      return await this.waMonitor.waInstances[instanceName].ptvMessage(data, file);
    }
    throw new BadRequestException('Owned media must be a url or base64');
  }

  public async sendSticker({ instanceName }: InstanceDto, data: SendStickerDto, file?: any) {
    if (file || isURL(data.sticker) || isBase64(data.sticker)) {
      return await this.waMonitor.waInstances[instanceName].mediaSticker(data, file);
    }
    throw new BadRequestException('Owned media must be a url or base64');
  }

  public async sendWhatsAppAudio({ instanceName }: InstanceDto, data: SendAudioDto, file?: any) {
    if (file?.buffer || isURL(data.audio) || isBase64(data.audio)) {
      // Si file existe y tiene buffer, o si es una URL o Base64, continúa
      return await this.waMonitor.waInstances[instanceName].audioWhatsapp(data, file);
    } else {
      console.error('El archivo no tiene buffer o el audio no es una URL o Base64 válida');
      throw new BadRequestException('Owned media must be a url, base64, or valid file with buffer');
    }
  }

  public async sendButtons({ instanceName }: InstanceDto, data: SendButtonsDto) {
    return await this.waMonitor.waInstances[instanceName].buttonMessage(data);
  }

  public async sendLocation({ instanceName }: InstanceDto, data: SendLocationDto) {
    return await this.waMonitor.waInstances[instanceName].locationMessage(data);
  }

  public async sendList({ instanceName }: InstanceDto, data: SendListDto) {
    return await this.waMonitor.waInstances[instanceName].listMessage(data);
  }

  public async sendContact({ instanceName }: InstanceDto, data: SendContactDto) {
    return await this.waMonitor.waInstances[instanceName].contactMessage(data);
  }

  public async sendReaction({ instanceName }: InstanceDto, data: SendReactionDto) {
    if (!data.reaction.match(/[^()\w\sà-ú"-+]+/)) {
      throw new BadRequestException('"reaction" must be an emoji');
    }
    return await this.waMonitor.waInstances[instanceName].reactionMessage(data);
  }

  public async sendPoll({ instanceName }: InstanceDto, data: SendPollDto) {
    return await this.waMonitor.waInstances[instanceName].pollMessage(data);
  }

  public async sendStatus({ instanceName }: InstanceDto, data: SendStatusDto, file?: any) {
    return await this.waMonitor.waInstances[instanceName].statusMessage(data, file);
  }
}



================================================
FILE: src/api/controllers/settings.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { SettingsDto } from '@api/dto/settings.dto';
import { SettingsService } from '@api/services/settings.service';

export class SettingsController {
  constructor(private readonly settingsService: SettingsService) {}

  public async createSettings(instance: InstanceDto, data: SettingsDto) {
    return this.settingsService.create(instance, data);
  }

  public async findSettings(instance: InstanceDto) {
    const settings = this.settingsService.find(instance);
    return settings;
  }
}



================================================
FILE: src/api/controllers/template.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { TemplateDto } from '@api/dto/template.dto';
import { TemplateService } from '@api/services/template.service';

export class TemplateController {
  constructor(private readonly templateService: TemplateService) {}

  public async createTemplate(instance: InstanceDto, data: TemplateDto) {
    return this.templateService.create(instance, data);
  }

  public async findTemplate(instance: InstanceDto) {
    return this.templateService.find(instance);
  }
}



================================================
FILE: src/api/dto/call.dto.ts
================================================
export class Metadata {
  number: string;
}

export class OfferCallDto extends Metadata {
  isVideo?: boolean;
  callDuration?: number;
}



================================================
FILE: src/api/dto/chat.dto.ts
================================================
import {
  proto,
  WAPresence,
  WAPrivacyGroupAddValue,
  WAPrivacyOnlineValue,
  WAPrivacyValue,
  WAReadReceiptsValue,
} from 'baileys';

export class OnWhatsAppDto {
  constructor(
    public readonly jid: string,
    public readonly exists: boolean,
    public readonly number: string,
    public readonly name?: string,
  ) {}
}

export class getBase64FromMediaMessageDto {
  message: proto.WebMessageInfo;
  convertToMp4?: boolean;
}

export class WhatsAppNumberDto {
  numbers: string[];
}

export class NumberDto {
  number: string;
}

export class NumberBusiness {
  wid?: string;
  jid?: string;
  exists?: boolean;
  isBusiness: boolean;
  name?: string;
  message?: string;
  description?: string;
  email?: string;
  websites?: string[];
  website?: string[];
  address?: string;
  about?: string;
  vertical?: string;
  profilehandle?: string;
}

export class ProfileNameDto {
  name: string;
}

export class ProfileStatusDto {
  status: string;
}

export class ProfilePictureDto {
  number?: string;
  // url or base64
  picture?: string;
}

class Key {
  id: string;
  fromMe: boolean;
  remoteJid: string;
}
export class ReadMessageDto {
  readMessages: Key[];
}

export class LastMessage {
  key: Key;
  messageTimestamp?: number;
}

export class ArchiveChatDto {
  lastMessage?: LastMessage;
  chat?: string;
  archive: boolean;
}

export class MarkChatUnreadDto {
  lastMessage?: LastMessage;
  chat?: string;
}

export class PrivacySettingDto {
  readreceipts: WAReadReceiptsValue;
  profile: WAPrivacyValue;
  status: WAPrivacyValue;
  online: WAPrivacyOnlineValue;
  last: WAPrivacyValue;
  groupadd: WAPrivacyGroupAddValue;
}

export class DeleteMessage {
  id: string;
  fromMe: boolean;
  remoteJid: string;
  participant?: string;
}
export class Options {
  delay?: number;
  presence?: WAPresence;
}
class OptionsMessage {
  options: Options;
}
export class Metadata extends OptionsMessage {
  number: string;
}

export class SendPresenceDto extends Metadata {
  presence: WAPresence;
  delay: number;
}

export class UpdateMessageDto extends Metadata {
  number: string;
  key: proto.IMessageKey;
  text: string;
}

export class BlockUserDto {
  number: string;
  status: 'block' | 'unblock';
}



================================================
FILE: src/api/dto/chatbot.dto.ts
================================================
export class Session {
  remoteJid?: string;
  sessionId?: string;
  status?: string;
  createdAt?: number;
  updateAt?: number;
}

export class IgnoreJidDto {
  remoteJid?: string;
  action?: string;
}



================================================
FILE: src/api/dto/group.dto.ts
================================================
export class CreateGroupDto {
  subject: string;
  participants: string[];
  description?: string;
  promoteParticipants?: boolean;
}

export class GroupPictureDto {
  groupJid: string;
  image: string;
}

export class GroupSubjectDto {
  groupJid: string;
  subject: string;
}

export class GroupDescriptionDto {
  groupJid: string;
  description: string;
}

export class GroupJid {
  groupJid: string;
}

export class GetParticipant {
  getParticipants: string;
}

export class GroupInvite {
  inviteCode: string;
}

export class AcceptGroupInvite {
  inviteCode: string;
}

export class GroupSendInvite {
  groupJid: string;
  description: string;
  numbers: string[];
}

export class GroupUpdateParticipantDto extends GroupJid {
  action: 'add' | 'remove' | 'promote' | 'demote';
  participants: string[];
}

export class GroupUpdateSettingDto extends GroupJid {
  action: 'announcement' | 'not_announcement' | 'unlocked' | 'locked';
}

export class GroupToggleEphemeralDto extends GroupJid {
  expiration: 0 | 86400 | 604800 | 7776000;
}



================================================
FILE: src/api/dto/instance.dto.ts
================================================
import { IntegrationDto } from '@api/integrations/integration.dto';
import { JsonValue } from '@prisma/client/runtime/library';
import { WAPresence } from 'baileys';

export class InstanceDto extends IntegrationDto {
  instanceName: string;
  instanceId?: string;
  qrcode?: boolean;
  businessId?: string;
  number?: string;
  integration?: string;
  token?: string;
  status?: string;
  ownerJid?: string;
  profileName?: string;
  profilePicUrl?: string;
  // settings
  rejectCall?: boolean;
  msgCall?: string;
  groupsIgnore?: boolean;
  alwaysOnline?: boolean;
  readMessages?: boolean;
  readStatus?: boolean;
  syncFullHistory?: boolean;
  wavoipToken?: string;
  // proxy
  proxyHost?: string;
  proxyPort?: string;
  proxyProtocol?: string;
  proxyUsername?: string;
  proxyPassword?: string;
  webhook?: {
    enabled?: boolean;
    events?: string[];
    headers?: JsonValue;
    url?: string;
    byEvents?: boolean;
    base64?: boolean;
  };
  chatwootAccountId?: string;
  chatwootConversationPending?: boolean;
  chatwootAutoCreate?: boolean;
  chatwootDaysLimitImportMessages?: number;
  chatwootImportContacts?: boolean;
  chatwootImportMessages?: boolean;
  chatwootLogo?: string;
  chatwootMergeBrazilContacts?: boolean;
  chatwootNameInbox?: string;
  chatwootOrganization?: string;
  chatwootReopenConversation?: boolean;
  chatwootSignMsg?: boolean;
  chatwootToken?: string;
  chatwootUrl?: string;
}

export class SetPresenceDto {
  presence: WAPresence;
}



================================================
FILE: src/api/dto/label.dto.ts
================================================
export class LabelDto {
  id?: string;
  name: string;
  color: string;
  predefinedId?: string;
}

export class HandleLabelDto {
  number: string;
  labelId: string;
  action: 'add' | 'remove';
}



================================================
FILE: src/api/dto/proxy.dto.ts
================================================
export class ProxyDto {
  enabled?: boolean;
  host: string;
  port: string;
  protocol: string;
  username?: string;
  password?: string;
}



================================================
FILE: src/api/dto/sendMessage.dto.ts
================================================
import { proto, WAPresence } from 'baileys';

export class Quoted {
  key: proto.IMessageKey;
  message: proto.IMessage;
}

export class Options {
  delay?: number;
  presence?: WAPresence;
  quoted?: Quoted;
  linkPreview?: boolean;
  encoding?: boolean;
  mentionsEveryOne?: boolean;
  mentioned?: string[];
  webhookUrl?: string;
}

export class MediaMessage {
  mediatype: MediaType;
  mimetype?: string;
  caption?: string;
  // for document
  fileName?: string;
  // url or base64
  media: string;
}

export class StatusMessage {
  type: string;
  content: string;
  statusJidList?: string[];
  allContacts?: boolean;
  caption?: string;
  backgroundColor?: string;
  font?: number;
}

export class Metadata {
  number: string;
  delay?: number;
  quoted?: Quoted;
  linkPreview?: boolean;
  mentionsEveryOne?: boolean;
  mentioned?: string[];
  encoding?: boolean;
}

export class SendTextDto extends Metadata {
  text: string;
}
export class SendPresence extends Metadata {
  text: string;
}

export class SendStatusDto extends Metadata {
  type: string;
  content: string;
  statusJidList?: string[];
  allContacts?: boolean;
  caption?: string;
  backgroundColor?: string;
  font?: number;
}

export class SendPollDto extends Metadata {
  name: string;
  selectableCount: number;
  values: string[];
  messageSecret?: Uint8Array;
}

export type MediaType = 'image' | 'document' | 'video' | 'audio' | 'ptv';

export class SendMediaDto extends Metadata {
  mediatype: MediaType;
  mimetype?: string;
  caption?: string;
  // for document
  fileName?: string;
  // url or base64
  media: string;
}

export class SendPtvDto extends Metadata {
  video: string;
}

export class SendStickerDto extends Metadata {
  sticker: string;
}

export class SendAudioDto extends Metadata {
  audio: string;
}

export type TypeButton = 'reply' | 'copy' | 'url' | 'call' | 'pix';

export type KeyType = 'phone' | 'email' | 'cpf' | 'cnpj' | 'random';

export class Button {
  type: TypeButton;
  displayText?: string;
  id?: string;
  url?: string;
  copyCode?: string;
  phoneNumber?: string;
  currency?: string;
  name?: string;
  keyType?: KeyType;
  key?: string;
}

export class SendButtonsDto extends Metadata {
  thumbnailUrl?: string;
  title: string;
  description?: string;
  footer?: string;
  buttons: Button[];
}

export class SendLocationDto extends Metadata {
  latitude: number;
  longitude: number;
  name?: string;
  address?: string;
}

class Row {
  title: string;
  description: string;
  rowId: string;
}
class Section {
  title: string;
  rows: Row[];
}
export class SendListDto extends Metadata {
  title: string;
  description?: string;
  footerText?: string;
  buttonText: string;
  sections: Section[];
}

export class ContactMessage {
  fullName: string;
  wuid: string;
  phoneNumber: string;
  organization?: string;
  email?: string;
  url?: string;
}

export class SendTemplateDto extends Metadata {
  name: string;
  language: string;
  components: any;
  webhookUrl?: string;
}
export class SendContactDto extends Metadata {
  contact: ContactMessage[];
}

export class SendReactionDto {
  key: proto.IMessageKey;
  reaction: string;
}



================================================
FILE: src/api/dto/settings.dto.ts
================================================
export class SettingsDto {
  rejectCall?: boolean;
  msgCall?: string;
  groupsIgnore?: boolean;
  alwaysOnline?: boolean;
  readMessages?: boolean;
  readStatus?: boolean;
  syncFullHistory?: boolean;
  wavoipToken?: string;
}



================================================
FILE: src/api/dto/template.dto.ts
================================================
export class TemplateDto {
  name: string;
  category: string;
  allowCategoryChange: boolean;
  language: string;
  components: any;
  webhookUrl?: string;
}



================================================
FILE: src/api/guards/auth.guard.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { prismaRepository } from '@api/server.module';
import { Auth, configService, Database } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { ForbiddenException, UnauthorizedException } from '@exceptions';
import { NextFunction, Request, Response } from 'express';

const logger = new Logger('GUARD');

async function apikey(req: Request, _: Response, next: NextFunction) {
  const env = configService.get<Auth>('AUTHENTICATION').API_KEY;
  const key = req.get('apikey');
  const db = configService.get<Database>('DATABASE');

  if (!key) {
    throw new UnauthorizedException();
  }

  if (env.KEY === key) {
    return next();
  }

  if ((req.originalUrl.includes('/instance/create') || req.originalUrl.includes('/instance/fetchInstances')) && !key) {
    throw new ForbiddenException('Missing global api key', 'The global api key must be set');
  }
  const param = req.params as unknown as InstanceDto;

  try {
    if (param?.instanceName) {
      const instance = await prismaRepository.instance.findUnique({
        where: { name: param.instanceName },
      });
      if (instance.token === key) {
        return next();
      }
    } else {
      if (req.originalUrl.includes('/instance/fetchInstances') && db.SAVE_DATA.INSTANCE) {
        const instanceByKey = await prismaRepository.instance.findFirst({
          where: { token: key },
        });
        if (instanceByKey) {
          return next();
        }
      }
    }
  } catch (error) {
    logger.error(error);
  }

  throw new UnauthorizedException();
}

export const authGuard = { apikey };



================================================
FILE: src/api/guards/instance.guard.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { cache, prismaRepository, waMonitor } from '@api/server.module';
import { CacheConf, configService } from '@config/env.config';
import { BadRequestException, ForbiddenException, InternalServerErrorException, NotFoundException } from '@exceptions';
import { NextFunction, Request, Response } from 'express';

async function getInstance(instanceName: string) {
  try {
    const cacheConf = configService.get<CacheConf>('CACHE');

    const exists = !!waMonitor.waInstances[instanceName];

    if (cacheConf.REDIS.ENABLED && cacheConf.REDIS.SAVE_INSTANCES) {
      const keyExists = await cache.has(instanceName);

      return exists || keyExists;
    }

    return exists || (await prismaRepository.instance.findMany({ where: { name: instanceName } })).length > 0;
  } catch (error) {
    throw new InternalServerErrorException(error?.toString());
  }
}

export async function instanceExistsGuard(req: Request, _: Response, next: NextFunction) {
  if (req.originalUrl.includes('/instance/create') || req.originalUrl.includes('/instance/fetchInstances')) {
    return next();
  }

  const param = req.params as unknown as InstanceDto;
  if (!param?.instanceName) {
    throw new BadRequestException('"instanceName" not provided.');
  }

  if (!(await getInstance(param.instanceName))) {
    throw new NotFoundException(`The "${param.instanceName}" instance does not exist`);
  }

  next();
}

export async function instanceLoggedGuard(req: Request, _: Response, next: NextFunction) {
  if (req.originalUrl.includes('/instance/create')) {
    const instance = req.body as InstanceDto;
    if (await getInstance(instance.instanceName)) {
      throw new ForbiddenException(`This name "${instance.instanceName}" is already in use.`);
    }

    if (waMonitor.waInstances[instance.instanceName]) {
      delete waMonitor.waInstances[instance.instanceName];
    }
  }

  next();
}



================================================
FILE: src/api/guards/telemetry.guard.ts
================================================
import { sendTelemetry } from '@utils/sendTelemetry';
import { NextFunction, Request, Response } from 'express';

class Telemetry {
  public collectTelemetry(req: Request, res: Response, next: NextFunction): void {
    sendTelemetry(req.path);

    next();
  }
}

export default Telemetry;



================================================
FILE: src/api/integrations/integration.dto.ts
================================================
import { ChatwootInstanceMixin } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
import { EventInstanceMixin } from '@api/integrations/event/event.dto';

export type Constructor<T = {}> = new (...args: any[]) => T;

export class IntegrationDto extends EventInstanceMixin(ChatwootInstanceMixin(class {})) {}



================================================
FILE: src/api/integrations/channel/channel.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { ProviderFiles } from '@api/provider/sessions';
import { PrismaRepository } from '@api/repository/repository.service';
import { CacheService } from '@api/services/cache.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Integration } from '@api/types/wa.types';
import { ConfigService } from '@config/env.config';
import { BadRequestException } from '@exceptions';
import EventEmitter2 from 'eventemitter2';

import { EvolutionStartupService } from './evolution/evolution.channel.service';
import { BusinessStartupService } from './meta/whatsapp.business.service';
import { BaileysStartupService } from './whatsapp/whatsapp.baileys.service';

type ChannelDataType = {
  configService: ConfigService;
  eventEmitter: EventEmitter2;
  prismaRepository: PrismaRepository;
  cache: CacheService;
  chatwootCache: CacheService;
  baileysCache: CacheService;
  providerFiles: ProviderFiles;
};

export interface ChannelControllerInterface {
  receiveWebhook(data: any): Promise<any>;
}

export class ChannelController {
  public prismaRepository: PrismaRepository;
  public waMonitor: WAMonitoringService;

  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    this.prisma = prismaRepository;
    this.monitor = waMonitor;
  }

  public set prisma(prisma: PrismaRepository) {
    this.prismaRepository = prisma;
  }

  public get prisma() {
    return this.prismaRepository;
  }

  public set monitor(waMonitor: WAMonitoringService) {
    this.waMonitor = waMonitor;
  }

  public get monitor() {
    return this.waMonitor;
  }

  public init(instanceData: InstanceDto, data: ChannelDataType) {
    if (!instanceData.token && instanceData.integration === Integration.WHATSAPP_BUSINESS) {
      throw new BadRequestException('token is required');
    }

    if (instanceData.integration === Integration.WHATSAPP_BUSINESS) {
      return new BusinessStartupService(
        data.configService,
        data.eventEmitter,
        data.prismaRepository,
        data.cache,
        data.chatwootCache,
        data.baileysCache,
        data.providerFiles,
      );
    }

    if (instanceData.integration === Integration.EVOLUTION) {
      return new EvolutionStartupService(
        data.configService,
        data.eventEmitter,
        data.prismaRepository,
        data.cache,
        data.chatwootCache,
      );
    }

    if (instanceData.integration === Integration.WHATSAPP_BAILEYS) {
      return new BaileysStartupService(
        data.configService,
        data.eventEmitter,
        data.prismaRepository,
        data.cache,
        data.chatwootCache,
        data.baileysCache,
        data.providerFiles,
      );
    }

    return null;
  }
}



================================================
FILE: src/api/integrations/channel/channel.router.ts
================================================
import { Router } from 'express';

import { EvolutionRouter } from './evolution/evolution.router';
import { MetaRouter } from './meta/meta.router';
import { BaileysRouter } from './whatsapp/baileys.router';

export class ChannelRouter {
  public readonly router: Router;

  constructor(configService: any, ...guards: any[]) {
    this.router = Router();

    this.router.use('/', new EvolutionRouter(configService).router);
    this.router.use('/', new MetaRouter(configService).router);
    this.router.use('/baileys', new BaileysRouter(...guards).router);
  }
}



================================================
FILE: src/api/integrations/channel/evolution/evolution.channel.service.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import {
  MediaMessage,
  Options,
  SendAudioDto,
  SendButtonsDto,
  SendMediaDto,
  SendTextDto,
} from '@api/dto/sendMessage.dto';
import * as s3Service from '@api/integrations/storage/s3/libs/minio.server';
import { PrismaRepository } from '@api/repository/repository.service';
import { chatbotController } from '@api/server.module';
import { CacheService } from '@api/services/cache.service';
import { ChannelStartupService } from '@api/services/channel.service';
import { Events, wa } from '@api/types/wa.types';
import { Chatwoot, ConfigService, Openai, S3 } from '@config/env.config';
import { BadRequestException, InternalServerErrorException } from '@exceptions';
import { createJid } from '@utils/createJid';
import axios from 'axios';
import { isBase64, isURL } from 'class-validator';
import EventEmitter2 from 'eventemitter2';
import FormData from 'form-data';
import mimeTypes from 'mime-types';
import { join } from 'path';
import { v4 } from 'uuid';

export class EvolutionStartupService extends ChannelStartupService {
  constructor(
    public readonly configService: ConfigService,
    public readonly eventEmitter: EventEmitter2,
    public readonly prismaRepository: PrismaRepository,
    public readonly cache: CacheService,
    public readonly chatwootCache: CacheService,
  ) {
    super(configService, eventEmitter, prismaRepository, chatwootCache);

    this.client = null;
  }

  public client: any;

  public stateConnection: wa.StateConnection = { state: 'open' };

  public phoneNumber: string;
  public mobile: boolean;

  public get connectionStatus() {
    return this.stateConnection;
  }

  public async closeClient() {
    this.stateConnection = { state: 'close' };
  }

  public get qrCode(): wa.QrCode {
    return {
      pairingCode: this.instance.qrcode?.pairingCode,
      code: this.instance.qrcode?.code,
      base64: this.instance.qrcode?.base64,
      count: this.instance.qrcode?.count,
    };
  }

  public async logoutInstance() {
    await this.closeClient();
  }

  public setInstance(instance: InstanceDto) {
    this.logger.setInstance(instance.instanceId);

    this.instance.name = instance.instanceName;
    this.instance.id = instance.instanceId;
    this.instance.integration = instance.integration;
    this.instance.number = instance.number;
    this.instance.token = instance.token;
    this.instance.businessId = instance.businessId;

    if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
      this.chatwootService.eventWhatsapp(
        Events.STATUS_INSTANCE,
        {
          instanceName: this.instance.name,
          instanceId: this.instance.id,
          integration: instance.integration,
        },
        {
          instance: this.instance.name,
          status: 'created',
        },
      );
    }
  }

  public async profilePicture(number: string) {
    const jid = createJid(number);

    return {
      wuid: jid,
      profilePictureUrl: null,
    };
  }

  public async getProfileName() {
    return null;
  }

  public async profilePictureUrl() {
    return null;
  }

  public async getProfileStatus() {
    return null;
  }

  public async connectToWhatsapp(data?: any): Promise<any> {
    if (!data) {
      this.loadChatwoot();
      return;
    }

    try {
      this.eventHandler(data);
    } catch (error) {
      this.logger.error(error);
      throw new InternalServerErrorException(error?.toString());
    }
  }

  protected async eventHandler(received: any) {
    try {
      let messageRaw: any;

      if (received.message) {
        const key = {
          id: received.key.id || v4(),
          remoteJid: received.key.remoteJid,
          fromMe: received.key.fromMe,
          profilePicUrl: received.profilePicUrl,
        };
        messageRaw = {
          key,
          pushName: received.pushName,
          message: received.message,
          messageType: received.messageType,
          messageTimestamp: Math.round(new Date().getTime() / 1000),
          source: 'unknown',
          instanceId: this.instanceId,
        };

        const isAudio = received?.message?.audioMessage;

        if (this.configService.get<Openai>('OPENAI').ENABLED && isAudio) {
          const openAiDefaultSettings = await this.prismaRepository.openaiSetting.findFirst({
            where: {
              instanceId: this.instanceId,
            },
            include: {
              OpenaiCreds: true,
            },
          });

          if (
            openAiDefaultSettings &&
            openAiDefaultSettings.openaiCredsId &&
            openAiDefaultSettings.speechToText &&
            received?.message?.audioMessage
          ) {
            messageRaw.message.speechToText = await this.openaiService.speechToText(
              openAiDefaultSettings.OpenaiCreds,
              received,
              this.client.updateMediaMessage,
            );
          }
        }

        this.logger.log(messageRaw);

        this.sendDataWebhook(Events.MESSAGES_UPSERT, messageRaw);

        await chatbotController.emit({
          instance: { instanceName: this.instance.name, instanceId: this.instanceId },
          remoteJid: messageRaw.key.remoteJid,
          msg: messageRaw,
          pushName: messageRaw.pushName,
        });

        if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
          const chatwootSentMessage = await this.chatwootService.eventWhatsapp(
            Events.MESSAGES_UPSERT,
            { instanceName: this.instance.name, instanceId: this.instanceId },
            messageRaw,
          );

          if (chatwootSentMessage?.id) {
            messageRaw.chatwootMessageId = chatwootSentMessage.id;
            messageRaw.chatwootInboxId = chatwootSentMessage.id;
            messageRaw.chatwootConversationId = chatwootSentMessage.id;
          }
        }

        await this.prismaRepository.message.create({
          data: messageRaw,
        });

        await this.updateContact({
          remoteJid: messageRaw.key.remoteJid,
          pushName: messageRaw.pushName,
          profilePicUrl: received.profilePicUrl,
        });
      }
    } catch (error) {
      this.logger.error(error);
    }
  }

  private async updateContact(data: { remoteJid: string; pushName?: string; profilePicUrl?: string }) {
    const contactRaw: any = {
      remoteJid: data.remoteJid,
      pushName: data?.pushName,
      instanceId: this.instanceId,
      profilePicUrl: data?.profilePicUrl,
    };

    const existingContact = await this.prismaRepository.contact.findFirst({
      where: {
        remoteJid: data.remoteJid,
        instanceId: this.instanceId,
      },
    });

    if (existingContact) {
      await this.prismaRepository.contact.updateMany({
        where: {
          remoteJid: data.remoteJid,
          instanceId: this.instanceId,
        },
        data: contactRaw,
      });
    } else {
      await this.prismaRepository.contact.create({
        data: contactRaw,
      });
    }

    this.sendDataWebhook(Events.CONTACTS_UPSERT, contactRaw);

    if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
      await this.chatwootService.eventWhatsapp(
        Events.CONTACTS_UPDATE,
        {
          instanceName: this.instance.name,
          instanceId: this.instanceId,
          integration: this.instance.integration,
        },
        contactRaw,
      );
    }

    const chat = await this.prismaRepository.chat.findFirst({
      where: { instanceId: this.instanceId, remoteJid: data.remoteJid },
    });

    if (chat) {
      const chatRaw: any = {
        remoteJid: data.remoteJid,
        instanceId: this.instanceId,
      };

      this.sendDataWebhook(Events.CHATS_UPDATE, chatRaw);

      await this.prismaRepository.chat.updateMany({
        where: { remoteJid: chat.remoteJid },
        data: chatRaw,
      });
    }

    const chatRaw: any = {
      remoteJid: data.remoteJid,
      instanceId: this.instanceId,
    };

    this.sendDataWebhook(Events.CHATS_UPSERT, chatRaw);

    await this.prismaRepository.chat.create({
      data: chatRaw,
    });
  }

  protected async sendMessageWithTyping(
    number: string,
    message: any,
    options?: Options,
    file?: any,
    isIntegration = false,
  ) {
    try {
      let quoted: any;
      let webhookUrl: any;

      if (options?.quoted) {
        const m = options?.quoted;

        const msg = m?.key;

        if (!msg) {
          throw 'Message not found';
        }

        quoted = msg;
      }

      if (options.delay) {
        await new Promise((resolve) => setTimeout(resolve, options.delay));
      }

      if (options?.webhookUrl) {
        webhookUrl = options.webhookUrl;
      }

      let audioFile;

      const messageId = v4();

      let messageRaw: any;

      if (message?.mediaType === 'image') {
        messageRaw = {
          key: { fromMe: true, id: messageId, remoteJid: number },
          message: {
            base64: isBase64(message.media) ? message.media : undefined,
            mediaUrl: isURL(message.media) ? message.media : undefined,
            quoted,
          },
          messageType: 'imageMessage',
          messageTimestamp: Math.round(new Date().getTime() / 1000),
          webhookUrl,
          source: 'unknown',
          instanceId: this.instanceId,
        };
      } else if (message?.mediaType === 'video') {
        messageRaw = {
          key: { fromMe: true, id: messageId, remoteJid: number },
          message: {
            base64: isBase64(message.media) ? message.media : undefined,
            mediaUrl: isURL(message.media) ? message.media : undefined,
            quoted,
          },
          messageType: 'videoMessage',
          messageTimestamp: Math.round(new Date().getTime() / 1000),
          webhookUrl,
          source: 'unknown',
          instanceId: this.instanceId,
        };
      } else if (message?.mediaType === 'audio') {
        messageRaw = {
          key: { fromMe: true, id: messageId, remoteJid: number },
          message: {
            base64: isBase64(message.media) ? message.media : undefined,
            mediaUrl: isURL(message.media) ? message.media : undefined,
            quoted,
          },
          messageType: 'audioMessage',
          messageTimestamp: Math.round(new Date().getTime() / 1000),
          webhookUrl,
          source: 'unknown',
          instanceId: this.instanceId,
        };

        const buffer = Buffer.from(message.media, 'base64');
        audioFile = {
          buffer,
          mimetype: 'audio/mp4',
          originalname: `${messageId}.mp4`,
        };
      } else if (message?.mediaType === 'document') {
        messageRaw = {
          key: { fromMe: true, id: messageId, remoteJid: number },
          message: {
            base64: isBase64(message.media) ? message.media : undefined,
            mediaUrl: isURL(message.media) ? message.media : undefined,
            quoted,
          },
          messageType: 'documentMessage',
          messageTimestamp: Math.round(new Date().getTime() / 1000),
          webhookUrl,
          source: 'unknown',
          instanceId: this.instanceId,
        };
      } else if (message.buttonMessage) {
        messageRaw = {
          key: { fromMe: true, id: messageId, remoteJid: number },
          message: {
            ...message.buttonMessage,
            buttons: message.buttonMessage.buttons,
            footer: message.buttonMessage.footer,
            body: message.buttonMessage.body,
            quoted,
          },
          messageType: 'buttonMessage',
          messageTimestamp: Math.round(new Date().getTime() / 1000),
          webhookUrl,
          source: 'unknown',
          instanceId: this.instanceId,
        };
      } else if (message.listMessage) {
        messageRaw = {
          key: { fromMe: true, id: messageId, remoteJid: number },
          message: {
            ...message.listMessage,
            quoted,
          },
          messageType: 'listMessage',
          messageTimestamp: Math.round(new Date().getTime() / 1000),
          webhookUrl,
          source: 'unknown',
          instanceId: this.instanceId,
        };
      } else {
        messageRaw = {
          key: { fromMe: true, id: messageId, remoteJid: number },
          message: {
            ...message,
            quoted,
          },
          messageType: 'conversation',
          messageTimestamp: Math.round(new Date().getTime() / 1000),
          webhookUrl,
          source: 'unknown',
          instanceId: this.instanceId,
        };
      }

      if (messageRaw.message.contextInfo) {
        messageRaw.contextInfo = {
          ...messageRaw.message.contextInfo,
        };
      }

      if (messageRaw.contextInfo?.stanzaId) {
        const key: any = {
          id: messageRaw.contextInfo.stanzaId,
        };

        const findMessage = await this.prismaRepository.message.findFirst({
          where: {
            instanceId: this.instanceId,
            key,
          },
        });

        if (findMessage) {
          messageRaw.contextInfo.quotedMessage = findMessage.message;
        }
      }

      const base64 = messageRaw.message.base64;
      delete messageRaw.message.base64;

      if (base64 || file || audioFile) {
        if (this.configService.get<S3>('S3').ENABLE) {
          try {
            const fileBuffer = audioFile?.buffer || file?.buffer;
            const buffer = base64 ? Buffer.from(base64, 'base64') : fileBuffer;

            let mediaType: string;
            let mimetype = audioFile?.mimetype || file.mimetype;

            if (messageRaw.messageType === 'documentMessage') {
              mediaType = 'document';
              mimetype = !mimetype ? 'application/pdf' : mimetype;
            } else if (messageRaw.messageType === 'imageMessage') {
              mediaType = 'image';
              mimetype = !mimetype ? 'image/png' : mimetype;
            } else if (messageRaw.messageType === 'audioMessage') {
              mediaType = 'audio';
              mimetype = !mimetype ? 'audio/mp4' : mimetype;
            } else if (messageRaw.messageType === 'videoMessage') {
              mediaType = 'video';
              mimetype = !mimetype ? 'video/mp4' : mimetype;
            }

            const fileName = `${messageRaw.key.id}.${mimetype.split('/')[1]}`;

            const size = buffer.byteLength;

            const fullName = join(`${this.instance.id}`, messageRaw.key.remoteJid, mediaType, fileName);

            await s3Service.uploadFile(fullName, buffer, size, {
              'Content-Type': mimetype,
            });

            const mediaUrl = await s3Service.getObjectUrl(fullName);

            messageRaw.message.mediaUrl = mediaUrl;
          } catch (error) {
            this.logger.error(['Error on upload file to minio', error?.message, error?.stack]);
          }
        }
      }

      this.logger.log(messageRaw);

      this.sendDataWebhook(Events.SEND_MESSAGE, messageRaw);

      if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled && !isIntegration) {
        this.chatwootService.eventWhatsapp(
          Events.SEND_MESSAGE,
          { instanceName: this.instance.name, instanceId: this.instanceId },
          messageRaw,
        );
      }

      if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled && isIntegration)
        await chatbotController.emit({
          instance: { instanceName: this.instance.name, instanceId: this.instanceId },
          remoteJid: messageRaw.key.remoteJid,
          msg: messageRaw,
          pushName: messageRaw.pushName,
        });

      await this.prismaRepository.message.create({
        data: messageRaw,
      });

      return messageRaw;
    } catch (error) {
      this.logger.error(error);
      throw new BadRequestException(error.toString());
    }
  }

  public async textMessage(data: SendTextDto, isIntegration = false) {
    const res = await this.sendMessageWithTyping(
      data.number,
      {
        conversation: data.text,
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      null,
      isIntegration,
    );
    return res;
  }

  protected async prepareMediaMessage(mediaMessage: MediaMessage) {
    try {
      if (mediaMessage.mediatype === 'document' && !mediaMessage.fileName) {
        const regex = new RegExp(/.*\/(.+?)\./);
        const arrayMatch = regex.exec(mediaMessage.media);
        mediaMessage.fileName = arrayMatch[1];
      }

      if (mediaMessage.mediatype === 'image' && !mediaMessage.fileName) {
        mediaMessage.fileName = 'image.png';
      }

      if (mediaMessage.mediatype === 'video' && !mediaMessage.fileName) {
        mediaMessage.fileName = 'video.mp4';
      }

      let mimetype: string | false;

      const prepareMedia: any = {
        caption: mediaMessage?.caption,
        fileName: mediaMessage.fileName,
        mediaType: mediaMessage.mediatype,
        media: mediaMessage.media,
        gifPlayback: false,
      };

      if (isURL(mediaMessage.media)) {
        mimetype = mimeTypes.lookup(mediaMessage.media);
      } else {
        mimetype = mimeTypes.lookup(mediaMessage.fileName);
      }

      prepareMedia.mimetype = mimetype;

      return prepareMedia;
    } catch (error) {
      this.logger.error(error);
      throw new InternalServerErrorException(error?.toString() || error);
    }
  }

  public async mediaMessage(data: SendMediaDto, file?: any, isIntegration = false) {
    const mediaData: SendMediaDto = { ...data };

    if (file) mediaData.media = file.buffer.toString('base64');

    const message = await this.prepareMediaMessage(mediaData);

    const mediaSent = await this.sendMessageWithTyping(
      data.number,
      { ...message },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      file,
      isIntegration,
    );

    return mediaSent;
  }

  public async processAudio(audio: string, number: string, file: any) {
    number = number.replace(/\D/g, '');
    const hash = `${number}-${new Date().getTime()}`;

    if (process.env.API_AUDIO_CONVERTER) {
      try {
        this.logger.verbose('Using audio converter API');
        const formData = new FormData();

        if (file) {
          formData.append('file', file.buffer, {
            filename: file.originalname,
            contentType: file.mimetype,
          });
        } else if (isURL(audio)) {
          formData.append('url', audio);
        } else {
          formData.append('base64', audio);
        }

        formData.append('format', 'mp4');

        const response = await axios.post(process.env.API_AUDIO_CONVERTER, formData, {
          headers: {
            ...formData.getHeaders(),
            apikey: process.env.API_AUDIO_CONVERTER_KEY,
          },
        });

        if (!response?.data?.audio) {
          throw new InternalServerErrorException('Failed to convert audio');
        }

        const prepareMedia: any = {
          fileName: `${hash}.mp4`,
          mediaType: 'audio',
          media: response?.data?.audio,
          mimetype: 'audio/mpeg',
        };

        return prepareMedia;
      } catch (error) {
        this.logger.error(error?.response?.data || error);
        throw new InternalServerErrorException(error?.response?.data?.message || error?.toString() || error);
      }
    } else {
      let mimetype: string;

      const prepareMedia: any = {
        fileName: `${hash}.mp3`,
        mediaType: 'audio',
        media: audio,
        mimetype: 'audio/mpeg',
      };

      if (isURL(audio)) {
        mimetype = mimeTypes.lookup(audio).toString();
      } else {
        mimetype = mimeTypes.lookup(prepareMedia.fileName).toString();
      }

      prepareMedia.mimetype = mimetype;

      return prepareMedia;
    }
  }

  public async audioWhatsapp(data: SendAudioDto, file?: any, isIntegration = false) {
    const mediaData: SendAudioDto = { ...data };

    if (file?.buffer) {
      mediaData.audio = file.buffer.toString('base64');
    } else {
      console.error('El archivo o buffer no est� definido correctamente.');
      throw new Error('File or buffer is undefined.');
    }

    const message = await this.processAudio(mediaData.audio, data.number, file);

    const audioSent = await this.sendMessageWithTyping(
      data.number,
      { ...message },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      file,
      isIntegration,
    );

    return audioSent;
  }

  public async buttonMessage(data: SendButtonsDto, isIntegration = false) {
    return await this.sendMessageWithTyping(
      data.number,
      {
        buttonMessage: {
          title: data.title,
          description: data.description,
          footer: data.footer,
          buttons: data.buttons,
        },
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      null,
      isIntegration,
    );
  }
  public async locationMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async listMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async templateMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async contactMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async reactionMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async getBase64FromMediaMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async deleteMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async mediaSticker() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async pollMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async statusMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async reloadConnection() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async whatsappNumber() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async markMessageAsRead() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async archiveChat() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async markChatUnread() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async fetchProfile() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async offerCall() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async sendPresence() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async setPresence() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async fetchPrivacySettings() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updatePrivacySettings() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async fetchBusinessProfile() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updateProfileName() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updateProfileStatus() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updateProfilePicture() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async removeProfilePicture() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async blockUser() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updateMessage() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async createGroup() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updateGroupPicture() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updateGroupSubject() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updateGroupDescription() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async findGroup() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async fetchAllGroups() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async inviteCode() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async inviteInfo() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async sendInvite() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async acceptInviteCode() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async revokeInviteCode() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async findParticipants() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updateGParticipant() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async updateGSetting() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async toggleEphemeral() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async leaveGroup() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async fetchLabels() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async handleLabel() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async receiveMobileCode() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
  public async fakeCall() {
    throw new BadRequestException('Method not available on Evolution Channel');
  }
}



================================================
FILE: src/api/integrations/channel/evolution/evolution.controller.ts
================================================
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Logger } from '@config/logger.config';

import { ChannelController, ChannelControllerInterface } from '../channel.controller';

export class EvolutionController extends ChannelController implements ChannelControllerInterface {
  private readonly logger = new Logger('EvolutionController');

  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    super(prismaRepository, waMonitor);
  }

  integrationEnabled: boolean;

  public async receiveWebhook(data: any) {
    const numberId = data.numberId;

    if (!numberId) {
      this.logger.error('WebhookService -> receiveWebhookEvolution -> numberId not found');
      return;
    }

    const instance = await this.prismaRepository.instance.findFirst({
      where: { number: numberId },
    });

    if (!instance) {
      this.logger.error('WebhookService -> receiveWebhook -> instance not found');
      return;
    }

    await this.waMonitor.waInstances[instance.name].connectToWhatsapp(data);

    return {
      status: 'success',
    };
  }
}



================================================
FILE: src/api/integrations/channel/evolution/evolution.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { evolutionController } from '@api/server.module';
import { ConfigService } from '@config/env.config';
import { Router } from 'express';

export class EvolutionRouter extends RouterBroker {
  constructor(readonly configService: ConfigService) {
    super();
    this.router.post(this.routerPath('webhook/evolution', false), async (req, res) => {
      const { body } = req;
      const response = await evolutionController.receiveWebhook(body);

      return res.status(200).json(response);
    });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/channel/meta/meta.controller.ts
================================================
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Logger } from '@config/logger.config';
import axios from 'axios';

import { ChannelController, ChannelControllerInterface } from '../channel.controller';

export class MetaController extends ChannelController implements ChannelControllerInterface {
  private readonly logger = new Logger('MetaController');

  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    super(prismaRepository, waMonitor);
  }

  integrationEnabled: boolean;

  public async receiveWebhook(data: any) {
    if (data.object === 'whatsapp_business_account') {
      if (data.entry[0]?.changes[0]?.field === 'message_template_status_update') {
        const template = await this.prismaRepository.template.findFirst({
          where: { templateId: `${data.entry[0].changes[0].value.message_template_id}` },
        });

        if (!template) {
          console.log('template not found');
          return;
        }

        const { webhookUrl } = template;

        await axios.post(webhookUrl, data.entry[0].changes[0].value, {
          headers: {
            'Content-Type': 'application/json',
          },
        });
        return;
      }

      data.entry?.forEach(async (entry: any) => {
        const numberId = entry.changes[0].value.metadata.phone_number_id;

        if (!numberId) {
          this.logger.error('WebhookService -> receiveWebhookMeta -> numberId not found');
          return {
            status: 'success',
          };
        }

        const instance = await this.prismaRepository.instance.findFirst({
          where: { number: numberId },
        });

        if (!instance) {
          this.logger.error('WebhookService -> receiveWebhookMeta -> instance not found');
          return {
            status: 'success',
          };
        }

        await this.waMonitor.waInstances[instance.name].connectToWhatsapp(data);

        return {
          status: 'success',
        };
      });
    }

    return {
      status: 'success',
    };
  }
}



================================================
FILE: src/api/integrations/channel/meta/meta.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { metaController } from '@api/server.module';
import { ConfigService, WaBusiness } from '@config/env.config';
import { Router } from 'express';

export class MetaRouter extends RouterBroker {
  constructor(readonly configService: ConfigService) {
    super();
    this.router
      .get(this.routerPath('webhook/meta', false), async (req, res) => {
        if (req.query['hub.verify_token'] === configService.get<WaBusiness>('WA_BUSINESS').TOKEN_WEBHOOK)
          res.send(req.query['hub.challenge']);
        else res.send('Error, wrong validation token');
      })
      .post(this.routerPath('webhook/meta', false), async (req, res) => {
        const { body } = req;
        const response = await metaController.receiveWebhook(body);

        return res.status(200).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/channel/meta/whatsapp.business.service.ts
================================================
import { NumberBusiness } from '@api/dto/chat.dto';
import {
  ContactMessage,
  MediaMessage,
  Options,
  SendAudioDto,
  SendButtonsDto,
  SendContactDto,
  SendListDto,
  SendLocationDto,
  SendMediaDto,
  SendReactionDto,
  SendTemplateDto,
  SendTextDto,
} from '@api/dto/sendMessage.dto';
import * as s3Service from '@api/integrations/storage/s3/libs/minio.server';
import { ProviderFiles } from '@api/provider/sessions';
import { PrismaRepository } from '@api/repository/repository.service';
import { chatbotController } from '@api/server.module';
import { CacheService } from '@api/services/cache.service';
import { ChannelStartupService } from '@api/services/channel.service';
import { Events, wa } from '@api/types/wa.types';
import { Chatwoot, ConfigService, Database, Openai, S3, WaBusiness } from '@config/env.config';
import { BadRequestException, InternalServerErrorException } from '@exceptions';
import { createJid } from '@utils/createJid';
import { status } from '@utils/renderStatus';
import axios from 'axios';
import { arrayUnique, isURL } from 'class-validator';
import EventEmitter2 from 'eventemitter2';
import FormData from 'form-data';
import { createReadStream } from 'fs';
import mimeTypes from 'mime-types';
import { join } from 'path';

export class BusinessStartupService extends ChannelStartupService {
  constructor(
    public readonly configService: ConfigService,
    public readonly eventEmitter: EventEmitter2,
    public readonly prismaRepository: PrismaRepository,
    public readonly cache: CacheService,
    public readonly chatwootCache: CacheService,
    public readonly baileysCache: CacheService,
    private readonly providerFiles: ProviderFiles,
  ) {
    super(configService, eventEmitter, prismaRepository, chatwootCache);
  }

  public stateConnection: wa.StateConnection = { state: 'open' };

  public phoneNumber: string;
  public mobile: boolean;

  public get connectionStatus() {
    return this.stateConnection;
  }

  public async closeClient() {
    this.stateConnection = { state: 'close' };
  }

  public get qrCode(): wa.QrCode {
    return {
      pairingCode: this.instance.qrcode?.pairingCode,
      code: this.instance.qrcode?.code,
      base64: this.instance.qrcode?.base64,
      count: this.instance.qrcode?.count,
    };
  }

  public async logoutInstance() {
    await this.closeClient();
  }

  private isMediaMessage(message: any) {
    return message.document || message.image || message.audio || message.video;
  }

  private async post(message: any, params: string) {
    try {
      let urlServer = this.configService.get<WaBusiness>('WA_BUSINESS').URL;
      const version = this.configService.get<WaBusiness>('WA_BUSINESS').VERSION;
      urlServer = `${urlServer}/${version}/${this.number}/${params}`;
      const headers = { 'Content-Type': 'application/json', Authorization: `Bearer ${this.token}` };
      const result = await axios.post(urlServer, message, { headers });
      return result.data;
    } catch (e) {
      return e.response?.data?.error;
    }
  }

  public async profilePicture(number: string) {
    const jid = createJid(number);

    return {
      wuid: jid,
      profilePictureUrl: null,
    };
  }

  public async getProfileName() {
    return null;
  }

  public async profilePictureUrl() {
    return null;
  }

  public async getProfileStatus() {
    return null;
  }

  public async setWhatsappBusinessProfile(data: NumberBusiness): Promise<any> {
    const content = {
      messaging_product: 'whatsapp',
      about: data.about,
      address: data.address,
      description: data.description,
      vertical: data.vertical,
      email: data.email,
      websites: data.websites,
      profile_picture_handle: data.profilehandle,
    };
    return await this.post(content, 'whatsapp_business_profile');
  }

  public async connectToWhatsapp(data?: any): Promise<any> {
    if (!data) return;

    const content = data.entry[0].changes[0].value;

    try {
      this.loadChatwoot();

      this.eventHandler(content);

      this.phoneNumber = createJid(content.messages ? content.messages[0].from : content.statuses[0]?.recipient_id);
    } catch (error) {
      this.logger.error(error);
      throw new InternalServerErrorException(error?.toString());
    }
  }

  private async downloadMediaMessage(message: any) {
    try {
      const id = message[message.type].id;
      let urlServer = this.configService.get<WaBusiness>('WA_BUSINESS').URL;
      const version = this.configService.get<WaBusiness>('WA_BUSINESS').VERSION;
      urlServer = `${urlServer}/${version}/${id}`;
      const headers = { 'Content-Type': 'application/json', Authorization: `Bearer ${this.token}` };
      let result = await axios.get(urlServer, { headers });
      result = await axios.get(result.data.url, { headers, responseType: 'arraybuffer' });
      return result.data;
    } catch (e) {
      this.logger.error(e);
    }
  }

  private messageMediaJson(received: any) {
    const message = received.messages[0];
    let content: any = message.type + 'Message';
    content = { [content]: message[message.type] };
    message.context ? (content = { ...content, contextInfo: { stanzaId: message.context.id } }) : content;
    return content;
  }

  private messageInteractiveJson(received: any) {
    const message = received.messages[0];
    let content: any = { conversation: message.interactive[message.interactive.type].title };
    message.context ? (content = { ...content, contextInfo: { stanzaId: message.context.id } }) : content;
    return content;
  }

  private messageButtonJson(received: any) {
    const message = received.messages[0];
    let content: any = { conversation: received.messages[0].button?.text };
    message.context ? (content = { ...content, contextInfo: { stanzaId: message.context.id } }) : content;
    return content;
  }

  private messageReactionJson(received: any) {
    const message = received.messages[0];
    let content: any = {
      reactionMessage: {
        key: {
          id: message.reaction.message_id,
        },
        text: message.reaction.emoji,
      },
    };
    message.context ? (content = { ...content, contextInfo: { stanzaId: message.context.id } }) : content;
    return content;
  }

  private messageTextJson(received: any) {
    let content: any;
    const message = received.messages[0];
    if (message.from === received.metadata.phone_number_id) {
      content = {
        extendedTextMessage: { text: message.text.body },
      };
      message.context ? (content = { ...content, contextInfo: { stanzaId: message.context.id } }) : content;
    } else {
      content = { conversation: message.text.body };
      message.context ? (content = { ...content, contextInfo: { stanzaId: message.context.id } }) : content;
    }
    return content;
  }

  private messageContactsJson(received: any) {
    const message = received.messages[0];
    let content: any = {};

    const vcard = (contact: any) => {
      let result =
        'BEGIN:VCARD\n' +
        'VERSION:3.0\n' +
        `N:${contact.name.formatted_name}\n` +
        `FN:${contact.name.formatted_name}\n`;

      if (contact.org) {
        result += `ORG:${contact.org.company};\n`;
      }

      if (contact.emails) {
        result += `EMAIL:${contact.emails[0].email}\n`;
      }

      if (contact.urls) {
        result += `URL:${contact.urls[0].url}\n`;
      }

      if (!contact.phones[0]?.wa_id) {
        contact.phones[0].wa_id = createJid(contact.phones[0].phone);
      }

      result +=
        `item1.TEL;waid=${contact.phones[0]?.wa_id}:${contact.phones[0].phone}\n` +
        'item1.X-ABLabel:Celular\n' +
        'END:VCARD';

      return result;
    };

    if (message.contacts.length === 1) {
      content.contactMessage = {
        displayName: message.contacts[0].name.formatted_name,
        vcard: vcard(message.contacts[0]),
      };
    } else {
      content.contactsArrayMessage = {
        displayName: `${message.length} contacts`,
        contacts: message.map((contact) => {
          return {
            displayName: contact.name.formatted_name,
            vcard: vcard(contact),
          };
        }),
      };
    }
    message.context ? (content = { ...content, contextInfo: { stanzaId: message.context.id } }) : content;
    return content;
  }

  private renderMessageType(type: string) {
    let messageType: string;

    switch (type) {
      case 'text':
        messageType = 'conversation';
        break;
      case 'image':
        messageType = 'imageMessage';
        break;
      case 'video':
        messageType = 'videoMessage';
        break;
      case 'audio':
        messageType = 'audioMessage';
        break;
      case 'document':
        messageType = 'documentMessage';
        break;
      case 'template':
        messageType = 'conversation';
        break;
      default:
        messageType = 'conversation';
        break;
    }

    return messageType;
  }

  protected async messageHandle(received: any, database: Database, settings: any) {
    try {
      let messageRaw: any;
      let pushName: any;

      if (received.contacts) pushName = received.contacts[0].profile.name;

      if (received.messages) {
        const key = {
          id: received.messages[0].id,
          remoteJid: this.phoneNumber,
          fromMe: received.messages[0].from === received.metadata.phone_number_id,
        };
        if (this.isMediaMessage(received?.messages[0])) {
          messageRaw = {
            key,
            pushName,
            message: this.messageMediaJson(received),
            contextInfo: this.messageMediaJson(received)?.contextInfo,
            messageType: this.renderMessageType(received.messages[0].type),
            messageTimestamp: parseInt(received.messages[0].timestamp) as number,
            source: 'unknown',
            instanceId: this.instanceId,
          };

          if (this.configService.get<S3>('S3').ENABLE) {
            try {
              const message: any = received;

              const id = message.messages[0][message.messages[0].type].id;
              let urlServer = this.configService.get<WaBusiness>('WA_BUSINESS').URL;
              const version = this.configService.get<WaBusiness>('WA_BUSINESS').VERSION;
              urlServer = `${urlServer}/${version}/${id}`;
              const headers = { 'Content-Type': 'application/json', Authorization: `Bearer ${this.token}` };
              const result = await axios.get(urlServer, { headers });

              const buffer = await axios.get(result.data.url, { headers, responseType: 'arraybuffer' });

              let mediaType;

              if (message.messages[0].document) {
                mediaType = 'document';
              } else if (message.messages[0].image) {
                mediaType = 'image';
              } else if (message.messages[0].audio) {
                mediaType = 'audio';
              } else {
                mediaType = 'video';
              }

              const mimetype = result.data?.mime_type || result.headers['content-type'];

              const contentDisposition = result.headers['content-disposition'];
              let fileName = `${message.messages[0].id}.${mimetype.split('/')[1]}`;
              if (contentDisposition) {
                const match = contentDisposition.match(/filename="(.+?)"/);
                if (match) {
                  fileName = match[1];
                }
              }

              const size = result.headers['content-length'] || buffer.data.byteLength;

              const fullName = join(`${this.instance.id}`, key.remoteJid, mediaType, fileName);

              await s3Service.uploadFile(fullName, buffer.data, size, {
                'Content-Type': mimetype,
              });

              const createdMessage = await this.prismaRepository.message.create({
                data: messageRaw,
              });

              await this.prismaRepository.media.create({
                data: {
                  messageId: createdMessage.id,
                  instanceId: this.instanceId,
                  type: mediaType,
                  fileName: fullName,
                  mimetype,
                },
              });

              const mediaUrl = await s3Service.getObjectUrl(fullName);

              messageRaw.message.mediaUrl = mediaUrl;
              messageRaw.message.base64 = buffer.data.toString('base64');
            } catch (error) {
              this.logger.error(['Error on upload file to minio', error?.message, error?.stack]);
            }
          } else {
            const buffer = await this.downloadMediaMessage(received?.messages[0]);

            messageRaw.message.base64 = buffer.toString('base64');
          }
        } else if (received?.messages[0].interactive) {
          messageRaw = {
            key,
            pushName,
            message: {
              ...this.messageInteractiveJson(received),
            },
            contextInfo: this.messageInteractiveJson(received)?.contextInfo,
            messageType: 'interactiveMessage',
            messageTimestamp: parseInt(received.messages[0].timestamp) as number,
            source: 'unknown',
            instanceId: this.instanceId,
          };
        } else if (received?.messages[0].button) {
          messageRaw = {
            key,
            pushName,
            message: {
              ...this.messageButtonJson(received),
            },
            contextInfo: this.messageButtonJson(received)?.contextInfo,
            messageType: 'buttonMessage',
            messageTimestamp: parseInt(received.messages[0].timestamp) as number,
            source: 'unknown',
            instanceId: this.instanceId,
          };
        } else if (received?.messages[0].reaction) {
          messageRaw = {
            key,
            pushName,
            message: {
              ...this.messageReactionJson(received),
            },
            contextInfo: this.messageReactionJson(received)?.contextInfo,
            messageType: 'reactionMessage',
            messageTimestamp: parseInt(received.messages[0].timestamp) as number,
            source: 'unknown',
            instanceId: this.instanceId,
          };
        } else if (received?.messages[0].contacts) {
          messageRaw = {
            key,
            pushName,
            message: {
              ...this.messageContactsJson(received),
            },
            contextInfo: this.messageContactsJson(received)?.contextInfo,
            messageType: 'contactMessage',
            messageTimestamp: parseInt(received.messages[0].timestamp) as number,
            source: 'unknown',
            instanceId: this.instanceId,
          };
        } else {
          messageRaw = {
            key,
            pushName,
            message: this.messageTextJson(received),
            contextInfo: this.messageTextJson(received)?.contextInfo,
            messageType: this.renderMessageType(received.messages[0].type),
            messageTimestamp: parseInt(received.messages[0].timestamp) as number,
            source: 'unknown',
            instanceId: this.instanceId,
          };
        }

        if (this.localSettings.readMessages) {
          // await this.client.readMessages([received.key]);
        }

        if (this.configService.get<Openai>('OPENAI').ENABLED) {
          const openAiDefaultSettings = await this.prismaRepository.openaiSetting.findFirst({
            where: {
              instanceId: this.instanceId,
            },
            include: {
              OpenaiCreds: true,
            },
          });

          const audioMessage = received?.messages[0]?.audio;

          if (
            openAiDefaultSettings &&
            openAiDefaultSettings.openaiCredsId &&
            openAiDefaultSettings.speechToText &&
            audioMessage
          ) {
            messageRaw.message.speechToText = await this.openaiService.speechToText(
              openAiDefaultSettings.OpenaiCreds,
              {
                message: {
                  mediaUrl: messageRaw.message.mediaUrl,
                  ...messageRaw,
                },
              },
              () => {},
            );
          }
        }

        this.logger.log(messageRaw);

        this.sendDataWebhook(Events.MESSAGES_UPSERT, messageRaw);

        await chatbotController.emit({
          instance: { instanceName: this.instance.name, instanceId: this.instanceId },
          remoteJid: messageRaw.key.remoteJid,
          msg: messageRaw,
          pushName: messageRaw.pushName,
        });

        if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
          const chatwootSentMessage = await this.chatwootService.eventWhatsapp(
            Events.MESSAGES_UPSERT,
            { instanceName: this.instance.name, instanceId: this.instanceId },
            messageRaw,
          );

          if (chatwootSentMessage?.id) {
            messageRaw.chatwootMessageId = chatwootSentMessage.id;
            messageRaw.chatwootInboxId = chatwootSentMessage.id;
            messageRaw.chatwootConversationId = chatwootSentMessage.id;
          }
        }

        if (!this.isMediaMessage(received?.messages[0])) {
          await this.prismaRepository.message.create({
            data: messageRaw,
          });
        }

        const contact = await this.prismaRepository.contact.findFirst({
          where: { instanceId: this.instanceId, remoteJid: key.remoteJid },
        });

        const contactRaw: any = {
          remoteJid: received.contacts[0].profile.phone,
          pushName,
          // profilePicUrl: '',
          instanceId: this.instanceId,
        };

        if (contactRaw.remoteJid === 'status@broadcast') {
          return;
        }

        if (contact) {
          const contactRaw: any = {
            remoteJid: received.contacts[0].profile.phone,
            pushName,
            // profilePicUrl: '',
            instanceId: this.instanceId,
          };

          this.sendDataWebhook(Events.CONTACTS_UPDATE, contactRaw);

          if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
            await this.chatwootService.eventWhatsapp(
              Events.CONTACTS_UPDATE,
              { instanceName: this.instance.name, instanceId: this.instanceId },
              contactRaw,
            );
          }

          await this.prismaRepository.contact.updateMany({
            where: { remoteJid: contact.remoteJid },
            data: contactRaw,
          });
          return;
        }

        this.sendDataWebhook(Events.CONTACTS_UPSERT, contactRaw);

        this.prismaRepository.contact.create({
          data: contactRaw,
        });
      }
      if (received.statuses) {
        for await (const item of received.statuses) {
          const key = {
            id: item.id,
            remoteJid: this.phoneNumber,
            fromMe: this.phoneNumber === received.metadata.phone_number_id,
          };
          if (settings?.groups_ignore && key.remoteJid.includes('@g.us')) {
            return;
          }
          if (key.remoteJid !== 'status@broadcast' && !key?.remoteJid?.match(/(:\d+)/)) {
            const findMessage = await this.prismaRepository.message.findFirst({
              where: {
                instanceId: this.instanceId,
                key: {
                  path: ['id'],
                  equals: key.id,
                },
              },
            });

            if (!findMessage) {
              return;
            }

            if (item.message === null && item.status === undefined) {
              this.sendDataWebhook(Events.MESSAGES_DELETE, key);

              const message: any = {
                messageId: findMessage.id,
                keyId: key.id,
                remoteJid: key.remoteJid,
                fromMe: key.fromMe,
                participant: key?.remoteJid,
                status: 'DELETED',
                instanceId: this.instanceId,
              };

              await this.prismaRepository.messageUpdate.create({
                data: message,
              });

              if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
                this.chatwootService.eventWhatsapp(
                  Events.MESSAGES_DELETE,
                  { instanceName: this.instance.name, instanceId: this.instanceId },
                  { key: key },
                );
              }

              return;
            }

            const message: any = {
              messageId: findMessage.id,
              keyId: key.id,
              remoteJid: key.remoteJid,
              fromMe: key.fromMe,
              participant: key?.remoteJid,
              status: item.status.toUpperCase(),
              instanceId: this.instanceId,
            };

            this.sendDataWebhook(Events.MESSAGES_UPDATE, message);

            await this.prismaRepository.messageUpdate.create({
              data: message,
            });

            if (findMessage.webhookUrl) {
              await axios.post(findMessage.webhookUrl, message);
            }
          }
        }
      }
    } catch (error) {
      this.logger.error(error);
    }
  }

  private convertMessageToRaw(message: any, content: any) {
    let convertMessage: any;

    if (message?.conversation) {
      if (content?.context?.message_id) {
        convertMessage = {
          ...message,
          contextInfo: { stanzaId: content.context.message_id },
        };
        return convertMessage;
      }
      convertMessage = message;
      return convertMessage;
    }

    if (message?.mediaType === 'image') {
      if (content?.context?.message_id) {
        convertMessage = {
          imageMessage: message,
          contextInfo: { stanzaId: content.context.message_id },
        };
        return convertMessage;
      }
      return {
        imageMessage: message,
      };
    }

    if (message?.mediaType === 'video') {
      if (content?.context?.message_id) {
        convertMessage = {
          videoMessage: message,
          contextInfo: { stanzaId: content.context.message_id },
        };
        return convertMessage;
      }
      return {
        videoMessage: message,
      };
    }

    if (message?.mediaType === 'audio') {
      if (content?.context?.message_id) {
        convertMessage = {
          audioMessage: message,
          contextInfo: { stanzaId: content.context.message_id },
        };
        return convertMessage;
      }
      return {
        audioMessage: message,
      };
    }

    if (message?.mediaType === 'document') {
      if (content?.context?.message_id) {
        convertMessage = {
          documentMessage: message,
          contextInfo: { stanzaId: content.context.message_id },
        };
        return convertMessage;
      }
      return {
        documentMessage: message,
      };
    }

    return message;
  }

  protected async eventHandler(content: any) {
    const database = this.configService.get<Database>('DATABASE');
    const settings = await this.findSettings();

    this.messageHandle(content, database, settings);
  }

  protected async sendMessageWithTyping(number: string, message: any, options?: Options, isIntegration = false) {
    try {
      let quoted: any;
      let webhookUrl: any;
      const linkPreview = options?.linkPreview != false ? undefined : false;
      if (options?.quoted) {
        const m = options?.quoted;

        const msg = m?.key;

        if (!msg) {
          throw 'Message not found';
        }

        quoted = msg;
      }
      if (options?.webhookUrl) {
        webhookUrl = options.webhookUrl;
      }

      let content: any;
      const messageSent = await (async () => {
        if (message['reactionMessage']) {
          content = {
            messaging_product: 'whatsapp',
            recipient_type: 'individual',
            type: 'reaction',
            to: number.replace(/\D/g, ''),
            reaction: {
              message_id: message['reactionMessage']['key']['id'],
              emoji: message['reactionMessage']['text'],
            },
          };
          quoted ? (content.context = { message_id: quoted.id }) : content;
          return await this.post(content, 'messages');
        }
        if (message['locationMessage']) {
          content = {
            messaging_product: 'whatsapp',
            recipient_type: 'individual',
            type: 'location',
            to: number.replace(/\D/g, ''),
            location: {
              longitude: message['locationMessage']['degreesLongitude'],
              latitude: message['locationMessage']['degreesLatitude'],
              name: message['locationMessage']['name'],
              address: message['locationMessage']['address'],
            },
          };
          quoted ? (content.context = { message_id: quoted.id }) : content;
          return await this.post(content, 'messages');
        }
        if (message['contacts']) {
          content = {
            messaging_product: 'whatsapp',
            recipient_type: 'individual',
            type: 'contacts',
            to: number.replace(/\D/g, ''),
            contacts: message['contacts'],
          };
          quoted ? (content.context = { message_id: quoted.id }) : content;
          message = message['message'];
          return await this.post(content, 'messages');
        }
        if (message['conversation']) {
          content = {
            messaging_product: 'whatsapp',
            recipient_type: 'individual',
            type: 'text',
            to: number.replace(/\D/g, ''),
            text: {
              body: message['conversation'],
              preview_url: linkPreview,
            },
          };
          quoted ? (content.context = { message_id: quoted.id }) : content;
          return await this.post(content, 'messages');
        }
        if (message['media']) {
          const isImage = message['mimetype']?.startsWith('image/');

          content = {
            messaging_product: 'whatsapp',
            recipient_type: 'individual',
            type: message['mediaType'],
            to: number.replace(/\D/g, ''),
            [message['mediaType']]: {
              [message['type']]: message['id'],
              preview_url: linkPreview,
              ...(message['fileName'] && !isImage && { filename: message['fileName'] }),
              caption: message['caption'],
            },
          };
          quoted ? (content.context = { message_id: quoted.id }) : content;
          return await this.post(content, 'messages');
        }
        if (message['audio']) {
          content = {
            messaging_product: 'whatsapp',
            recipient_type: 'individual',
            type: 'audio',
            to: number.replace(/\D/g, ''),
            audio: {
              [message['type']]: message['id'],
            },
          };
          quoted ? (content.context = { message_id: quoted.id }) : content;
          return await this.post(content, 'messages');
        }
        if (message['buttons']) {
          content = {
            messaging_product: 'whatsapp',
            recipient_type: 'individual',
            to: number.replace(/\D/g, ''),
            type: 'interactive',
            interactive: {
              type: 'button',
              body: {
                text: message['text'] || 'Select',
              },
              action: {
                buttons: message['buttons'],
              },
            },
          };
          quoted ? (content.context = { message_id: quoted.id }) : content;
          let formattedText = '';
          for (const item of message['buttons']) {
            formattedText += `▶️ ${item.reply?.title}\n`;
          }
          message = { conversation: `${message['text'] || 'Select'}\n` + formattedText };
          return await this.post(content, 'messages');
        }
        if (message['listMessage']) {
          content = {
            messaging_product: 'whatsapp',
            recipient_type: 'individual',
            to: number.replace(/\D/g, ''),
            type: 'interactive',
            interactive: {
              type: 'list',
              header: {
                type: 'text',
                text: message['listMessage']['title'],
              },
              body: {
                text: message['listMessage']['description'],
              },
              footer: {
                text: message['listMessage']['footerText'],
              },
              action: {
                button: message['listMessage']['buttonText'],
                sections: message['listMessage']['sections'],
              },
            },
          };
          quoted ? (content.context = { message_id: quoted.id }) : content;
          let formattedText = '';
          for (const section of message['listMessage']['sections']) {
            formattedText += `${section?.title}\n`;
            for (const row of section.rows) {
              formattedText += `${row?.title}\n`;
            }
          }
          message = { conversation: `${message['listMessage']['title']}\n` + formattedText };
          return await this.post(content, 'messages');
        }
        if (message['template']) {
          content = {
            messaging_product: 'whatsapp',
            recipient_type: 'individual',
            to: number.replace(/\D/g, ''),
            type: 'template',
            template: {
              name: message['template']['name'],
              language: {
                code: message['template']['language'] || 'en_US',
              },
              components: message['template']['components'],
            },
          };
          quoted ? (content.context = { message_id: quoted.id }) : content;
          message = { conversation: `▶️${message['template']['name']}◀️` };
          return await this.post(content, 'messages');
        }
      })();

      if (messageSent?.error_data) {
        this.logger.error(messageSent);
        return messageSent;
      }

      const messageRaw: any = {
        key: { fromMe: true, id: messageSent?.messages[0]?.id, remoteJid: createJid(number) },
        message: this.convertMessageToRaw(message, content),
        messageType: this.renderMessageType(content.type),
        messageTimestamp: (messageSent?.messages[0]?.timestamp as number) || Math.round(new Date().getTime() / 1000),
        instanceId: this.instanceId,
        webhookUrl,
        status: status[1],
        source: 'unknown',
      };

      this.logger.log(messageRaw);

      this.sendDataWebhook(Events.SEND_MESSAGE, messageRaw);

      if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled && !isIntegration) {
        this.chatwootService.eventWhatsapp(
          Events.SEND_MESSAGE,
          { instanceName: this.instance.name, instanceId: this.instanceId },
          messageRaw,
        );
      }

      if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled && isIntegration)
        await chatbotController.emit({
          instance: { instanceName: this.instance.name, instanceId: this.instanceId },
          remoteJid: messageRaw.key.remoteJid,
          msg: messageRaw,
          pushName: messageRaw.pushName,
        });

      await this.prismaRepository.message.create({
        data: messageRaw,
      });

      return messageRaw;
    } catch (error) {
      this.logger.error(error);
      throw new BadRequestException(error.toString());
    }
  }

  // Send Message Controller
  public async textMessage(data: SendTextDto, isIntegration = false) {
    const res = await this.sendMessageWithTyping(
      data.number,
      {
        conversation: data.text,
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      isIntegration,
    );
    return res;
  }

  private async getIdMedia(mediaMessage: any) {
    const formData = new FormData();

    const fileStream = createReadStream(mediaMessage.media);

    formData.append('file', fileStream, { filename: 'media', contentType: mediaMessage.mimetype });
    formData.append('typeFile', mediaMessage.mimetype);
    formData.append('messaging_product', 'whatsapp');

    // const fileBuffer = await fs.readFile(mediaMessage.media);

    // const fileBlob = new Blob([fileBuffer], { type: mediaMessage.mimetype });
    // formData.append('file', fileBlob);
    // formData.append('typeFile', mediaMessage.mimetype);
    // formData.append('messaging_product', 'whatsapp');

    const headers = { Authorization: `Bearer ${this.token}` };
    const res = await axios.post(
      process.env.API_URL + '/' + process.env.VERSION + '/' + this.number + '/media',
      formData,
      { headers },
    );
    return res.data.id;
  }

  protected async prepareMediaMessage(mediaMessage: MediaMessage) {
    try {
      if (mediaMessage.mediatype === 'document' && !mediaMessage.fileName) {
        const regex = new RegExp(/.*\/(.+?)\./);
        const arrayMatch = regex.exec(mediaMessage.media);
        mediaMessage.fileName = arrayMatch[1];
      }

      if (mediaMessage.mediatype === 'image' && !mediaMessage.fileName) {
        mediaMessage.fileName = 'image.png';
      }

      if (mediaMessage.mediatype === 'video' && !mediaMessage.fileName) {
        mediaMessage.fileName = 'video.mp4';
      }

      let mimetype: string | false;

      const prepareMedia: any = {
        caption: mediaMessage?.caption,
        fileName: mediaMessage.fileName,
        mediaType: mediaMessage.mediatype,
        media: mediaMessage.media,
        gifPlayback: false,
      };

      if (isURL(mediaMessage.media)) {
        mimetype = mimeTypes.lookup(mediaMessage.media);
        prepareMedia.id = mediaMessage.media;
        prepareMedia.type = 'link';
      } else {
        mimetype = mimeTypes.lookup(mediaMessage.fileName);
        const id = await this.getIdMedia(prepareMedia);
        prepareMedia.id = id;
        prepareMedia.type = 'id';
      }

      prepareMedia.mimetype = mimetype;

      return prepareMedia;
    } catch (error) {
      this.logger.error(error);
      throw new InternalServerErrorException(error?.toString() || error);
    }
  }

  public async mediaMessage(data: SendMediaDto, file?: any, isIntegration = false) {
    const mediaData: SendMediaDto = { ...data };

    if (file) mediaData.media = file.buffer.toString('base64');

    const message = await this.prepareMediaMessage(mediaData);

    const mediaSent = await this.sendMessageWithTyping(
      data.number,
      { ...message },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      isIntegration,
    );

    return mediaSent;
  }

  public async processAudio(audio: string, number: string) {
    number = number.replace(/\D/g, '');
    const hash = `${number}-${new Date().getTime()}`;

    let mimetype: string | false;

    const prepareMedia: any = {
      fileName: `${hash}.mp3`,
      mediaType: 'audio',
      media: audio,
    };

    if (isURL(audio)) {
      mimetype = mimeTypes.lookup(audio);
      prepareMedia.id = audio;
      prepareMedia.type = 'link';
    } else {
      mimetype = mimeTypes.lookup(prepareMedia.fileName);
      const id = await this.getIdMedia(prepareMedia);
      prepareMedia.id = id;
      prepareMedia.type = 'id';
    }

    prepareMedia.mimetype = mimetype;

    return prepareMedia;
  }

  public async audioWhatsapp(data: SendAudioDto, file?: any, isIntegration = false) {
    const mediaData: SendAudioDto = { ...data };

    if (file?.buffer) {
      mediaData.audio = file.buffer.toString('base64');
    } else if (isURL(mediaData.audio)) {
      // DO NOTHING
      // mediaData.audio = mediaData.audio;
    } else {
      console.error('El archivo no tiene buffer o file es undefined');
      throw new Error('File or buffer is undefined');
    }

    const message = await this.processAudio(mediaData.audio, data.number);

    const audioSent = await this.sendMessageWithTyping(
      data.number,
      { ...message },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      isIntegration,
    );

    return audioSent;
  }

  public async buttonMessage(data: SendButtonsDto) {
    const embeddedMedia: any = {};

    const btnItems = {
      text: data.buttons.map((btn) => btn.displayText),
      ids: data.buttons.map((btn) => btn.id),
    };

    if (!arrayUnique(btnItems.text) || !arrayUnique(btnItems.ids)) {
      throw new BadRequestException('Button texts cannot be repeated', 'Button IDs cannot be repeated.');
    }

    return await this.sendMessageWithTyping(
      data.number,
      {
        text: !embeddedMedia?.mediaKey ? data.title : undefined,
        buttons: data.buttons.map((button) => {
          return {
            type: 'reply',
            reply: {
              title: button.displayText,
              id: button.id,
            },
          };
        }),
        [embeddedMedia?.mediaKey]: embeddedMedia?.message,
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
    );
  }

  public async locationMessage(data: SendLocationDto) {
    return await this.sendMessageWithTyping(
      data.number,
      {
        locationMessage: {
          degreesLatitude: data.latitude,
          degreesLongitude: data.longitude,
          name: data?.name,
          address: data?.address,
        },
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
    );
  }

  public async listMessage(data: SendListDto) {
    const sectionsItems = {
      title: data.sections.map((list) => list.title),
    };

    if (!arrayUnique(sectionsItems.title)) {
      throw new BadRequestException('Section tiles cannot be repeated');
    }

    const sendData: any = {
      listMessage: {
        title: data.title,
        description: data.description,
        footerText: data?.footerText,
        buttonText: data?.buttonText,
        sections: data.sections.map((section) => {
          return {
            title: section.title,
            rows: section.rows.map((row) => {
              return {
                title: row.title,
                description: row.description.substring(0, 72),
                id: row.rowId,
              };
            }),
          };
        }),
      },
    };

    return await this.sendMessageWithTyping(data.number, sendData, {
      delay: data?.delay,
      presence: 'composing',
      quoted: data?.quoted,
      linkPreview: data?.linkPreview,
      mentionsEveryOne: data?.mentionsEveryOne,
      mentioned: data?.mentioned,
    });
  }

  public async templateMessage(data: SendTemplateDto, isIntegration = false) {
    const res = await this.sendMessageWithTyping(
      data.number,
      {
        template: {
          name: data.name,
          language: data.language,
          components: data.components,
        },
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
        webhookUrl: data?.webhookUrl,
      },
      isIntegration,
    );
    return res;
  }

  public async contactMessage(data: SendContactDto) {
    const message: any = {};

    const vcard = (contact: ContactMessage) => {
      let result = 'BEGIN:VCARD\n' + 'VERSION:3.0\n' + `N:${contact.fullName}\n` + `FN:${contact.fullName}\n`;

      if (contact.organization) {
        result += `ORG:${contact.organization};\n`;
      }

      if (contact.email) {
        result += `EMAIL:${contact.email}\n`;
      }

      if (contact.url) {
        result += `URL:${contact.url}\n`;
      }

      if (!contact.wuid) {
        contact.wuid = createJid(contact.phoneNumber);
      }

      result += `item1.TEL;waid=${contact.wuid}:${contact.phoneNumber}\n` + 'item1.X-ABLabel:Celular\n' + 'END:VCARD';

      return result;
    };

    if (data.contact.length === 1) {
      message.contact = {
        displayName: data.contact[0].fullName,
        vcard: vcard(data.contact[0]),
      };
    } else {
      message.contactsArrayMessage = {
        displayName: `${data.contact.length} contacts`,
        contacts: data.contact.map((contact) => {
          return {
            displayName: contact.fullName,
            vcard: vcard(contact),
          };
        }),
      };
    }
    return await this.sendMessageWithTyping(
      data.number,
      {
        contacts: data.contact.map((contact) => {
          return {
            name: { formatted_name: contact.fullName, first_name: contact.fullName },
            phones: [{ phone: contact.phoneNumber }],
            urls: [{ url: contact.url }],
            emails: [{ email: contact.email }],
            org: { company: contact.organization },
          };
        }),
        message,
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
    );
  }

  public async reactionMessage(data: SendReactionDto) {
    return await this.sendMessageWithTyping(data.key.remoteJid, {
      reactionMessage: {
        key: data.key,
        text: data.reaction,
      },
    });
  }

  public async getBase64FromMediaMessage(data: any) {
    try {
      const msg = data.message;
      const messageType = msg.messageType.includes('Message') ? msg.messageType : msg.messageType + 'Message';
      const mediaMessage = msg.message[messageType];

      return {
        mediaType: msg.messageType,
        fileName: mediaMessage?.fileName,
        caption: mediaMessage?.caption,
        size: {
          fileLength: mediaMessage?.fileLength,
          height: mediaMessage?.fileLength,
          width: mediaMessage?.width,
        },
        mimetype: mediaMessage?.mime_type,
        base64: msg.message.base64,
      };
    } catch (error) {
      this.logger.error(error);
      throw new BadRequestException(error.toString());
    }
  }

  public async deleteMessage() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }

  // methods not available on WhatsApp Business API
  public async mediaSticker() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async pollMessage() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async statusMessage() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async reloadConnection() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async whatsappNumber() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async markMessageAsRead() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async archiveChat() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async markChatUnread() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async fetchProfile() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async offerCall() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async sendPresence() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async setPresence() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async fetchPrivacySettings() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updatePrivacySettings() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async fetchBusinessProfile() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updateProfileName() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updateProfileStatus() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updateProfilePicture() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async removeProfilePicture() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async blockUser() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updateMessage() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async createGroup() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updateGroupPicture() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updateGroupSubject() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updateGroupDescription() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async findGroup() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async fetchAllGroups() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async inviteCode() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async inviteInfo() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async sendInvite() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async acceptInviteCode() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async revokeInviteCode() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async findParticipants() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updateGParticipant() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async updateGSetting() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async toggleEphemeral() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async leaveGroup() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async fetchLabels() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async handleLabel() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async receiveMobileCode() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
  public async fakeCall() {
    throw new BadRequestException('Method not available on WhatsApp Business API');
  }
}



================================================
FILE: src/api/integrations/channel/whatsapp/baileys.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { WAMonitoringService } from '@api/services/monitor.service';

export class BaileysController {
  constructor(private readonly waMonitor: WAMonitoringService) {}

  public async onWhatsapp({ instanceName }: InstanceDto, body: any) {
    const instance = this.waMonitor.waInstances[instanceName];

    return instance.baileysOnWhatsapp(body?.jid);
  }

  public async profilePictureUrl({ instanceName }: InstanceDto, body: any) {
    const instance = this.waMonitor.waInstances[instanceName];

    return instance.baileysProfilePictureUrl(body?.jid, body?.type, body?.timeoutMs);
  }

  public async assertSessions({ instanceName }: InstanceDto, body: any) {
    const instance = this.waMonitor.waInstances[instanceName];

    return instance.baileysAssertSessions(body?.jids, body?.force);
  }

  public async createParticipantNodes({ instanceName }: InstanceDto, body: any) {
    const instance = this.waMonitor.waInstances[instanceName];

    return instance.baileysCreateParticipantNodes(body?.jids, body?.message, body?.extraAttrs);
  }

  public async getUSyncDevices({ instanceName }: InstanceDto, body: any) {
    const instance = this.waMonitor.waInstances[instanceName];

    return instance.baileysGetUSyncDevices(body?.jids, body?.useCache, body?.ignoreZeroDevices);
  }

  public async generateMessageTag({ instanceName }: InstanceDto) {
    const instance = this.waMonitor.waInstances[instanceName];

    return instance.baileysGenerateMessageTag();
  }

  public async sendNode({ instanceName }: InstanceDto, body: any) {
    const instance = this.waMonitor.waInstances[instanceName];

    return instance.baileysSendNode(body?.stanza);
  }

  public async signalRepositoryDecryptMessage({ instanceName }: InstanceDto, body: any) {
    const instance = this.waMonitor.waInstances[instanceName];

    return instance.baileysSignalRepositoryDecryptMessage(body?.jid, body?.type, body?.ciphertext);
  }

  public async getAuthState({ instanceName }: InstanceDto) {
    const instance = this.waMonitor.waInstances[instanceName];

    return instance.baileysGetAuthState();
  }
}



================================================
FILE: src/api/integrations/channel/whatsapp/baileys.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { HttpStatus } from '@api/routes/index.router';
import { baileysController } from '@api/server.module';
import { instanceSchema } from '@validate/instance.schema';
import { RequestHandler, Router } from 'express';

export class BaileysRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('onWhatsapp'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => baileysController.onWhatsapp(instance, req.body),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('profilePictureUrl'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => baileysController.profilePictureUrl(instance, req.body),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('assertSessions'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => baileysController.assertSessions(instance, req.body),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('createParticipantNodes'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => baileysController.createParticipantNodes(instance, req.body),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('getUSyncDevices'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => baileysController.getUSyncDevices(instance, req.body),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('generateMessageTag'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => baileysController.generateMessageTag(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('sendNode'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => baileysController.sendNode(instance, req.body),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('signalRepositoryDecryptMessage'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => baileysController.signalRepositoryDecryptMessage(instance, req.body),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('getAuthState'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => baileysController.getAuthState(instance),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/channel/whatsapp/whatsapp.baileys.service.ts
================================================
import { OfferCallDto } from '@api/dto/call.dto';
import {
  ArchiveChatDto,
  BlockUserDto,
  DeleteMessage,
  getBase64FromMediaMessageDto,
  LastMessage,
  MarkChatUnreadDto,
  NumberBusiness,
  OnWhatsAppDto,
  PrivacySettingDto,
  ReadMessageDto,
  SendPresenceDto,
  UpdateMessageDto,
  WhatsAppNumberDto,
} from '@api/dto/chat.dto';
import {
  AcceptGroupInvite,
  CreateGroupDto,
  GetParticipant,
  GroupDescriptionDto,
  GroupInvite,
  GroupJid,
  GroupPictureDto,
  GroupSendInvite,
  GroupSubjectDto,
  GroupToggleEphemeralDto,
  GroupUpdateParticipantDto,
  GroupUpdateSettingDto,
} from '@api/dto/group.dto';
import { InstanceDto, SetPresenceDto } from '@api/dto/instance.dto';
import { HandleLabelDto, LabelDto } from '@api/dto/label.dto';
import {
  Button,
  ContactMessage,
  KeyType,
  MediaMessage,
  Options,
  SendAudioDto,
  SendButtonsDto,
  SendContactDto,
  SendListDto,
  SendLocationDto,
  SendMediaDto,
  SendPollDto,
  SendPtvDto,
  SendReactionDto,
  SendStatusDto,
  SendStickerDto,
  SendTextDto,
  StatusMessage,
  TypeButton,
} from '@api/dto/sendMessage.dto';
import { chatwootImport } from '@api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper';
import * as s3Service from '@api/integrations/storage/s3/libs/minio.server';
import { ProviderFiles } from '@api/provider/sessions';
import { PrismaRepository } from '@api/repository/repository.service';
import { chatbotController, waMonitor } from '@api/server.module';
import { CacheService } from '@api/services/cache.service';
import { ChannelStartupService } from '@api/services/channel.service';
import { Events, MessageSubtype, TypeMediaMessage, wa } from '@api/types/wa.types';
import { CacheEngine } from '@cache/cacheengine';
import {
  CacheConf,
  Chatwoot,
  ConfigService,
  configService,
  ConfigSessionPhone,
  Database,
  Log,
  Openai,
  ProviderSession,
  QrCode,
  S3,
} from '@config/env.config';
import { BadRequestException, InternalServerErrorException, NotFoundException } from '@exceptions';
import ffmpegPath from '@ffmpeg-installer/ffmpeg';
import { Boom } from '@hapi/boom';
import { createId as cuid } from '@paralleldrive/cuid2';
import { Instance } from '@prisma/client';
import { createJid } from '@utils/createJid';
import { makeProxyAgent } from '@utils/makeProxyAgent';
import { getOnWhatsappCache, saveOnWhatsappCache } from '@utils/onWhatsappCache';
import { status } from '@utils/renderStatus';
import useMultiFileAuthStatePrisma from '@utils/use-multi-file-auth-state-prisma';
import { AuthStateProvider } from '@utils/use-multi-file-auth-state-provider-files';
import { useMultiFileAuthStateRedisDb } from '@utils/use-multi-file-auth-state-redis-db';
import axios from 'axios';
import makeWASocket, {
  AnyMessageContent,
  BufferedEventData,
  BufferJSON,
  CacheStore,
  Chat,
  ConnectionState,
  Contact,
  delay,
  DisconnectReason,
  downloadMediaMessage,
  fetchLatestBaileysVersion,
  generateWAMessageFromContent,
  getAggregateVotesInPollMessage,
  getContentType,
  getDevice,
  GroupMetadata,
  isJidBroadcast,
  isJidGroup,
  isJidNewsletter,
  isJidUser,
  makeCacheableSignalKeyStore,
  MessageUpsertType,
  MessageUserReceiptUpdate,
  MiscMessageGenerationOptions,
  ParticipantAction,
  prepareWAMessageMedia,
  proto,
  UserFacingSocketConfig,
  WABrowserDescription,
  WAMediaUpload,
  WAMessage,
  WAMessageUpdate,
  WAPresence,
  WASocket,
} from 'baileys';
import { Label } from 'baileys/lib/Types/Label';
import { LabelAssociation } from 'baileys/lib/Types/LabelAssociation';
import { spawn } from 'child_process';
import { isArray, isBase64, isURL } from 'class-validator';
import { randomBytes } from 'crypto';
import EventEmitter2 from 'eventemitter2';
import ffmpeg from 'fluent-ffmpeg';
import FormData from 'form-data';
import { readFileSync } from 'fs';
import Long from 'long';
import mimeTypes from 'mime-types';
import NodeCache from 'node-cache';
import cron from 'node-cron';
import { release } from 'os';
import { join } from 'path';
import P from 'pino';
import qrcode, { QRCodeToDataURLOptions } from 'qrcode';
import qrcodeTerminal from 'qrcode-terminal';
import sharp from 'sharp';
import { PassThrough, Readable } from 'stream';
import { v4 } from 'uuid';

import { useVoiceCallsBaileys } from './voiceCalls/useVoiceCallsBaileys';

const groupMetadataCache = new CacheService(new CacheEngine(configService, 'groups').getEngine());

// Adicione a função getVideoDuration no início do arquivo
async function getVideoDuration(input: Buffer | string | Readable): Promise<number> {
  const MediaInfoFactory = (await import('mediainfo.js')).default;
  const mediainfo = await MediaInfoFactory({ format: 'JSON' });

  let fileSize: number;
  let readChunk: (size: number, offset: number) => Promise<Buffer>;

  if (Buffer.isBuffer(input)) {
    fileSize = input.length;
    readChunk = async (size: number, offset: number): Promise<Buffer> => {
      return input.slice(offset, offset + size);
    };
  } else if (typeof input === 'string') {
    const fs = await import('fs');
    const stat = await fs.promises.stat(input);
    fileSize = stat.size;
    const fd = await fs.promises.open(input, 'r');

    readChunk = async (size: number, offset: number): Promise<Buffer> => {
      const buffer = Buffer.alloc(size);
      await fd.read(buffer, 0, size, offset);
      return buffer;
    };

    try {
      const result = await mediainfo.analyzeData(() => fileSize, readChunk);
      const jsonResult = JSON.parse(result);

      const generalTrack = jsonResult.media.track.find((t: any) => t['@type'] === 'General');
      const duration = generalTrack.Duration;

      return Math.round(parseFloat(duration));
    } finally {
      await fd.close();
    }
  } else if (input instanceof Readable) {
    const chunks: Buffer[] = [];
    for await (const chunk of input) {
      chunks.push(chunk);
    }
    const data = Buffer.concat(chunks);
    fileSize = data.length;

    readChunk = async (size: number, offset: number): Promise<Buffer> => {
      return data.slice(offset, offset + size);
    };
  } else {
    throw new Error('Tipo de entrada não suportado');
  }

  const result = await mediainfo.analyzeData(() => fileSize, readChunk);
  const jsonResult = JSON.parse(result);

  const generalTrack = jsonResult.media.track.find((t: any) => t['@type'] === 'General');
  const duration = generalTrack.Duration;

  return Math.round(parseFloat(duration));
}

export class BaileysStartupService extends ChannelStartupService {
  constructor(
    public readonly configService: ConfigService,
    public readonly eventEmitter: EventEmitter2,
    public readonly prismaRepository: PrismaRepository,
    public readonly cache: CacheService,
    public readonly chatwootCache: CacheService,
    public readonly baileysCache: CacheService,
    private readonly providerFiles: ProviderFiles,
  ) {
    super(configService, eventEmitter, prismaRepository, chatwootCache);
    this.instance.qrcode = { count: 0 };

    this.authStateProvider = new AuthStateProvider(this.providerFiles);
  }

  private authStateProvider: AuthStateProvider;
  private readonly msgRetryCounterCache: CacheStore = new NodeCache();
  private readonly userDevicesCache: CacheStore = new NodeCache();
  private endSession = false;
  private logBaileys = this.configService.get<Log>('LOG').BAILEYS;

  public stateConnection: wa.StateConnection = { state: 'close' };

  public phoneNumber: string;

  public get connectionStatus() {
    return this.stateConnection;
  }

  public async logoutInstance() {
    await this.client?.logout('Log out instance: ' + this.instanceName);

    this.client?.ws?.close();

    const sessionExists = await this.prismaRepository.session.findFirst({
      where: { sessionId: this.instanceId },
    });
    if (sessionExists) {
      await this.prismaRepository.session.delete({
        where: {
          sessionId: this.instanceId,
        },
      });
    }
  }

  public async getProfileName() {
    let profileName = this.client.user?.name ?? this.client.user?.verifiedName;
    if (!profileName) {
      const data = await this.prismaRepository.session.findUnique({
        where: { sessionId: this.instanceId },
      });

      if (data) {
        const creds = JSON.parse(JSON.stringify(data.creds), BufferJSON.reviver);
        profileName = creds.me?.name || creds.me?.verifiedName;
      }
    }

    return profileName;
  }

  public async getProfileStatus() {
    const status = await this.client.fetchStatus(this.instance.wuid);

    return status[0]?.status;
  }

  public get profilePictureUrl() {
    return this.instance.profilePictureUrl;
  }

  public get qrCode(): wa.QrCode {
    return {
      pairingCode: this.instance.qrcode?.pairingCode,
      code: this.instance.qrcode?.code,
      base64: this.instance.qrcode?.base64,
      count: this.instance.qrcode?.count,
    };
  }

  private async connectionUpdate({ qr, connection, lastDisconnect }: Partial<ConnectionState>) {
    if (qr) {
      if (this.instance.qrcode.count === this.configService.get<QrCode>('QRCODE').LIMIT) {
        this.sendDataWebhook(Events.QRCODE_UPDATED, {
          message: 'QR code limit reached, please login again',
          statusCode: DisconnectReason.badSession,
        });

        if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
          this.chatwootService.eventWhatsapp(
            Events.QRCODE_UPDATED,
            { instanceName: this.instance.name, instanceId: this.instanceId },
            {
              message: 'QR code limit reached, please login again',
              statusCode: DisconnectReason.badSession,
            },
          );
        }

        this.sendDataWebhook(Events.CONNECTION_UPDATE, {
          instance: this.instance.name,
          state: 'refused',
          statusReason: DisconnectReason.connectionClosed,
          wuid: this.instance.wuid,
          profileName: await this.getProfileName(),
          profilePictureUrl: this.instance.profilePictureUrl,
        });

        this.endSession = true;

        return this.eventEmitter.emit('no.connection', this.instance.name);
      }

      this.instance.qrcode.count++;

      const color = this.configService.get<QrCode>('QRCODE').COLOR;

      const optsQrcode: QRCodeToDataURLOptions = {
        margin: 3,
        scale: 4,
        errorCorrectionLevel: 'H',
        color: { light: '#ffffff', dark: color },
      };

      if (this.phoneNumber) {
        await delay(1000);
        this.instance.qrcode.pairingCode = await this.client.requestPairingCode(this.phoneNumber);
      } else {
        this.instance.qrcode.pairingCode = null;
      }

      qrcode.toDataURL(qr, optsQrcode, (error, base64) => {
        if (error) {
          this.logger.error('Qrcode generate failed:' + error.toString());
          return;
        }

        this.instance.qrcode.base64 = base64;
        this.instance.qrcode.code = qr;

        this.sendDataWebhook(Events.QRCODE_UPDATED, {
          qrcode: {
            instance: this.instance.name,
            pairingCode: this.instance.qrcode.pairingCode,
            code: qr,
            base64,
          },
        });

        if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
          this.chatwootService.eventWhatsapp(
            Events.QRCODE_UPDATED,
            { instanceName: this.instance.name, instanceId: this.instanceId },
            {
              qrcode: {
                instance: this.instance.name,
                pairingCode: this.instance.qrcode.pairingCode,
                code: qr,
                base64,
              },
            },
          );
        }
      });

      qrcodeTerminal.generate(qr, { small: true }, (qrcode) =>
        this.logger.log(
          `\n{ instance: ${this.instance.name} pairingCode: ${this.instance.qrcode.pairingCode}, qrcodeCount: ${this.instance.qrcode.count} }\n` +
            qrcode,
        ),
      );

      await this.prismaRepository.instance.update({
        where: { id: this.instanceId },
        data: {
          connectionStatus: 'connecting',
        },
      });
    }

    if (connection) {
      this.stateConnection = {
        state: connection,
        statusReason: (lastDisconnect?.error as Boom)?.output?.statusCode ?? 200,
      };
    }

    if (connection === 'close') {
      const statusCode = (lastDisconnect?.error as Boom)?.output?.statusCode;
      const codesToNotReconnect = [DisconnectReason.loggedOut, DisconnectReason.forbidden, 402, 406];
      const shouldReconnect = !codesToNotReconnect.includes(statusCode);
      if (shouldReconnect) {
        await this.connectToWhatsapp(this.phoneNumber);
      } else {
        this.sendDataWebhook(Events.STATUS_INSTANCE, {
          instance: this.instance.name,
          status: 'closed',
          disconnectionAt: new Date(),
          disconnectionReasonCode: statusCode,
          disconnectionObject: JSON.stringify(lastDisconnect),
        });

        await this.prismaRepository.instance.update({
          where: { id: this.instanceId },
          data: {
            connectionStatus: 'close',
            disconnectionAt: new Date(),
            disconnectionReasonCode: statusCode,
            disconnectionObject: JSON.stringify(lastDisconnect),
          },
        });

        if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
          this.chatwootService.eventWhatsapp(
            Events.STATUS_INSTANCE,
            { instanceName: this.instance.name, instanceId: this.instanceId },
            {
              instance: this.instance.name,
              status: 'closed',
            },
          );
        }

        this.eventEmitter.emit('logout.instance', this.instance.name, 'inner');
        this.client?.ws?.close();
        this.client.end(new Error('Close connection'));

        this.sendDataWebhook(Events.CONNECTION_UPDATE, {
          instance: this.instance.name,
          ...this.stateConnection,
        });
      }
    }

    if (connection === 'open') {
      this.instance.wuid = this.client.user.id.replace(/:\d+/, '');
      try {
        const profilePic = await this.profilePicture(this.instance.wuid);
        this.instance.profilePictureUrl = profilePic.profilePictureUrl;
      } catch (error) {
        this.instance.profilePictureUrl = null;
      }
      const formattedWuid = this.instance.wuid.split('@')[0].padEnd(30, ' ');
      const formattedName = this.instance.name;
      this.logger.info(
        `
        ┌──────────────────────────────┐
        │    CONNECTED TO WHATSAPP     │
        └──────────────────────────────┘`.replace(/^ +/gm, '  '),
      );
      this.logger.info(
        `
        wuid: ${formattedWuid}
        name: ${formattedName}
      `,
      );

      await this.prismaRepository.instance.update({
        where: { id: this.instanceId },
        data: {
          ownerJid: this.instance.wuid,
          profileName: (await this.getProfileName()) as string,
          profilePicUrl: this.instance.profilePictureUrl,
          connectionStatus: 'open',
        },
      });

      if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
        this.chatwootService.eventWhatsapp(
          Events.CONNECTION_UPDATE,
          { instanceName: this.instance.name, instanceId: this.instanceId },
          {
            instance: this.instance.name,
            status: 'open',
          },
        );
        this.syncChatwootLostMessages();
      }

      this.sendDataWebhook(Events.CONNECTION_UPDATE, {
        instance: this.instance.name,
        wuid: this.instance.wuid,
        profileName: await this.getProfileName(),
        profilePictureUrl: this.instance.profilePictureUrl,
        ...this.stateConnection,
      });
    }

    if (connection === 'connecting') {
      this.sendDataWebhook(Events.CONNECTION_UPDATE, {
        instance: this.instance.name,
        ...this.stateConnection,
      });
    }
  }

  private async getMessage(key: proto.IMessageKey, full = false) {
    try {
      const webMessageInfo = (await this.prismaRepository.message.findMany({
        where: {
          instanceId: this.instanceId,
          key: {
            path: ['id'],
            equals: key.id,
          },
        },
      })) as unknown as proto.IWebMessageInfo[];
      if (full) {
        return webMessageInfo[0];
      }
      if (webMessageInfo[0].message?.pollCreationMessage) {
        const messageSecretBase64 = webMessageInfo[0].message?.messageContextInfo?.messageSecret;

        if (typeof messageSecretBase64 === 'string') {
          const messageSecret = Buffer.from(messageSecretBase64, 'base64');

          const msg = {
            messageContextInfo: {
              messageSecret,
            },
            pollCreationMessage: webMessageInfo[0].message?.pollCreationMessage,
          };

          return msg;
        }
      }

      return webMessageInfo[0].message;
    } catch (error) {
      return { conversation: '' };
    }
  }

  private async defineAuthState() {
    const db = this.configService.get<Database>('DATABASE');
    const cache = this.configService.get<CacheConf>('CACHE');

    const provider = this.configService.get<ProviderSession>('PROVIDER');

    if (provider?.ENABLED) {
      return await this.authStateProvider.authStateProvider(this.instance.id);
    }

    if (cache?.REDIS.ENABLED && cache?.REDIS.SAVE_INSTANCES) {
      this.logger.info('Redis enabled');
      return await useMultiFileAuthStateRedisDb(this.instance.id, this.cache);
    }

    if (db.SAVE_DATA.INSTANCE) {
      return await useMultiFileAuthStatePrisma(this.instance.id, this.cache);
    }
  }

  private async createClient(number?: string): Promise<WASocket> {
    this.instance.authState = await this.defineAuthState();

    const session = this.configService.get<ConfigSessionPhone>('CONFIG_SESSION_PHONE');

    let browserOptions = {};

    if (number || this.phoneNumber) {
      this.phoneNumber = number;

      this.logger.info(`Phone number: ${number}`);
    } else {
      const browser: WABrowserDescription = [session.CLIENT, session.NAME, release()];
      browserOptions = { browser };

      this.logger.info(`Browser: ${browser}`);
    }

    let version;
    let log;

    if (session.VERSION) {
      version = session.VERSION.split('.');
      log = `Baileys version env: ${version}`;
    } else {
      const baileysVersion = await fetchLatestBaileysVersion();
      version = baileysVersion.version;
      log = `Baileys version: ${version}`;
    }

    this.logger.info(log);

    this.logger.info(`Group Ignore: ${this.localSettings.groupsIgnore}`);

    let options;

    if (this.localProxy?.enabled) {
      this.logger.info('Proxy enabled: ' + this.localProxy?.host);

      if (this.localProxy?.host?.includes('proxyscrape')) {
        try {
          const response = await axios.get(this.localProxy?.host);
          const text = response.data;
          const proxyUrls = text.split('\r\n');
          const rand = Math.floor(Math.random() * Math.floor(proxyUrls.length));
          const proxyUrl = 'http://' + proxyUrls[rand];
          options = {
            agent: makeProxyAgent(proxyUrl),
            fetchAgent: makeProxyAgent(proxyUrl),
          };
        } catch (error) {
          this.localProxy.enabled = false;
        }
      } else {
        options = {
          agent: makeProxyAgent({
            host: this.localProxy.host,
            port: this.localProxy.port,
            protocol: this.localProxy.protocol,
            username: this.localProxy.username,
            password: this.localProxy.password,
          }),
          fetchAgent: makeProxyAgent({
            host: this.localProxy.host,
            port: this.localProxy.port,
            protocol: this.localProxy.protocol,
            username: this.localProxy.username,
            password: this.localProxy.password,
          }),
        };
      }
    }

    const socketConfig: UserFacingSocketConfig = {
      ...options,
      version,
      logger: P({ level: this.logBaileys }),
      printQRInTerminal: false,
      auth: {
        creds: this.instance.authState.state.creds,
        keys: makeCacheableSignalKeyStore(this.instance.authState.state.keys, P({ level: 'error' }) as any),
      },
      msgRetryCounterCache: this.msgRetryCounterCache,
      generateHighQualityLinkPreview: true,
      getMessage: async (key) => (await this.getMessage(key)) as Promise<proto.IMessage>,
      ...browserOptions,
      markOnlineOnConnect: this.localSettings.alwaysOnline,
      retryRequestDelayMs: 350,
      maxMsgRetryCount: 4,
      fireInitQueries: true,
      connectTimeoutMs: 30_000,
      keepAliveIntervalMs: 30_000,
      qrTimeout: 45_000,
      emitOwnEvents: false,
      shouldIgnoreJid: (jid) => {
        const isGroupJid = this.localSettings.groupsIgnore && isJidGroup(jid);
        const isBroadcast = !this.localSettings.readStatus && isJidBroadcast(jid);
        const isNewsletter = isJidNewsletter(jid);

        return isGroupJid || isBroadcast || isNewsletter;
      },
      syncFullHistory: this.localSettings.syncFullHistory,
      shouldSyncHistoryMessage: (msg: proto.Message.IHistorySyncNotification) => {
        return this.historySyncNotification(msg);
      },
      cachedGroupMetadata: this.getGroupMetadataCache,
      userDevicesCache: this.userDevicesCache,
      transactionOpts: { maxCommitRetries: 10, delayBetweenTriesMs: 3000 },
      patchMessageBeforeSending(message) {
        if (
          message.deviceSentMessage?.message?.listMessage?.listType === proto.Message.ListMessage.ListType.PRODUCT_LIST
        ) {
          message = JSON.parse(JSON.stringify(message));

          message.deviceSentMessage.message.listMessage.listType = proto.Message.ListMessage.ListType.SINGLE_SELECT;
        }

        if (message.listMessage?.listType == proto.Message.ListMessage.ListType.PRODUCT_LIST) {
          message = JSON.parse(JSON.stringify(message));

          message.listMessage.listType = proto.Message.ListMessage.ListType.SINGLE_SELECT;
        }

        return message;
      },
    };

    this.endSession = false;

    this.client = makeWASocket(socketConfig);

    if (this.localSettings.wavoipToken && this.localSettings.wavoipToken.length > 0) {
      useVoiceCallsBaileys(this.localSettings.wavoipToken, this.client, this.connectionStatus.state as any, true);
    }

    this.eventHandler();

    this.client.ws.on('CB:call', (packet) => {
      console.log('CB:call', packet);
      const payload = {
        event: 'CB:call',
        packet: packet,
      };
      this.sendDataWebhook(Events.CALL, payload, true, ['websocket']);
    });

    this.client.ws.on('CB:ack,class:call', (packet) => {
      console.log('CB:ack,class:call', packet);
      const payload = {
        event: 'CB:ack,class:call',
        packet: packet,
      };
      this.sendDataWebhook(Events.CALL, payload, true, ['websocket']);
    });

    this.phoneNumber = number;

    return this.client;
  }

  public async connectToWhatsapp(number?: string): Promise<WASocket> {
    try {
      this.loadChatwoot();
      this.loadSettings();
      this.loadWebhook();
      this.loadProxy();

      return await this.createClient(number);
    } catch (error) {
      this.logger.error(error);
      throw new InternalServerErrorException(error?.toString());
    }
  }

  public async reloadConnection(): Promise<WASocket> {
    try {
      return await this.createClient(this.phoneNumber);
    } catch (error) {
      this.logger.error(error);
      throw new InternalServerErrorException(error?.toString());
    }
  }

  private readonly chatHandle = {
    'chats.upsert': async (chats: Chat[]) => {
      const existingChatIds = await this.prismaRepository.chat.findMany({
        where: { instanceId: this.instanceId },
        select: { remoteJid: true },
      });

      const existingChatIdSet = new Set(existingChatIds.map((chat) => chat.remoteJid));

      const chatsToInsert = chats
        .filter((chat) => !existingChatIdSet?.has(chat.id))
        .map((chat) => ({
          remoteJid: chat.id,
          instanceId: this.instanceId,
          name: chat.name,
          unreadMessages: chat.unreadCount !== undefined ? chat.unreadCount : 0,
        }));

      this.sendDataWebhook(Events.CHATS_UPSERT, chatsToInsert);

      if (chatsToInsert.length > 0) {
        if (this.configService.get<Database>('DATABASE').SAVE_DATA.CHATS)
          await this.prismaRepository.chat.createMany({
            data: chatsToInsert,
            skipDuplicates: true,
          });
      }
    },

    'chats.update': async (
      chats: Partial<
        proto.IConversation & {
          lastMessageRecvTimestamp?: number;
        } & {
          conditional: (bufferedData: BufferedEventData) => boolean;
        }
      >[],
    ) => {
      const chatsRaw = chats.map((chat) => {
        return { remoteJid: chat.id, instanceId: this.instanceId };
      });

      this.sendDataWebhook(Events.CHATS_UPDATE, chatsRaw);

      for (const chat of chats) {
        await this.prismaRepository.chat.updateMany({
          where: {
            instanceId: this.instanceId,
            remoteJid: chat.id,
            name: chat.name,
          },
          data: { remoteJid: chat.id },
        });
      }
    },

    'chats.delete': async (chats: string[]) => {
      chats.forEach(
        async (chat) =>
          await this.prismaRepository.chat.deleteMany({
            where: { instanceId: this.instanceId, remoteJid: chat },
          }),
      );

      this.sendDataWebhook(Events.CHATS_DELETE, [...chats]);
    },
  };

  private readonly contactHandle = {
    'contacts.upsert': async (contacts: Contact[]) => {
      try {
        const contactsRaw: any = contacts.map((contact) => ({
          remoteJid: contact.id,
          pushName: contact?.name || contact?.verifiedName || contact.id.split('@')[0],
          profilePicUrl: null,
          instanceId: this.instanceId,
        }));

        if (contactsRaw.length > 0) {
          this.sendDataWebhook(Events.CONTACTS_UPSERT, contactsRaw);

          if (this.configService.get<Database>('DATABASE').SAVE_DATA.CONTACTS)
            await this.prismaRepository.contact.createMany({
              data: contactsRaw,
              skipDuplicates: true,
            });

          const usersContacts = contactsRaw.filter((c) => c.remoteJid.includes('@s.whatsapp'));
          if (usersContacts) {
            await saveOnWhatsappCache(usersContacts.map((c) => ({ remoteJid: c.remoteJid })));
          }
        }

        if (
          this.configService.get<Chatwoot>('CHATWOOT').ENABLED &&
          this.localChatwoot?.enabled &&
          this.localChatwoot.importContacts &&
          contactsRaw.length
        ) {
          this.chatwootService.addHistoryContacts(
            { instanceName: this.instance.name, instanceId: this.instance.id },
            contactsRaw,
          );
          chatwootImport.importHistoryContacts(
            { instanceName: this.instance.name, instanceId: this.instance.id },
            this.localChatwoot,
          );
        }

        const updatedContacts = await Promise.all(
          contacts.map(async (contact) => ({
            remoteJid: contact.id,
            pushName: contact?.name || contact?.verifiedName || contact.id.split('@')[0],
            profilePicUrl: (await this.profilePicture(contact.id)).profilePictureUrl,
            instanceId: this.instanceId,
          })),
        );

        if (updatedContacts.length > 0) {
          const usersContacts = updatedContacts.filter((c) => c.remoteJid.includes('@s.whatsapp'));
          if (usersContacts) {
            await saveOnWhatsappCache(usersContacts.map((c) => ({ remoteJid: c.remoteJid })));
          }

          this.sendDataWebhook(Events.CONTACTS_UPDATE, updatedContacts);
          await Promise.all(
            updatedContacts.map(async (contact) => {
              const update = this.prismaRepository.contact.updateMany({
                where: { remoteJid: contact.remoteJid, instanceId: this.instanceId },
                data: {
                  profilePicUrl: contact.profilePicUrl,
                },
              });

              if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
                const instance = { instanceName: this.instance.name, instanceId: this.instance.id };

                const findParticipant = await this.chatwootService.findContact(
                  instance,
                  contact.remoteJid.split('@')[0],
                );

                if (!findParticipant) {
                  return;
                }

                this.chatwootService.updateContact(instance, findParticipant.id, {
                  name: contact.pushName,
                  avatar_url: contact.profilePicUrl,
                });
              }

              return update;
            }),
          );
        }
      } catch (error) {
        console.error(error);
        this.logger.error(`Error: ${error.message}`);
      }
    },

    'contacts.update': async (contacts: Partial<Contact>[]) => {
      const contactsRaw: {
        remoteJid: string;
        pushName?: string;
        profilePicUrl?: string;
        instanceId: string;
      }[] = [];
      for await (const contact of contacts) {
        contactsRaw.push({
          remoteJid: contact.id,
          pushName: contact?.name ?? contact?.verifiedName,
          profilePicUrl: (await this.profilePicture(contact.id)).profilePictureUrl,
          instanceId: this.instanceId,
        });
      }

      this.sendDataWebhook(Events.CONTACTS_UPDATE, contactsRaw);

      const updateTransactions = contactsRaw.map((contact) =>
        this.prismaRepository.contact.upsert({
          where: { remoteJid_instanceId: { remoteJid: contact.remoteJid, instanceId: contact.instanceId } },
          create: contact,
          update: contact,
        }),
      );
      await this.prismaRepository.$transaction(updateTransactions);

      const usersContacts = contactsRaw.filter((c) => c.remoteJid.includes('@s.whatsapp'));
      if (usersContacts) {
        await saveOnWhatsappCache(usersContacts.map((c) => ({ remoteJid: c.remoteJid })));
      }
    },
  };

  private readonly messageHandle = {
    'messaging-history.set': async ({
      messages,
      chats,
      contacts,
      isLatest,
      progress,
      syncType,
    }: {
      chats: Chat[];
      contacts: Contact[];
      messages: proto.IWebMessageInfo[];
      isLatest?: boolean;
      progress?: number;
      syncType?: proto.HistorySync.HistorySyncType;
    }) => {
      try {
        if (syncType === proto.HistorySync.HistorySyncType.ON_DEMAND) {
          console.log('received on-demand history sync, messages=', messages);
        }
        console.log(
          `recv ${chats.length} chats, ${contacts.length} contacts, ${messages.length} msgs (is latest: ${isLatest}, progress: ${progress}%), type: ${syncType}`,
        );

        const instance: InstanceDto = { instanceName: this.instance.name };

        let timestampLimitToImport = null;

        if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED) {
          const daysLimitToImport = this.localChatwoot?.enabled ? this.localChatwoot.daysLimitImportMessages : 1000;

          const date = new Date();
          timestampLimitToImport = new Date(date.setDate(date.getDate() - daysLimitToImport)).getTime() / 1000;

          const maxBatchTimestamp = Math.max(...messages.map((message) => message.messageTimestamp as number));

          const processBatch = maxBatchTimestamp >= timestampLimitToImport;

          if (!processBatch) {
            return;
          }
        }

        const chatsRaw: { remoteJid: string; instanceId: string; name?: string }[] = [];
        const chatsRepository = new Set(
          (
            await this.prismaRepository.chat.findMany({
              where: { instanceId: this.instanceId },
            })
          ).map((chat) => chat.remoteJid),
        );

        for (const chat of chats) {
          if (chatsRepository?.has(chat.id)) {
            continue;
          }

          chatsRaw.push({
            remoteJid: chat.id,
            instanceId: this.instanceId,
            name: chat.name,
          });
        }

        this.sendDataWebhook(Events.CHATS_SET, chatsRaw);

        if (this.configService.get<Database>('DATABASE').SAVE_DATA.HISTORIC) {
          await this.prismaRepository.chat.createMany({
            data: chatsRaw,
            skipDuplicates: true,
          });
        }

        const messagesRaw: any[] = [];

        const messagesRepository: Set<string> = new Set(
          chatwootImport.getRepositoryMessagesCache(instance) ??
            (
              await this.prismaRepository.message.findMany({
                select: { key: true },
                where: { instanceId: this.instanceId },
              })
            ).map((message) => {
              const key = message.key as {
                id: string;
              };

              return key.id;
            }),
        );

        if (chatwootImport.getRepositoryMessagesCache(instance) === null) {
          chatwootImport.setRepositoryMessagesCache(instance, messagesRepository);
        }

        for (const m of messages) {
          if (!m.message || !m.key || !m.messageTimestamp) {
            continue;
          }

          if (Long.isLong(m?.messageTimestamp)) {
            m.messageTimestamp = m.messageTimestamp?.toNumber();
          }

          if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED) {
            if (m.messageTimestamp <= timestampLimitToImport) {
              continue;
            }
          }

          if (messagesRepository?.has(m.key.id)) {
            continue;
          }

          messagesRaw.push(this.prepareMessage(m));
        }

        this.sendDataWebhook(Events.MESSAGES_SET, [...messagesRaw]);

        if (this.configService.get<Database>('DATABASE').SAVE_DATA.HISTORIC) {
          await this.prismaRepository.message.createMany({
            data: messagesRaw,
            skipDuplicates: true,
          });
        }

        if (
          this.configService.get<Chatwoot>('CHATWOOT').ENABLED &&
          this.localChatwoot?.enabled &&
          this.localChatwoot.importMessages &&
          messagesRaw.length > 0
        ) {
          this.chatwootService.addHistoryMessages(
            instance,
            messagesRaw.filter((msg) => !chatwootImport.isIgnorePhoneNumber(msg.key?.remoteJid)),
          );
        }

        await this.contactHandle['contacts.upsert'](
          contacts
            .filter((c) => !!c.notify || !!c.name)
            .map((c) => ({
              id: c.id,
              name: c.name ?? c.notify,
            })),
        );

        contacts = undefined;
        messages = undefined;
        chats = undefined;
      } catch (error) {
        this.logger.error(error);
      }
    },

    'messages.upsert': async (
      {
        messages,
        type,
        requestId,
      }: {
        messages: proto.IWebMessageInfo[];
        type: MessageUpsertType;
        requestId?: string;
      },
      settings: any,
    ) => {
      try {
        for (const received of messages) {
          if (received.message?.conversation || received.message?.extendedTextMessage?.text) {
            const text = received.message?.conversation || received.message?.extendedTextMessage?.text;

            if (text == 'requestPlaceholder' && !requestId) {
              const messageId = await this.client.requestPlaceholderResend(received.key);

              console.log('requested placeholder resync, id=', messageId);
            } else if (requestId) {
              console.log('Message received from phone, id=', requestId, received);
            }

            if (text == 'onDemandHistSync') {
              const messageId = await this.client.fetchMessageHistory(50, received.key, received.messageTimestamp!);
              console.log('requested on-demand sync, id=', messageId);
            }
          }

          if (received.message?.protocolMessage?.editedMessage || received.message?.editedMessage?.message) {
            const editedMessage =
              received.message?.protocolMessage || received.message?.editedMessage?.message?.protocolMessage;
            if (editedMessage) {
              if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled)
                this.chatwootService.eventWhatsapp(
                  'messages.edit',
                  { instanceName: this.instance.name, instanceId: this.instance.id },
                  editedMessage,
                );

              await this.sendDataWebhook(Events.MESSAGES_EDITED, editedMessage);
            }
          }

          if (received.messageStubParameters && received.messageStubParameters[0] === 'Message absent from node') {
            this.logger.info(`Recovering message lost messageId: ${received.key.id}`);

            await this.baileysCache.set(received.key.id, {
              message: received,
              retry: 0,
            });

            continue;
          }

          const retryCache = (await this.baileysCache.get(received.key.id)) || null;

          if (retryCache) {
            this.logger.info('Recovered message lost');
            await this.baileysCache.delete(received.key.id);
          }

          if (
            (type !== 'notify' && type !== 'append') ||
            received.message?.protocolMessage ||
            received.message?.pollUpdateMessage ||
            !received?.message
          ) {
            continue;
          }

          if (Long.isLong(received.messageTimestamp)) {
            received.messageTimestamp = received.messageTimestamp?.toNumber();
          }

          if (settings?.groupsIgnore && received.key.remoteJid.includes('@g.us')) {
            continue;
          }
          const existingChat = await this.prismaRepository.chat.findFirst({
            where: { instanceId: this.instanceId, remoteJid: received.key.remoteJid },
            select: { id: true, name: true },
          });

          if (
            existingChat &&
            received.pushName &&
            existingChat.name !== received.pushName &&
            received.pushName.trim().length > 0
          ) {
            this.sendDataWebhook(Events.CHATS_UPSERT, [{ ...existingChat, name: received.pushName }]);
            if (this.configService.get<Database>('DATABASE').SAVE_DATA.CHATS) {
              try {
                await this.prismaRepository.chat.update({
                  where: { id: existingChat.id },
                  data: { name: received.pushName },
                });
              } catch (error) {
                console.log(`Chat insert record ignored: ${received.key.remoteJid} - ${this.instanceId}`);
              }
            }
          }

          const messageRaw = this.prepareMessage(received);

          const isMedia =
            received?.message?.imageMessage ||
            received?.message?.videoMessage ||
            received?.message?.stickerMessage ||
            received?.message?.documentMessage ||
            received?.message?.documentWithCaptionMessage ||
            received?.message?.ptvMessage ||
            received?.message?.audioMessage;

          if (this.localSettings.readMessages && received.key.id !== 'status@broadcast') {
            await this.client.readMessages([received.key]);
          }

          if (this.localSettings.readStatus && received.key.id === 'status@broadcast') {
            await this.client.readMessages([received.key]);
          }

          if (
            this.configService.get<Chatwoot>('CHATWOOT').ENABLED &&
            this.localChatwoot?.enabled &&
            !received.key.id.includes('@broadcast')
          ) {
            const chatwootSentMessage = await this.chatwootService.eventWhatsapp(
              Events.MESSAGES_UPSERT,
              { instanceName: this.instance.name, instanceId: this.instance.id },
              messageRaw,
            );

            if (chatwootSentMessage?.id) {
              messageRaw.chatwootMessageId = chatwootSentMessage.id;
              messageRaw.chatwootInboxId = chatwootSentMessage.inbox_id;
              messageRaw.chatwootConversationId = chatwootSentMessage.conversation_id;
            }
          }

          if (this.configService.get<Openai>('OPENAI').ENABLED && received?.message?.audioMessage) {
            const openAiDefaultSettings = await this.prismaRepository.openaiSetting.findFirst({
              where: {
                instanceId: this.instanceId,
              },
              include: {
                OpenaiCreds: true,
              },
            });

            if (openAiDefaultSettings && openAiDefaultSettings.openaiCredsId && openAiDefaultSettings.speechToText) {
              messageRaw.message.speechToText = await this.openaiService.speechToText(
                openAiDefaultSettings.OpenaiCreds,
                received,
                this.client.updateMediaMessage,
              );
            }
          }

          if (this.configService.get<Database>('DATABASE').SAVE_DATA.NEW_MESSAGE) {
            const msg = await this.prismaRepository.message.create({
              data: messageRaw,
            });

            if (received.key.fromMe === false) {
              if (msg.status === status[3]) {
                this.logger.log(`Update not read messages ${received.key.remoteJid}`);

                await this.updateChatUnreadMessages(received.key.remoteJid);
              } else if (msg.status === status[4]) {
                this.logger.log(`Update readed messages ${received.key.remoteJid} - ${msg.messageTimestamp}`);

                await this.updateMessagesReadedByTimestamp(received.key.remoteJid, msg.messageTimestamp);
              }
            } else {
              // is send message by me
              this.logger.log(`Update readed messages ${received.key.remoteJid} - ${msg.messageTimestamp}`);

              await this.updateMessagesReadedByTimestamp(received.key.remoteJid, msg.messageTimestamp);
            }

            if (isMedia) {
              if (this.configService.get<S3>('S3').ENABLE) {
                try {
                  const message: any = received;
                  const media = await this.getBase64FromMediaMessage(
                    {
                      message,
                    },
                    true,
                  );

                  const { buffer, mediaType, fileName, size } = media;
                  const mimetype = mimeTypes.lookup(fileName).toString();
                  const fullName = join(`${this.instance.id}`, received.key.remoteJid, mediaType, fileName);
                  await s3Service.uploadFile(fullName, buffer, size.fileLength?.low, {
                    'Content-Type': mimetype,
                  });

                  await this.prismaRepository.media.create({
                    data: {
                      messageId: msg.id,
                      instanceId: this.instanceId,
                      type: mediaType,
                      fileName: fullName,
                      mimetype,
                    },
                  });

                  const mediaUrl = await s3Service.getObjectUrl(fullName);

                  messageRaw.message.mediaUrl = mediaUrl;

                  await this.prismaRepository.message.update({
                    where: { id: msg.id },
                    data: messageRaw,
                  });
                } catch (error) {
                  this.logger.error(['Error on upload file to minio', error?.message, error?.stack]);
                }
              }
            }
          }

          if (this.localWebhook.enabled) {
            if (isMedia && this.localWebhook.webhookBase64) {
              try {
                const buffer = await downloadMediaMessage(
                  { key: received.key, message: received?.message },
                  'buffer',
                  {},
                  {
                    logger: P({ level: 'error' }) as any,
                    reuploadRequest: this.client.updateMediaMessage,
                  },
                );

                messageRaw.message.base64 = buffer ? buffer.toString('base64') : undefined;
              } catch (error) {
                this.logger.error(['Error converting media to base64', error?.message]);
              }
            }
          }

          this.logger.log(messageRaw);

          this.sendDataWebhook(Events.MESSAGES_UPSERT, messageRaw);

          await chatbotController.emit({
            instance: { instanceName: this.instance.name, instanceId: this.instanceId },
            remoteJid: messageRaw.key.remoteJid,
            msg: messageRaw,
            pushName: messageRaw.pushName,
          });

          const contact = await this.prismaRepository.contact.findFirst({
            where: { remoteJid: received.key.remoteJid, instanceId: this.instanceId },
          });

          const contactRaw: { remoteJid: string; pushName: string; profilePicUrl?: string; instanceId: string } = {
            remoteJid: received.key.remoteJid,
            pushName: received.key.fromMe ? '' : received.key.fromMe == null ? '' : received.pushName,
            profilePicUrl: (await this.profilePicture(received.key.remoteJid)).profilePictureUrl,
            instanceId: this.instanceId,
          };

          if (contactRaw.remoteJid === 'status@broadcast') {
            continue;
          }

          if (contact) {
            this.sendDataWebhook(Events.CONTACTS_UPDATE, contactRaw);

            if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
              await this.chatwootService.eventWhatsapp(
                Events.CONTACTS_UPDATE,
                { instanceName: this.instance.name, instanceId: this.instanceId },
                contactRaw,
              );
            }

            if (this.configService.get<Database>('DATABASE').SAVE_DATA.CONTACTS)
              await this.prismaRepository.contact.upsert({
                where: { remoteJid_instanceId: { remoteJid: contactRaw.remoteJid, instanceId: contactRaw.instanceId } },
                create: contactRaw,
                update: contactRaw,
              });

            continue;
          }

          this.sendDataWebhook(Events.CONTACTS_UPSERT, contactRaw);

          if (this.configService.get<Database>('DATABASE').SAVE_DATA.CONTACTS)
            await this.prismaRepository.contact.upsert({
              where: {
                remoteJid_instanceId: {
                  remoteJid: contactRaw.remoteJid,
                  instanceId: contactRaw.instanceId,
                },
              },
              update: contactRaw,
              create: contactRaw,
            });

          if (contactRaw.remoteJid.includes('@s.whatsapp')) {
            await saveOnWhatsappCache([{ remoteJid: contactRaw.remoteJid }]);
          }
        }
      } catch (error) {
        this.logger.error(error);
      }
    },

    'messages.update': async (args: WAMessageUpdate[], settings: any) => {
      this.logger.log(`Update messages ${JSON.stringify(args, undefined, 2)}`);

      const readChatToUpdate: Record<string, true> = {}; // {remoteJid: true}

      for await (const { key, update } of args) {
        if (settings?.groupsIgnore && key.remoteJid?.includes('@g.us')) {
          continue;
        }

        if (status[update.status] === 'READ' && key.fromMe) {
          if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
            this.chatwootService.eventWhatsapp(
              'messages.read',
              { instanceName: this.instance.name, instanceId: this.instanceId },
              { key: key },
            );
          }
        }

        if (key.remoteJid !== 'status@broadcast') {
          let pollUpdates: any;

          if (update.pollUpdates) {
            const pollCreation = await this.getMessage(key);

            if (pollCreation) {
              pollUpdates = getAggregateVotesInPollMessage({
                message: pollCreation as proto.IMessage,
                pollUpdates: update.pollUpdates,
              });
            }
          }

          const findMessage = await this.prismaRepository.message.findFirst({
            where: {
              instanceId: this.instanceId,
              key: {
                path: ['id'],
                equals: key.id,
              },
            },
          });

          if (!findMessage) {
            continue;
          }

          if (update.message === null && update.status === undefined) {
            this.sendDataWebhook(Events.MESSAGES_DELETE, key);

            const message: any = {
              messageId: findMessage.id,
              keyId: key.id,
              remoteJid: key.remoteJid,
              fromMe: key.fromMe,
              participant: key?.remoteJid,
              status: 'DELETED',
              instanceId: this.instanceId,
            };

            if (this.configService.get<Database>('DATABASE').SAVE_DATA.MESSAGE_UPDATE)
              await this.prismaRepository.messageUpdate.create({
                data: message,
              });

            if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
              this.chatwootService.eventWhatsapp(
                Events.MESSAGES_DELETE,
                { instanceName: this.instance.name, instanceId: this.instanceId },
                { key: key },
              );
            }

            continue;
          } else if (update.status !== undefined && status[update.status] !== findMessage.status) {
            if (!key.fromMe && key.remoteJid) {
              readChatToUpdate[key.remoteJid] = true;

              if (status[update.status] === status[4]) {
                this.logger.log(`Update as read ${key.remoteJid} - ${findMessage.messageTimestamp}`);
                this.updateMessagesReadedByTimestamp(key.remoteJid, findMessage.messageTimestamp);
              }
            }

            await this.prismaRepository.message.update({
              where: { id: findMessage.id },
              data: { status: status[update.status] },
            });
          }

          const message: any = {
            messageId: findMessage.id,
            keyId: key.id,
            remoteJid: key.remoteJid,
            fromMe: key.fromMe,
            participant: key?.remoteJid,
            status: status[update.status],
            pollUpdates,
            instanceId: this.instanceId,
          };

          this.sendDataWebhook(Events.MESSAGES_UPDATE, message);

          if (this.configService.get<Database>('DATABASE').SAVE_DATA.MESSAGE_UPDATE)
            await this.prismaRepository.messageUpdate.create({
              data: message,
            });

          const existingChat = await this.prismaRepository.chat.findFirst({
            where: { instanceId: this.instanceId, remoteJid: message.remoteJid },
          });

          if (existingChat) {
            const chatToInsert = {
              remoteJid: message.remoteJid,
              instanceId: this.instanceId,
              name: message.pushName || '',
              unreadMessages: 0,
            };

            this.sendDataWebhook(Events.CHATS_UPSERT, [chatToInsert]);
            if (this.configService.get<Database>('DATABASE').SAVE_DATA.CHATS) {
              try {
                await this.prismaRepository.chat.update({
                  where: {
                    id: existingChat.id,
                  },
                  data: chatToInsert,
                });
              } catch (error) {
                console.log(`Chat insert record ignored: ${chatToInsert.remoteJid} - ${chatToInsert.instanceId}`);
              }
            }
          }
        }
      }

      await Promise.all(Object.keys(readChatToUpdate).map((remoteJid) => this.updateChatUnreadMessages(remoteJid)));
    },
  };

  private readonly groupHandler = {
    'groups.upsert': (groupMetadata: GroupMetadata[]) => {
      this.sendDataWebhook(Events.GROUPS_UPSERT, groupMetadata);
    },

    'groups.update': (groupMetadataUpdate: Partial<GroupMetadata>[]) => {
      this.sendDataWebhook(Events.GROUPS_UPDATE, groupMetadataUpdate);

      groupMetadataUpdate.forEach((group) => {
        if (isJidGroup(group.id)) {
          this.updateGroupMetadataCache(group.id);
        }
      });
    },

    'group-participants.update': (participantsUpdate: {
      id: string;
      participants: string[];
      action: ParticipantAction;
    }) => {
      this.sendDataWebhook(Events.GROUP_PARTICIPANTS_UPDATE, participantsUpdate);

      this.updateGroupMetadataCache(participantsUpdate.id);
    },
  };

  private readonly labelHandle = {
    [Events.LABELS_EDIT]: async (label: Label) => {
      this.sendDataWebhook(Events.LABELS_EDIT, { ...label, instance: this.instance.name });

      const labelsRepository = await this.prismaRepository.label.findMany({
        where: { instanceId: this.instanceId },
      });

      const savedLabel = labelsRepository.find((l) => l.labelId === label.id);
      if (label.deleted && savedLabel) {
        await this.prismaRepository.label.delete({
          where: { labelId_instanceId: { instanceId: this.instanceId, labelId: label.id } },
        });
        this.sendDataWebhook(Events.LABELS_EDIT, { ...label, instance: this.instance.name });
        return;
      }

      const labelName = label.name.replace(/[^\x20-\x7E]/g, '');
      if (!savedLabel || savedLabel.color !== `${label.color}` || savedLabel.name !== labelName) {
        if (this.configService.get<Database>('DATABASE').SAVE_DATA.LABELS) {
          const labelData = {
            color: `${label.color}`,
            name: labelName,
            labelId: label.id,
            predefinedId: label.predefinedId,
            instanceId: this.instanceId,
          };
          await this.prismaRepository.label.upsert({
            where: {
              labelId_instanceId: {
                instanceId: labelData.instanceId,
                labelId: labelData.labelId,
              },
            },
            update: labelData,
            create: labelData,
          });
        }
      }
    },

    [Events.LABELS_ASSOCIATION]: async (
      data: { association: LabelAssociation; type: 'remove' | 'add' },
      database: Database,
    ) => {
      this.logger.info(
        `labels association - ${data?.association?.chatId} (${data.type}-${data?.association?.type}): ${data?.association?.labelId}`,
      );
      if (database.SAVE_DATA.CHATS) {
        const instanceId = this.instanceId;
        const chatId = data.association.chatId;
        const labelId = data.association.labelId;

        if (data.type === 'add') {
          await this.addLabel(labelId, instanceId, chatId);
        } else if (data.type === 'remove') {
          await this.removeLabel(labelId, instanceId, chatId);
        }
      }

      this.sendDataWebhook(Events.LABELS_ASSOCIATION, {
        instance: this.instance.name,
        type: data.type,
        chatId: data.association.chatId,
        labelId: data.association.labelId,
      });
    },
  };

  private eventHandler() {
    this.client.ev.process(async (events) => {
      if (!this.endSession) {
        const database = this.configService.get<Database>('DATABASE');
        const settings = await this.findSettings();

        if (events.call) {
          const call = events.call[0];

          if (settings?.rejectCall && call.status == 'offer') {
            this.client.rejectCall(call.id, call.from);
          }

          if (settings?.msgCall?.trim().length > 0 && call.status == 'offer') {
            const msg = await this.client.sendMessage(call.from, {
              text: settings.msgCall,
            });

            this.client.ev.emit('messages.upsert', {
              messages: [msg],
              type: 'notify',
            });
          }

          this.sendDataWebhook(Events.CALL, call);
        }

        if (events['connection.update']) {
          this.connectionUpdate(events['connection.update']);
        }

        if (events['creds.update']) {
          this.instance.authState.saveCreds();
        }

        if (events['messaging-history.set']) {
          const payload = events['messaging-history.set'];
          this.messageHandle['messaging-history.set'](payload);
        }

        if (events['messages.upsert']) {
          const payload = events['messages.upsert'];
          this.messageHandle['messages.upsert'](payload, settings);
        }

        if (events['messages.update']) {
          const payload = events['messages.update'];
          this.messageHandle['messages.update'](payload, settings);
        }

        if (events['message-receipt.update']) {
          const payload = events['message-receipt.update'] as MessageUserReceiptUpdate[];
          const remotesJidMap: Record<string, number> = {};

          for (const event of payload) {
            if (typeof event.key.remoteJid === 'string' && typeof event.receipt.readTimestamp === 'number') {
              remotesJidMap[event.key.remoteJid] = event.receipt.readTimestamp;
            }
          }

          await Promise.all(
            Object.keys(remotesJidMap).map(async (remoteJid) =>
              this.updateMessagesReadedByTimestamp(remoteJid, remotesJidMap[remoteJid]),
            ),
          );
        }

        if (events['presence.update']) {
          const payload = events['presence.update'];

          if (settings?.groupsIgnore && payload.id.includes('@g.us')) {
            return;
          }

          this.sendDataWebhook(Events.PRESENCE_UPDATE, payload);
        }

        if (!settings?.groupsIgnore) {
          if (events['groups.upsert']) {
            const payload = events['groups.upsert'];
            this.groupHandler['groups.upsert'](payload);
          }

          if (events['groups.update']) {
            const payload = events['groups.update'];
            this.groupHandler['groups.update'](payload);
          }

          if (events['group-participants.update']) {
            const payload = events['group-participants.update'];
            this.groupHandler['group-participants.update'](payload);
          }
        }

        if (events['chats.upsert']) {
          const payload = events['chats.upsert'];
          this.chatHandle['chats.upsert'](payload);
        }

        if (events['chats.update']) {
          const payload = events['chats.update'];
          this.chatHandle['chats.update'](payload);
        }

        if (events['chats.delete']) {
          const payload = events['chats.delete'];
          this.chatHandle['chats.delete'](payload);
        }

        if (events['contacts.upsert']) {
          const payload = events['contacts.upsert'];
          this.contactHandle['contacts.upsert'](payload);
        }

        if (events['contacts.update']) {
          const payload = events['contacts.update'];
          this.contactHandle['contacts.update'](payload);
        }

        if (events[Events.LABELS_ASSOCIATION]) {
          const payload = events[Events.LABELS_ASSOCIATION];
          this.labelHandle[Events.LABELS_ASSOCIATION](payload, database);
          return;
        }

        if (events[Events.LABELS_EDIT]) {
          const payload = events[Events.LABELS_EDIT];
          this.labelHandle[Events.LABELS_EDIT](payload);
          return;
        }
      }
    });
  }

  private historySyncNotification(msg: proto.Message.IHistorySyncNotification) {
    const instance: InstanceDto = { instanceName: this.instance.name };

    if (
      this.configService.get<Chatwoot>('CHATWOOT').ENABLED &&
      this.localChatwoot?.enabled &&
      this.localChatwoot.importMessages &&
      this.isSyncNotificationFromUsedSyncType(msg)
    ) {
      if (msg.chunkOrder === 1) {
        this.chatwootService.startImportHistoryMessages(instance);
      }

      if (msg.progress === 100) {
        setTimeout(() => {
          this.chatwootService.importHistoryMessages(instance);
        }, 10000);
      }
    }

    return true;
  }

  private isSyncNotificationFromUsedSyncType(msg: proto.Message.IHistorySyncNotification) {
    return (
      (this.localSettings.syncFullHistory && msg?.syncType === 2) ||
      (!this.localSettings.syncFullHistory && msg?.syncType === 3)
    );
  }

  public async profilePicture(number: string) {
    const jid = createJid(number);

    try {
      const profilePictureUrl = await this.client.profilePictureUrl(jid, 'image');

      return {
        wuid: jid,
        profilePictureUrl,
      };
    } catch (error) {
      return {
        wuid: jid,
        profilePictureUrl: null,
      };
    }
  }

  public async getStatus(number: string) {
    const jid = createJid(number);

    try {
      return {
        wuid: jid,
        status: (await this.client.fetchStatus(jid))[0]?.status,
      };
    } catch (error) {
      return {
        wuid: jid,
        status: null,
      };
    }
  }

  public async fetchProfile(instanceName: string, number?: string) {
    const jid = number ? createJid(number) : this.client?.user?.id;

    const onWhatsapp = (await this.whatsappNumber({ numbers: [jid] }))?.shift();

    if (!onWhatsapp.exists) {
      throw new BadRequestException(onWhatsapp);
    }

    try {
      if (number) {
        const info = (await this.whatsappNumber({ numbers: [jid] }))?.shift();
        const picture = await this.profilePicture(info?.jid);
        const status = await this.getStatus(info?.jid);
        const business = await this.fetchBusinessProfile(info?.jid);

        return {
          wuid: info?.jid || jid,
          name: info?.name,
          numberExists: info?.exists,
          picture: picture?.profilePictureUrl,
          status: status?.status,
          isBusiness: business.isBusiness,
          email: business?.email,
          description: business?.description,
          website: business?.website?.shift(),
        };
      } else {
        const instanceNames = instanceName ? [instanceName] : null;
        const info: Instance = await waMonitor.instanceInfo(instanceNames);
        const business = await this.fetchBusinessProfile(jid);

        return {
          wuid: jid,
          name: info?.profileName,
          numberExists: true,
          picture: info?.profilePicUrl,
          status: info?.connectionStatus,
          isBusiness: business.isBusiness,
          email: business?.email,
          description: business?.description,
          website: business?.website?.shift(),
        };
      }
    } catch (error) {
      return {
        wuid: jid,
        name: null,
        picture: null,
        status: null,
        os: null,
        isBusiness: false,
      };
    }
  }

  public async offerCall({ number, isVideo, callDuration }: OfferCallDto) {
    const jid = createJid(number);

    try {
      const call = await this.client.offerCall(jid, isVideo);
      setTimeout(() => this.client.terminateCall(call.id, call.to), callDuration * 1000);

      return call;
    } catch (error) {
      return error;
    }
  }

  private async sendMessage(
    sender: string,
    message: any,
    mentions: any,
    linkPreview: any,
    quoted: any,
    messageId?: string,
    ephemeralExpiration?: number,
    // participants?: GroupParticipant[],
  ) {
    sender = sender.toLowerCase();

    const option: any = {
      quoted,
    };

    if (isJidGroup(sender)) {
      option.useCachedGroupMetadata = true;
      // if (participants)
      //   option.cachedGroupMetadata = async () => {
      //     return { participants: participants as GroupParticipant[] };
      //   };
    }

    if (ephemeralExpiration) option.ephemeralExpiration = ephemeralExpiration;

    if (messageId) option.messageId = messageId;
    else option.messageId = '3EB0' + randomBytes(18).toString('hex').toUpperCase();

    if (message['viewOnceMessage']) {
      const m = generateWAMessageFromContent(sender, message, {
        timestamp: new Date(),
        userJid: this.instance.wuid,
        messageId,
        quoted,
      });
      const id = await this.client.relayMessage(sender, message, { messageId });
      m.key = {
        id: id,
        remoteJid: sender,
        participant: isJidUser(sender) ? sender : undefined,
        fromMe: true,
      };
      for (const [key, value] of Object.entries(m)) {
        if (!value || (isArray(value) && value.length) === 0) {
          delete m[key];
        }
      }
      return m;
    }

    if (
      !message['audio'] &&
      !message['poll'] &&
      !message['sticker'] &&
      !message['conversation'] &&
      sender !== 'status@broadcast'
    ) {
      if (message['reactionMessage']) {
        return await this.client.sendMessage(
          sender,
          {
            react: {
              text: message['reactionMessage']['text'],
              key: message['reactionMessage']['key'],
            },
          } as unknown as AnyMessageContent,
          option as unknown as MiscMessageGenerationOptions,
        );
      }
    }

    if (message['conversation']) {
      return await this.client.sendMessage(
        sender,
        {
          text: message['conversation'],
          mentions,
          linkPreview: linkPreview,
        } as unknown as AnyMessageContent,
        option as unknown as MiscMessageGenerationOptions,
      );
    }

    if (!message['audio'] && !message['poll'] && !message['sticker'] && sender != 'status@broadcast') {
      return await this.client.sendMessage(
        sender,
        {
          forward: {
            key: { remoteJid: this.instance.wuid, fromMe: true },
            message,
          },
          mentions,
        },
        option as unknown as MiscMessageGenerationOptions,
      );
    }

    if (sender === 'status@broadcast') {
      let jidList;
      if (message['status'].option.allContacts) {
        const contacts = await this.prismaRepository.contact.findMany({
          where: {
            instanceId: this.instanceId,
            remoteJid: {
              not: {
                endsWith: '@g.us',
              },
            },
          },
        });

        jidList = contacts.map((contact) => contact.remoteJid);
      } else {
        jidList = message['status'].option.statusJidList;
      }

      const batchSize = 10;

      const batches = Array.from({ length: Math.ceil(jidList.length / batchSize) }, (_, i) =>
        jidList.slice(i * batchSize, i * batchSize + batchSize),
      );

      let msgId: string | null = null;

      let firstMessage: WAMessage;

      const firstBatch = batches.shift();

      if (firstBatch) {
        firstMessage = await this.client.sendMessage(
          sender,
          message['status'].content as unknown as AnyMessageContent,
          {
            backgroundColor: message['status'].option.backgroundColor,
            font: message['status'].option.font,
            statusJidList: firstBatch,
          } as unknown as MiscMessageGenerationOptions,
        );

        msgId = firstMessage.key.id;
      }

      if (batches.length === 0) return firstMessage;

      await Promise.allSettled(
        batches.map(async (batch) => {
          const messageSent = await this.client.sendMessage(
            sender,
            message['status'].content as unknown as AnyMessageContent,
            {
              backgroundColor: message['status'].option.backgroundColor,
              font: message['status'].option.font,
              statusJidList: batch,
              messageId: msgId,
            } as unknown as MiscMessageGenerationOptions,
          );

          return messageSent;
        }),
      );

      return firstMessage;
    }

    return await this.client.sendMessage(
      sender,
      message as unknown as AnyMessageContent,
      option as unknown as MiscMessageGenerationOptions,
    );
  }

  private async sendMessageWithTyping<T = proto.IMessage>(
    number: string,
    message: T,
    options?: Options,
    isIntegration = false,
  ) {
    const isWA = (await this.whatsappNumber({ numbers: [number] }))?.shift();

    if (!isWA.exists && !isJidGroup(isWA.jid) && !isWA.jid.includes('@broadcast')) {
      throw new BadRequestException(isWA);
    }

    const sender = isWA.jid.toLowerCase();

    this.logger.verbose(`Sending message to ${sender}`);

    try {
      if (options?.delay) {
        this.logger.verbose(`Typing for ${options.delay}ms to ${sender}`);
        if (options.delay > 20000) {
          let remainingDelay = options.delay;
          while (remainingDelay > 20000) {
            await this.client.presenceSubscribe(sender);

            await this.client.sendPresenceUpdate((options.presence as WAPresence) ?? 'composing', sender);

            await delay(20000);

            await this.client.sendPresenceUpdate('paused', sender);

            remainingDelay -= 20000;
          }
          if (remainingDelay > 0) {
            await this.client.presenceSubscribe(sender);

            await this.client.sendPresenceUpdate((options.presence as WAPresence) ?? 'composing', sender);

            await delay(remainingDelay);

            await this.client.sendPresenceUpdate('paused', sender);
          }
        } else {
          await this.client.presenceSubscribe(sender);

          await this.client.sendPresenceUpdate((options.presence as WAPresence) ?? 'composing', sender);

          await delay(options.delay);

          await this.client.sendPresenceUpdate('paused', sender);
        }
      }

      const linkPreview = options?.linkPreview != false ? undefined : false;

      let quoted: WAMessage;

      if (options?.quoted) {
        const m = options?.quoted;

        const msg = m?.message ? m : ((await this.getMessage(m.key, true)) as proto.IWebMessageInfo);

        if (msg) {
          quoted = msg;
        }
      }

      let messageSent: WAMessage;

      let mentions: string[];
      if (isJidGroup(sender)) {
        let group;
        try {
          const cache = this.configService.get<CacheConf>('CACHE');
          if (!cache.REDIS.ENABLED && !cache.LOCAL.ENABLED) group = await this.findGroup({ groupJid: sender }, 'inner');
          else group = await this.getGroupMetadataCache(sender);
          // group = await this.findGroup({ groupJid: sender }, 'inner');
        } catch (error) {
          throw new NotFoundException('Group not found');
        }

        if (!group) {
          throw new NotFoundException('Group not found');
        }

        if (options?.mentionsEveryOne) {
          mentions = group.participants.map((participant) => participant.id);
        } else if (options?.mentioned?.length) {
          mentions = options.mentioned.map((mention) => {
            const jid = createJid(mention);
            if (isJidGroup(jid)) {
              return null;
            }
            return jid;
          });
        }

        messageSent = await this.sendMessage(
          sender,
          message,
          mentions,
          linkPreview,
          quoted,
          null,
          group?.ephemeralDuration,
          // group?.participants,
        );
      } else {
        messageSent = await this.sendMessage(sender, message, mentions, linkPreview, quoted);
      }

      if (Long.isLong(messageSent?.messageTimestamp)) {
        messageSent.messageTimestamp = messageSent.messageTimestamp?.toNumber();
      }

      const messageRaw = this.prepareMessage(messageSent);

      const isMedia =
        messageSent?.message?.imageMessage ||
        messageSent?.message?.videoMessage ||
        messageSent?.message?.stickerMessage ||
        messageSent?.message?.ptvMessage ||
        messageSent?.message?.documentMessage ||
        messageSent?.message?.documentWithCaptionMessage ||
        messageSent?.message?.ptvMessage ||
        messageSent?.message?.audioMessage;

      if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled && !isIntegration) {
        this.chatwootService.eventWhatsapp(
          Events.SEND_MESSAGE,
          { instanceName: this.instance.name, instanceId: this.instanceId },
          messageRaw,
        );
      }

      if (this.configService.get<Openai>('OPENAI').ENABLED && messageRaw?.message?.audioMessage) {
        const openAiDefaultSettings = await this.prismaRepository.openaiSetting.findFirst({
          where: {
            instanceId: this.instanceId,
          },
          include: {
            OpenaiCreds: true,
          },
        });

        if (openAiDefaultSettings && openAiDefaultSettings.openaiCredsId && openAiDefaultSettings.speechToText) {
          messageRaw.message.speechToText = await this.openaiService.speechToText(
            openAiDefaultSettings.OpenaiCreds,
            messageRaw,
            this.client.updateMediaMessage,
          );
        }
      }

      if (this.configService.get<Database>('DATABASE').SAVE_DATA.NEW_MESSAGE) {
        const msg = await this.prismaRepository.message.create({
          data: messageRaw,
        });

        if (isMedia && this.configService.get<S3>('S3').ENABLE) {
          try {
            const message: any = messageRaw;
            const media = await this.getBase64FromMediaMessage(
              {
                message,
              },
              true,
            );

            const { buffer, mediaType, fileName, size } = media;

            const mimetype = mimeTypes.lookup(fileName).toString();

            const fullName = join(
              `${this.instance.id}`,
              messageRaw.key.remoteJid,
              `${messageRaw.key.id}`,
              mediaType,
              fileName,
            );

            await s3Service.uploadFile(fullName, buffer, size.fileLength?.low, {
              'Content-Type': mimetype,
            });

            await this.prismaRepository.media.create({
              data: {
                messageId: msg.id,
                instanceId: this.instanceId,
                type: mediaType,
                fileName: fullName,
                mimetype,
              },
            });

            const mediaUrl = await s3Service.getObjectUrl(fullName);

            messageRaw.message.mediaUrl = mediaUrl;

            await this.prismaRepository.message.update({
              where: { id: msg.id },
              data: messageRaw,
            });
          } catch (error) {
            this.logger.error(['Error on upload file to minio', error?.message, error?.stack]);
          }
        }
      }

      if (this.localWebhook.enabled) {
        if (isMedia && this.localWebhook.webhookBase64) {
          try {
            const buffer = await downloadMediaMessage(
              { key: messageRaw.key, message: messageRaw?.message },
              'buffer',
              {},
              {
                logger: P({ level: 'error' }) as any,
                reuploadRequest: this.client.updateMediaMessage,
              },
            );

            messageRaw.message.base64 = buffer ? buffer.toString('base64') : undefined;
          } catch (error) {
            this.logger.error(['Error converting media to base64', error?.message]);
          }
        }
      }

      this.logger.log(messageRaw);

      this.sendDataWebhook(Events.SEND_MESSAGE, messageRaw);

      if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled && isIntegration) {
        await chatbotController.emit({
          instance: { instanceName: this.instance.name, instanceId: this.instanceId },
          remoteJid: messageRaw.key.remoteJid,
          msg: messageRaw,
          pushName: messageRaw.pushName,
          isIntegration,
        });
      }

      return messageRaw;
    } catch (error) {
      this.logger.error(error);
      throw new BadRequestException(error.toString());
    }
  }

  // Instance Controller
  public async sendPresence(data: SendPresenceDto) {
    try {
      const { number } = data;

      const isWA = (await this.whatsappNumber({ numbers: [number] }))?.shift();

      if (!isWA.exists && !isJidGroup(isWA.jid) && !isWA.jid.includes('@broadcast')) {
        throw new BadRequestException(isWA);
      }

      const sender = isWA.jid;

      if (data?.delay && data?.delay > 20000) {
        let remainingDelay = data?.delay;
        while (remainingDelay > 20000) {
          await this.client.presenceSubscribe(sender);

          await this.client.sendPresenceUpdate((data?.presence as WAPresence) ?? 'composing', sender);

          await delay(20000);

          await this.client.sendPresenceUpdate('paused', sender);

          remainingDelay -= 20000;
        }
        if (remainingDelay > 0) {
          await this.client.presenceSubscribe(sender);

          await this.client.sendPresenceUpdate((data?.presence as WAPresence) ?? 'composing', sender);

          await delay(remainingDelay);

          await this.client.sendPresenceUpdate('paused', sender);
        }
      } else {
        await this.client.presenceSubscribe(sender);

        await this.client.sendPresenceUpdate((data?.presence as WAPresence) ?? 'composing', sender);

        await delay(data?.delay);

        await this.client.sendPresenceUpdate('paused', sender);
      }

      return { presence: data.presence };
    } catch (error) {
      this.logger.error(error);
      throw new BadRequestException(error.toString());
    }
  }

  // Presence Controller
  public async setPresence(data: SetPresenceDto) {
    try {
      await this.client.sendPresenceUpdate(data.presence);

      return { presence: data.presence };
    } catch (error) {
      this.logger.error(error);
      throw new BadRequestException(error.toString());
    }
  }

  // Send Message Controller
  public async textMessage(data: SendTextDto, isIntegration = false) {
    const text = data.text;

    if (!text || text.trim().length === 0) {
      throw new BadRequestException('Text is required');
    }

    return await this.sendMessageWithTyping(
      data.number,
      {
        conversation: data.text,
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      isIntegration,
    );
  }

  public async pollMessage(data: SendPollDto) {
    return await this.sendMessageWithTyping(
      data.number,
      {
        poll: {
          name: data.name,
          selectableCount: data.selectableCount,
          values: data.values,
        },
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        linkPreview: data?.linkPreview,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
    );
  }

  private async formatStatusMessage(status: StatusMessage) {
    if (!status.type) {
      throw new BadRequestException('Type is required');
    }

    if (!status.content) {
      throw new BadRequestException('Content is required');
    }

    if (status.allContacts) {
      const contacts = await this.prismaRepository.contact.findMany({
        where: { instanceId: this.instanceId },
      });

      if (!contacts.length) {
        throw new BadRequestException('Contacts not found');
      }

      status.statusJidList = contacts.filter((contact) => contact.pushName).map((contact) => contact.remoteJid);
    }

    if (!status.statusJidList?.length && !status.allContacts) {
      throw new BadRequestException('StatusJidList is required');
    }

    if (status.type === 'text') {
      if (!status.backgroundColor) {
        throw new BadRequestException('Background color is required');
      }

      if (!status.font) {
        throw new BadRequestException('Font is required');
      }

      return {
        content: {
          text: status.content,
        },
        option: {
          backgroundColor: status.backgroundColor,
          font: status.font,
          statusJidList: status.statusJidList,
        },
      };
    }
    if (status.type === 'image') {
      return {
        content: {
          image: {
            url: status.content,
          },
          caption: status.caption,
        },
        option: {
          statusJidList: status.statusJidList,
        },
      };
    }

    if (status.type === 'video') {
      return {
        content: {
          video: {
            url: status.content,
          },
          caption: status.caption,
        },
        option: {
          statusJidList: status.statusJidList,
        },
      };
    }

    if (status.type === 'audio') {
      const convert = await this.processAudioMp4(status.content);
      if (Buffer.isBuffer(convert)) {
        const result = {
          content: {
            audio: convert,
            ptt: true,
            mimetype: 'audio/ogg; codecs=opus',
          },
          option: {
            statusJidList: status.statusJidList,
          },
        };

        return result;
      } else {
        throw new InternalServerErrorException(convert);
      }
    }

    throw new BadRequestException('Type not found');
  }

  public async statusMessage(data: SendStatusDto, file?: any) {
    const mediaData: SendStatusDto = { ...data };

    if (file) mediaData.content = file.buffer.toString('base64');

    const status = await this.formatStatusMessage(mediaData);

    const statusSent = await this.sendMessageWithTyping('status@broadcast', {
      status,
    });

    return statusSent;
  }

  private async prepareMediaMessage(mediaMessage: MediaMessage) {
    try {
      const type = mediaMessage.mediatype === 'ptv' ? 'video' : mediaMessage.mediatype;

      const prepareMedia = await prepareWAMessageMedia(
        {
          [type]: isURL(mediaMessage.media) ? { url: mediaMessage.media } : Buffer.from(mediaMessage.media, 'base64'),
        } as any,
        { upload: this.client.waUploadToServer },
      );

      const mediaType = mediaMessage.mediatype + 'Message';

      if (mediaMessage.mediatype === 'document' && !mediaMessage.fileName) {
        const regex = new RegExp(/.*\/(.+?)\./);
        const arrayMatch = regex.exec(mediaMessage.media);
        mediaMessage.fileName = arrayMatch[1];
      }

      if (mediaMessage.mediatype === 'image' && !mediaMessage.fileName) {
        mediaMessage.fileName = 'image.png';
      }

      if (mediaMessage.mediatype === 'video' && !mediaMessage.fileName) {
        mediaMessage.fileName = 'video.mp4';
      }

      let mimetype: string | false;

      if (mediaMessage.mimetype) {
        mimetype = mediaMessage.mimetype;
      } else {
        mimetype = mimeTypes.lookup(mediaMessage.fileName);

        if (!mimetype && isURL(mediaMessage.media)) {
          let config: any = {
            responseType: 'arraybuffer',
          };

          if (this.localProxy?.enabled) {
            config = {
              ...config,
              httpsAgent: makeProxyAgent({
                host: this.localProxy.host,
                port: this.localProxy.port,
                protocol: this.localProxy.protocol,
                username: this.localProxy.username,
                password: this.localProxy.password,
              }),
            };
          }

          const response = await axios.get(mediaMessage.media, config);

          mimetype = response.headers['content-type'];
        }
      }

      if (mediaMessage.mediatype === 'ptv') {
        prepareMedia[mediaType] = prepareMedia[type + 'Message'];
        mimetype = 'video/mp4';

        if (!prepareMedia[mediaType]) {
          throw new Error('Failed to prepare video message');
        }

        try {
          let mediaInput;
          if (isURL(mediaMessage.media)) {
            mediaInput = mediaMessage.media;
          } else {
            const mediaBuffer = Buffer.from(mediaMessage.media, 'base64');
            if (!mediaBuffer || mediaBuffer.length === 0) {
              throw new Error('Invalid media buffer');
            }
            mediaInput = mediaBuffer;
          }

          const duration = await getVideoDuration(mediaInput);
          if (!duration || duration <= 0) {
            throw new Error('Invalid media duration');
          }

          this.logger.verbose(`Video duration: ${duration} seconds`);
          prepareMedia[mediaType].seconds = duration;
        } catch (error) {
          this.logger.error('Error getting video duration:');
          this.logger.error(error);
          throw new Error(`Failed to get video duration: ${error.message}`);
        }
      }

      prepareMedia[mediaType].caption = mediaMessage?.caption;
      prepareMedia[mediaType].mimetype = mimetype;
      prepareMedia[mediaType].fileName = mediaMessage.fileName;

      if (mediaMessage.mediatype === 'video') {
        prepareMedia[mediaType].jpegThumbnail = Uint8Array.from(
          readFileSync(join(process.cwd(), 'public', 'images', 'video-cover.png')),
        );
        prepareMedia[mediaType].gifPlayback = false;
      }

      return generateWAMessageFromContent(
        '',
        { [mediaType]: { ...prepareMedia[mediaType] } },
        { userJid: this.instance.wuid },
      );
    } catch (error) {
      this.logger.error(error);
      throw new InternalServerErrorException(error?.toString() || error);
    }
  }

  private async convertToWebP(image: string): Promise<Buffer> {
    try {
      let imageBuffer: Buffer;

      if (isBase64(image)) {
        const base64Data = image.replace(/^data:image\/(jpeg|png|gif);base64,/, '');
        imageBuffer = Buffer.from(base64Data, 'base64');
      } else {
        const timestamp = new Date().getTime();
        const url = `${image}?timestamp=${timestamp}`;

        let config: any = {
          responseType: 'arraybuffer',
        };

        if (this.localProxy?.enabled) {
          config = {
            ...config,
            httpsAgent: makeProxyAgent({
              host: this.localProxy.host,
              port: this.localProxy.port,
              protocol: this.localProxy.protocol,
              username: this.localProxy.username,
              password: this.localProxy.password,
            }),
          };
        }

        const response = await axios.get(url, config);
        imageBuffer = Buffer.from(response.data, 'binary');
      }

      const webpBuffer = await sharp(imageBuffer).webp().toBuffer();

      return webpBuffer;
    } catch (error) {
      console.error('Erro ao converter a imagem para WebP:', error);
      throw error;
    }
  }

  public async mediaSticker(data: SendStickerDto, file?: any) {
    const mediaData: SendStickerDto = { ...data };

    if (file) mediaData.sticker = file.buffer.toString('base64');

    const convert = await this.convertToWebP(data.sticker);
    const gifPlayback = data.sticker.includes('.gif');
    const result = await this.sendMessageWithTyping(
      data.number,
      {
        sticker: convert,
        gifPlayback,
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
    );

    return result;
  }

  public async mediaMessage(data: SendMediaDto, file?: any, isIntegration = false) {
    const mediaData: SendMediaDto = { ...data };

    if (file) mediaData.media = file.buffer.toString('base64');

    const generate = await this.prepareMediaMessage(mediaData);

    const mediaSent = await this.sendMessageWithTyping(
      data.number,
      { ...generate.message },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      isIntegration,
    );

    return mediaSent;
  }

  public async ptvMessage(data: SendPtvDto, file?: any, isIntegration = false) {
    const mediaData: SendMediaDto = {
      number: data.number,
      media: data.video,
      mediatype: 'ptv',
      delay: data?.delay,
      quoted: data?.quoted,
      mentionsEveryOne: data?.mentionsEveryOne,
      mentioned: data?.mentioned,
    };

    if (file) mediaData.media = file.buffer.toString('base64');

    const generate = await this.prepareMediaMessage(mediaData);

    const mediaSent = await this.sendMessageWithTyping(
      data.number,
      { ...generate.message },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
      isIntegration,
    );

    return mediaSent;
  }

  public async processAudioMp4(audio: string) {
    let inputStream: PassThrough;

    if (isURL(audio)) {
      const response = await axios.get(audio, { responseType: 'stream' });
      inputStream = response.data;
    } else {
      const audioBuffer = Buffer.from(audio, 'base64');
      inputStream = new PassThrough();
      inputStream.end(audioBuffer);
    }

    return new Promise<Buffer>((resolve, reject) => {
      const ffmpegProcess = spawn(ffmpegPath.path, [
        '-i',
        'pipe:0',
        '-vn',
        '-ab',
        '128k',
        '-ar',
        '44100',
        '-f',
        'mp4',
        '-movflags',
        'frag_keyframe+empty_moov',
        'pipe:1',
      ]);

      const outputChunks: Buffer[] = [];
      let stderrData = '';

      ffmpegProcess.stdout.on('data', (chunk) => {
        outputChunks.push(chunk);
      });

      ffmpegProcess.stderr.on('data', (data) => {
        stderrData += data.toString();
        this.logger.verbose(`ffmpeg stderr: ${data}`);
      });

      ffmpegProcess.on('error', (error) => {
        console.error('Error in ffmpeg process', error);
        reject(error);
      });

      ffmpegProcess.on('close', (code) => {
        if (code === 0) {
          this.logger.verbose('Audio converted to mp4');
          const outputBuffer = Buffer.concat(outputChunks);
          resolve(outputBuffer);
        } else {
          this.logger.error(`ffmpeg exited with code ${code}`);
          this.logger.error(`ffmpeg stderr: ${stderrData}`);
          reject(new Error(`ffmpeg exited with code ${code}: ${stderrData}`));
        }
      });

      inputStream.pipe(ffmpegProcess.stdin);

      inputStream.on('error', (err) => {
        console.error('Error in inputStream', err);
        ffmpegProcess.stdin.end();
        reject(err);
      });
    });
  }

  public async processAudio(audio: string): Promise<Buffer> {
    if (process.env.API_AUDIO_CONVERTER) {
      this.logger.verbose('Using audio converter API');
      const formData = new FormData();

      if (isURL(audio)) {
        formData.append('url', audio);
      } else {
        formData.append('base64', audio);
      }

      const { data } = await axios.post(process.env.API_AUDIO_CONVERTER, formData, {
        headers: {
          ...formData.getHeaders(),
          apikey: process.env.API_AUDIO_CONVERTER_KEY,
        },
      });

      if (!data.audio) {
        throw new InternalServerErrorException('Failed to convert audio');
      }

      this.logger.verbose('Audio converted');
      return Buffer.from(data.audio, 'base64');
    } else {
      let inputAudioStream: PassThrough;

      if (isURL(audio)) {
        const timestamp = new Date().getTime();
        const url = `${audio}?timestamp=${timestamp}`;

        const config: any = {
          responseType: 'stream',
        };

        const response = await axios.get(url, config);
        inputAudioStream = response.data.pipe(new PassThrough());
      } else {
        const audioBuffer = Buffer.from(audio, 'base64');
        inputAudioStream = new PassThrough();
        inputAudioStream.end(audioBuffer);
      }

      return new Promise((resolve, reject) => {
        const outputAudioStream = new PassThrough();
        const chunks: Buffer[] = [];

        outputAudioStream.on('data', (chunk) => chunks.push(chunk));
        outputAudioStream.on('end', () => {
          const outputBuffer = Buffer.concat(chunks);
          resolve(outputBuffer);
        });

        outputAudioStream.on('error', (error) => {
          console.log('error', error);
          reject(error);
        });

        ffmpeg.setFfmpegPath(ffmpegPath.path);

        ffmpeg(inputAudioStream)
          .outputFormat('ogg')
          .noVideo()
          .audioCodec('libopus')
          .addOutputOptions('-avoid_negative_ts make_zero')
          .audioChannels(1)
          .pipe(outputAudioStream, { end: true })
          .on('error', function (error) {
            console.log('error', error);
            reject(error);
          });
      });
    }
  }

  public async audioWhatsapp(data: SendAudioDto, file?: any, isIntegration = false) {
    const mediaData: SendAudioDto = { ...data };

    if (file?.buffer) {
      mediaData.audio = file.buffer.toString('base64');
    } else if (!isURL(data.audio) && !isBase64(data.audio)) {
      console.error('Invalid file or audio source');
      throw new BadRequestException('File buffer, URL, or base64 audio is required');
    }

    if (!data?.encoding && data?.encoding !== false) {
      data.encoding = true;
    }

    if (data?.encoding) {
      const convert = await this.processAudio(mediaData.audio);

      if (Buffer.isBuffer(convert)) {
        const result = this.sendMessageWithTyping<AnyMessageContent>(
          data.number,
          {
            audio: convert,
            ptt: true,
            mimetype: 'audio/ogg; codecs=opus',
          },
          { presence: 'recording', delay: data?.delay },
          isIntegration,
        );

        return result;
      } else {
        throw new InternalServerErrorException('Failed to convert audio');
      }
    }

    return await this.sendMessageWithTyping<AnyMessageContent>(
      data.number,
      {
        audio: isURL(data.audio) ? { url: data.audio } : Buffer.from(data.audio, 'base64'),
        ptt: true,
        mimetype: 'audio/ogg; codecs=opus',
      },
      { presence: 'recording', delay: data?.delay },
      isIntegration,
    );
  }

  private generateRandomId(length = 11) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
  }

  private toJSONString(button: Button): string {
    const toString = (obj: any) => JSON.stringify(obj);

    const json = {
      call: () => toString({ display_text: button.displayText, phone_number: button.phoneNumber }),
      reply: () => toString({ display_text: button.displayText, id: button.id }),
      copy: () => toString({ display_text: button.displayText, copy_code: button.copyCode }),
      url: () =>
        toString({
          display_text: button.displayText,
          url: button.url,
          merchant_url: button.url,
        }),
      pix: () =>
        toString({
          currency: button.currency,
          total_amount: {
            value: 0,
            offset: 100,
          },
          reference_id: this.generateRandomId(),
          type: 'physical-goods',
          order: {
            status: 'pending',
            subtotal: {
              value: 0,
              offset: 100,
            },
            order_type: 'ORDER',
            items: [
              {
                name: '',
                amount: {
                  value: 0,
                  offset: 100,
                },
                quantity: 0,
                sale_amount: {
                  value: 0,
                  offset: 100,
                },
              },
            ],
          },
          payment_settings: [
            {
              type: 'pix_static_code',
              pix_static_code: {
                merchant_name: button.name,
                key: button.key,
                key_type: this.mapKeyType.get(button.keyType),
              },
            },
          ],
          share_payment_status: false,
        }),
    };

    return json[button.type]?.() || '';
  }

  private readonly mapType = new Map<TypeButton, string>([
    ['reply', 'quick_reply'],
    ['copy', 'cta_copy'],
    ['url', 'cta_url'],
    ['call', 'cta_call'],
    ['pix', 'payment_info'],
  ]);

  private readonly mapKeyType = new Map<KeyType, string>([
    ['phone', 'PHONE'],
    ['email', 'EMAIL'],
    ['cpf', 'CPF'],
    ['cnpj', 'CNPJ'],
    ['random', 'EVP'],
  ]);

  public async buttonMessage(data: SendButtonsDto) {
    if (data.buttons.length === 0) {
      throw new BadRequestException('At least one button is required');
    }

    const hasReplyButtons = data.buttons.some((btn) => btn.type === 'reply');

    const hasPixButton = data.buttons.some((btn) => btn.type === 'pix');

    const hasOtherButtons = data.buttons.some((btn) => btn.type !== 'reply' && btn.type !== 'pix');

    if (hasReplyButtons) {
      if (data.buttons.length > 3) {
        throw new BadRequestException('Maximum of 3 reply buttons allowed');
      }
      if (hasOtherButtons) {
        throw new BadRequestException('Reply buttons cannot be mixed with other button types');
      }
    }

    if (hasPixButton) {
      if (data.buttons.length > 1) {
        throw new BadRequestException('Only one PIX button is allowed');
      }
      if (hasOtherButtons) {
        throw new BadRequestException('PIX button cannot be mixed with other button types');
      }

      const message: proto.IMessage = {
        viewOnceMessage: {
          message: {
            interactiveMessage: {
              nativeFlowMessage: {
                buttons: [
                  {
                    name: this.mapType.get('pix'),
                    buttonParamsJson: this.toJSONString(data.buttons[0]),
                  },
                ],
                messageParamsJson: JSON.stringify({
                  from: 'api',
                  templateId: v4(),
                }),
              },
            },
          },
        },
      };

      return await this.sendMessageWithTyping(data.number, message, {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      });
    }

    const generate = await (async () => {
      if (data?.thumbnailUrl) {
        return await this.prepareMediaMessage({
          mediatype: 'image',
          media: data.thumbnailUrl,
        });
      }
    })();

    const buttons = data.buttons.map((value) => {
      return {
        name: this.mapType.get(value.type),
        buttonParamsJson: this.toJSONString(value),
      };
    });

    const message: proto.IMessage = {
      viewOnceMessage: {
        message: {
          interactiveMessage: {
            body: {
              text: (() => {
                let t = '*' + data.title + '*';
                if (data?.description) {
                  t += '\n\n';
                  t += data.description;
                  t += '\n';
                }
                return t;
              })(),
            },
            footer: {
              text: data?.footer,
            },
            header: (() => {
              if (generate?.message?.imageMessage) {
                return {
                  hasMediaAttachment: !!generate.message.imageMessage,
                  imageMessage: generate.message.imageMessage,
                };
              }
            })(),
            nativeFlowMessage: {
              buttons: buttons,
              messageParamsJson: JSON.stringify({
                from: 'api',
                templateId: v4(),
              }),
            },
          },
        },
      },
    };

    return await this.sendMessageWithTyping(data.number, message, {
      delay: data?.delay,
      presence: 'composing',
      quoted: data?.quoted,
      mentionsEveryOne: data?.mentionsEveryOne,
      mentioned: data?.mentioned,
    });
  }

  public async locationMessage(data: SendLocationDto) {
    return await this.sendMessageWithTyping(
      data.number,
      {
        locationMessage: {
          degreesLatitude: data.latitude,
          degreesLongitude: data.longitude,
          name: data?.name,
          address: data?.address,
        },
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
    );
  }

  public async listMessage(data: SendListDto) {
    return await this.sendMessageWithTyping(
      data.number,
      {
        listMessage: {
          title: data.title,
          description: data.description,
          buttonText: data?.buttonText,
          footerText: data?.footerText,
          sections: data.sections,
          listType: 2,
        },
      },
      {
        delay: data?.delay,
        presence: 'composing',
        quoted: data?.quoted,
        mentionsEveryOne: data?.mentionsEveryOne,
        mentioned: data?.mentioned,
      },
    );
  }

  public async contactMessage(data: SendContactDto) {
    const message: proto.IMessage = {};

    const vcard = (contact: ContactMessage) => {
      let result = 'BEGIN:VCARD\n' + 'VERSION:3.0\n' + `N:${contact.fullName}\n` + `FN:${contact.fullName}\n`;

      if (contact.organization) {
        result += `ORG:${contact.organization};\n`;
      }

      if (contact.email) {
        result += `EMAIL:${contact.email}\n`;
      }

      if (contact.url) {
        result += `URL:${contact.url}\n`;
      }

      if (!contact.wuid) {
        contact.wuid = createJid(contact.phoneNumber);
      }

      result += `item1.TEL;waid=${contact.wuid}:${contact.phoneNumber}\n` + 'item1.X-ABLabel:Celular\n' + 'END:VCARD';

      return result;
    };

    if (data.contact.length === 1) {
      message.contactMessage = {
        displayName: data.contact[0].fullName,
        vcard: vcard(data.contact[0]),
      };
    } else {
      message.contactsArrayMessage = {
        displayName: `${data.contact.length} contacts`,
        contacts: data.contact.map((contact) => {
          return {
            displayName: contact.fullName,
            vcard: vcard(contact),
          };
        }),
      };
    }

    return await this.sendMessageWithTyping(data.number, { ...message }, {});
  }

  public async reactionMessage(data: SendReactionDto) {
    return await this.sendMessageWithTyping(data.key.remoteJid, {
      reactionMessage: {
        key: data.key,
        text: data.reaction,
      },
    });
  }

  // Chat Controller
  public async whatsappNumber(data: WhatsAppNumberDto) {
    const jids: {
      groups: { number: string; jid: string }[];
      broadcast: { number: string; jid: string }[];
      users: { number: string; jid: string; name?: string }[];
    } = {
      groups: [],
      broadcast: [],
      users: [],
    };

    data.numbers.forEach((number) => {
      const jid = createJid(number);

      if (isJidGroup(jid)) {
        jids.groups.push({ number, jid });
      } else if (jid === 'status@broadcast') {
        jids.broadcast.push({ number, jid });
      } else {
        jids.users.push({ number, jid });
      }
    });

    const onWhatsapp: OnWhatsAppDto[] = [];

    // BROADCAST
    onWhatsapp.push(...jids.broadcast.map(({ jid, number }) => new OnWhatsAppDto(jid, false, number)));

    // GROUPS
    const groups = await Promise.all(
      jids.groups.map(async ({ jid, number }) => {
        const group = await this.findGroup({ groupJid: jid }, 'inner');

        if (!group) {
          new OnWhatsAppDto(jid, false, number);
        }

        return new OnWhatsAppDto(group.id, !!group?.id, number, group?.subject);
      }),
    );
    onWhatsapp.push(...groups);

    // USERS
    const contacts: any[] = await this.prismaRepository.contact.findMany({
      where: {
        instanceId: this.instanceId,
        remoteJid: {
          in: jids.users.map(({ jid }) => jid),
        },
      },
    });

    const numbersToVerify = jids.users.map(({ jid }) => jid.replace('+', ''));

    const cachedNumbers = await getOnWhatsappCache(numbersToVerify);
    const filteredNumbers = numbersToVerify.filter(
      (jid) => !cachedNumbers.some((cached) => cached.jidOptions.includes(jid)),
    );

    const verify = await this.client.onWhatsApp(...filteredNumbers);
    const users: OnWhatsAppDto[] = await Promise.all(
      jids.users.map(async (user) => {
        let numberVerified: (typeof verify)[0] | null = null;

        const cached = cachedNumbers.find((cached) => cached.jidOptions.includes(user.jid.replace('+', '')));
        if (cached) {
          return {
            exists: true,
            jid: cached.remoteJid,
            name: contacts.find((c) => c.remoteJid === cached.remoteJid)?.pushName,
            number: user.number,
          };
        }

        // Brazilian numbers
        if (user.number.startsWith('55')) {
          const numberWithDigit =
            user.number.slice(4, 5) === '9' && user.number.length === 13
              ? user.number
              : `${user.number.slice(0, 4)}9${user.number.slice(4)}`;
          const numberWithoutDigit =
            user.number.length === 12 ? user.number : user.number.slice(0, 4) + user.number.slice(5);

          numberVerified = verify.find(
            (v) => v.jid === `${numberWithDigit}@s.whatsapp.net` || v.jid === `${numberWithoutDigit}@s.whatsapp.net`,
          );
        }

        // Mexican/Argentina numbers
        // Ref: https://faq.whatsapp.com/1294841057948784
        if (!numberVerified && (user.number.startsWith('52') || user.number.startsWith('54'))) {
          let prefix = '';
          if (user.number.startsWith('52')) {
            prefix = '';
          }
          if (user.number.startsWith('54')) {
            prefix = '9';
          }

          const numberWithDigit =
            user.number.slice(2, 3) === prefix && user.number.length === 13
              ? user.number
              : `${user.number.slice(0, 2)}${prefix}${user.number.slice(2)}`;
          const numberWithoutDigit =
            user.number.length === 12 ? user.number : user.number.slice(0, 2) + user.number.slice(3);

          numberVerified = verify.find(
            (v) => v.jid === `${numberWithDigit}@s.whatsapp.net` || v.jid === `${numberWithoutDigit}@s.whatsapp.net`,
          );
        }

        if (!numberVerified) {
          numberVerified = verify.find((v) => v.jid === user.jid);
        }

        const numberJid = numberVerified?.jid || user.jid;

        return {
          exists: !!numberVerified?.exists,
          jid: numberJid,
          name: contacts.find((c) => c.remoteJid === numberJid)?.pushName,
          number: user.number,
        };
      }),
    );

    await saveOnWhatsappCache(users.filter((user) => user.exists).map((user) => ({ remoteJid: user.jid })));

    onWhatsapp.push(...users);

    return onWhatsapp;
  }

  public async markMessageAsRead(data: ReadMessageDto) {
    try {
      const keys: proto.IMessageKey[] = [];
      data.readMessages.forEach((read) => {
        if (isJidGroup(read.remoteJid) || isJidUser(read.remoteJid)) {
          keys.push({
            remoteJid: read.remoteJid,
            fromMe: read.fromMe,
            id: read.id,
          });
        }
      });
      await this.client.readMessages(keys);
      return { message: 'Read messages', read: 'success' };
    } catch (error) {
      throw new InternalServerErrorException('Read messages fail', error.toString());
    }
  }

  public async getLastMessage(number: string) {
    const where: any = {
      key: {
        remoteJid: number,
      },
      instanceId: this.instance.id,
    };

    const messages = await this.prismaRepository.message.findMany({
      where,
      orderBy: {
        messageTimestamp: 'desc',
      },
      take: 1,
    });

    if (messages.length === 0) {
      throw new NotFoundException('Messages not found');
    }

    let lastMessage = messages.pop();

    for (const message of messages) {
      if (message.messageTimestamp >= lastMessage.messageTimestamp) {
        lastMessage = message;
      }
    }

    return lastMessage as unknown as LastMessage;
  }

  public async archiveChat(data: ArchiveChatDto) {
    try {
      let last_message = data.lastMessage;
      let number = data.chat;

      if (!last_message && number) {
        last_message = await this.getLastMessage(number);
      } else {
        last_message = data.lastMessage;
        last_message.messageTimestamp = last_message?.messageTimestamp ?? Date.now();
        number = last_message?.key?.remoteJid;
      }

      if (!last_message || Object.keys(last_message).length === 0) {
        throw new NotFoundException('Last message not found');
      }

      await this.client.chatModify(
        {
          archive: data.archive,
          lastMessages: [last_message],
        },
        createJid(number),
      );

      return {
        chatId: number,
        archived: true,
      };
    } catch (error) {
      throw new InternalServerErrorException({
        archived: false,
        message: ['An error occurred while archiving the chat. Open a calling.', error.toString()],
      });
    }
  }

  public async markChatUnread(data: MarkChatUnreadDto) {
    try {
      let last_message = data.lastMessage;
      let number = data.chat;

      if (!last_message && number) {
        last_message = await this.getLastMessage(number);
      } else {
        last_message = data.lastMessage;
        last_message.messageTimestamp = last_message?.messageTimestamp ?? Date.now();
        number = last_message?.key?.remoteJid;
      }

      if (!last_message || Object.keys(last_message).length === 0) {
        throw new NotFoundException('Last message not found');
      }

      await this.client.chatModify(
        {
          markRead: false,
          lastMessages: [last_message],
        },
        createJid(number),
      );

      return {
        chatId: number,
        markedChatUnread: true,
      };
    } catch (error) {
      throw new InternalServerErrorException({
        markedChatUnread: false,
        message: ['An error occurred while marked unread the chat. Open a calling.', error.toString()],
      });
    }
  }

  public async deleteMessage(del: DeleteMessage) {
    try {
      const response = await this.client.sendMessage(del.remoteJid, { delete: del });
      if (response) {
        const messageId = response.message?.protocolMessage?.key?.id;
        if (messageId) {
          const isLogicalDeleted = configService.get<Database>('DATABASE').DELETE_DATA.LOGICAL_MESSAGE_DELETE;
          let message = await this.prismaRepository.message.findFirst({
            where: {
              key: {
                path: ['id'],
                equals: messageId,
              },
            },
          });
          if (isLogicalDeleted) {
            if (!message) return response;
            const existingKey = typeof message?.key === 'object' && message.key !== null ? message.key : {};
            message = await this.prismaRepository.message.update({
              where: { id: message.id },
              data: {
                key: {
                  ...existingKey,
                  deleted: true,
                },
                status: 'DELETED',
              },
            });
          } else {
            await this.prismaRepository.message.deleteMany({
              where: {
                id: message.id,
              },
            });
          }
          this.sendDataWebhook(Events.MESSAGES_DELETE, {
            id: message.id,
            instanceId: message.instanceId,
            key: message.key,
            messageType: message.messageType,
            status: 'DELETED',
            source: message.source,
            messageTimestamp: message.messageTimestamp,
            pushName: message.pushName,
            participant: message.participant,
            message: message.message,
          });
        }
      }

      return response;
    } catch (error) {
      throw new InternalServerErrorException('Error while deleting message for everyone', error?.toString());
    }
  }

  public async getBase64FromMediaMessage(data: getBase64FromMediaMessageDto, getBuffer = false) {
    try {
      const m = data?.message;
      const convertToMp4 = data?.convertToMp4 ?? false;

      const msg = m?.message ? m : ((await this.getMessage(m.key, true)) as proto.IWebMessageInfo);

      if (!msg) {
        throw 'Message not found';
      }

      for (const subtype of MessageSubtype) {
        if (msg.message[subtype]) {
          msg.message = msg.message[subtype].message;
        }
      }

      let mediaMessage: any;
      let mediaType: string;

      for (const type of TypeMediaMessage) {
        mediaMessage = msg.message[type];
        if (mediaMessage) {
          mediaType = type;
          break;
        }
      }

      if (!mediaMessage) {
        throw 'The message is not of the media type';
      }

      if (typeof mediaMessage['mediaKey'] === 'object') {
        msg.message = JSON.parse(JSON.stringify(msg.message));
      }

      const buffer = await downloadMediaMessage(
        { key: msg?.key, message: msg?.message },
        'buffer',
        {},
        {
          logger: P({ level: 'error' }) as any,
          reuploadRequest: this.client.updateMediaMessage,
        },
      );
      const typeMessage = getContentType(msg.message);

      const ext = mimeTypes.extension(mediaMessage?.['mimetype']);
      const fileName = mediaMessage?.['fileName'] || `${msg.key.id}.${ext}` || `${v4()}.${ext}`;

      if (convertToMp4 && typeMessage === 'audioMessage') {
        try {
          const convert = await this.processAudioMp4(buffer.toString('base64'));

          if (Buffer.isBuffer(convert)) {
            const result = {
              mediaType,
              fileName,
              caption: mediaMessage['caption'],
              size: {
                fileLength: mediaMessage['fileLength'],
                height: mediaMessage['height'],
                width: mediaMessage['width'],
              },
              mimetype: 'audio/mp4',
              base64: convert.toString('base64'),
              buffer: getBuffer ? convert : null,
            };

            return result;
          }
        } catch (error) {
          this.logger.error('Error converting audio to mp4:');
          this.logger.error(error);
          throw new BadRequestException('Failed to convert audio to MP4');
        }
      }

      return {
        mediaType,
        fileName,
        caption: mediaMessage['caption'],
        size: {
          fileLength: mediaMessage['fileLength'],
          height: mediaMessage['height'],
          width: mediaMessage['width'],
        },
        mimetype: mediaMessage['mimetype'],
        base64: buffer.toString('base64'),
        buffer: getBuffer ? buffer : null,
      };
    } catch (error) {
      this.logger.error('Error processing media message:');
      this.logger.error(error);
      throw new BadRequestException(error.toString());
    }
  }

  public async fetchPrivacySettings() {
    const privacy = await this.client.fetchPrivacySettings();

    return {
      readreceipts: privacy.readreceipts,
      profile: privacy.profile,
      status: privacy.status,
      online: privacy.online,
      last: privacy.last,
      groupadd: privacy.groupadd,
    };
  }

  public async updatePrivacySettings(settings: PrivacySettingDto) {
    try {
      await this.client.updateReadReceiptsPrivacy(settings.readreceipts);
      await this.client.updateProfilePicturePrivacy(settings.profile);
      await this.client.updateStatusPrivacy(settings.status);
      await this.client.updateOnlinePrivacy(settings.online);
      await this.client.updateLastSeenPrivacy(settings.last);
      await this.client.updateGroupsAddPrivacy(settings.groupadd);

      this.reloadConnection();

      return {
        update: 'success',
        data: {
          readreceipts: settings.readreceipts,
          profile: settings.profile,
          status: settings.status,
          online: settings.online,
          last: settings.last,
          groupadd: settings.groupadd,
        },
      };
    } catch (error) {
      throw new InternalServerErrorException('Error updating privacy settings', error.toString());
    }
  }

  public async fetchBusinessProfile(number: string): Promise<NumberBusiness> {
    try {
      const jid = number ? createJid(number) : this.instance.wuid;

      const profile = await this.client.getBusinessProfile(jid);

      if (!profile) {
        const info = await this.whatsappNumber({ numbers: [jid] });

        return {
          isBusiness: false,
          message: 'Not is business profile',
          ...info?.shift(),
        };
      }

      return {
        isBusiness: true,
        ...profile,
      };
    } catch (error) {
      throw new InternalServerErrorException('Error updating profile name', error.toString());
    }
  }

  public async updateProfileName(name: string) {
    try {
      await this.client.updateProfileName(name);

      return { update: 'success' };
    } catch (error) {
      throw new InternalServerErrorException('Error updating profile name', error.toString());
    }
  }

  public async updateProfileStatus(status: string) {
    try {
      await this.client.updateProfileStatus(status);

      return { update: 'success' };
    } catch (error) {
      throw new InternalServerErrorException('Error updating profile status', error.toString());
    }
  }

  public async updateProfilePicture(picture: string) {
    try {
      let pic: WAMediaUpload;
      if (isURL(picture)) {
        const timestamp = new Date().getTime();
        const url = `${picture}?timestamp=${timestamp}`;

        let config: any = {
          responseType: 'arraybuffer',
        };

        if (this.localProxy?.enabled) {
          config = {
            ...config,
            httpsAgent: makeProxyAgent({
              host: this.localProxy.host,
              port: this.localProxy.port,
              protocol: this.localProxy.protocol,
              username: this.localProxy.username,
              password: this.localProxy.password,
            }),
          };
        }

        pic = (await axios.get(url, config)).data;
      } else if (isBase64(picture)) {
        pic = Buffer.from(picture, 'base64');
      } else {
        throw new BadRequestException('"profilePicture" must be a url or a base64');
      }

      await this.client.updateProfilePicture(this.instance.wuid, pic);

      this.reloadConnection();

      return { update: 'success' };
    } catch (error) {
      throw new InternalServerErrorException('Error updating profile picture', error.toString());
    }
  }

  public async removeProfilePicture() {
    try {
      await this.client.removeProfilePicture(this.instance.wuid);

      this.reloadConnection();

      return { update: 'success' };
    } catch (error) {
      throw new InternalServerErrorException('Error removing profile picture', error.toString());
    }
  }

  public async blockUser(data: BlockUserDto) {
    try {
      const { number } = data;

      const isWA = (await this.whatsappNumber({ numbers: [number] }))?.shift();

      if (!isWA.exists && !isJidGroup(isWA.jid) && !isWA.jid.includes('@broadcast')) {
        throw new BadRequestException(isWA);
      }

      const sender = isWA.jid;

      await this.client.updateBlockStatus(sender, data.status);

      return { block: 'success' };
    } catch (error) {
      throw new InternalServerErrorException('Error blocking user', error.toString());
    }
  }

  private async formatUpdateMessage(data: UpdateMessageDto) {
    try {
      const msg: any = await this.getMessage(data.key, true);

      if (msg?.messageType === 'conversation' || msg?.messageType === 'extendedTextMessage') {
        return {
          text: data.text,
        };
      }

      if (msg?.messageType === 'imageMessage') {
        return {
          image: msg?.message?.imageMessage,
          caption: data.text,
        };
      }

      if (msg?.messageType === 'videoMessage') {
        return {
          video: msg?.message?.videoMessage,
          caption: data.text,
        };
      }

      return null;
    } catch (error) {
      this.logger.error(error);
      throw new BadRequestException(error.toString());
    }
  }

  public async updateMessage(data: UpdateMessageDto) {
    const jid = createJid(data.number);

    const options = await this.formatUpdateMessage(data);

    if (!options) {
      this.logger.error('Message not compatible');
      throw new BadRequestException('Message not compatible');
    }

    try {
      return await this.client.sendMessage(jid, {
        ...(options as any),
        edit: data.key,
      });
    } catch (error) {
      this.logger.error(error);
      throw new BadRequestException(error.toString());
    }
  }

  public async fetchLabels(): Promise<LabelDto[]> {
    const labels = await this.prismaRepository.label.findMany({
      where: {
        instanceId: this.instanceId,
      },
    });

    return labels.map((label) => ({
      color: label.color,
      name: label.name,
      id: label.labelId,
      predefinedId: label.predefinedId,
    }));
  }

  public async handleLabel(data: HandleLabelDto) {
    const whatsappContact = await this.whatsappNumber({ numbers: [data.number] });
    if (whatsappContact.length === 0) {
      throw new NotFoundException('Number not found');
    }
    const contact = whatsappContact[0];
    if (!contact.exists) {
      throw new NotFoundException('Number is not on WhatsApp');
    }

    try {
      if (data.action === 'add') {
        await this.client.addChatLabel(contact.jid, data.labelId);
        await this.addLabel(data.labelId, this.instanceId, contact.jid);

        return { numberJid: contact.jid, labelId: data.labelId, add: true };
      }
      if (data.action === 'remove') {
        await this.client.removeChatLabel(contact.jid, data.labelId);
        await this.removeLabel(data.labelId, this.instanceId, contact.jid);

        return { numberJid: contact.jid, labelId: data.labelId, remove: true };
      }
    } catch (error) {
      throw new BadRequestException(`Unable to ${data.action} label to chat`, error.toString());
    }
  }

  // Group
  private async updateGroupMetadataCache(groupJid: string) {
    try {
      const meta = await this.client.groupMetadata(groupJid);

      const cacheConf = this.configService.get<CacheConf>('CACHE');

      if ((cacheConf?.REDIS?.ENABLED && cacheConf?.REDIS?.URI !== '') || cacheConf?.LOCAL?.ENABLED) {
        this.logger.verbose(`Updating cache for group: ${groupJid}`);
        await groupMetadataCache.set(groupJid, {
          timestamp: Date.now(),
          data: meta,
        });
      }

      return meta;
    } catch (error) {
      this.logger.error(error);
      return null;
    }
  }

  private getGroupMetadataCache = async (groupJid: string) => {
    if (!isJidGroup(groupJid)) return null;

    const cacheConf = this.configService.get<CacheConf>('CACHE');

    if ((cacheConf?.REDIS?.ENABLED && cacheConf?.REDIS?.URI !== '') || cacheConf?.LOCAL?.ENABLED) {
      if (await groupMetadataCache?.has(groupJid)) {
        console.log(`Cache request for group: ${groupJid}`);
        const meta = await groupMetadataCache.get(groupJid);

        if (Date.now() - meta.timestamp > 3600000) {
          await this.updateGroupMetadataCache(groupJid);
        }

        return meta.data;
      }

      console.log(`Cache request for group: ${groupJid} - not found`);
      return await this.updateGroupMetadataCache(groupJid);
    }

    return await this.findGroup({ groupJid }, 'inner');
  };

  public async createGroup(create: CreateGroupDto) {
    try {
      const participants = (await this.whatsappNumber({ numbers: create.participants }))
        .filter((participant) => participant.exists)
        .map((participant) => participant.jid);
      const { id } = await this.client.groupCreate(create.subject, participants);

      if (create?.description) {
        await this.client.groupUpdateDescription(id, create.description);
      }

      if (create?.promoteParticipants) {
        await this.updateGParticipant({
          groupJid: id,
          action: 'promote',
          participants: participants,
        });
      }

      const group = await this.client.groupMetadata(id);

      return group;
    } catch (error) {
      this.logger.error(error);
      throw new InternalServerErrorException('Error creating group', error.toString());
    }
  }

  public async updateGroupPicture(picture: GroupPictureDto) {
    try {
      let pic: WAMediaUpload;
      if (isURL(picture.image)) {
        const timestamp = new Date().getTime();
        const url = `${picture.image}?timestamp=${timestamp}`;

        let config: any = {
          responseType: 'arraybuffer',
        };

        if (this.localProxy?.enabled) {
          config = {
            ...config,
            httpsAgent: makeProxyAgent({
              host: this.localProxy.host,
              port: this.localProxy.port,
              protocol: this.localProxy.protocol,
              username: this.localProxy.username,
              password: this.localProxy.password,
            }),
          };
        }

        pic = (await axios.get(url, config)).data;
      } else if (isBase64(picture.image)) {
        pic = Buffer.from(picture.image, 'base64');
      } else {
        throw new BadRequestException('"profilePicture" must be a url or a base64');
      }
      await this.client.updateProfilePicture(picture.groupJid, pic);

      return { update: 'success' };
    } catch (error) {
      throw new InternalServerErrorException('Error update group picture', error.toString());
    }
  }

  public async updateGroupSubject(data: GroupSubjectDto) {
    try {
      await this.client.groupUpdateSubject(data.groupJid, data.subject);

      return { update: 'success' };
    } catch (error) {
      throw new InternalServerErrorException('Error updating group subject', error.toString());
    }
  }

  public async updateGroupDescription(data: GroupDescriptionDto) {
    try {
      await this.client.groupUpdateDescription(data.groupJid, data.description);

      return { update: 'success' };
    } catch (error) {
      throw new InternalServerErrorException('Error updating group description', error.toString());
    }
  }

  public async findGroup(id: GroupJid, reply: 'inner' | 'out' = 'out') {
    try {
      const group = await this.client.groupMetadata(id.groupJid);

      if (!group) {
        this.logger.error('Group not found');
        return null;
      }

      const picture = await this.profilePicture(group.id);

      return {
        id: group.id,
        subject: group.subject,
        subjectOwner: group.subjectOwner,
        subjectTime: group.subjectTime,
        pictureUrl: picture.profilePictureUrl,
        size: group.participants.length,
        creation: group.creation,
        owner: group.owner,
        desc: group.desc,
        descId: group.descId,
        restrict: group.restrict,
        announce: group.announce,
        participants: group.participants,
        isCommunity: group.isCommunity,
        isCommunityAnnounce: group.isCommunityAnnounce,
        linkedParent: group.linkedParent,
      };
    } catch (error) {
      if (reply === 'inner') {
        return;
      }
      throw new NotFoundException('Error fetching group', error.toString());
    }
  }

  public async fetchAllGroups(getParticipants: GetParticipant) {
    const fetch = Object.values(await this?.client?.groupFetchAllParticipating());

    let groups = [];
    for (const group of fetch) {
      const picture = await this.profilePicture(group.id);

      const result = {
        id: group.id,
        subject: group.subject,
        subjectOwner: group.subjectOwner,
        subjectTime: group.subjectTime,
        pictureUrl: picture?.profilePictureUrl,
        size: group.participants.length,
        creation: group.creation,
        owner: group.owner,
        desc: group.desc,
        descId: group.descId,
        restrict: group.restrict,
        announce: group.announce,
        isCommunity: group.isCommunity,
        isCommunityAnnounce: group.isCommunityAnnounce,
        linkedParent: group.linkedParent,
      };

      if (getParticipants.getParticipants == 'true') {
        result['participants'] = group.participants;
      }

      groups = [...groups, result];
    }

    return groups;
  }

  public async inviteCode(id: GroupJid) {
    try {
      const code = await this.client.groupInviteCode(id.groupJid);
      return { inviteUrl: `https://chat.whatsapp.com/${code}`, inviteCode: code };
    } catch (error) {
      throw new NotFoundException('No invite code', error.toString());
    }
  }

  public async inviteInfo(id: GroupInvite) {
    try {
      return await this.client.groupGetInviteInfo(id.inviteCode);
    } catch (error) {
      throw new NotFoundException('No invite info', id.inviteCode);
    }
  }

  public async sendInvite(id: GroupSendInvite) {
    try {
      const inviteCode = await this.inviteCode({ groupJid: id.groupJid });

      const inviteUrl = inviteCode.inviteUrl;

      const numbers = id.numbers.map((number) => createJid(number));
      const description = id.description ?? '';

      const msg = `${description}\n\n${inviteUrl}`;

      const message = {
        conversation: msg,
      };

      for await (const number of numbers) {
        await this.sendMessageWithTyping(number, message);
      }

      return { send: true, inviteUrl };
    } catch (error) {
      throw new NotFoundException('No send invite');
    }
  }

  public async acceptInviteCode(id: AcceptGroupInvite) {
    try {
      const groupJid = await this.client.groupAcceptInvite(id.inviteCode);
      return { accepted: true, groupJid: groupJid };
    } catch (error) {
      throw new NotFoundException('Accept invite error', error.toString());
    }
  }

  public async revokeInviteCode(id: GroupJid) {
    try {
      const inviteCode = await this.client.groupRevokeInvite(id.groupJid);
      return { revoked: true, inviteCode };
    } catch (error) {
      throw new NotFoundException('Revoke error', error.toString());
    }
  }

  public async findParticipants(id: GroupJid) {
    try {
      const participants = (await this.client.groupMetadata(id.groupJid)).participants;
      const contacts = await this.prismaRepository.contact.findMany({
        where: {
          instanceId: this.instanceId,
          remoteJid: {
            in: participants.map((p) => p.id),
          },
        },
      });
      const parsedParticipants = participants.map((participant) => {
        const contact = contacts.find((c) => c.remoteJid === participant.id);
        return {
          ...participant,
          name: participant.name ?? contact?.pushName,
          imgUrl: participant.imgUrl ?? contact?.profilePicUrl,
        };
      });

      const usersContacts = parsedParticipants.filter((c) => c.id.includes('@s.whatsapp'));
      if (usersContacts) {
        await saveOnWhatsappCache(usersContacts.map((c) => ({ remoteJid: c.id })));
      }

      return { participants: parsedParticipants };
    } catch (error) {
      console.error(error);
      throw new NotFoundException('No participants', error.toString());
    }
  }

  public async updateGParticipant(update: GroupUpdateParticipantDto) {
    try {
      const participants = update.participants.map((p) => createJid(p));
      const updateParticipants = await this.client.groupParticipantsUpdate(
        update.groupJid,
        participants,
        update.action,
      );
      return { updateParticipants: updateParticipants };
    } catch (error) {
      throw new BadRequestException('Error updating participants', error.toString());
    }
  }

  public async updateGSetting(update: GroupUpdateSettingDto) {
    try {
      const updateSetting = await this.client.groupSettingUpdate(update.groupJid, update.action);
      return { updateSetting: updateSetting };
    } catch (error) {
      throw new BadRequestException('Error updating setting', error.toString());
    }
  }

  public async toggleEphemeral(update: GroupToggleEphemeralDto) {
    try {
      await this.client.groupToggleEphemeral(update.groupJid, update.expiration);
      return { success: true };
    } catch (error) {
      throw new BadRequestException('Error updating setting', error.toString());
    }
  }

  public async leaveGroup(id: GroupJid) {
    try {
      await this.client.groupLeave(id.groupJid);
      return { groupJid: id.groupJid, leave: true };
    } catch (error) {
      throw new BadRequestException('Unable to leave the group', error.toString());
    }
  }

  public async templateMessage() {
    throw new Error('Method not available in the Baileys service');
  }

  private prepareMessage(message: proto.IWebMessageInfo): any {
    const contentType = getContentType(message.message);
    const contentMsg = message?.message[contentType] as any;

    const messageRaw = {
      key: message.key,
      pushName: message.pushName,
      status: status[message.status],
      message: { ...message.message },
      contextInfo: contentMsg?.contextInfo,
      messageType: contentType || 'unknown',
      messageTimestamp: message.messageTimestamp as number,
      instanceId: this.instanceId,
      source: getDevice(message.key.id),
    };

    if (!messageRaw.status && message.key.fromMe === false) {
      messageRaw.status = status[3]; // DELIVERED MESSAGE
    }

    if (messageRaw.message.extendedTextMessage) {
      messageRaw.messageType = 'conversation';
      messageRaw.message.conversation = messageRaw.message.extendedTextMessage.text;
      delete messageRaw.message.extendedTextMessage;
    }

    if (messageRaw.message.documentWithCaptionMessage) {
      messageRaw.messageType = 'documentMessage';
      messageRaw.message.documentMessage = messageRaw.message.documentWithCaptionMessage.message.documentMessage;
      delete messageRaw.message.documentWithCaptionMessage;
    }

    const quotedMessage = messageRaw?.contextInfo?.quotedMessage;
    if (quotedMessage) {
      if (quotedMessage.extendedTextMessage) {
        quotedMessage.conversation = quotedMessage.extendedTextMessage.text;
        delete quotedMessage.extendedTextMessage;
      }

      if (quotedMessage.documentWithCaptionMessage) {
        quotedMessage.documentMessage = quotedMessage.documentWithCaptionMessage.message.documentMessage;
        delete quotedMessage.documentWithCaptionMessage;
      }
    }

    return messageRaw;
  }

  private async syncChatwootLostMessages() {
    if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
      const chatwootConfig = await this.findChatwoot();
      const prepare = (message: any) => this.prepareMessage(message);
      this.chatwootService.syncLostMessages({ instanceName: this.instance.name }, chatwootConfig, prepare);

      const task = cron.schedule('0,30 * * * *', async () => {
        this.chatwootService.syncLostMessages({ instanceName: this.instance.name }, chatwootConfig, prepare);
      });
      task.start();
    }
  }

  private async updateMessagesReadedByTimestamp(remoteJid: string, timestamp?: number): Promise<number> {
    if (timestamp === undefined || timestamp === null) return 0;

    const result = await this.prismaRepository.message.updateMany({
      where: {
        AND: [
          { key: { path: ['remoteJid'], equals: remoteJid } },
          { key: { path: ['fromMe'], equals: false } },
          { messageTimestamp: { lte: timestamp } },
          {
            OR: [{ status: null }, { status: status[3] }],
          },
        ],
      },
      data: { status: status[4] },
    });

    if (result) {
      if (result.count > 0) {
        this.updateChatUnreadMessages(remoteJid);
      }

      return result.count;
    }

    return 0;
  }

  private async updateChatUnreadMessages(remoteJid: string): Promise<number> {
    const [chat, unreadMessages] = await Promise.all([
      this.prismaRepository.chat.findFirst({ where: { remoteJid } }),
      this.prismaRepository.message.count({
        where: {
          AND: [
            { key: { path: ['remoteJid'], equals: remoteJid } },
            { key: { path: ['fromMe'], equals: false } },
            { status: { equals: status[3] } },
          ],
        },
      }),
    ]);

    if (chat && chat.unreadMessages !== unreadMessages) {
      await this.prismaRepository.chat.update({
        where: { id: chat.id },
        data: { unreadMessages },
      });
    }

    return unreadMessages;
  }

  private async addLabel(labelId: string, instanceId: string, chatId: string) {
    const id = cuid();

    await this.prismaRepository.$executeRawUnsafe(
      `INSERT INTO "Chat" ("id", "instanceId", "remoteJid", "labels", "createdAt", "updatedAt")
       VALUES ($4, $2, $3, to_jsonb(ARRAY[$1]::text[]), NOW(), NOW()) ON CONFLICT ("instanceId", "remoteJid")
     DO
      UPDATE
          SET "labels" = (
          SELECT to_jsonb(array_agg(DISTINCT elem))
          FROM (
          SELECT jsonb_array_elements_text("Chat"."labels") AS elem
          UNION
          SELECT $1::text AS elem
          ) sub
          ),
          "updatedAt" = NOW();`,
      labelId,
      instanceId,
      chatId,
      id,
    );
  }

  private async removeLabel(labelId: string, instanceId: string, chatId: string) {
    const id = cuid();

    await this.prismaRepository.$executeRawUnsafe(
      `INSERT INTO "Chat" ("id", "instanceId", "remoteJid", "labels", "createdAt", "updatedAt")
       VALUES ($4, $2, $3, '[]'::jsonb, NOW(), NOW()) ON CONFLICT ("instanceId", "remoteJid")
     DO
      UPDATE
          SET "labels" = COALESCE (
          (
          SELECT jsonb_agg(elem)
          FROM jsonb_array_elements_text("Chat"."labels") AS elem
          WHERE elem <> $1
          ),
          '[]'::jsonb
          ),
          "updatedAt" = NOW();`,
      labelId,
      instanceId,
      chatId,
      id,
    );
  }

  public async baileysOnWhatsapp(jid: string) {
    const response = await this.client.onWhatsApp(jid);

    return response;
  }

  public async baileysProfilePictureUrl(jid: string, type: 'image' | 'preview', timeoutMs: number) {
    const response = await this.client.profilePictureUrl(jid, type, timeoutMs);

    return response;
  }

  public async baileysAssertSessions(jids: string[], force: boolean) {
    const response = await this.client.assertSessions(jids, force);

    return response;
  }

  public async baileysCreateParticipantNodes(jids: string[], message: proto.IMessage, extraAttrs: any) {
    const response = await this.client.createParticipantNodes(jids, message, extraAttrs);

    const convertedResponse = {
      ...response,
      nodes: response.nodes.map((node: any) => ({
        ...node,
        content: node.content?.map((c: any) => ({
          ...c,
          content: c.content instanceof Uint8Array ? Buffer.from(c.content).toString('base64') : c.content,
        })),
      })),
    };

    return convertedResponse;
  }

  public async baileysSendNode(stanza: any) {
    console.log('stanza', JSON.stringify(stanza));
    const response = await this.client.sendNode(stanza);

    return response;
  }

  public async baileysGetUSyncDevices(jids: string[], useCache: boolean, ignoreZeroDevices: boolean) {
    const response = await this.client.getUSyncDevices(jids, useCache, ignoreZeroDevices);

    return response;
  }

  public async baileysGenerateMessageTag() {
    const response = await this.client.generateMessageTag();

    return response;
  }

  public async baileysSignalRepositoryDecryptMessage(jid: string, type: 'pkmsg' | 'msg', ciphertext: string) {
    try {
      const ciphertextBuffer = Buffer.from(ciphertext, 'base64');

      const response = await this.client.signalRepository.decryptMessage({
        jid,
        type,
        ciphertext: ciphertextBuffer,
      });

      return response instanceof Uint8Array ? Buffer.from(response).toString('base64') : response;
    } catch (error) {
      this.logger.error('Error decrypting message:');
      this.logger.error(error);
      throw error;
    }
  }

  public async baileysGetAuthState() {
    const response = {
      me: this.client.authState.creds.me,
      account: this.client.authState.creds.account,
    };

    return response;
  }
}



================================================
FILE: src/api/integrations/channel/whatsapp/voiceCalls/transport.type.ts
================================================
import { BinaryNode, Contact, JidWithDevice, proto, WAConnectionState } from 'baileys';

export interface ServerToClientEvents {
  withAck: (d: string, callback: (e: number) => void) => void;
  onWhatsApp: onWhatsAppType;
  profilePictureUrl: ProfilePictureUrlType;
  assertSessions: AssertSessionsType;
  createParticipantNodes: CreateParticipantNodesType;
  getUSyncDevices: GetUSyncDevicesType;
  generateMessageTag: GenerateMessageTagType;
  sendNode: SendNodeType;
  'signalRepository:decryptMessage': SignalRepositoryDecryptMessageType;
}

export interface ClientToServerEvents {
  init: (
    me: Contact | undefined,
    account: proto.IADVSignedDeviceIdentity | undefined,
    status: WAConnectionState,
  ) => void;
  'CB:call': (packet: any) => void;
  'CB:ack,class:call': (packet: any) => void;
  'connection.update:status': (
    me: Contact | undefined,
    account: proto.IADVSignedDeviceIdentity | undefined,
    status: WAConnectionState,
  ) => void;
  'connection.update:qr': (qr: string) => void;
}

export type onWhatsAppType = (jid: string, callback: onWhatsAppCallback) => void;
export type onWhatsAppCallback = (
  response: {
    exists: boolean;
    jid: string;
  }[],
) => void;

export type ProfilePictureUrlType = (
  jid: string,
  type: 'image' | 'preview',
  timeoutMs: number | undefined,
  callback: ProfilePictureUrlCallback,
) => void;
export type ProfilePictureUrlCallback = (response: string | undefined) => void;

export type AssertSessionsType = (jids: string[], force: boolean, callback: AssertSessionsCallback) => void;
export type AssertSessionsCallback = (response: boolean) => void;

export type CreateParticipantNodesType = (
  jids: string[],
  message: any,
  extraAttrs: any,
  callback: CreateParticipantNodesCallback,
) => void;
export type CreateParticipantNodesCallback = (nodes: any, shouldIncludeDeviceIdentity: boolean) => void;

export type GetUSyncDevicesType = (
  jids: string[],
  useCache: boolean,
  ignoreZeroDevices: boolean,
  callback: GetUSyncDevicesTypeCallback,
) => void;
export type GetUSyncDevicesTypeCallback = (jids: JidWithDevice[]) => void;

export type GenerateMessageTagType = (callback: GenerateMessageTagTypeCallback) => void;
export type GenerateMessageTagTypeCallback = (response: string) => void;

export type SendNodeType = (stanza: BinaryNode, callback: SendNodeTypeCallback) => void;
export type SendNodeTypeCallback = (response: boolean) => void;

export type SignalRepositoryDecryptMessageType = (
  jid: string,
  type: 'pkmsg' | 'msg',
  ciphertext: Buffer,
  callback: SignalRepositoryDecryptMessageCallback,
) => void;
export type SignalRepositoryDecryptMessageCallback = (response: any) => void;



================================================
FILE: src/api/integrations/channel/whatsapp/voiceCalls/useVoiceCallsBaileys.ts
================================================
import { ConnectionState, WAConnectionState, WASocket } from 'baileys';
import { io, Socket } from 'socket.io-client';

import { ClientToServerEvents, ServerToClientEvents } from './transport.type';

let baileys_connection_state: WAConnectionState = 'close';

export const useVoiceCallsBaileys = async (
  wavoip_token: string,
  baileys_sock: WASocket,
  status?: WAConnectionState,
  logger?: boolean,
) => {
  baileys_connection_state = status ?? 'close';

  const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io('https://devices.wavoip.com/baileys', {
    transports: ['websocket'],
    path: `/${wavoip_token}/websocket`,
  });

  socket.on('connect', () => {
    if (logger) console.log('[*] - Wavoip connected', socket.id);

    socket.emit(
      'init',
      baileys_sock.authState.creds.me,
      baileys_sock.authState.creds.account,
      baileys_connection_state,
    );
  });

  socket.on('disconnect', () => {
    if (logger) console.log('[*] - Wavoip disconnect');
  });

  socket.on('connect_error', (error) => {
    if (socket.active) {
      if (logger)
        console.log(
          '[*] - Wavoip connection error temporary failure, the socket will automatically try to reconnect',
          error,
        );
    } else {
      if (logger) console.log('[*] - Wavoip connection error', error.message);
    }
  });

  socket.on('onWhatsApp', async (jid, callback) => {
    try {
      const response: any = await baileys_sock.onWhatsApp(jid);

      callback(response);

      if (logger) console.log('[*] Success on call onWhatsApp function', response, jid);
    } catch (error) {
      if (logger) console.error('[*] Error on call onWhatsApp function', error);
    }
  });

  socket.on('profilePictureUrl', async (jid, type, timeoutMs, callback) => {
    try {
      const response = await baileys_sock.profilePictureUrl(jid, type, timeoutMs);

      callback(response);

      if (logger) console.log('[*] Success on call profilePictureUrl function', response);
    } catch (error) {
      if (logger) console.error('[*] Error on call profilePictureUrl function', error);
    }
  });

  socket.on('assertSessions', async (jids, force, callback) => {
    try {
      const response = await baileys_sock.assertSessions(jids, force);

      callback(response);

      if (logger) console.log('[*] Success on call assertSessions function', response);
    } catch (error) {
      if (logger) console.error('[*] Error on call assertSessions function', error);
    }
  });

  socket.on('createParticipantNodes', async (jids, message, extraAttrs, callback) => {
    try {
      const response = await baileys_sock.createParticipantNodes(jids, message, extraAttrs);

      callback(response, true);

      if (logger) console.log('[*] Success on call createParticipantNodes function', response);
    } catch (error) {
      if (logger) console.error('[*] Error on call createParticipantNodes function', error);
    }
  });

  socket.on('getUSyncDevices', async (jids, useCache, ignoreZeroDevices, callback) => {
    try {
      const response = await baileys_sock.getUSyncDevices(jids, useCache, ignoreZeroDevices);

      callback(response);

      if (logger) console.log('[*] Success on call getUSyncDevices function', response);
    } catch (error) {
      if (logger) console.error('[*] Error on call getUSyncDevices function', error);
    }
  });

  socket.on('generateMessageTag', async (callback) => {
    try {
      const response = await baileys_sock.generateMessageTag();

      callback(response);

      if (logger) console.log('[*] Success on call generateMessageTag function', response);
    } catch (error) {
      if (logger) console.error('[*] Error on call generateMessageTag function', error);
    }
  });

  socket.on('sendNode', async (stanza, callback) => {
    try {
      console.log('sendNode', JSON.stringify(stanza));
      const response = await baileys_sock.sendNode(stanza);

      callback(true);

      if (logger) console.log('[*] Success on call sendNode function', response);
    } catch (error) {
      if (logger) console.error('[*] Error on call sendNode function', error);
    }
  });

  socket.on('signalRepository:decryptMessage', async (jid, type, ciphertext, callback) => {
    try {
      const response = await baileys_sock.signalRepository.decryptMessage({
        jid: jid,
        type: type,
        ciphertext: ciphertext,
      });

      callback(response);

      if (logger) console.log('[*] Success on call signalRepository:decryptMessage function', response);
    } catch (error) {
      if (logger) console.error('[*] Error on call signalRepository:decryptMessage function', error);
    }
  });

  // we only use this connection data to inform the webphone that the device is connected and creeds account to generate e2e whatsapp key for make call packets
  baileys_sock.ev.on('connection.update', (update: Partial<ConnectionState>) => {
    const { connection } = update;

    if (connection) {
      baileys_connection_state = connection;
      socket
        .timeout(1000)
        .emit(
          'connection.update:status',
          baileys_sock.authState.creds.me,
          baileys_sock.authState.creds.account,
          connection,
        );
    }

    if (update.qr) {
      socket.timeout(1000).emit('connection.update:qr', update.qr);
    }
  });

  baileys_sock.ws.on('CB:call', (packet) => {
    if (logger) console.log('[*] Signling received');
    socket.volatile.timeout(1000).emit('CB:call', packet);
  });

  baileys_sock.ws.on('CB:ack,class:call', (packet) => {
    if (logger) console.log('[*] Signling ack received');
    socket.volatile.timeout(1000).emit('CB:ack,class:call', packet);
  });

  return socket;
};



================================================
FILE: src/api/integrations/chatbot/chatbot.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import {
  difyController,
  evolutionBotController,
  flowiseController,
  openaiController,
  typebotController,
} from '@api/server.module';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Logger } from '@config/logger.config';
import { IntegrationSession } from '@prisma/client';
import { findBotByTrigger } from '@utils/findBotByTrigger';

export type EmitData = {
  instance: InstanceDto;
  remoteJid: string;
  msg: any;
  pushName?: string;
};

export interface ChatbotControllerInterface {
  integrationEnabled: boolean;
  botRepository: any;
  settingsRepository: any;
  sessionRepository: any;
  userMessageDebounce: { [key: string]: { message: string; timeoutId: NodeJS.Timeout } };

  createBot(instance: InstanceDto, data: any): Promise<any>;
  findBot(instance: InstanceDto): Promise<any>;
  fetchBot(instance: InstanceDto, botId: string): Promise<any>;
  updateBot(instance: InstanceDto, botId: string, data: any): Promise<any>;
  deleteBot(instance: InstanceDto, botId: string): Promise<any>;

  settings(instance: InstanceDto, data: any): Promise<any>;
  fetchSettings(instance: InstanceDto): Promise<any>;

  changeStatus(instance: InstanceDto, botId: string, status: string): Promise<any>;
  fetchSessions(instance: InstanceDto, botId: string, remoteJid?: string): Promise<any>;
  ignoreJid(instance: InstanceDto, data: any): Promise<any>;

  emit(data: EmitData): Promise<void>;
}

export class ChatbotController {
  public prismaRepository: PrismaRepository;
  public waMonitor: WAMonitoringService;

  public readonly logger = new Logger('ChatbotController');

  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    this.prisma = prismaRepository;
    this.monitor = waMonitor;
  }

  public set prisma(prisma: PrismaRepository) {
    this.prismaRepository = prisma;
  }

  public get prisma() {
    return this.prismaRepository;
  }

  public set monitor(waMonitor: WAMonitoringService) {
    this.waMonitor = waMonitor;
  }

  public get monitor() {
    return this.waMonitor;
  }

  public async emit({
    instance,
    remoteJid,
    msg,
    pushName,
    isIntegration = false,
  }: {
    instance: InstanceDto;
    remoteJid: string;
    msg: any;
    pushName?: string;
    isIntegration?: boolean;
  }): Promise<void> {
    const emitData = {
      instance,
      remoteJid,
      msg,
      pushName,
      isIntegration,
    };
    await evolutionBotController.emit(emitData);

    await typebotController.emit(emitData);

    await openaiController.emit(emitData);

    await difyController.emit(emitData);

    await flowiseController.emit(emitData);
  }

  public processDebounce(
    userMessageDebounce: any,
    content: string,
    remoteJid: string,
    debounceTime: number,
    callback: any,
  ) {
    if (userMessageDebounce[remoteJid]) {
      userMessageDebounce[remoteJid].message += `\n${content}`;
      this.logger.log('message debounced: ' + userMessageDebounce[remoteJid].message);
      clearTimeout(userMessageDebounce[remoteJid].timeoutId);
    } else {
      userMessageDebounce[remoteJid] = {
        message: content,
        timeoutId: null,
      };
    }

    userMessageDebounce[remoteJid].timeoutId = setTimeout(() => {
      const myQuestion = userMessageDebounce[remoteJid].message;
      this.logger.log('Debounce complete. Processing message: ' + myQuestion);

      delete userMessageDebounce[remoteJid];
      callback(myQuestion);
    }, debounceTime * 1000);
  }

  public checkIgnoreJids(ignoreJids: any, remoteJid: string) {
    if (ignoreJids && ignoreJids.length > 0) {
      let ignoreGroups = false;
      let ignoreContacts = false;

      if (ignoreJids.includes('@g.us')) {
        ignoreGroups = true;
      }

      if (ignoreJids.includes('@s.whatsapp.net')) {
        ignoreContacts = true;
      }

      if (ignoreGroups && remoteJid.endsWith('@g.us')) {
        this.logger.warn('Ignoring message from group: ' + remoteJid);
        return true;
      }

      if (ignoreContacts && remoteJid.endsWith('@s.whatsapp.net')) {
        this.logger.warn('Ignoring message from contact: ' + remoteJid);
        return true;
      }

      if (ignoreJids.includes(remoteJid)) {
        this.logger.warn('Ignoring message from jid: ' + remoteJid);
        return true;
      }

      return false;
    }

    return false;
  }

  public async getSession(remoteJid: string, instance: InstanceDto) {
    let session = await this.prismaRepository.integrationSession.findFirst({
      where: {
        remoteJid: remoteJid,
        instanceId: instance.instanceId,
      },
      orderBy: { createdAt: 'desc' },
    });

    if (session) {
      if (session.status !== 'closed' && !session.botId) {
        this.logger.warn('Session is already opened in another integration');
        return;
      } else if (!session.botId) {
        session = null;
      }
    }

    return session;
  }

  public async findBotTrigger(
    botRepository: any,
    content: string,
    instance: InstanceDto,
    session?: IntegrationSession,
  ) {
    let findBot: null;

    if (!session) {
      findBot = await findBotByTrigger(botRepository, content, instance.instanceId);

      if (!findBot) {
        return;
      }
    } else {
      findBot = await botRepository.findFirst({
        where: {
          id: session.botId,
        },
      });
    }

    return findBot;
  }
}



================================================
FILE: src/api/integrations/chatbot/chatbot.router.ts
================================================
import { ChatwootRouter } from '@api/integrations/chatbot/chatwoot/routes/chatwoot.router';
import { DifyRouter } from '@api/integrations/chatbot/dify/routes/dify.router';
import { OpenaiRouter } from '@api/integrations/chatbot/openai/routes/openai.router';
import { TypebotRouter } from '@api/integrations/chatbot/typebot/routes/typebot.router';
import { Router } from 'express';

import { EvolutionBotRouter } from './evolutionBot/routes/evolutionBot.router';
import { FlowiseRouter } from './flowise/routes/flowise.router';

export class ChatbotRouter {
  public readonly router: Router;

  constructor(...guards: any[]) {
    this.router = Router();

    this.router.use('/evolutionBot', new EvolutionBotRouter(...guards).router);
    this.router.use('/chatwoot', new ChatwootRouter(...guards).router);
    this.router.use('/typebot', new TypebotRouter(...guards).router);
    this.router.use('/openai', new OpenaiRouter(...guards).router);
    this.router.use('/dify', new DifyRouter(...guards).router);
    this.router.use('/flowise', new FlowiseRouter(...guards).router);
  }
}



================================================
FILE: src/api/integrations/chatbot/chatbot.schema.ts
================================================
export * from '@api/integrations/chatbot/chatwoot/validate/chatwoot.schema';
export * from '@api/integrations/chatbot/dify/validate/dify.schema';
export * from '@api/integrations/chatbot/evolutionBot/validate/evolutionBot.schema';
export * from '@api/integrations/chatbot/flowise/validate/flowise.schema';
export * from '@api/integrations/chatbot/openai/validate/openai.schema';
export * from '@api/integrations/chatbot/typebot/validate/typebot.schema';



================================================
FILE: src/api/integrations/chatbot/chatwoot/controllers/chatwoot.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { ChatwootDto } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
import { ChatwootService } from '@api/integrations/chatbot/chatwoot/services/chatwoot.service';
import { PrismaRepository } from '@api/repository/repository.service';
import { waMonitor } from '@api/server.module';
import { CacheService } from '@api/services/cache.service';
import { CacheEngine } from '@cache/cacheengine';
import { Chatwoot, ConfigService, HttpServer } from '@config/env.config';
import { BadRequestException } from '@exceptions';
import { isURL } from 'class-validator';

export class ChatwootController {
  constructor(
    private readonly chatwootService: ChatwootService,
    private readonly configService: ConfigService,
    private readonly prismaRepository: PrismaRepository,
  ) {}

  public async createChatwoot(instance: InstanceDto, data: ChatwootDto) {
    if (!this.configService.get<Chatwoot>('CHATWOOT').ENABLED) throw new BadRequestException('Chatwoot is disabled');

    if (data?.enabled) {
      if (!isURL(data.url, { require_tld: false })) {
        throw new BadRequestException('url is not valid');
      }

      if (!data.accountId) {
        throw new BadRequestException('accountId is required');
      }

      if (!data.token) {
        throw new BadRequestException('token is required');
      }

      if (data.signMsg !== true && data.signMsg !== false) {
        throw new BadRequestException('signMsg is required');
      }
      if (data.signMsg === false) data.signDelimiter = null;
    }

    if (!data.nameInbox || data.nameInbox === '') {
      data.nameInbox = instance.instanceName;
    }

    const result = await this.chatwootService.create(instance, data);

    const urlServer = this.configService.get<HttpServer>('SERVER').URL;

    const response = {
      ...result,
      webhook_url: `${urlServer}/chatwoot/webhook/${encodeURIComponent(instance.instanceName)}`,
    };

    return response;
  }

  public async findChatwoot(instance: InstanceDto): Promise<ChatwootDto & { webhook_url: string }> {
    if (!this.configService.get<Chatwoot>('CHATWOOT').ENABLED) throw new BadRequestException('Chatwoot is disabled');

    const result = await this.chatwootService.find(instance);

    const urlServer = this.configService.get<HttpServer>('SERVER').URL;

    if (Object.keys(result || {}).length === 0) {
      return {
        enabled: false,
        url: '',
        accountId: '',
        token: '',
        signMsg: false,
        nameInbox: '',
        webhook_url: '',
      };
    }

    const response = {
      ...result,
      webhook_url: `${urlServer}/chatwoot/webhook/${encodeURIComponent(instance.instanceName)}`,
    };

    return response;
  }

  public async receiveWebhook(instance: InstanceDto, data: any) {
    if (!this.configService.get<Chatwoot>('CHATWOOT').ENABLED) throw new BadRequestException('Chatwoot is disabled');

    const chatwootCache = new CacheService(new CacheEngine(this.configService, ChatwootService.name).getEngine());
    const chatwootService = new ChatwootService(waMonitor, this.configService, this.prismaRepository, chatwootCache);

    return chatwootService.receiveWebhook(instance, data);
  }
}



================================================
FILE: src/api/integrations/chatbot/chatwoot/dto/chatwoot.dto.ts
================================================
import { Constructor } from '@api/integrations/integration.dto';

export class ChatwootDto {
  enabled?: boolean;
  accountId?: string;
  token?: string;
  url?: string;
  nameInbox?: string;
  signMsg?: boolean;
  signDelimiter?: string;
  number?: string;
  reopenConversation?: boolean;
  conversationPending?: boolean;
  mergeBrazilContacts?: boolean;
  importContacts?: boolean;
  importMessages?: boolean;
  daysLimitImportMessages?: number;
  autoCreate?: boolean;
  organization?: string;
  logo?: string;
  ignoreJids?: string[];
}

export function ChatwootInstanceMixin<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    chatwootAccountId?: string;
    chatwootToken?: string;
    chatwootUrl?: string;
    chatwootSignMsg?: boolean;
    chatwootReopenConversation?: boolean;
    chatwootConversationPending?: boolean;
    chatwootMergeBrazilContacts?: boolean;
    chatwootImportContacts?: boolean;
    chatwootImportMessages?: boolean;
    chatwootDaysLimitImportMessages?: number;
    chatwootNameInbox?: string;
    chatwootOrganization?: string;
    chatwootLogo?: string;
    chatwootAutoCreate?: boolean;
  };
}



================================================
FILE: src/api/integrations/chatbot/chatwoot/libs/postgres.client.ts
================================================
import { Chatwoot, configService } from '@config/env.config';
import { Logger } from '@config/logger.config';
import postgresql from 'pg';

const { Pool } = postgresql;

class Postgres {
  private logger = new Logger('Postgres');
  private pool;
  private connected = false;

  getConnection(connectionString: string) {
    if (this.connected) {
      return this.pool;
    } else {
      this.pool = new Pool({
        connectionString,
        ssl: {
          rejectUnauthorized: false,
        },
      });

      this.pool.on('error', () => {
        this.logger.error('postgres disconnected');
        this.connected = false;
      });

      try {
        this.connected = true;
      } catch (e) {
        this.connected = false;
        this.logger.error('postgres connect exception caught: ' + e);
        return null;
      }

      return this.pool;
    }
  }

  getChatwootConnection() {
    const uri = configService.get<Chatwoot>('CHATWOOT').IMPORT.DATABASE.CONNECTION.URI;

    return this.getConnection(uri);
  }
}

export const postgresClient = new Postgres();



================================================
FILE: src/api/integrations/chatbot/chatwoot/routes/chatwoot.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { ChatwootDto } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
import { HttpStatus } from '@api/routes/index.router';
import { chatwootController } from '@api/server.module';
import { chatwootSchema, instanceSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

export class ChatwootRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('set'), ...guards, async (req, res) => {
        const response = await this.dataValidate<ChatwootDto>({
          request: req,
          schema: chatwootSchema,
          ClassRef: ChatwootDto,
          execute: (instance, data) => chatwootController.createChatwoot(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => chatwootController.findChatwoot(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('webhook'), async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance, data) => chatwootController.receiveWebhook(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/chatbot/chatwoot/services/chatwoot.service.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { Options, Quoted, SendAudioDto, SendMediaDto, SendTextDto } from '@api/dto/sendMessage.dto';
import { ChatwootDto } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
import { postgresClient } from '@api/integrations/chatbot/chatwoot/libs/postgres.client';
import { chatwootImport } from '@api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper';
import { PrismaRepository } from '@api/repository/repository.service';
import { CacheService } from '@api/services/cache.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Events } from '@api/types/wa.types';
import { Chatwoot, ConfigService, Database, HttpServer } from '@config/env.config';
import { Logger } from '@config/logger.config';
import ChatwootClient, {
  ChatwootAPIConfig,
  contact,
  contact_inboxes,
  conversation,
  conversation_show,
  generic_id,
  inbox,
} from '@figuro/chatwoot-sdk';
import { request as chatwootRequest } from '@figuro/chatwoot-sdk/dist/core/request';
import { Chatwoot as ChatwootModel, Contact as ContactModel, Message as MessageModel } from '@prisma/client';
import i18next from '@utils/i18n';
import { sendTelemetry } from '@utils/sendTelemetry';
import axios from 'axios';
import { proto } from 'baileys';
import dayjs from 'dayjs';
import FormData from 'form-data';
import Jimp from 'jimp';
import Long from 'long';
import mimeTypes from 'mime-types';
import path from 'path';
import { Readable } from 'stream';

interface ChatwootMessage {
  messageId?: number;
  inboxId?: number;
  conversationId?: number;
  contactInboxSourceId?: string;
  isRead?: boolean;
}

export class ChatwootService {
  private readonly logger = new Logger('ChatwootService');

  private provider: any;

  constructor(
    private readonly waMonitor: WAMonitoringService,
    private readonly configService: ConfigService,
    private readonly prismaRepository: PrismaRepository,
    private readonly cache: CacheService,
  ) {}

  private pgClient = postgresClient.getChatwootConnection();

  private async getProvider(instance: InstanceDto): Promise<ChatwootModel | null> {
    const cacheKey = `${instance.instanceName}:getProvider`;
    if (await this.cache.has(cacheKey)) {
      const provider = (await this.cache.get(cacheKey)) as ChatwootModel;

      return provider;
    }

    const provider = await this.waMonitor.waInstances[instance.instanceName]?.findChatwoot();

    if (!provider) {
      this.logger.warn('provider not found');
      return null;
    }

    this.cache.set(cacheKey, provider);

    return provider;
  }

  private async clientCw(instance: InstanceDto) {
    const provider = await this.getProvider(instance);

    if (!provider) {
      this.logger.error('provider not found');
      return null;
    }

    this.provider = provider;

    const client = new ChatwootClient({
      config: this.getClientCwConfig(),
    });

    return client;
  }

  public getClientCwConfig(): ChatwootAPIConfig & { nameInbox: string; mergeBrazilContacts: boolean } {
    return {
      basePath: this.provider.url,
      with_credentials: true,
      credentials: 'include',
      token: this.provider.token,
      nameInbox: this.provider.nameInbox,
      mergeBrazilContacts: this.provider.mergeBrazilContacts,
    };
  }

  public getCache() {
    return this.cache;
  }

  public async create(instance: InstanceDto, data: ChatwootDto) {
    await this.waMonitor.waInstances[instance.instanceName].setChatwoot(data);

    if (data.autoCreate) {
      this.logger.log('Auto create chatwoot instance');
      const urlServer = this.configService.get<HttpServer>('SERVER').URL;

      await this.initInstanceChatwoot(
        instance,
        data.nameInbox ?? instance.instanceName.split('-cwId-')[0],
        `${urlServer}/chatwoot/webhook/${encodeURIComponent(instance.instanceName)}`,
        true,
        data.number,
        data.organization,
        data.logo,
      );
    }
    return data;
  }

  public async find(instance: InstanceDto): Promise<ChatwootDto> {
    try {
      return await this.waMonitor.waInstances[instance.instanceName].findChatwoot();
    } catch (error) {
      this.logger.error('chatwoot not found');
      return { enabled: null, url: '' };
    }
  }

  public async getContact(instance: InstanceDto, id: number) {
    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    if (!id) {
      this.logger.warn('id is required');
      return null;
    }

    const contact = await client.contact.getContactable({
      accountId: this.provider.accountId,
      id,
    });

    if (!contact) {
      this.logger.warn('contact not found');
      return null;
    }

    return contact;
  }

  public async initInstanceChatwoot(
    instance: InstanceDto,
    inboxName: string,
    webhookUrl: string,
    qrcode: boolean,
    number: string,
    organization?: string,
    logo?: string,
  ) {
    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    const findInbox: any = await client.inboxes.list({
      accountId: this.provider.accountId,
    });

    const checkDuplicate = findInbox.payload.map((inbox) => inbox.name).includes(inboxName);

    let inboxId: number;

    this.logger.log('Creating chatwoot inbox');
    if (!checkDuplicate) {
      const data = {
        type: 'api',
        webhook_url: webhookUrl,
      };

      const inbox = await client.inboxes.create({
        accountId: this.provider.accountId,
        data: {
          name: inboxName,
          channel: data as any,
        },
      });

      if (!inbox) {
        this.logger.warn('inbox not found');
        return null;
      }

      inboxId = inbox.id;
    } else {
      const inbox = findInbox.payload.find((inbox) => inbox.name === inboxName);

      if (!inbox) {
        this.logger.warn('inbox not found');
        return null;
      }

      inboxId = inbox.id;
    }
    this.logger.log(`Inbox created - inboxId: ${inboxId}`);

    if (!this.configService.get<Chatwoot>('CHATWOOT').BOT_CONTACT) {
      this.logger.log('Chatwoot bot contact is disabled');

      return true;
    }

    this.logger.log('Creating chatwoot bot contact');
    const contact =
      (await this.findContact(instance, '123456')) ||
      ((await this.createContact(
        instance,
        '123456',
        inboxId,
        false,
        organization ? organization : 'EvolutionAPI',
        logo ? logo : 'https://evolution-api.com/files/evolution-api-favicon.png',
      )) as any);

    if (!contact) {
      this.logger.warn('contact not found');
      return null;
    }

    const contactId = contact.id || contact.payload.contact.id;
    this.logger.log(`Contact created - contactId: ${contactId}`);

    if (qrcode) {
      this.logger.log('QR code enabled');
      const data = {
        contact_id: contactId.toString(),
        inbox_id: inboxId.toString(),
      };

      const conversation = await client.conversations.create({
        accountId: this.provider.accountId,
        data,
      });

      if (!conversation) {
        this.logger.warn('conversation not found');
        return null;
      }

      let contentMsg = 'init';

      if (number) {
        contentMsg = `init:${number}`;
      }

      const message = await client.messages.create({
        accountId: this.provider.accountId,
        conversationId: conversation.id,
        data: {
          content: contentMsg,
          message_type: 'outgoing',
        },
      });

      if (!message) {
        this.logger.warn('conversation not found');
        return null;
      }
      this.logger.log('Init message sent');
    }

    return true;
  }

  public async createContact(
    instance: InstanceDto,
    phoneNumber: string,
    inboxId: number,
    isGroup: boolean,
    name?: string,
    avatar_url?: string,
    jid?: string,
  ) {
    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    let data: any = {};
    if (!isGroup) {
      data = {
        inbox_id: inboxId,
        name: name || phoneNumber,
        identifier: jid,
        avatar_url: avatar_url,
      };

      if ((jid && jid.includes('@')) || !jid) {
        data['phone_number'] = `+${phoneNumber}`;
      }
    } else {
      data = {
        inbox_id: inboxId,
        name: name || phoneNumber,
        identifier: phoneNumber,
        avatar_url: avatar_url,
      };
    }

    const contact = await client.contacts.create({
      accountId: this.provider.accountId,
      data,
    });

    if (!contact) {
      this.logger.warn('contact not found');
      return null;
    }

    const findContact = await this.findContact(instance, phoneNumber);

    const contactId = findContact?.id;

    await this.addLabelToContact(this.provider.nameInbox, contactId);

    return contact;
  }

  public async updateContact(instance: InstanceDto, id: number, data: any) {
    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    if (!id) {
      this.logger.warn('id is required');
      return null;
    }

    try {
      const contact = await client.contacts.update({
        accountId: this.provider.accountId,
        id,
        data,
      });

      return contact;
    } catch (error) {
      return null;
    }
  }

  public async addLabelToContact(nameInbox: string, contactId: number) {
    try {
      const uri = this.configService.get<Chatwoot>('CHATWOOT').IMPORT.DATABASE.CONNECTION.URI;

      if (!uri) return false;

      const sqlTags = `SELECT id, taggings_count FROM tags WHERE name = $1 LIMIT 1`;
      const tagData = (await this.pgClient.query(sqlTags, [nameInbox]))?.rows[0];
      let tagId = tagData?.id;
      const taggingsCount = tagData?.taggings_count || 0;

      const sqlTag = `INSERT INTO tags (name, taggings_count) 
                      VALUES ($1, $2) 
                      ON CONFLICT (name) 
                      DO UPDATE SET taggings_count = tags.taggings_count + 1 
                      RETURNING id`;

      tagId = (await this.pgClient.query(sqlTag, [nameInbox, taggingsCount + 1]))?.rows[0]?.id;

      const sqlCheckTagging = `SELECT 1 FROM taggings 
                               WHERE tag_id = $1 AND taggable_type = 'Contact' AND taggable_id = $2 AND context = 'labels' LIMIT 1`;

      const taggingExists = (await this.pgClient.query(sqlCheckTagging, [tagId, contactId]))?.rowCount > 0;

      if (!taggingExists) {
        const sqlInsertLabel = `INSERT INTO taggings (tag_id, taggable_type, taggable_id, context, created_at) 
                                VALUES ($1, 'Contact', $2, 'labels', NOW())`;

        await this.pgClient.query(sqlInsertLabel, [tagId, contactId]);
      }

      return true;
    } catch (error) {
      return false;
    }
  }

  public async findContact(instance: InstanceDto, phoneNumber: string) {
    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    let query: any;
    const isGroup = phoneNumber.includes('@g.us');

    if (!isGroup) {
      query = `+${phoneNumber}`;
    } else {
      query = phoneNumber;
    }

    let contact: any;

    if (isGroup) {
      contact = await client.contacts.search({
        accountId: this.provider.accountId,
        q: query,
      });
    } else {
      contact = await chatwootRequest(this.getClientCwConfig(), {
        method: 'POST',
        url: `/api/v1/accounts/${this.provider.accountId}/contacts/filter`,
        body: {
          payload: this.getFilterPayload(query),
        },
      });
    }

    if (!contact && contact?.payload?.length === 0) {
      this.logger.warn('contact not found');
      return null;
    }

    if (!isGroup) {
      return contact.payload.length > 1 ? this.findContactInContactList(contact.payload, query) : contact.payload[0];
    } else {
      return contact.payload.find((contact) => contact.identifier === query);
    }
  }

  private async mergeBrazilianContacts(contacts: any[]) {
    try {
      const contact = await chatwootRequest(this.getClientCwConfig(), {
        method: 'POST',
        url: `/api/v1/accounts/${this.provider.accountId}/actions/contact_merge`,
        body: {
          base_contact_id: contacts.find((contact) => contact.phone_number.length === 14)?.id,
          mergee_contact_id: contacts.find((contact) => contact.phone_number.length === 13)?.id,
        },
      });

      return contact;
    } catch {
      this.logger.error('Error merging contacts');
      return null;
    }
  }

  private findContactInContactList(contacts: any[], query: string) {
    const phoneNumbers = this.getNumbers(query);
    const searchableFields = this.getSearchableFields();

    // eslint-disable-next-line prettier/prettier
    if (contacts.length === 2 && this.getClientCwConfig().mergeBrazilContacts && query.startsWith('+55')) {
      const contact = this.mergeBrazilianContacts(contacts);
      if (contact) {
        return contact;
      }
    }

    const phone = phoneNumbers.reduce(
      (savedNumber, number) => (number.length > savedNumber.length ? number : savedNumber),
      '',
    );

    const contact_with9 = contacts.find((contact) => contact.phone_number === phone);
    if (contact_with9) {
      return contact_with9;
    }

    for (const contact of contacts) {
      for (const field of searchableFields) {
        if (contact[field] && phoneNumbers.includes(contact[field])) {
          return contact;
        }
      }
    }

    return null;
  }

  private getNumbers(query: string) {
    const numbers = [];
    numbers.push(query);

    if (query.startsWith('+55') && query.length === 14) {
      const withoutNine = query.slice(0, 5) + query.slice(6);
      numbers.push(withoutNine);
    } else if (query.startsWith('+55') && query.length === 13) {
      const withNine = query.slice(0, 5) + '9' + query.slice(5);
      numbers.push(withNine);
    }

    return numbers;
  }

  private getSearchableFields() {
    return ['phone_number'];
  }

  private getFilterPayload(query: string) {
    const filterPayload = [];

    const numbers = this.getNumbers(query);
    const fieldsToSearch = this.getSearchableFields();

    fieldsToSearch.forEach((field, index1) => {
      numbers.forEach((number, index2) => {
        const queryOperator = fieldsToSearch.length - 1 === index1 && numbers.length - 1 === index2 ? null : 'OR';
        filterPayload.push({
          attribute_key: field,
          filter_operator: 'equal_to',
          values: [number.replace('+', '')],
          query_operator: queryOperator,
        });
      });
    });

    return filterPayload;
  }

  public async createConversation(instance: InstanceDto, body: any) {
    try {
      this.logger.verbose('--- Start createConversation ---');
      this.logger.verbose(`Instance: ${JSON.stringify(instance)}`);

      const client = await this.clientCw(instance);

      if (!client) {
        this.logger.warn(`Client not found for instance: ${JSON.stringify(instance)}`);
        return null;
      }

      const cacheKey = `${instance.instanceName}:createConversation-${body.key.remoteJid}`;
      this.logger.verbose(`Cache key: ${cacheKey}`);

      if (await this.cache.has(cacheKey)) {
        this.logger.verbose(`Cache hit for key: ${cacheKey}`);
        const conversationId = (await this.cache.get(cacheKey)) as number;
        this.logger.verbose(`Cached conversation ID: ${conversationId}`);
        let conversationExists: conversation | boolean;
        try {
          conversationExists = await client.conversations.get({
            accountId: this.provider.accountId,
            conversationId: conversationId,
          });
          this.logger.verbose(`Conversation exists: ${JSON.stringify(conversationExists)}`);
        } catch (error) {
          this.logger.error(`Error getting conversation: ${error}`);
          conversationExists = false;
        }
        if (!conversationExists) {
          this.logger.verbose('Conversation does not exist, re-calling createConversation');
          this.cache.delete(cacheKey);
          return await this.createConversation(instance, body);
        }

        return conversationId;
      }

      const isGroup = body.key.remoteJid.includes('@g.us');
      this.logger.verbose(`Is group: ${isGroup}`);

      const chatId = isGroup ? body.key.remoteJid : body.key.remoteJid.split('@')[0];
      this.logger.verbose(`Chat ID: ${chatId}`);

      let nameContact: string;

      nameContact = !body.key.fromMe ? body.pushName : chatId;
      this.logger.verbose(`Name contact: ${nameContact}`);

      const filterInbox = await this.getInbox(instance);

      if (!filterInbox) {
        this.logger.warn(`Inbox not found for instance: ${JSON.stringify(instance)}`);
        return null;
      }

      if (isGroup) {
        this.logger.verbose('Processing group conversation');
        const group = await this.waMonitor.waInstances[instance.instanceName].client.groupMetadata(chatId);
        this.logger.verbose(`Group metadata: ${JSON.stringify(group)}`);

        nameContact = `${group.subject} (GROUP)`;

        const picture_url = await this.waMonitor.waInstances[instance.instanceName].profilePicture(
          body.key.participant.split('@')[0],
        );
        this.logger.verbose(`Participant profile picture URL: ${JSON.stringify(picture_url)}`);

        const findParticipant = await this.findContact(instance, body.key.participant.split('@')[0]);
        this.logger.verbose(`Found participant: ${JSON.stringify(findParticipant)}`);

        if (findParticipant) {
          if (!findParticipant.name || findParticipant.name === chatId) {
            await this.updateContact(instance, findParticipant.id, {
              name: body.pushName,
              avatar_url: picture_url.profilePictureUrl || null,
            });
          }
        } else {
          await this.createContact(
            instance,
            body.key.participant.split('@')[0],
            filterInbox.id,
            false,
            body.pushName,
            picture_url.profilePictureUrl || null,
            body.key.participant,
          );
        }
      }

      const picture_url = await this.waMonitor.waInstances[instance.instanceName].profilePicture(chatId);
      this.logger.verbose(`Contact profile picture URL: ${JSON.stringify(picture_url)}`);

      let contact = await this.findContact(instance, chatId);
      this.logger.verbose(`Found contact: ${JSON.stringify(contact)}`);

      if (contact) {
        if (!body.key.fromMe) {
          const waProfilePictureFile =
            picture_url?.profilePictureUrl?.split('#')[0].split('?')[0].split('/').pop() || '';
          const chatwootProfilePictureFile = contact?.thumbnail?.split('#')[0].split('?')[0].split('/').pop() || '';
          const pictureNeedsUpdate = waProfilePictureFile !== chatwootProfilePictureFile;
          const nameNeedsUpdate =
            !contact.name ||
            contact.name === chatId ||
            (`+${chatId}`.startsWith('+55')
              ? this.getNumbers(`+${chatId}`).some(
                  (v) => contact.name === v || contact.name === v.substring(3) || contact.name === v.substring(1),
                )
              : false);

          this.logger.verbose(`Picture needs update: ${pictureNeedsUpdate}`);
          this.logger.verbose(`Name needs update: ${nameNeedsUpdate}`);

          if (pictureNeedsUpdate || nameNeedsUpdate) {
            contact = await this.updateContact(instance, contact.id, {
              ...(nameNeedsUpdate && { name: nameContact }),
              ...(waProfilePictureFile === '' && { avatar: null }),
              ...(pictureNeedsUpdate && { avatar_url: picture_url?.profilePictureUrl }),
            });
          }
        }
      } else {
        const jid = body.key.remoteJid;
        contact = await this.createContact(
          instance,
          chatId,
          filterInbox.id,
          isGroup,
          nameContact,
          picture_url.profilePictureUrl || null,
          jid,
        );
      }

      if (!contact) {
        this.logger.warn('Contact not created or found');
        return null;
      }

      const contactId = contact?.payload?.id || contact?.payload?.contact?.id || contact?.id;
      this.logger.verbose(`Contact ID: ${contactId}`);

      const contactConversations = (await client.contacts.listConversations({
        accountId: this.provider.accountId,
        id: contactId,
      })) as any;
      this.logger.verbose(`Contact conversations: ${JSON.stringify(contactConversations)}`);

      if (!contactConversations || !contactConversations.payload) {
        this.logger.error('No conversations found or payload is undefined');
        return null;
      }

      if (contactConversations.payload.length) {
        let conversation: any;
        if (this.provider.reopenConversation) {
          conversation = contactConversations.payload.find((conversation) => conversation.inbox_id == filterInbox.id);
          this.logger.verbose(`Found conversation in reopenConversation mode: ${JSON.stringify(conversation)}`);

          if (this.provider.conversationPending && conversation.status !== 'open') {
            if (conversation) {
              await client.conversations.toggleStatus({
                accountId: this.provider.accountId,
                conversationId: conversation.id,
                data: {
                  status: 'pending',
                },
              });
            }
          }
        } else {
          conversation = contactConversations.payload.find(
            (conversation) => conversation.status !== 'resolved' && conversation.inbox_id == filterInbox.id,
          );
          this.logger.verbose(`Found conversation: ${JSON.stringify(conversation)}`);
        }

        if (conversation) {
          this.logger.verbose(`Returning existing conversation ID: ${conversation.id}`);
          this.cache.set(cacheKey, conversation.id);
          return conversation.id;
        }
      }

      const data = {
        contact_id: contactId.toString(),
        inbox_id: filterInbox.id.toString(),
      };

      if (this.provider.conversationPending) {
        data['status'] = 'pending';
      }

      const conversation = await client.conversations.create({
        accountId: this.provider.accountId,
        data,
      });

      if (!conversation) {
        this.logger.warn('Conversation not created or found');
        return null;
      }

      this.logger.verbose(`New conversation created with ID: ${conversation.id}`);
      this.cache.set(cacheKey, conversation.id);
      return conversation.id;
    } catch (error) {
      this.logger.error(`Error in createConversation: ${error}`);
    }
  }

  public async getInbox(instance: InstanceDto): Promise<inbox | null> {
    const cacheKey = `${instance.instanceName}:getInbox`;
    if (await this.cache.has(cacheKey)) {
      return (await this.cache.get(cacheKey)) as inbox;
    }

    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    const inbox = (await client.inboxes.list({
      accountId: this.provider.accountId,
    })) as any;

    if (!inbox) {
      this.logger.warn('inbox not found');
      return null;
    }

    const findByName = inbox.payload.find((inbox) => inbox.name === this.getClientCwConfig().nameInbox);

    if (!findByName) {
      this.logger.warn('inbox not found');
      return null;
    }

    this.cache.set(cacheKey, findByName);
    return findByName;
  }

  public async createMessage(
    instance: InstanceDto,
    conversationId: number,
    content: string,
    messageType: 'incoming' | 'outgoing' | undefined,
    privateMessage?: boolean,
    attachments?: {
      content: unknown;
      encoding: string;
      filename: string;
    }[],
    messageBody?: any,
    sourceId?: string,
    quotedMsg?: MessageModel,
  ) {
    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    const replyToIds = await this.getReplyToIds(messageBody, instance);

    const sourceReplyId = quotedMsg?.chatwootMessageId || null;

    const message = await client.messages.create({
      accountId: this.provider.accountId,
      conversationId: conversationId,
      data: {
        content: content,
        message_type: messageType,
        attachments: attachments,
        private: privateMessage || false,
        source_id: sourceId,
        content_attributes: {
          ...replyToIds,
        },
        source_reply_id: sourceReplyId ? sourceReplyId.toString() : null,
      },
    });

    if (!message) {
      this.logger.warn('message not found');
      return null;
    }

    return message;
  }

  public async getOpenConversationByContact(
    instance: InstanceDto,
    inbox: inbox,
    contact: generic_id & contact,
  ): Promise<conversation> {
    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    const conversations = (await client.contacts.listConversations({
      accountId: this.provider.accountId,
      id: contact.id,
    })) as any;

    return (
      conversations.payload.find(
        (conversation) => conversation.inbox_id === inbox.id && conversation.status === 'open',
      ) || undefined
    );
  }

  public async createBotMessage(
    instance: InstanceDto,
    content: string,
    messageType: 'incoming' | 'outgoing' | undefined,
    attachments?: {
      content: unknown;
      encoding: string;
      filename: string;
    }[],
  ) {
    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    const contact = await this.findContact(instance, '123456');

    if (!contact) {
      this.logger.warn('contact not found');
      return null;
    }

    const filterInbox = await this.getInbox(instance);

    if (!filterInbox) {
      this.logger.warn('inbox not found');
      return null;
    }

    const conversation = await this.getOpenConversationByContact(instance, filterInbox, contact);

    if (!conversation) {
      this.logger.warn('conversation not found');
      return;
    }

    const message = await client.messages.create({
      accountId: this.provider.accountId,
      conversationId: conversation.id,
      data: {
        content: content,
        message_type: messageType,
        attachments: attachments,
      },
    });

    if (!message) {
      this.logger.warn('message not found');
      return null;
    }

    return message;
  }

  private async sendData(
    conversationId: number,
    fileStream: Readable,
    fileName: string,
    messageType: 'incoming' | 'outgoing' | undefined,
    content?: string,
    instance?: InstanceDto,
    messageBody?: any,
    sourceId?: string,
    quotedMsg?: MessageModel,
  ) {
    if (sourceId && this.isImportHistoryAvailable()) {
      const messageAlreadySaved = await chatwootImport.getExistingSourceIds([sourceId]);
      if (messageAlreadySaved) {
        if (messageAlreadySaved.size > 0) {
          this.logger.warn('Message already saved on chatwoot');
          return null;
        }
      }
    }
    const data = new FormData();

    if (content) {
      data.append('content', content);
    }

    data.append('message_type', messageType);

    data.append('attachments[]', fileStream, { filename: fileName });

    const sourceReplyId = quotedMsg?.chatwootMessageId || null;

    if (messageBody && instance) {
      const replyToIds = await this.getReplyToIds(messageBody, instance);

      if (replyToIds.in_reply_to || replyToIds.in_reply_to_external_id) {
        const content = JSON.stringify({
          ...replyToIds,
        });
        data.append('content_attributes', content);
      }
    }

    if (sourceReplyId) {
      data.append('source_reply_id', sourceReplyId.toString());
    }

    if (sourceId) {
      data.append('source_id', sourceId);
    }

    const config = {
      method: 'post',
      maxBodyLength: Infinity,
      url: `${this.provider.url}/api/v1/accounts/${this.provider.accountId}/conversations/${conversationId}/messages`,
      headers: {
        api_access_token: this.provider.token,
        ...data.getHeaders(),
      },
      data: data,
    };

    try {
      const { data } = await axios.request(config);

      return data;
    } catch (error) {
      this.logger.error(error);
    }
  }

  public async createBotQr(
    instance: InstanceDto,
    content: string,
    messageType: 'incoming' | 'outgoing' | undefined,
    fileStream?: Readable,
    fileName?: string,
  ) {
    const client = await this.clientCw(instance);

    if (!client) {
      this.logger.warn('client not found');
      return null;
    }

    if (!this.configService.get<Chatwoot>('CHATWOOT').BOT_CONTACT) {
      this.logger.log('Chatwoot bot contact is disabled');

      return true;
    }

    const contact = await this.findContact(instance, '123456');

    if (!contact) {
      this.logger.warn('contact not found');
      return null;
    }

    const filterInbox = await this.getInbox(instance);

    if (!filterInbox) {
      this.logger.warn('inbox not found');
      return null;
    }

    const conversation = await this.getOpenConversationByContact(instance, filterInbox, contact);

    if (!conversation) {
      this.logger.warn('conversation not found');
      return;
    }

    const data = new FormData();

    if (content) {
      data.append('content', content);
    }

    data.append('message_type', messageType);

    if (fileStream && fileName) {
      data.append('attachments[]', fileStream, { filename: fileName });
    }

    const config = {
      method: 'post',
      maxBodyLength: Infinity,
      url: `${this.provider.url}/api/v1/accounts/${this.provider.accountId}/conversations/${conversation.id}/messages`,
      headers: {
        api_access_token: this.provider.token,
        ...data.getHeaders(),
      },
      data: data,
    };

    try {
      const { data } = await axios.request(config);

      return data;
    } catch (error) {
      this.logger.error(error);
    }
  }

  public async sendAttachment(waInstance: any, number: string, media: any, caption?: string, options?: Options) {
    try {
      const parsedMedia = path.parse(decodeURIComponent(media));
      let mimeType = mimeTypes.lookup(parsedMedia?.ext) || '';
      let fileName = parsedMedia?.name + parsedMedia?.ext;

      if (!mimeType) {
        const parts = media.split('/');
        fileName = decodeURIComponent(parts[parts.length - 1]);

        const response = await axios.get(media, {
          responseType: 'arraybuffer',
        });
        mimeType = response.headers['content-type'];
      }

      let type = 'document';

      switch (mimeType.split('/')[0]) {
        case 'image':
          type = 'image';
          break;
        case 'video':
          type = 'video';
          break;
        case 'audio':
          type = 'audio';
          break;
        default:
          type = 'document';
          break;
      }

      if (type === 'audio') {
        const data: SendAudioDto = {
          number: number,
          audio: media,
          delay: 1200,
          quoted: options?.quoted,
        };

        sendTelemetry('/message/sendWhatsAppAudio');

        const messageSent = await waInstance?.audioWhatsapp(data, true);

        return messageSent;
      }

      if (type === 'image' && parsedMedia && parsedMedia?.ext === '.gif') {
        type = 'document';
      }

      const data: SendMediaDto = {
        number: number,
        mediatype: type as any,
        fileName: fileName,
        media: media,
        delay: 1200,
        quoted: options?.quoted,
      };

      sendTelemetry('/message/sendMedia');

      if (caption) {
        data.caption = caption;
      }

      const messageSent = await waInstance?.mediaMessage(data, null, true);

      return messageSent;
    } catch (error) {
      this.logger.error(error);
    }
  }

  public async onSendMessageError(instance: InstanceDto, conversation: number, error?: any) {
    this.logger.verbose(`onSendMessageError ${JSON.stringify(error)}`);

    const client = await this.clientCw(instance);

    if (!client) {
      return;
    }

    if (error && error?.status === 400 && error?.message[0]?.exists === false) {
      client.messages.create({
        accountId: this.provider.accountId,
        conversationId: conversation,
        data: {
          content: `${i18next.t('cw.message.numbernotinwhatsapp')}`,
          message_type: 'outgoing',
          private: true,
        },
      });

      return;
    }

    client.messages.create({
      accountId: this.provider.accountId,
      conversationId: conversation,
      data: {
        content: i18next.t('cw.message.notsent', {
          error: error ? `_${error.toString()}_` : '',
        }),
        message_type: 'outgoing',
        private: true,
      },
    });
  }

  public async receiveWebhook(instance: InstanceDto, body: any) {
    try {
      await new Promise((resolve) => setTimeout(resolve, 500));

      const client = await this.clientCw(instance);

      if (!client) {
        this.logger.warn('client not found');
        return null;
      }

      if (
        this.provider.reopenConversation === false &&
        body.event === 'conversation_status_changed' &&
        body.status === 'resolved' &&
        body.meta?.sender?.identifier
      ) {
        const keyToDelete = `${instance.instanceName}:createConversation-${body.meta.sender.identifier}`;
        this.cache.delete(keyToDelete);
      }

      if (
        !body?.conversation ||
        body.private ||
        (body.event === 'message_updated' && !body.content_attributes?.deleted)
      ) {
        return { message: 'bot' };
      }

      const chatId =
        body.conversation.meta.sender?.identifier || body.conversation.meta.sender?.phone_number.replace('+', '');
      // Chatwoot to Whatsapp
      const messageReceived = body.content
        ? body.content
            .replaceAll(/(?<!\*)\*((?!\s)([^\n*]+?)(?<!\s))\*(?!\*)/g, '_$1_') // Substitui * por _
            .replaceAll(/\*{2}((?!\s)([^\n*]+?)(?<!\s))\*{2}/g, '*$1*') // Substitui ** por *
            .replaceAll(/~{2}((?!\s)([^\n*]+?)(?<!\s))~{2}/g, '~$1~') // Substitui ~~ por ~
            .replaceAll(/(?<!`)`((?!\s)([^`*]+?)(?<!\s))`(?!`)/g, '```$1```') // Substitui ` por ```
        : body.content;

      const senderName = body?.conversation?.messages[0]?.sender?.available_name || body?.sender?.name;
      const waInstance = this.waMonitor.waInstances[instance.instanceName];

      if (body.event === 'message_updated' && body.content_attributes?.deleted) {
        const message = await this.prismaRepository.message.findFirst({
          where: {
            chatwootMessageId: body.id,
            instanceId: instance.instanceId,
          },
        });

        if (message) {
          const key = message.key as {
            id: string;
            remoteJid: string;
            fromMe: boolean;
            participant: string;
          };

          await waInstance?.client.sendMessage(key.remoteJid, { delete: key });

          await this.prismaRepository.message.deleteMany({
            where: {
              instanceId: instance.instanceId,
              chatwootMessageId: body.id,
            },
          });
        }
        return { message: 'bot' };
      }

      const cwBotContact = this.configService.get<Chatwoot>('CHATWOOT').BOT_CONTACT;

      if (chatId === '123456' && body.message_type === 'outgoing') {
        const command = messageReceived.replace('/', '');

        if (cwBotContact && (command.includes('init') || command.includes('iniciar'))) {
          const state = waInstance?.connectionStatus?.state;

          if (state !== 'open') {
            const number = command.split(':')[1];
            await waInstance.connectToWhatsapp(number);
          } else {
            await this.createBotMessage(
              instance,
              i18next.t('cw.inbox.alreadyConnected', {
                inboxName: body.inbox.name,
              }),
              'incoming',
            );
          }
        }

        if (command === 'clearcache') {
          waInstance.clearCacheChatwoot();
          await this.createBotMessage(
            instance,
            i18next.t('cw.inbox.clearCache', {
              inboxName: body.inbox.name,
            }),
            'incoming',
          );
        }

        if (command === 'status') {
          const state = waInstance?.connectionStatus?.state;

          if (!state) {
            await this.createBotMessage(
              instance,
              i18next.t('cw.inbox.notFound', {
                inboxName: body.inbox.name,
              }),
              'incoming',
            );
          }

          if (state) {
            await this.createBotMessage(
              instance,
              i18next.t('cw.inbox.status', {
                inboxName: body.inbox.name,
                state: state,
              }),
              'incoming',
            );
          }
        }

        if (cwBotContact && (command === 'disconnect' || command === 'desconectar')) {
          const msgLogout = i18next.t('cw.inbox.disconnect', {
            inboxName: body.inbox.name,
          });

          await this.createBotMessage(instance, msgLogout, 'incoming');

          await waInstance?.client?.logout('Log out instance: ' + instance.instanceName);
          await waInstance?.client?.ws?.close();
        }
      }

      if (body.message_type === 'outgoing' && body?.conversation?.messages?.length && chatId !== '123456') {
        if (body?.conversation?.messages[0]?.source_id?.substring(0, 5) === 'WAID:') {
          return { message: 'bot' };
        }

        if (!waInstance && body.conversation?.id) {
          this.onSendMessageError(instance, body.conversation?.id, 'Instance not found');
          return { message: 'bot' };
        }

        let formatText: string;
        if (senderName === null || senderName === undefined) {
          formatText = messageReceived;
        } else {
          const formattedDelimiter = this.provider.signDelimiter
            ? this.provider.signDelimiter.replaceAll('\\n', '\n')
            : '\n';
          const textToConcat = this.provider.signMsg ? [`*${senderName}:*`] : [];
          textToConcat.push(messageReceived);

          formatText = textToConcat.join(formattedDelimiter);
        }

        for (const message of body.conversation.messages) {
          if (message.attachments && message.attachments.length > 0) {
            for (const attachment of message.attachments) {
              if (!messageReceived) {
                formatText = null;
              }

              const options: Options = {
                quoted: await this.getQuotedMessage(body, instance),
              };

              const messageSent = await this.sendAttachment(
                waInstance,
                chatId,
                attachment.data_url,
                formatText,
                options,
              );
              if (!messageSent && body.conversation?.id) {
                this.onSendMessageError(instance, body.conversation?.id);
              }

              await this.updateChatwootMessageId(
                {
                  ...messageSent,
                  owner: instance.instanceName,
                },
                {
                  messageId: body.id,
                  inboxId: body.inbox?.id,
                  conversationId: body.conversation?.id,
                  contactInboxSourceId: body.conversation?.contact_inbox?.source_id,
                },
                instance,
              );
            }
          } else {
            const data: SendTextDto = {
              number: chatId,
              text: formatText,
              delay: 1200,
              quoted: await this.getQuotedMessage(body, instance),
            };

            sendTelemetry('/message/sendText');

            let messageSent: any;
            try {
              messageSent = await waInstance?.textMessage(data, true);
              if (!messageSent) {
                throw new Error('Message not sent');
              }

              if (Long.isLong(messageSent?.messageTimestamp)) {
                messageSent.messageTimestamp = messageSent.messageTimestamp?.toNumber();
              }

              await this.updateChatwootMessageId(
                {
                  ...messageSent,
                  instanceId: instance.instanceId,
                },
                {
                  messageId: body.id,
                  inboxId: body.inbox?.id,
                  conversationId: body.conversation?.id,
                  contactInboxSourceId: body.conversation?.contact_inbox?.source_id,
                },
                instance,
              );
            } catch (error) {
              if (!messageSent && body.conversation?.id) {
                this.onSendMessageError(instance, body.conversation?.id, error);
              }
              throw error;
            }
          }
        }

        const chatwootRead = this.configService.get<Chatwoot>('CHATWOOT').MESSAGE_READ;
        if (chatwootRead) {
          const lastMessage = await this.prismaRepository.message.findFirst({
            where: {
              key: {
                path: ['fromMe'],
                equals: false,
              },
              instanceId: instance.instanceId,
            },
          });
          if (lastMessage && !lastMessage.chatwootIsRead) {
            const key = lastMessage.key as {
              id: string;
              fromMe: boolean;
              remoteJid: string;
              participant?: string;
            };

            waInstance?.markMessageAsRead({
              readMessages: [
                {
                  id: key.id,
                  fromMe: key.fromMe,
                  remoteJid: key.remoteJid,
                },
              ],
            });
            const updateMessage = {
              chatwootMessageId: lastMessage.chatwootMessageId,
              chatwootConversationId: lastMessage.chatwootConversationId,
              chatwootInboxId: lastMessage.chatwootInboxId,
              chatwootContactInboxSourceId: lastMessage.chatwootContactInboxSourceId,
              chatwootIsRead: true,
            };

            await this.prismaRepository.message.updateMany({
              where: {
                instanceId: instance.instanceId,
                key: {
                  path: ['id'],
                  equals: key.id,
                },
              },
              data: updateMessage,
            });
          }
        }
      }

      if (body.message_type === 'template' && body.event === 'message_created') {
        const data: SendTextDto = {
          number: chatId,
          text: body.content.replace(/\\\r\n|\\\n|\n/g, '\n'),
          delay: 1200,
        };

        sendTelemetry('/message/sendText');

        await waInstance?.textMessage(data);
      }

      return { message: 'bot' };
    } catch (error) {
      this.logger.error(error);

      return { message: 'bot' };
    }
  }

  private async updateChatwootMessageId(
    message: MessageModel,
    chatwootMessageIds: ChatwootMessage,
    instance: InstanceDto,
  ) {
    const key = message.key as {
      id: string;
      fromMe: boolean;
      remoteJid: string;
      participant?: string;
    };

    if (!chatwootMessageIds.messageId || !key?.id) {
      return;
    }

    await this.prismaRepository.message.updateMany({
      where: {
        key: {
          path: ['id'],
          equals: key.id,
        },
        instanceId: instance.instanceId,
      },
      data: {
        chatwootMessageId: chatwootMessageIds.messageId,
        chatwootConversationId: chatwootMessageIds.conversationId,
        chatwootInboxId: chatwootMessageIds.inboxId,
        chatwootContactInboxSourceId: chatwootMessageIds.contactInboxSourceId,
        chatwootIsRead: chatwootMessageIds.isRead,
      },
    });

    if (this.isImportHistoryAvailable()) {
      chatwootImport.updateMessageSourceID(chatwootMessageIds.messageId, key.id);
    }
  }

  private async getMessageByKeyId(instance: InstanceDto, keyId: string): Promise<MessageModel> {
    const messages = await this.prismaRepository.message.findFirst({
      where: {
        key: {
          path: ['id'],
          equals: keyId,
        },
        instanceId: instance.instanceId,
      },
    });

    return messages || null;
  }

  private async getReplyToIds(
    msg: any,
    instance: InstanceDto,
  ): Promise<{ in_reply_to: string; in_reply_to_external_id: string }> {
    let inReplyTo = null;
    let inReplyToExternalId = null;

    if (msg) {
      inReplyToExternalId = msg.message?.extendedTextMessage?.contextInfo?.stanzaId ?? msg.contextInfo?.stanzaId;
      if (inReplyToExternalId) {
        const message = await this.getMessageByKeyId(instance, inReplyToExternalId);
        if (message?.chatwootMessageId) {
          inReplyTo = message.chatwootMessageId;
        }
      }
    }

    return {
      in_reply_to: inReplyTo,
      in_reply_to_external_id: inReplyToExternalId,
    };
  }

  private async getQuotedMessage(msg: any, instance: InstanceDto): Promise<Quoted> {
    if (msg?.content_attributes?.in_reply_to) {
      const message = await this.prismaRepository.message.findFirst({
        where: {
          chatwootMessageId: msg?.content_attributes?.in_reply_to,
          instanceId: instance.instanceId,
        },
      });

      const key = message?.key as {
        id: string;
        fromMe: boolean;
        remoteJid: string;
        participant?: string;
      };

      if (message && key?.id) {
        return {
          key: message.key as proto.IMessageKey,
          message: message.message as proto.IMessage,
        };
      }
    }

    return null;
  }

  private isMediaMessage(message: any) {
    const media = [
      'imageMessage',
      'documentMessage',
      'documentWithCaptionMessage',
      'audioMessage',
      'videoMessage',
      'stickerMessage',
      'viewOnceMessageV2',
    ];

    const messageKeys = Object.keys(message);

    const result = messageKeys.some((key) => media.includes(key));

    return result;
  }

  private getAdsMessage(msg: any) {
    interface AdsMessage {
      title: string;
      body: string;
      thumbnailUrl: string;
      sourceUrl: string;
    }

    const adsMessage: AdsMessage | undefined = {
      title: msg.extendedTextMessage?.contextInfo?.externalAdReply?.title || msg.contextInfo?.externalAdReply?.title,
      body: msg.extendedTextMessage?.contextInfo?.externalAdReply?.body || msg.contextInfo?.externalAdReply?.body,
      thumbnailUrl:
        msg.extendedTextMessage?.contextInfo?.externalAdReply?.thumbnailUrl ||
        msg.contextInfo?.externalAdReply?.thumbnailUrl,
      sourceUrl:
        msg.extendedTextMessage?.contextInfo?.externalAdReply?.sourceUrl || msg.contextInfo?.externalAdReply?.sourceUrl,
    };

    return adsMessage;
  }

  private getReactionMessage(msg: any) {
    interface ReactionMessage {
      key: {
        id: string;
        fromMe: boolean;
        remoteJid: string;
        participant?: string;
      };
      text: string;
    }
    const reactionMessage: ReactionMessage | undefined = msg?.reactionMessage;

    return reactionMessage;
  }

  private getTypeMessage(msg: any) {
    const types = {
      conversation: msg.conversation,
      imageMessage: msg.imageMessage?.caption,
      videoMessage: msg.videoMessage?.caption,
      extendedTextMessage: msg.extendedTextMessage?.text,
      messageContextInfo: msg.messageContextInfo?.stanzaId,
      stickerMessage: undefined,
      documentMessage: msg.documentMessage?.caption,
      documentWithCaptionMessage: msg.documentWithCaptionMessage?.message?.documentMessage?.caption,
      audioMessage: msg.audioMessage?.caption,
      contactMessage: msg.contactMessage?.vcard,
      contactsArrayMessage: msg.contactsArrayMessage,
      locationMessage: msg.locationMessage,
      liveLocationMessage: msg.liveLocationMessage,
      listMessage: msg.listMessage,
      listResponseMessage: msg.listResponseMessage,
      viewOnceMessageV2:
        msg?.message?.viewOnceMessageV2?.message?.imageMessage?.url ||
        msg?.message?.viewOnceMessageV2?.message?.videoMessage?.url ||
        msg?.message?.viewOnceMessageV2?.message?.audioMessage?.url,
    };

    return types;
  }

  private getMessageContent(types: any) {
    const typeKey = Object.keys(types).find((key) => types[key] !== undefined);

    let result = typeKey ? types[typeKey] : undefined;

    // Remove externalAdReplyBody| in Chatwoot (Already Have)
    if (result && typeof result === 'string' && result.includes('externalAdReplyBody|')) {
      result = result.split('externalAdReplyBody|').filter(Boolean).join('');
    }

    if (typeKey === 'locationMessage' || typeKey === 'liveLocationMessage') {
      const latitude = result.degreesLatitude;
      const longitude = result.degreesLongitude;

      const locationName = result?.name;
      const locationAddress = result?.address;

      const formattedLocation =
        `*${i18next.t('cw.locationMessage.location')}:*\n\n` +
        `_${i18next.t('cw.locationMessage.latitude')}:_ ${latitude} \n` +
        `_${i18next.t('cw.locationMessage.longitude')}:_ ${longitude} \n` +
        (locationName ? `_${i18next.t('cw.locationMessage.locationName')}:_ ${locationName}\n` : '') +
        (locationAddress ? `_${i18next.t('cw.locationMessage.locationAddress')}:_ ${locationAddress} \n` : '') +
        `_${i18next.t('cw.locationMessage.locationUrl')}:_ ` +
        `https://www.google.com/maps/search/?api=1&query=${latitude},${longitude}`;

      return formattedLocation;
    }

    if (typeKey === 'contactMessage') {
      const vCardData = result.split('\n');
      const contactInfo = {};

      vCardData.forEach((line) => {
        const [key, value] = line.split(':');
        if (key && value) {
          contactInfo[key] = value;
        }
      });

      let formattedContact =
        `*${i18next.t('cw.contactMessage.contact')}:*\n\n` +
        `_${i18next.t('cw.contactMessage.name')}:_ ${contactInfo['FN']}`;

      let numberCount = 1;
      Object.keys(contactInfo).forEach((key) => {
        if (key.startsWith('item') && key.includes('TEL')) {
          const phoneNumber = contactInfo[key];
          formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
          numberCount++;
        } else if (key.includes('TEL')) {
          const phoneNumber = contactInfo[key];
          formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
          numberCount++;
        }
      });

      return formattedContact;
    }

    if (typeKey === 'contactsArrayMessage') {
      const formattedContacts = result.contacts.map((contact) => {
        const vCardData = contact.vcard.split('\n');
        const contactInfo = {};

        vCardData.forEach((line) => {
          const [key, value] = line.split(':');
          if (key && value) {
            contactInfo[key] = value;
          }
        });

        let formattedContact = `*${i18next.t('cw.contactMessage.contact')}:*\n\n_${i18next.t(
          'cw.contactMessage.name',
        )}:_ ${contact.displayName}`;

        let numberCount = 1;
        Object.keys(contactInfo).forEach((key) => {
          if (key.startsWith('item') && key.includes('TEL')) {
            const phoneNumber = contactInfo[key];
            formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
            numberCount++;
          } else if (key.includes('TEL')) {
            const phoneNumber = contactInfo[key];
            formattedContact += `\n_${i18next.t('cw.contactMessage.number')} (${numberCount}):_ ${phoneNumber}`;
            numberCount++;
          }
        });

        return formattedContact;
      });

      const formattedContactsArray = formattedContacts.join('\n\n');

      return formattedContactsArray;
    }

    if (typeKey === 'listMessage') {
      const listTitle = result?.title || 'Unknown';
      const listDescription = result?.description || 'Unknown';
      const listFooter = result?.footerText || 'Unknown';

      let formattedList =
        '*List Menu:*\n\n' +
        '_Title_: ' +
        listTitle +
        '\n' +
        '_Description_: ' +
        listDescription +
        '\n' +
        '_Footer_: ' +
        listFooter;

      if (result.sections && result.sections.length > 0) {
        result.sections.forEach((section, sectionIndex) => {
          formattedList += '\n\n*Section ' + (sectionIndex + 1) + ':* ' + section.title || 'Unknown\n';

          if (section.rows && section.rows.length > 0) {
            section.rows.forEach((row, rowIndex) => {
              formattedList += '\n*Line ' + (rowIndex + 1) + ':*\n';
              formattedList += '_▪️ Title:_ ' + (row.title || 'Unknown') + '\n';
              formattedList += '_▪️ Description:_ ' + (row.description || 'Unknown') + '\n';
              formattedList += '_▪️ ID:_ ' + (row.rowId || 'Unknown') + '\n';
            });
          } else {
            formattedList += '\nNo lines found in this section.\n';
          }
        });
      } else {
        formattedList += '\nNo sections found.\n';
      }

      return formattedList;
    }

    if (typeKey === 'listResponseMessage') {
      const responseTitle = result?.title || 'Unknown';
      const responseDescription = result?.description || 'Unknown';
      const responseRowId = result?.singleSelectReply?.selectedRowId || 'Unknown';

      const formattedResponseList =
        '*List Response:*\n\n' +
        '_Title_: ' +
        responseTitle +
        '\n' +
        '_Description_: ' +
        responseDescription +
        '\n' +
        '_ID_: ' +
        responseRowId;
      return formattedResponseList;
    }

    return result;
  }

  public getConversationMessage(msg: any) {
    const types = this.getTypeMessage(msg);

    const messageContent = this.getMessageContent(types);

    return messageContent;
  }

  public async eventWhatsapp(event: string, instance: InstanceDto, body: any) {
    try {
      const waInstance = this.waMonitor.waInstances[instance.instanceName];

      if (!waInstance) {
        this.logger.warn('wa instance not found');
        return null;
      }

      const client = await this.clientCw(instance);

      if (!client) {
        this.logger.warn('client not found');
        return null;
      }

      if (this.provider?.ignoreJids && this.provider?.ignoreJids.length > 0) {
        const ignoreJids: any = this.provider?.ignoreJids;

        let ignoreGroups = false;
        let ignoreContacts = false;

        if (ignoreJids.includes('@g.us')) {
          ignoreGroups = true;
        }

        if (ignoreJids.includes('@s.whatsapp.net')) {
          ignoreContacts = true;
        }

        if (ignoreGroups && body?.key?.remoteJid.endsWith('@g.us')) {
          this.logger.warn('Ignoring message from group: ' + body?.key?.remoteJid);
          return;
        }

        if (ignoreContacts && body?.key?.remoteJid.endsWith('@s.whatsapp.net')) {
          this.logger.warn('Ignoring message from contact: ' + body?.key?.remoteJid);
          return;
        }

        if (ignoreJids.includes(body?.key?.remoteJid)) {
          this.logger.warn('Ignoring message from jid: ' + body?.key?.remoteJid);
          return;
        }
      }

      if (event === 'messages.upsert' || event === 'send.message') {
        if (body.key.remoteJid === 'status@broadcast') {
          return;
        }

        if (body.message?.ephemeralMessage?.message) {
          body.message = {
            ...body.message?.ephemeralMessage?.message,
          };
        }

        const originalMessage = await this.getConversationMessage(body.message);
        const bodyMessage = originalMessage
          ? originalMessage
              .replaceAll(/\*((?!\s)([^\n*]+?)(?<!\s))\*/g, '**$1**')
              .replaceAll(/_((?!\s)([^\n_]+?)(?<!\s))_/g, '*$1*')
              .replaceAll(/~((?!\s)([^\n~]+?)(?<!\s))~/g, '~~$1~~')
          : originalMessage;

        if (bodyMessage && bodyMessage.includes('Por favor, classifique esta conversa, http')) {
          return;
        }

        const quotedId = body.contextInfo?.stanzaId || body.message?.contextInfo?.stanzaId;

        let quotedMsg = null;

        if (quotedId)
          quotedMsg = await this.prismaRepository.message.findFirst({
            where: {
              key: {
                path: ['id'],
                equals: quotedId,
              },
              chatwootMessageId: {
                not: null,
              },
            },
          });

        const isMedia = this.isMediaMessage(body.message);

        const adsMessage = this.getAdsMessage(body);

        const reactionMessage = this.getReactionMessage(body.message);

        if (!bodyMessage && !isMedia && !reactionMessage) {
          this.logger.warn('no body message found');
          return;
        }

        const getConversation = await this.createConversation(instance, body);

        if (!getConversation) {
          this.logger.warn('conversation not found');
          return;
        }

        const messageType = body.key.fromMe ? 'outgoing' : 'incoming';

        if (isMedia) {
          const downloadBase64 = await waInstance?.getBase64FromMediaMessage({
            message: {
              ...body,
            },
          });

          let nameFile: string;
          const messageBody = body?.message[body?.messageType];
          const originalFilename =
            messageBody?.fileName || messageBody?.filename || messageBody?.message?.documentMessage?.fileName;
          if (originalFilename) {
            const parsedFile = path.parse(originalFilename);
            if (parsedFile.name && parsedFile.ext) {
              nameFile = `${parsedFile.name}-${Math.floor(Math.random() * (99 - 10 + 1) + 10)}${parsedFile.ext}`;
            }
          }

          if (!nameFile) {
            nameFile = `${Math.random().toString(36).substring(7)}.${mimeTypes.extension(downloadBase64.mimetype) || ''}`;
          }

          const fileData = Buffer.from(downloadBase64.base64, 'base64');

          const fileStream = new Readable();
          fileStream._read = () => {};
          fileStream.push(fileData);
          fileStream.push(null);

          if (body.key.remoteJid.includes('@g.us')) {
            const participantName = body.pushName;
            const rawPhoneNumber = body.key.participant.split('@')[0];
            const phoneMatch = rawPhoneNumber.match(/^(\d{2})(\d{2})(\d{4})(\d{4})$/);

            let formattedPhoneNumber: string;

            if (phoneMatch) {
              formattedPhoneNumber = `+${phoneMatch[1]} (${phoneMatch[2]}) ${phoneMatch[3]}-${phoneMatch[4]}`;
            } else {
              formattedPhoneNumber = `+${rawPhoneNumber}`;
            }

            let content: string;

            if (!body.key.fromMe) {
              content = `**${formattedPhoneNumber} - ${participantName}:**\n\n${bodyMessage}`;
            } else {
              content = `${bodyMessage}`;
            }

            const send = await this.sendData(
              getConversation,
              fileStream,
              nameFile,
              messageType,
              content,
              instance,
              body,
              'WAID:' + body.key.id,
              quotedMsg,
            );

            if (!send) {
              this.logger.warn('message not sent');
              return;
            }

            return send;
          } else {
            const send = await this.sendData(
              getConversation,
              fileStream,
              nameFile,
              messageType,
              bodyMessage,
              instance,
              body,
              'WAID:' + body.key.id,
              quotedMsg,
            );

            if (!send) {
              this.logger.warn('message not sent');
              return;
            }

            return send;
          }
        }

        if (reactionMessage) {
          if (reactionMessage.text) {
            const send = await this.createMessage(
              instance,
              getConversation,
              reactionMessage.text,
              messageType,
              false,
              [],
              {
                message: { extendedTextMessage: { contextInfo: { stanzaId: reactionMessage.key.id } } },
              },
              'WAID:' + body.key.id,
              quotedMsg,
            );
            if (!send) {
              this.logger.warn('message not sent');
              return;
            }
          }

          return;
        }

        const isAdsMessage = (adsMessage && adsMessage.title) || adsMessage.body || adsMessage.thumbnailUrl;
        if (isAdsMessage) {
          const imgBuffer = await axios.get(adsMessage.thumbnailUrl, { responseType: 'arraybuffer' });

          const extension = mimeTypes.extension(imgBuffer.headers['content-type']);
          const mimeType = extension && mimeTypes.lookup(extension);

          if (!mimeType) {
            this.logger.warn('mimetype of Ads message not found');
            return;
          }

          const random = Math.random().toString(36).substring(7);
          const nameFile = `${random}.${mimeTypes.extension(mimeType)}`;
          const fileData = Buffer.from(imgBuffer.data, 'binary');

          const img = await Jimp.read(fileData);
          await img.cover(320, 180);

          const processedBuffer = await img.getBufferAsync(Jimp.MIME_PNG);

          const fileStream = new Readable();
          fileStream._read = () => {}; // _read is required but you can noop it
          fileStream.push(processedBuffer);
          fileStream.push(null);

          const truncStr = (str: string, len: number) => {
            if (!str) return '';

            return str.length > len ? str.substring(0, len) + '...' : str;
          };

          const title = truncStr(adsMessage.title, 40);
          const description = truncStr(adsMessage?.body, 75);

          const send = await this.sendData(
            getConversation,
            fileStream,
            nameFile,
            messageType,
            `${bodyMessage}\n\n\n**${title}**\n${description}\n${adsMessage.sourceUrl}`,
            instance,
            body,
            'WAID:' + body.key.id,
          );

          if (!send) {
            this.logger.warn('message not sent');
            return;
          }

          return send;
        }

        if (body.key.remoteJid.includes('@g.us')) {
          const participantName = body.pushName;
          const rawPhoneNumber = body.key.participant.split('@')[0];
          const phoneMatch = rawPhoneNumber.match(/^(\d{2})(\d{2})(\d{4})(\d{4})$/);

          let formattedPhoneNumber: string;

          if (phoneMatch) {
            formattedPhoneNumber = `+${phoneMatch[1]} (${phoneMatch[2]}) ${phoneMatch[3]}-${phoneMatch[4]}`;
          } else {
            formattedPhoneNumber = `+${rawPhoneNumber}`;
          }

          let content: string;

          if (!body.key.fromMe) {
            content = `**${formattedPhoneNumber} - ${participantName}:**\n\n${bodyMessage}`;
          } else {
            content = `${bodyMessage}`;
          }

          const send = await this.createMessage(
            instance,
            getConversation,
            content,
            messageType,
            false,
            [],
            body,
            'WAID:' + body.key.id,
            quotedMsg,
          );

          if (!send) {
            this.logger.warn('message not sent');
            return;
          }

          return send;
        } else {
          const send = await this.createMessage(
            instance,
            getConversation,
            bodyMessage,
            messageType,
            false,
            [],
            body,
            'WAID:' + body.key.id,
            quotedMsg,
          );

          if (!send) {
            this.logger.warn('message not sent');
            return;
          }

          return send;
        }
      }

      if (event === Events.MESSAGES_DELETE) {
        const chatwootDelete = this.configService.get<Chatwoot>('CHATWOOT').MESSAGE_DELETE;

        if (chatwootDelete === true) {
          if (!body?.key?.id) {
            this.logger.warn('message id not found');
            return;
          }

          const message = await this.getMessageByKeyId(instance, body.key.id);

          if (message?.chatwootMessageId && message?.chatwootConversationId) {
            await this.prismaRepository.message.deleteMany({
              where: {
                key: {
                  path: ['id'],
                  equals: body.key.id,
                },
                instanceId: instance.instanceId,
              },
            });

            return await client.messages.delete({
              accountId: this.provider.accountId,
              conversationId: message.chatwootConversationId,
              messageId: message.chatwootMessageId,
            });
          }
        }
      }

      if (event === 'messages.edit') {
        const editedText = `${
          body?.editedMessage?.conversation || body?.editedMessage?.extendedTextMessage?.text
        }\n\n_\`${i18next.t('cw.message.edited')}.\`_`;
        const message = await this.getMessageByKeyId(instance, body?.key?.id);
        const key = message.key as {
          id: string;
          fromMe: boolean;
          remoteJid: string;
          participant?: string;
        };

        const messageType = key?.fromMe ? 'outgoing' : 'incoming';

        if (message && message.chatwootConversationId) {
          const send = await this.createMessage(
            instance,
            message.chatwootConversationId,
            editedText,
            messageType,
            false,
            [],
            {
              message: { extendedTextMessage: { contextInfo: { stanzaId: key.id } } },
            },
            'WAID:' + body.key.id,
            null,
          );
          if (!send) {
            this.logger.warn('edited message not sent');
            return;
          }
        }
        return;
      }

      if (event === 'messages.read') {
        if (!body?.key?.id || !body?.key?.remoteJid) {
          this.logger.warn('message id not found');
          return;
        }

        const message = await this.getMessageByKeyId(instance, body.key.id);
        const conversationId = message?.chatwootConversationId;
        const contactInboxSourceId = message?.chatwootContactInboxSourceId;

        if (conversationId) {
          let sourceId = contactInboxSourceId;
          const inbox = (await this.getInbox(instance)) as inbox & {
            inbox_identifier?: string;
          };

          if (!sourceId && inbox) {
            const conversation = (await client.conversations.get({
              accountId: this.provider.accountId,
              conversationId: conversationId,
            })) as conversation_show & {
              last_non_activity_message: { conversation: { contact_inbox: contact_inboxes } };
            };
            sourceId = conversation.last_non_activity_message?.conversation?.contact_inbox?.source_id;
          }

          if (sourceId && inbox?.inbox_identifier) {
            const url =
              `/public/api/v1/inboxes/${inbox.inbox_identifier}/contacts/${sourceId}` +
              `/conversations/${conversationId}/update_last_seen`;
            chatwootRequest(this.getClientCwConfig(), {
              method: 'POST',
              url: url,
            });
          }
        }
        return;
      }

      if (event === 'status.instance') {
        const data = body;
        const inbox = await this.getInbox(instance);

        if (!inbox) {
          this.logger.warn('inbox not found');
          return;
        }

        const msgStatus = i18next.t('cw.inbox.status', {
          inboxName: inbox.name,
          state: data.status,
        });

        await this.createBotMessage(instance, msgStatus, 'incoming');
      }

      if (event === 'connection.update') {
        if (body.status === 'open') {
          // if we have qrcode count then we understand that a new connection was established
          if (this.waMonitor.waInstances[instance.instanceName].qrCode.count > 0) {
            const msgConnection = i18next.t('cw.inbox.connected');
            await this.createBotMessage(instance, msgConnection, 'incoming');
            this.waMonitor.waInstances[instance.instanceName].qrCode.count = 0;
            chatwootImport.clearAll(instance);
          }
        }
      }

      if (event === 'qrcode.updated') {
        if (body.statusCode === 500) {
          const erroQRcode = `🚨 ${i18next.t('qrlimitreached')}`;
          return await this.createBotMessage(instance, erroQRcode, 'incoming');
        } else {
          const fileData = Buffer.from(body?.qrcode.base64.replace('data:image/png;base64,', ''), 'base64');

          const fileStream = new Readable();
          fileStream._read = () => {};
          fileStream.push(fileData);
          fileStream.push(null);

          await this.createBotQr(
            instance,
            i18next.t('qrgeneratedsuccesfully'),
            'incoming',
            fileStream,
            `${instance.instanceName}.png`,
          );

          let msgQrCode = `⚡️${i18next.t('qrgeneratedsuccesfully')}\n\n${i18next.t('scanqr')}`;

          if (body?.qrcode?.pairingCode) {
            msgQrCode =
              msgQrCode +
              `\n\n*Pairing Code:* ${body.qrcode.pairingCode.substring(0, 4)}-${body.qrcode.pairingCode.substring(
                4,
                8,
              )}`;
          }

          await this.createBotMessage(instance, msgQrCode, 'incoming');
        }
      }
    } catch (error) {
      this.logger.error(error);
    }
  }

  public getNumberFromRemoteJid(remoteJid: string) {
    return remoteJid.replace(/:\d+/, '').split('@')[0];
  }

  public startImportHistoryMessages(instance: InstanceDto) {
    if (!this.isImportHistoryAvailable()) {
      return;
    }

    this.createBotMessage(instance, i18next.t('cw.import.startImport'), 'incoming');
  }

  public isImportHistoryAvailable() {
    const uri = this.configService.get<Chatwoot>('CHATWOOT').IMPORT.DATABASE.CONNECTION.URI;

    return uri && uri !== 'postgres://user:password@hostname:port/dbname';
  }

  public addHistoryMessages(instance: InstanceDto, messagesRaw: MessageModel[]) {
    if (!this.isImportHistoryAvailable()) {
      return;
    }

    chatwootImport.addHistoryMessages(instance, messagesRaw);
  }

  public addHistoryContacts(instance: InstanceDto, contactsRaw: ContactModel[]) {
    if (!this.isImportHistoryAvailable()) {
      return;
    }

    return chatwootImport.addHistoryContacts(instance, contactsRaw);
  }

  public async importHistoryMessages(instance: InstanceDto) {
    if (!this.isImportHistoryAvailable()) {
      return;
    }

    this.createBotMessage(instance, i18next.t('cw.import.importingMessages'), 'incoming');

    const totalMessagesImported = await chatwootImport.importHistoryMessages(
      instance,
      this,
      await this.getInbox(instance),
      this.provider,
    );
    this.updateContactAvatarInRecentConversations(instance);

    const msg = Number.isInteger(totalMessagesImported)
      ? i18next.t('cw.import.messagesImported', { totalMessagesImported })
      : i18next.t('cw.import.messagesException');

    this.createBotMessage(instance, msg, 'incoming');

    return totalMessagesImported;
  }

  public async updateContactAvatarInRecentConversations(instance: InstanceDto, limitContacts = 100) {
    try {
      if (!this.isImportHistoryAvailable()) {
        return;
      }

      const client = await this.clientCw(instance);
      if (!client) {
        this.logger.warn('client not found');
        return null;
      }

      const inbox = await this.getInbox(instance);
      if (!inbox) {
        this.logger.warn('inbox not found');
        return null;
      }

      const recentContacts = await chatwootImport.getContactsOrderByRecentConversations(
        inbox,
        this.provider,
        limitContacts,
      );

      const contactIdentifiers = recentContacts
        .map((contact) => contact.identifier)
        .filter((identifier) => identifier !== null);

      const contactsWithProfilePicture = (
        await this.prismaRepository.contact.findMany({
          where: {
            instanceId: instance.instanceId,
            id: {
              in: contactIdentifiers,
            },
            profilePicUrl: {
              not: null,
            },
          },
        })
      ).reduce((acc: Map<string, ContactModel>, contact: ContactModel) => acc.set(contact.id, contact), new Map());

      recentContacts.forEach(async (contact) => {
        if (contactsWithProfilePicture.has(contact.identifier)) {
          client.contacts.update({
            accountId: this.provider.accountId,
            id: contact.id,
            data: {
              avatar_url: contactsWithProfilePicture.get(contact.identifier).profilePictureUrl || null,
            },
          });
        }
      });
    } catch (error) {
      this.logger.error(`Error on update avatar in recent conversations: ${error.toString()}`);
    }
  }

  public async syncLostMessages(
    instance: InstanceDto,
    chatwootConfig: ChatwootDto,
    prepareMessage: (message: any) => any,
  ) {
    try {
      if (!this.isImportHistoryAvailable()) {
        return;
      }
      if (!this.configService.get<Database>('DATABASE').SAVE_DATA.MESSAGE_UPDATE) {
        return;
      }

      const inbox = await this.getInbox(instance);

      const sqlMessages = `select * from messages m
      where account_id = ${chatwootConfig.accountId}
      and inbox_id = ${inbox.id}
      and created_at >= now() - interval '6h'
      order by created_at desc`;

      const messagesData = (await this.pgClient.query(sqlMessages))?.rows;
      const ids: string[] = messagesData
        .filter((message) => !!message.source_id)
        .map((message) => message.source_id.replace('WAID:', ''));

      const savedMessages = await this.prismaRepository.message.findMany({
        where: {
          Instance: { name: instance.instanceName },
          messageTimestamp: { gte: dayjs().subtract(6, 'hours').unix() },
          AND: ids.map((id) => ({ key: { path: ['id'], not: id } })),
        },
      });

      const filteredMessages = savedMessages.filter(
        (msg: any) => !chatwootImport.isIgnorePhoneNumber(msg.key?.remoteJid),
      );
      const messagesRaw: any[] = [];
      for (const m of filteredMessages) {
        if (!m.message || !m.key || !m.messageTimestamp) {
          continue;
        }

        if (Long.isLong(m?.messageTimestamp)) {
          m.messageTimestamp = m.messageTimestamp?.toNumber();
        }

        messagesRaw.push(prepareMessage(m as any));
      }

      this.addHistoryMessages(
        instance,
        messagesRaw.filter((msg) => !chatwootImport.isIgnorePhoneNumber(msg.key?.remoteJid)),
      );

      await chatwootImport.importHistoryMessages(instance, this, inbox, this.provider);
      const waInstance = this.waMonitor.waInstances[instance.instanceName];
      waInstance.clearCacheChatwoot();
    } catch (error) {
      return;
    }
  }
}



================================================
FILE: src/api/integrations/chatbot/chatwoot/utils/chatwoot-import-helper.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { ChatwootDto } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
import { postgresClient } from '@api/integrations/chatbot/chatwoot/libs/postgres.client';
import { ChatwootService } from '@api/integrations/chatbot/chatwoot/services/chatwoot.service';
import { Chatwoot, configService } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { inbox } from '@figuro/chatwoot-sdk';
import { Chatwoot as ChatwootModel, Contact, Message } from '@prisma/client';
import { proto } from 'baileys';

type ChatwootUser = {
  user_type: string;
  user_id: number;
};

type FksChatwoot = {
  phone_number: string;
  contact_id: string;
  conversation_id: string;
};

type firstLastTimestamp = {
  first: number;
  last: number;
};

type IWebMessageInfo = Omit<proto.IWebMessageInfo, 'key'> & Partial<Pick<proto.IWebMessageInfo, 'key'>>;

class ChatwootImport {
  private logger = new Logger('ChatwootImport');
  private repositoryMessagesCache = new Map<string, Set<string>>();
  private historyMessages = new Map<string, Message[]>();
  private historyContacts = new Map<string, Contact[]>();

  public getRepositoryMessagesCache(instance: InstanceDto) {
    return this.repositoryMessagesCache.has(instance.instanceName)
      ? this.repositoryMessagesCache.get(instance.instanceName)
      : null;
  }

  public setRepositoryMessagesCache(instance: InstanceDto, repositoryMessagesCache: Set<string>) {
    this.repositoryMessagesCache.set(instance.instanceName, repositoryMessagesCache);
  }

  public deleteRepositoryMessagesCache(instance: InstanceDto) {
    this.repositoryMessagesCache.delete(instance.instanceName);
  }

  public addHistoryMessages(instance: InstanceDto, messagesRaw: Message[]) {
    const actualValue = this.historyMessages.has(instance.instanceName)
      ? this.historyMessages.get(instance.instanceName)
      : [];
    this.historyMessages.set(instance.instanceName, [...actualValue, ...messagesRaw]);
  }

  public addHistoryContacts(instance: InstanceDto, contactsRaw: Contact[]) {
    const actualValue = this.historyContacts.has(instance.instanceName)
      ? this.historyContacts.get(instance.instanceName)
      : [];
    this.historyContacts.set(instance.instanceName, actualValue.concat(contactsRaw));
  }

  public deleteHistoryMessages(instance: InstanceDto) {
    this.historyMessages.delete(instance.instanceName);
  }

  public deleteHistoryContacts(instance: InstanceDto) {
    this.historyContacts.delete(instance.instanceName);
  }

  public clearAll(instance: InstanceDto) {
    this.deleteRepositoryMessagesCache(instance);
    this.deleteHistoryMessages(instance);
    this.deleteHistoryContacts(instance);
  }

  public getHistoryMessagesLenght(instance: InstanceDto) {
    return this.historyMessages.get(instance.instanceName)?.length ?? 0;
  }

  public async importHistoryContacts(instance: InstanceDto, provider: ChatwootDto) {
    try {
      if (this.getHistoryMessagesLenght(instance) > 0) {
        return;
      }

      const pgClient = postgresClient.getChatwootConnection();

      let totalContactsImported = 0;

      const contacts = this.historyContacts.get(instance.instanceName) || [];
      if (contacts.length === 0) {
        return 0;
      }

      let contactsChunk: Contact[] = this.sliceIntoChunks(contacts, 3000);
      while (contactsChunk.length > 0) {
        const labelSql = `SELECT id FROM labels WHERE title = '${provider.nameInbox}' AND account_id = ${provider.accountId} LIMIT 1`;

        let labelId = (await pgClient.query(labelSql))?.rows[0]?.id;

        if (!labelId) {
          // creating label in chatwoot db and getting the id
          const sqlLabel = `INSERT INTO labels (title, color, show_on_sidebar, account_id, created_at, updated_at) VALUES ('${provider.nameInbox}', '#34039B', true, ${provider.accountId}, NOW(), NOW()) RETURNING id`;

          labelId = (await pgClient.query(sqlLabel))?.rows[0]?.id;
        }

        // inserting contacts in chatwoot db
        let sqlInsert = `INSERT INTO contacts
          (name, phone_number, account_id, identifier, created_at, updated_at) VALUES `;
        const bindInsert = [provider.accountId];

        for (const contact of contactsChunk) {
          bindInsert.push(contact.pushName);
          const bindName = `$${bindInsert.length}`;

          bindInsert.push(`+${contact.remoteJid.split('@')[0]}`);
          const bindPhoneNumber = `$${bindInsert.length}`;

          bindInsert.push(contact.remoteJid);
          const bindIdentifier = `$${bindInsert.length}`;

          sqlInsert += `(${bindName}, ${bindPhoneNumber}, $1, ${bindIdentifier}, NOW(), NOW()),`;
        }
        if (sqlInsert.slice(-1) === ',') {
          sqlInsert = sqlInsert.slice(0, -1);
        }
        sqlInsert += ` ON CONFLICT (identifier, account_id)
                       DO UPDATE SET
                        name = EXCLUDED.name,
                        phone_number = EXCLUDED.phone_number,
                        identifier = EXCLUDED.identifier`;

        totalContactsImported += (await pgClient.query(sqlInsert, bindInsert))?.rowCount ?? 0;

        const sqlTags = `SELECT id FROM tags WHERE name = '${provider.nameInbox}' LIMIT 1`;

        const tagData = (await pgClient.query(sqlTags))?.rows[0];
        let tagId = tagData?.id;

        const sqlTag = `INSERT INTO tags (name, taggings_count) VALUES ('${provider.nameInbox}', ${totalContactsImported}) ON CONFLICT (name) DO UPDATE SET taggings_count = tags.taggings_count + ${totalContactsImported} RETURNING id`;

        tagId = (await pgClient.query(sqlTag))?.rows[0]?.id;

        await pgClient.query(sqlTag);

        let sqlInsertLabel = `INSERT INTO taggings (tag_id, taggable_type, taggable_id, context, created_at) VALUES `;

        contactsChunk.forEach((contact) => {
          const bindTaggableId = `(SELECT id FROM contacts WHERE identifier = '${contact.remoteJid}' AND account_id = ${provider.accountId})`;
          sqlInsertLabel += `($1, $2, ${bindTaggableId}, $3, NOW()),`;
        });

        if (sqlInsertLabel.slice(-1) === ',') {
          sqlInsertLabel = sqlInsertLabel.slice(0, -1);
        }

        await pgClient.query(sqlInsertLabel, [tagId, 'Contact', 'labels']);

        contactsChunk = this.sliceIntoChunks(contacts, 3000);
      }

      this.deleteHistoryContacts(instance);

      return totalContactsImported;
    } catch (error) {
      this.logger.error(`Error on import history contacts: ${error.toString()}`);
    }
  }

  public async getExistingSourceIds(sourceIds: string[]): Promise<Set<string>> {
    try {
      const existingSourceIdsSet = new Set<string>();

      if (sourceIds.length === 0) {
        return existingSourceIdsSet;
      }

      const formattedSourceIds = sourceIds.map((sourceId) => `WAID:${sourceId.replace('WAID:', '')}`); // Make sure the sourceId is always formatted as WAID:1234567890
      const query = 'SELECT source_id FROM messages WHERE source_id = ANY($1)';
      const pgClient = postgresClient.getChatwootConnection();
      const result = await pgClient.query(query, [formattedSourceIds]);

      for (const row of result.rows) {
        existingSourceIdsSet.add(row.source_id);
      }

      return existingSourceIdsSet;
    } catch (error) {
      return null;
    }
  }

  public async importHistoryMessages(
    instance: InstanceDto,
    chatwootService: ChatwootService,
    inbox: inbox,
    provider: ChatwootModel,
  ) {
    try {
      const pgClient = postgresClient.getChatwootConnection();

      const chatwootUser = await this.getChatwootUser(provider);
      if (!chatwootUser) {
        throw new Error('User not found to import messages.');
      }

      let totalMessagesImported = 0;

      let messagesOrdered = this.historyMessages.get(instance.instanceName) || [];
      if (messagesOrdered.length === 0) {
        return 0;
      }

      // ordering messages by number and timestamp asc
      messagesOrdered.sort((a, b) => {
        const aKey = a.key as {
          remoteJid: string;
        };

        const bKey = b.key as {
          remoteJid: string;
        };

        const aMessageTimestamp = a.messageTimestamp as any as number;
        const bMessageTimestamp = b.messageTimestamp as any as number;

        return parseInt(aKey.remoteJid) - parseInt(bKey.remoteJid) || aMessageTimestamp - bMessageTimestamp;
      });

      const allMessagesMappedByPhoneNumber = this.createMessagesMapByPhoneNumber(messagesOrdered);
      // Map structure: +552199999999 => { first message timestamp from number, last message timestamp from number}
      const phoneNumbersWithTimestamp = new Map<string, firstLastTimestamp>();
      allMessagesMappedByPhoneNumber.forEach((messages: Message[], phoneNumber: string) => {
        phoneNumbersWithTimestamp.set(phoneNumber, {
          first: messages[0]?.messageTimestamp as any as number,
          last: messages[messages.length - 1]?.messageTimestamp as any as number,
        });
      });

      const existingSourceIds = await this.getExistingSourceIds(messagesOrdered.map((message: any) => message.key.id));
      messagesOrdered = messagesOrdered.filter((message: any) => !existingSourceIds.has(message.key.id));
      // processing messages in batch
      const batchSize = 4000;
      let messagesChunk: Message[] = this.sliceIntoChunks(messagesOrdered, batchSize);
      while (messagesChunk.length > 0) {
        // Map structure: +552199999999 => Message[]
        const messagesByPhoneNumber = this.createMessagesMapByPhoneNumber(messagesChunk);

        if (messagesByPhoneNumber.size > 0) {
          const fksByNumber = await this.selectOrCreateFksFromChatwoot(
            provider,
            inbox,
            phoneNumbersWithTimestamp,
            messagesByPhoneNumber,
          );

          // inserting messages in chatwoot db
          let sqlInsertMsg = `INSERT INTO messages
            (content, processed_message_content, account_id, inbox_id, conversation_id, message_type, private, content_type,
            sender_type, sender_id, source_id, created_at, updated_at) VALUES `;
          const bindInsertMsg = [provider.accountId, inbox.id];

          messagesByPhoneNumber.forEach((messages: any[], phoneNumber: string) => {
            const fksChatwoot = fksByNumber.get(phoneNumber);

            messages.forEach((message) => {
              if (!message.message) {
                return;
              }

              if (!fksChatwoot?.conversation_id || !fksChatwoot?.contact_id) {
                return;
              }

              const contentMessage = this.getContentMessage(chatwootService, message);
              if (!contentMessage) {
                return;
              }

              bindInsertMsg.push(contentMessage);
              const bindContent = `$${bindInsertMsg.length}`;

              bindInsertMsg.push(fksChatwoot.conversation_id);
              const bindConversationId = `$${bindInsertMsg.length}`;

              bindInsertMsg.push(message.key.fromMe ? '1' : '0');
              const bindMessageType = `$${bindInsertMsg.length}`;

              bindInsertMsg.push(message.key.fromMe ? chatwootUser.user_type : 'Contact');
              const bindSenderType = `$${bindInsertMsg.length}`;

              bindInsertMsg.push(message.key.fromMe ? chatwootUser.user_id : fksChatwoot.contact_id);
              const bindSenderId = `$${bindInsertMsg.length}`;

              bindInsertMsg.push('WAID:' + message.key.id);
              const bindSourceId = `$${bindInsertMsg.length}`;

              bindInsertMsg.push(message.messageTimestamp as number);
              const bindmessageTimestamp = `$${bindInsertMsg.length}`;

              sqlInsertMsg += `(${bindContent}, ${bindContent}, $1, $2, ${bindConversationId}, ${bindMessageType}, FALSE, 0,
                  ${bindSenderType},${bindSenderId},${bindSourceId}, to_timestamp(${bindmessageTimestamp}), to_timestamp(${bindmessageTimestamp})),`;
            });
          });
          if (bindInsertMsg.length > 2) {
            if (sqlInsertMsg.slice(-1) === ',') {
              sqlInsertMsg = sqlInsertMsg.slice(0, -1);
            }
            totalMessagesImported += (await pgClient.query(sqlInsertMsg, bindInsertMsg))?.rowCount ?? 0;
          }
        }
        messagesChunk = this.sliceIntoChunks(messagesOrdered, batchSize);
      }

      this.deleteHistoryMessages(instance);
      this.deleteRepositoryMessagesCache(instance);

      const providerData: ChatwootDto = {
        ...provider,
        ignoreJids: Array.isArray(provider.ignoreJids) ? provider.ignoreJids.map((event) => String(event)) : [],
      };

      this.importHistoryContacts(instance, providerData);

      return totalMessagesImported;
    } catch (error) {
      this.logger.error(`Error on import history messages: ${error.toString()}`);

      this.deleteHistoryMessages(instance);
      this.deleteRepositoryMessagesCache(instance);
    }
  }

  public async selectOrCreateFksFromChatwoot(
    provider: ChatwootModel,
    inbox: inbox,
    phoneNumbersWithTimestamp: Map<string, firstLastTimestamp>,
    messagesByPhoneNumber: Map<string, Message[]>,
  ): Promise<Map<string, FksChatwoot>> {
    const pgClient = postgresClient.getChatwootConnection();

    const bindValues = [provider.accountId, inbox.id];
    const phoneNumberBind = Array.from(messagesByPhoneNumber.keys())
      .map((phoneNumber) => {
        const phoneNumberTimestamp = phoneNumbersWithTimestamp.get(phoneNumber);

        if (phoneNumberTimestamp) {
          bindValues.push(phoneNumber);
          let bindStr = `($${bindValues.length},`;

          bindValues.push(phoneNumberTimestamp.first);
          bindStr += `$${bindValues.length},`;

          bindValues.push(phoneNumberTimestamp.last);
          return `${bindStr}$${bindValues.length})`;
        }
      })
      .join(',');

    // select (or insert when necessary) data from tables contacts, contact_inboxes, conversations from chatwoot db
    const sqlFromChatwoot = `WITH
              phone_number AS (
                SELECT phone_number, created_at::INTEGER, last_activity_at::INTEGER FROM (
                  VALUES 
                   ${phoneNumberBind}
                 ) as t (phone_number, created_at, last_activity_at)
              ),

              only_new_phone_number AS (
                SELECT * FROM phone_number
                WHERE phone_number NOT IN (
                  SELECT phone_number
                  FROM contacts
                    JOIN contact_inboxes ci ON ci.contact_id = contacts.id AND ci.inbox_id = $2
                    JOIN conversations con ON con.contact_inbox_id = ci.id 
                      AND con.account_id = $1
                      AND con.inbox_id = $2
                      AND con.contact_id = contacts.id
                  WHERE contacts.account_id = $1
                )
              ),

              new_contact AS (
                INSERT INTO contacts (name, phone_number, account_id, identifier, created_at, updated_at)
                SELECT REPLACE(p.phone_number, '+', ''), p.phone_number, $1, CONCAT(REPLACE(p.phone_number, '+', ''),
                  '@s.whatsapp.net'), to_timestamp(p.created_at), to_timestamp(p.last_activity_at)
                FROM only_new_phone_number AS p
                ON CONFLICT(identifier, account_id) DO UPDATE SET updated_at = EXCLUDED.updated_at
                RETURNING id, phone_number, created_at, updated_at
              ),

              new_contact_inbox AS (
                INSERT INTO contact_inboxes (contact_id, inbox_id, source_id, created_at, updated_at)
                SELECT new_contact.id, $2, gen_random_uuid(), new_contact.created_at, new_contact.updated_at
                FROM new_contact 
                RETURNING id, contact_id, created_at, updated_at
              ),

              new_conversation AS (
                INSERT INTO conversations (account_id, inbox_id, status, contact_id,
                  contact_inbox_id, uuid, last_activity_at, created_at, updated_at)
                SELECT $1, $2, 0, new_contact_inbox.contact_id, new_contact_inbox.id, gen_random_uuid(),
                  new_contact_inbox.updated_at, new_contact_inbox.created_at, new_contact_inbox.updated_at
                FROM new_contact_inbox
                RETURNING id, contact_id
              )

              SELECT new_contact.phone_number, new_conversation.contact_id, new_conversation.id AS conversation_id
              FROM new_conversation 
              JOIN new_contact ON new_conversation.contact_id = new_contact.id

              UNION

              SELECT p.phone_number, c.id contact_id, con.id conversation_id
                FROM phone_number p
              JOIN contacts c ON c.phone_number = p.phone_number
              JOIN contact_inboxes ci ON ci.contact_id = c.id AND ci.inbox_id = $2
              JOIN conversations con ON con.contact_inbox_id = ci.id AND con.account_id = $1
                AND con.inbox_id = $2 AND con.contact_id = c.id`;

    const fksFromChatwoot = await pgClient.query(sqlFromChatwoot, bindValues);

    return new Map(fksFromChatwoot.rows.map((item: FksChatwoot) => [item.phone_number, item]));
  }

  public async getChatwootUser(provider: ChatwootModel): Promise<ChatwootUser> {
    try {
      const pgClient = postgresClient.getChatwootConnection();

      const sqlUser = `SELECT owner_type AS user_type, owner_id AS user_id
                         FROM access_tokens
                       WHERE token = $1`;

      return (await pgClient.query(sqlUser, [provider.token]))?.rows[0] || false;
    } catch (error) {
      this.logger.error(`Error on getChatwootUser: ${error.toString()}`);
    }
  }

  public createMessagesMapByPhoneNumber(messages: Message[]): Map<string, Message[]> {
    return messages.reduce((acc: Map<string, Message[]>, message: Message) => {
      const key = message?.key as {
        remoteJid: string;
      };
      if (!this.isIgnorePhoneNumber(key?.remoteJid)) {
        const phoneNumber = key?.remoteJid?.split('@')[0];
        if (phoneNumber) {
          const phoneNumberPlus = `+${phoneNumber}`;
          const messages = acc.has(phoneNumberPlus) ? acc.get(phoneNumberPlus) : [];
          messages.push(message);
          acc.set(phoneNumberPlus, messages);
        }
      }

      return acc;
    }, new Map());
  }

  public async getContactsOrderByRecentConversations(
    inbox: inbox,
    provider: ChatwootModel,
    limit = 50,
  ): Promise<{ id: number; phone_number: string; identifier: string }[]> {
    try {
      const pgClient = postgresClient.getChatwootConnection();

      const sql = `SELECT contacts.id, contacts.identifier, contacts.phone_number
                     FROM conversations
                   JOIN contacts ON contacts.id = conversations.contact_id
                   WHERE conversations.account_id = $1
                     AND inbox_id = $2
                   ORDER BY conversations.last_activity_at DESC
                   LIMIT $3`;

      return (await pgClient.query(sql, [provider.accountId, inbox.id, limit]))?.rows;
    } catch (error) {
      this.logger.error(`Error on get recent conversations: ${error.toString()}`);
    }
  }

  public getContentMessage(chatwootService: ChatwootService, msg: IWebMessageInfo) {
    const contentMessage = chatwootService.getConversationMessage(msg.message);
    if (contentMessage) {
      return contentMessage;
    }

    if (!configService.get<Chatwoot>('CHATWOOT').IMPORT.PLACEHOLDER_MEDIA_MESSAGE) {
      return '';
    }

    const types = {
      documentMessage: msg.message.documentMessage,
      documentWithCaptionMessage: msg.message.documentWithCaptionMessage?.message?.documentMessage,
      imageMessage: msg.message.imageMessage,
      videoMessage: msg.message.videoMessage,
      audioMessage: msg.message.audioMessage,
      stickerMessage: msg.message.stickerMessage,
      templateMessage: msg.message.templateMessage?.hydratedTemplate?.hydratedContentText,
    };
    const typeKey = Object.keys(types).find((key) => types[key] !== undefined);

    switch (typeKey) {
      case 'documentMessage':
        return `_<File: ${msg.message.documentMessage.fileName}${
          msg.message.documentMessage.caption ? ` ${msg.message.documentMessage.caption}` : ''
        }>_`;

      case 'documentWithCaptionMessage':
        return `_<File: ${msg.message.documentWithCaptionMessage.message.documentMessage.fileName}${
          msg.message.documentWithCaptionMessage.message.documentMessage.caption
            ? ` ${msg.message.documentWithCaptionMessage.message.documentMessage.caption}`
            : ''
        }>_`;

      case 'templateMessage':
        return msg.message.templateMessage.hydratedTemplate.hydratedTitleText
          ? `*${msg.message.templateMessage.hydratedTemplate.hydratedTitleText}*\\n`
          : '' + msg.message.templateMessage.hydratedTemplate.hydratedContentText;

      case 'imageMessage':
        return '_<Image Message>_';

      case 'videoMessage':
        return '_<Video Message>_';

      case 'audioMessage':
        return '_<Audio Message>_';

      case 'stickerMessage':
        return '_<Sticker Message>_';

      default:
        return '';
    }
  }

  public sliceIntoChunks(arr: any[], chunkSize: number) {
    return arr.splice(0, chunkSize);
  }

  public isGroup(remoteJid: string) {
    return remoteJid.includes('@g.us');
  }

  public isIgnorePhoneNumber(remoteJid: string) {
    return this.isGroup(remoteJid) || remoteJid === 'status@broadcast' || remoteJid === '0@s.whatsapp.net';
  }

  public updateMessageSourceID(messageId: string | number, sourceId: string) {
    const pgClient = postgresClient.getChatwootConnection();

    const sql = `UPDATE messages SET source_id = $1, status = 0, created_at = NOW(), updated_at = NOW() WHERE id = $2;`;

    return pgClient.query(sql, [`WAID:${sourceId}`, messageId]);
  }
}

export const chatwootImport = new ChatwootImport();



================================================
FILE: src/api/integrations/chatbot/chatwoot/validate/chatwoot.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const chatwootSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    enabled: { type: 'boolean', enum: [true, false] },
    accountId: { type: 'string' },
    token: { type: 'string' },
    url: { type: 'string' },
    signMsg: { type: 'boolean', enum: [true, false] },
    signDelimiter: { type: ['string', 'null'] },
    nameInbox: { type: ['string', 'null'] },
    reopenConversation: { type: 'boolean', enum: [true, false] },
    conversationPending: { type: 'boolean', enum: [true, false] },
    autoCreate: { type: 'boolean', enum: [true, false] },
    importContacts: { type: 'boolean', enum: [true, false] },
    mergeBrazilContacts: { type: 'boolean', enum: [true, false] },
    importMessages: { type: 'boolean', enum: [true, false] },
    daysLimitImportMessages: { type: 'number' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
  },
  required: ['enabled', 'accountId', 'token', 'url', 'signMsg', 'reopenConversation', 'conversationPending'],
  ...isNotEmpty('enabled', 'accountId', 'token', 'url', 'signMsg', 'reopenConversation', 'conversationPending'),
};



================================================
FILE: src/api/integrations/chatbot/dify/controllers/dify.controller.ts
================================================
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { DifyDto } from '@api/integrations/chatbot/dify/dto/dify.dto';
import { DifyService } from '@api/integrations/chatbot/dify/services/dify.service';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { configService, Dify } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { BadRequestException } from '@exceptions';
import { Dify as DifyModel } from '@prisma/client';
import { getConversationMessage } from '@utils/getConversationMessage';

import { ChatbotController, ChatbotControllerInterface, EmitData } from '../../chatbot.controller';

export class DifyController extends ChatbotController implements ChatbotControllerInterface {
  constructor(
    private readonly difyService: DifyService,
    prismaRepository: PrismaRepository,
    waMonitor: WAMonitoringService,
  ) {
    super(prismaRepository, waMonitor);

    this.botRepository = this.prismaRepository.dify;
    this.settingsRepository = this.prismaRepository.difySetting;
    this.sessionRepository = this.prismaRepository.integrationSession;
  }

  public readonly logger = new Logger('DifyController');

  integrationEnabled = configService.get<Dify>('DIFY').ENABLED;
  botRepository: any;
  settingsRepository: any;
  sessionRepository: any;
  userMessageDebounce: { [key: string]: { message: string; timeoutId: NodeJS.Timeout } } = {};

  // Bots
  public async createBot(instance: InstanceDto, data: DifyDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    if (
      !data.expire ||
      !data.keywordFinish ||
      !data.delayMessage ||
      !data.unknownMessage ||
      !data.listeningFromMe ||
      !data.stopBotFromMe ||
      !data.keepOpen ||
      !data.debounceTime ||
      !data.ignoreJids ||
      !data.splitMessages ||
      !data.timePerChar
    ) {
      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (data.expire === undefined || data.expire === null) data.expire = defaultSettingCheck.expire;
      if (data.keywordFinish === undefined || data.keywordFinish === null)
        data.keywordFinish = defaultSettingCheck.keywordFinish;
      if (data.delayMessage === undefined || data.delayMessage === null)
        data.delayMessage = defaultSettingCheck.delayMessage;
      if (data.unknownMessage === undefined || data.unknownMessage === null)
        data.unknownMessage = defaultSettingCheck.unknownMessage;
      if (data.listeningFromMe === undefined || data.listeningFromMe === null)
        data.listeningFromMe = defaultSettingCheck.listeningFromMe;
      if (data.stopBotFromMe === undefined || data.stopBotFromMe === null)
        data.stopBotFromMe = defaultSettingCheck.stopBotFromMe;
      if (data.keepOpen === undefined || data.keepOpen === null) data.keepOpen = defaultSettingCheck.keepOpen;
      if (data.debounceTime === undefined || data.debounceTime === null)
        data.debounceTime = defaultSettingCheck.debounceTime;
      if (data.ignoreJids === undefined || data.ignoreJids === null) data.ignoreJids = defaultSettingCheck.ignoreJids;
      if (data.splitMessages === undefined || data.splitMessages === null)
        data.splitMessages = defaultSettingCheck?.splitMessages ?? false;
      if (data.timePerChar === undefined || data.timePerChar === null)
        data.timePerChar = defaultSettingCheck?.timePerChar ?? 0;

      if (!defaultSettingCheck) {
        await this.settings(instance, {
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        });
      }
    }

    const checkTriggerAll = await this.botRepository.findFirst({
      where: {
        enabled: true,
        triggerType: 'all',
        instanceId: instanceId,
      },
    });

    if (checkTriggerAll && data.triggerType === 'all') {
      throw new Error('You already have a dify with an "All" trigger, you cannot have more bots while it is active');
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: {
        instanceId: instanceId,
        botType: data.botType,
        apiUrl: data.apiUrl,
        apiKey: data.apiKey,
      },
    });

    if (checkDuplicate) {
      throw new Error('Dify already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.create({
        data: {
          enabled: data?.enabled,
          description: data.description,
          botType: data.botType,
          apiUrl: data.apiUrl,
          apiKey: data.apiKey,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          instanceId: instanceId,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error creating dify');
    }
  }

  public async findBot(instance: InstanceDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bots = await this.botRepository.findMany({
      where: {
        instanceId: instanceId,
      },
    });

    if (!bots.length) {
      return null;
    }

    return bots;
  }

  public async fetchBot(instance: InstanceDto, botId: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Dify not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Dify not found');
    }

    return bot;
  }

  public async updateBot(instance: InstanceDto, botId: string, data: DifyDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Dify not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Dify not found');
    }

    if (data.triggerType === 'all') {
      const checkTriggerAll = await this.botRepository.findFirst({
        where: {
          enabled: true,
          triggerType: 'all',
          id: {
            not: botId,
          },
          instanceId: instanceId,
        },
      });

      if (checkTriggerAll) {
        throw new Error('You already have a dify with an "All" trigger, you cannot have more bots while it is active');
      }
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: {
        id: {
          not: botId,
        },
        instanceId: instanceId,
        botType: data.botType,
        apiUrl: data.apiUrl,
        apiKey: data.apiKey,
      },
    });

    if (checkDuplicate) {
      throw new Error('Dify already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          id: { not: botId },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          id: { not: botId },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.update({
        where: {
          id: botId,
        },
        data: {
          enabled: data?.enabled,
          description: data.description,
          botType: data.botType,
          apiUrl: data.apiUrl,
          apiKey: data.apiKey,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          instanceId: instanceId,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error updating dify');
    }
  }

  public async deleteBot(instance: InstanceDto, botId: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Dify not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Dify not found');
    }
    try {
      await this.prismaRepository.integrationSession.deleteMany({
        where: {
          botId: botId,
        },
      });

      await this.botRepository.delete({
        where: {
          id: botId,
        },
      });

      return { bot: { id: botId } };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error deleting dify bot');
    }
  }

  // Settings
  public async settings(instance: InstanceDto, data: any) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (settings) {
        const updateSettings = await this.settingsRepository.update({
          where: {
            id: settings.id,
          },
          data: {
            expire: data.expire,
            keywordFinish: data.keywordFinish,
            delayMessage: data.delayMessage,
            unknownMessage: data.unknownMessage,
            listeningFromMe: data.listeningFromMe,
            stopBotFromMe: data.stopBotFromMe,
            keepOpen: data.keepOpen,
            debounceTime: data.debounceTime,
            difyIdFallback: data.difyIdFallback,
            ignoreJids: data.ignoreJids,
            splitMessages: data.splitMessages,
            timePerChar: data.timePerChar,
          },
        });

        return {
          expire: updateSettings.expire,
          keywordFinish: updateSettings.keywordFinish,
          delayMessage: updateSettings.delayMessage,
          unknownMessage: updateSettings.unknownMessage,
          listeningFromMe: updateSettings.listeningFromMe,
          stopBotFromMe: updateSettings.stopBotFromMe,
          keepOpen: updateSettings.keepOpen,
          debounceTime: updateSettings.debounceTime,
          difyIdFallback: updateSettings.difyIdFallback,
          ignoreJids: updateSettings.ignoreJids,
          splitMessages: updateSettings.splitMessages,
          timePerChar: updateSettings.timePerChar,
        };
      }

      const newSetttings = await this.settingsRepository.create({
        data: {
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          difyIdFallback: data.difyIdFallback,
          ignoreJids: data.ignoreJids,
          instanceId: instanceId,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return {
        expire: newSetttings.expire,
        keywordFinish: newSetttings.keywordFinish,
        delayMessage: newSetttings.delayMessage,
        unknownMessage: newSetttings.unknownMessage,
        listeningFromMe: newSetttings.listeningFromMe,
        stopBotFromMe: newSetttings.stopBotFromMe,
        keepOpen: newSetttings.keepOpen,
        debounceTime: newSetttings.debounceTime,
        difyIdFallback: newSetttings.difyIdFallback,
        ignoreJids: newSetttings.ignoreJids,
        splitMessages: newSetttings.splitMessages,
        timePerChar: newSetttings.timePerChar,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  public async fetchSettings(instance: InstanceDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
        include: {
          Fallback: true,
        },
      });

      if (!settings) {
        return {
          expire: 0,
          keywordFinish: '',
          delayMessage: 0,
          unknownMessage: '',
          listeningFromMe: false,
          stopBotFromMe: false,
          keepOpen: false,
          ignoreJids: [],
          splitMessages: false,
          timePerChar: 0,
          difyIdFallback: '',
          fallback: null,
        };
      }

      return {
        expire: settings.expire,
        keywordFinish: settings.keywordFinish,
        delayMessage: settings.delayMessage,
        unknownMessage: settings.unknownMessage,
        listeningFromMe: settings.listeningFromMe,
        stopBotFromMe: settings.stopBotFromMe,
        keepOpen: settings.keepOpen,
        ignoreJids: settings.ignoreJids,
        splitMessages: settings.splitMessages,
        timePerChar: settings.timePerChar,
        difyIdFallback: settings.difyIdFallback,
        fallback: settings.Fallback,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching default settings');
    }
  }

  // Sessions
  public async changeStatus(instance: InstanceDto, data: any) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId,
        },
      });

      const remoteJid = data.remoteJid;
      const status = data.status;

      if (status === 'delete') {
        await this.sessionRepository.deleteMany({
          where: {
            remoteJid: remoteJid,
            botId: { not: null },
          },
        });

        return { bot: { remoteJid: remoteJid, status: status } };
      }

      if (status === 'closed') {
        if (defaultSettingCheck?.keepOpen) {
          await this.sessionRepository.updateMany({
            where: {
              remoteJid: remoteJid,
              botId: { not: null },
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.sessionRepository.deleteMany({
            where: {
              remoteJid: remoteJid,
              botId: { not: null },
            },
          });
        }

        return { bot: { ...instance, bot: { remoteJid: remoteJid, status: status } } };
      } else {
        const session = await this.sessionRepository.updateMany({
          where: {
            instanceId: instanceId,
            remoteJid: remoteJid,
            botId: { not: null },
          },
          data: {
            status: status,
          },
        });

        const botData = {
          remoteJid: remoteJid,
          status: status,
          session,
        };

        return { bot: { ...instance, bot: botData } };
      }
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error changing status');
    }
  }

  public async fetchSessions(instance: InstanceDto, botId: string, remoteJid?: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const bot = await this.botRepository.findFirst({
        where: {
          id: botId,
        },
      });

      if (bot && bot.instanceId !== instanceId) {
        throw new Error('Dify not found');
      }

      return await this.sessionRepository.findMany({
        where: {
          instanceId: instanceId,
          remoteJid,
          botId: bot ? botId : { not: null },
          type: 'dify',
        },
      });
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching sessions');
    }
  }

  public async ignoreJid(instance: InstanceDto, data: IgnoreJidDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Dify is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (!settings) {
        throw new Error('Settings not found');
      }

      let ignoreJids: any = settings?.ignoreJids || [];

      if (data.action === 'add') {
        if (ignoreJids.includes(data.remoteJid)) return { ignoreJids: ignoreJids };

        ignoreJids.push(data.remoteJid);
      } else {
        ignoreJids = ignoreJids.filter((jid) => jid !== data.remoteJid);
      }

      const updateSettings = await this.settingsRepository.update({
        where: {
          id: settings.id,
        },
        data: {
          ignoreJids: ignoreJids,
        },
      });

      return {
        ignoreJids: updateSettings.ignoreJids,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  // Emit
  public async emit({ instance, remoteJid, msg }: EmitData) {
    if (!this.integrationEnabled) return;

    try {
      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instance.instanceId,
        },
      });

      if (this.checkIgnoreJids(settings?.ignoreJids, remoteJid)) return;

      const session = await this.getSession(remoteJid, instance);

      const content = getConversationMessage(msg);

      let findBot = (await this.findBotTrigger(this.botRepository, content, instance, session)) as DifyModel;

      if (!findBot) {
        const fallback = await this.settingsRepository.findFirst({
          where: {
            instanceId: instance.instanceId,
          },
        });

        if (fallback?.difyIdFallback) {
          const findFallback = await this.botRepository.findFirst({
            where: {
              id: fallback.difyIdFallback,
            },
          });

          findBot = findFallback;
        } else {
          return;
        }
      }

      let expire = findBot?.expire;
      let keywordFinish = findBot?.keywordFinish;
      let delayMessage = findBot?.delayMessage;
      let unknownMessage = findBot?.unknownMessage;
      let listeningFromMe = findBot?.listeningFromMe;
      let stopBotFromMe = findBot?.stopBotFromMe;
      let keepOpen = findBot?.keepOpen;
      let debounceTime = findBot?.debounceTime;
      let ignoreJids = findBot?.ignoreJids;
      let splitMessages = findBot?.splitMessages;
      let timePerChar = findBot?.timePerChar;

      if (expire === undefined || expire === null) expire = settings.expire;
      if (keywordFinish === undefined || keywordFinish === null) keywordFinish = settings.keywordFinish;
      if (delayMessage === undefined || delayMessage === null) delayMessage = settings.delayMessage;
      if (unknownMessage === undefined || unknownMessage === null) unknownMessage = settings.unknownMessage;
      if (listeningFromMe === undefined || listeningFromMe === null) listeningFromMe = settings.listeningFromMe;
      if (stopBotFromMe === undefined || stopBotFromMe === null) stopBotFromMe = settings.stopBotFromMe;
      if (keepOpen === undefined || keepOpen === null) keepOpen = settings.keepOpen;
      if (debounceTime === undefined || debounceTime === null) debounceTime = settings.debounceTime;
      if (ignoreJids === undefined || ignoreJids === null) ignoreJids = settings.ignoreJids;
      if (splitMessages === undefined || splitMessages === null) splitMessages = settings?.splitMessages ?? false;
      if (timePerChar === undefined || timePerChar === null) timePerChar = settings?.timePerChar ?? 0;

      const key = msg.key as {
        id: string;
        remoteJid: string;
        fromMe: boolean;
        participant: string;
      };

      if (stopBotFromMe && key.fromMe && session) {
        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'paused',
          },
        });
        return;
      }

      if (!listeningFromMe && key.fromMe) {
        return;
      }

      if (session && !session.awaitUser) {
        return;
      }

      if (debounceTime && debounceTime > 0) {
        this.processDebounce(this.userMessageDebounce, content, remoteJid, debounceTime, async (debouncedContent) => {
          await this.difyService.processDify(
            this.waMonitor.waInstances[instance.instanceName],
            remoteJid,
            findBot,
            session,
            {
              ...settings,
              expire,
              keywordFinish,
              delayMessage,
              unknownMessage,
              listeningFromMe,
              stopBotFromMe,
              keepOpen,
              debounceTime,
              ignoreJids,
              splitMessages,
              timePerChar,
            },
            debouncedContent,
            msg?.pushName,
          );
        });
      } else {
        await this.difyService.processDify(
          this.waMonitor.waInstances[instance.instanceName],
          remoteJid,
          findBot,
          session,
          {
            ...settings,
            expire,
            keywordFinish,
            delayMessage,
            unknownMessage,
            listeningFromMe,
            stopBotFromMe,
            keepOpen,
            debounceTime,
            ignoreJids,
            splitMessages,
            timePerChar,
          },
          content,
          msg?.pushName,
        );
      }

      return;
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }
}



================================================
FILE: src/api/integrations/chatbot/dify/dto/dify.dto.ts
================================================
import { $Enums, TriggerOperator, TriggerType } from '@prisma/client';

export class DifyDto {
  enabled?: boolean;
  description?: string;
  botType?: $Enums.DifyBotType;
  apiUrl?: string;
  apiKey?: string;
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  triggerType?: TriggerType;
  triggerOperator?: TriggerOperator;
  triggerValue?: string;
  ignoreJids?: any;
  splitMessages?: boolean;
  timePerChar?: number;
}

export class DifySettingDto {
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  difyIdFallback?: string;
  ignoreJids?: any;
  splitMessages?: boolean;
  timePerChar?: number;
}



================================================
FILE: src/api/integrations/chatbot/dify/routes/dify.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { DifyDto, DifySettingDto } from '@api/integrations/chatbot/dify/dto/dify.dto';
import { HttpStatus } from '@api/routes/index.router';
import { difyController } from '@api/server.module';
import {
  difyIgnoreJidSchema,
  difySchema,
  difySettingSchema,
  difyStatusSchema,
  instanceSchema,
} from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

export class DifyRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('create'), ...guards, async (req, res) => {
        const response = await this.dataValidate<DifyDto>({
          request: req,
          schema: difySchema,
          ClassRef: DifyDto,
          execute: (instance, data) => difyController.createBot(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => difyController.findBot(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetch/:difyId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => difyController.fetchBot(instance, req.params.difyId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .put(this.routerPath('update/:difyId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<DifyDto>({
          request: req,
          schema: difySchema,
          ClassRef: DifyDto,
          execute: (instance, data) => difyController.updateBot(instance, req.params.difyId, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .delete(this.routerPath('delete/:difyId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => difyController.deleteBot(instance, req.params.difyId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('settings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<DifySettingDto>({
          request: req,
          schema: difySettingSchema,
          ClassRef: DifySettingDto,
          execute: (instance, data) => difyController.settings(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSettings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => difyController.fetchSettings(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('changeStatus'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: difyStatusSchema,
          ClassRef: InstanceDto,
          execute: (instance, data) => difyController.changeStatus(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSessions/:difyId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => difyController.fetchSessions(instance, req.params.difyId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('ignoreJid'), ...guards, async (req, res) => {
        const response = await this.dataValidate<IgnoreJidDto>({
          request: req,
          schema: difyIgnoreJidSchema,
          ClassRef: IgnoreJidDto,
          execute: (instance, data) => difyController.ignoreJid(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/chatbot/dify/services/dify.service.ts
================================================
/* eslint-disable @typescript-eslint/no-unused-vars */
import { InstanceDto } from '@api/dto/instance.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Integration } from '@api/types/wa.types';
import { Auth, ConfigService, HttpServer } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { Dify, DifySetting, IntegrationSession } from '@prisma/client';
import { sendTelemetry } from '@utils/sendTelemetry';
import axios from 'axios';
import { Readable } from 'stream';

export class DifyService {
  constructor(
    private readonly waMonitor: WAMonitoringService,
    private readonly configService: ConfigService,
    private readonly prismaRepository: PrismaRepository,
  ) {}

  private readonly logger = new Logger('DifyService');

  public async createNewSession(instance: InstanceDto, data: any) {
    try {
      const session = await this.prismaRepository.integrationSession.create({
        data: {
          remoteJid: data.remoteJid,
          pushName: data.pushName,
          sessionId: data.remoteJid,
          status: 'opened',
          awaitUser: false,
          botId: data.botId,
          instanceId: instance.instanceId,
          type: 'dify',
        },
      });

      return { session };
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }

  private isImageMessage(content: string) {
    return content.includes('imageMessage');
  }

  private isJSON(str: string): boolean {
    try {
      JSON.parse(str);
      return true;
    } catch (e) {
      return false;
    }
  }

  private async sendMessageToBot(
    instance: any,
    session: IntegrationSession,
    settings: DifySetting,
    dify: Dify,
    remoteJid: string,
    pushName: string,
    content: string,
  ) {
    try {
      let endpoint: string = dify.apiUrl;

      if (dify.botType === 'chatBot') {
        endpoint += '/chat-messages';
        const payload: any = {
          inputs: {
            remoteJid: remoteJid,
            pushName: pushName,
            instanceName: instance.instanceName,
            serverUrl: this.configService.get<HttpServer>('SERVER').URL,
            apiKey: this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY,
          },
          query: content,
          response_mode: 'blocking',
          conversation_id: session.sessionId === remoteJid ? undefined : session.sessionId,
          user: remoteJid,
        };

        if (this.isImageMessage(content)) {
          const contentSplit = content.split('|');

          payload.files = [
            {
              type: 'image',
              transfer_method: 'remote_url',
              url: contentSplit[1].split('?')[0],
            },
          ];
          payload.query = contentSplit[2] || content;
        }

        if (instance.integration === Integration.WHATSAPP_BAILEYS) {
          await instance.client.presenceSubscribe(remoteJid);
          await instance.client.sendPresenceUpdate('composing', remoteJid);
        }

        const response = await axios.post(endpoint, payload, {
          headers: {
            Authorization: `Bearer ${dify.apiKey}`,
          },
        });

        if (instance.integration === Integration.WHATSAPP_BAILEYS)
          await instance.client.sendPresenceUpdate('paused', remoteJid);

        const message = response?.data?.answer;
        const conversationId = response?.data?.conversation_id;

        await this.sendMessageWhatsApp(instance, remoteJid, message, settings);

        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'opened',
            awaitUser: true,
            sessionId: session.sessionId === remoteJid ? conversationId : session.sessionId,
          },
        });
      }

      if (dify.botType === 'textGenerator') {
        endpoint += '/completion-messages';
        const payload: any = {
          inputs: {
            query: content,
            pushName: pushName,
            remoteJid: remoteJid,
            instanceName: instance.instanceName,
            serverUrl: this.configService.get<HttpServer>('SERVER').URL,
            apiKey: this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY,
          },
          response_mode: 'blocking',
          conversation_id: session.sessionId === remoteJid ? undefined : session.sessionId,
          user: remoteJid,
        };

        if (this.isImageMessage(content)) {
          const contentSplit = content.split('|');

          payload.files = [
            {
              type: 'image',
              transfer_method: 'remote_url',
              url: contentSplit[1].split('?')[0],
            },
          ];
          payload.inputs.query = contentSplit[2] || content;
        }

        if (instance.integration === Integration.WHATSAPP_BAILEYS) {
          await instance.client.presenceSubscribe(remoteJid);
          await instance.client.sendPresenceUpdate('composing', remoteJid);
        }

        const response = await axios.post(endpoint, payload, {
          headers: {
            Authorization: `Bearer ${dify.apiKey}`,
          },
        });

        if (instance.integration === Integration.WHATSAPP_BAILEYS)
          await instance.client.sendPresenceUpdate('paused', remoteJid);

        const message = response?.data?.answer;
        const conversationId = response?.data?.conversation_id;

        await this.sendMessageWhatsApp(instance, remoteJid, message, settings);

        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'opened',
            awaitUser: true,
            sessionId: session.sessionId === remoteJid ? conversationId : session.sessionId,
          },
        });
      }

      if (dify.botType === 'agent') {
        endpoint += '/chat-messages';
        const payload: any = {
          inputs: {
            remoteJid: remoteJid,
            pushName: pushName,
            instanceName: instance.instanceName,
            serverUrl: this.configService.get<HttpServer>('SERVER').URL,
            apiKey: this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY,
          },
          query: content,
          response_mode: 'streaming',
          conversation_id: session.sessionId === remoteJid ? undefined : session.sessionId,
          user: remoteJid,
        };

        if (this.isImageMessage(content)) {
          const contentSplit = content.split('|');

          payload.files = [
            {
              type: 'image',
              transfer_method: 'remote_url',
              url: contentSplit[1].split('?')[0],
            },
          ];
          payload.query = contentSplit[2] || content;
        }

        if (instance.integration === Integration.WHATSAPP_BAILEYS) {
          await instance.client.presenceSubscribe(remoteJid);
          await instance.client.sendPresenceUpdate('composing', remoteJid);
        }

        const response = await axios.post(endpoint, payload, {
          headers: {
            Authorization: `Bearer ${dify.apiKey}`,
          },
        });

        let conversationId;
        let answer = '';

        const data = response.data.replaceAll('data: ', '');

        const events = data.split('\n').filter((line) => line.trim() !== '');

        for (const eventString of events) {
          if (eventString.trim().startsWith('{')) {
            const event = JSON.parse(eventString);

            if (event?.event === 'agent_message') {
              console.log('event:', event);
              conversationId = conversationId ?? event?.conversation_id;
              answer += event?.answer;
            }
          }
        }

        if (instance.integration === Integration.WHATSAPP_BAILEYS)
          await instance.client.sendPresenceUpdate('paused', remoteJid);

        const message = answer;

        await this.sendMessageWhatsApp(instance, remoteJid, message, settings);

        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'opened',
            awaitUser: true,
            sessionId: conversationId,
          },
        });

        return;
      }

      if (dify.botType === 'workflow') {
        endpoint += '/workflows/run';
        const payload: any = {
          inputs: {
            query: content,
            remoteJid: remoteJid,
            pushName: pushName,
            instanceName: instance.instanceName,
            serverUrl: this.configService.get<HttpServer>('SERVER').URL,
            apiKey: this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY,
          },
          response_mode: 'blocking',
          user: remoteJid,
        };

        if (this.isImageMessage(content)) {
          const contentSplit = content.split('|');

          payload.files = [
            {
              type: 'image',
              transfer_method: 'remote_url',
              url: contentSplit[1].split('?')[0],
            },
          ];
          payload.inputs.query = contentSplit[2] || content;
        }

        if (instance.integration === Integration.WHATSAPP_BAILEYS) {
          await instance.client.presenceSubscribe(remoteJid);
          await instance.client.sendPresenceUpdate('composing', remoteJid);
        }

        const response = await axios.post(endpoint, payload, {
          headers: {
            Authorization: `Bearer ${dify.apiKey}`,
          },
        });

        if (instance.integration === Integration.WHATSAPP_BAILEYS)
          await instance.client.sendPresenceUpdate('paused', remoteJid);

        const message = response?.data?.data.outputs.text;

        await this.sendMessageWhatsApp(instance, remoteJid, message, settings);

        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'opened',
            awaitUser: true,
          },
        });

        return;
      }
    } catch (error) {
      this.logger.error(error.response?.data || error);
      return;
    }
  }

  private async sendMessageWhatsApp(instance: any, remoteJid: string, message: string, settings: DifySetting) {
    const linkRegex = /(!?)\[(.*?)\]\((.*?)\)/g;

    let textBuffer = '';
    let lastIndex = 0;

    let match: RegExpExecArray | null;

    const getMediaType = (url: string): string | null => {
      const extension = url.split('.').pop()?.toLowerCase();
      const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'];
      const audioExtensions = ['mp3', 'wav', 'aac', 'ogg'];
      const videoExtensions = ['mp4', 'avi', 'mkv', 'mov'];
      const documentExtensions = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt'];

      if (imageExtensions.includes(extension || '')) return 'image';
      if (audioExtensions.includes(extension || '')) return 'audio';
      if (videoExtensions.includes(extension || '')) return 'video';
      if (documentExtensions.includes(extension || '')) return 'document';
      return null;
    };

    while ((match = linkRegex.exec(message)) !== null) {
      const [fullMatch, exclMark, altText, url] = match;
      const mediaType = getMediaType(url);

      const beforeText = message.slice(lastIndex, match.index);
      if (beforeText) {
        textBuffer += beforeText;
      }

      if (mediaType) {
        const splitMessages = settings.splitMessages ?? false;
        const timePerChar = settings.timePerChar ?? 0;
        const minDelay = 1000;
        const maxDelay = 20000;

        if (textBuffer.trim()) {
          if (splitMessages) {
            const multipleMessages = textBuffer.trim().split('\n\n');

            for (let index = 0; index < multipleMessages.length; index++) {
              const message = multipleMessages[index];

              const delay = Math.min(Math.max(message.length * timePerChar, minDelay), maxDelay);

              if (instance.integration === Integration.WHATSAPP_BAILEYS) {
                await instance.client.presenceSubscribe(remoteJid);
                await instance.client.sendPresenceUpdate('composing', remoteJid);
              }

              await new Promise<void>((resolve) => {
                setTimeout(async () => {
                  await instance.textMessage(
                    {
                      number: remoteJid.split('@')[0],
                      delay: settings?.delayMessage || 1000,
                      text: message,
                    },
                    false,
                  );
                  resolve();
                }, delay);
              });

              if (instance.integration === Integration.WHATSAPP_BAILEYS) {
                await instance.client.sendPresenceUpdate('paused', remoteJid);
              }
            }
          } else {
            await instance.textMessage(
              {
                number: remoteJid.split('@')[0],
                delay: settings?.delayMessage || 1000,
                text: textBuffer.trim(),
              },
              false,
            );
          }
          textBuffer = '';
        }

        if (mediaType === 'audio') {
          await instance.audioWhatsapp({
            number: remoteJid.split('@')[0],
            delay: settings?.delayMessage || 1000,
            audio: url,
            caption: altText,
          });
        } else {
          await instance.mediaMessage(
            {
              number: remoteJid.split('@')[0],
              delay: settings?.delayMessage || 1000,
              mediatype: mediaType,
              media: url,
              caption: altText,
            },
            null,
            false,
          );
        }
      } else {
        textBuffer += `[${altText}](${url})`;
      }

      lastIndex = linkRegex.lastIndex;
    }

    if (lastIndex < message.length) {
      const remainingText = message.slice(lastIndex);
      if (remainingText.trim()) {
        textBuffer += remainingText;
      }
    }

    const splitMessages = settings.splitMessages ?? false;
    const timePerChar = settings.timePerChar ?? 0;
    const minDelay = 1000;
    const maxDelay = 20000;

    if (textBuffer.trim()) {
      if (splitMessages) {
        const multipleMessages = textBuffer.trim().split('\n\n');

        for (let index = 0; index < multipleMessages.length; index++) {
          const message = multipleMessages[index];

          const delay = Math.min(Math.max(message.length * timePerChar, minDelay), maxDelay);

          if (instance.integration === Integration.WHATSAPP_BAILEYS) {
            await instance.client.presenceSubscribe(remoteJid);
            await instance.client.sendPresenceUpdate('composing', remoteJid);
          }

          await new Promise<void>((resolve) => {
            setTimeout(async () => {
              await instance.textMessage(
                {
                  number: remoteJid.split('@')[0],
                  delay: settings?.delayMessage || 1000,
                  text: message,
                },
                false,
              );
              resolve();
            }, delay);
          });

          if (instance.integration === Integration.WHATSAPP_BAILEYS) {
            await instance.client.sendPresenceUpdate('paused', remoteJid);
          }
        }
      } else {
        await instance.textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: settings?.delayMessage || 1000,
            text: textBuffer.trim(),
          },
          false,
        );
      }
    }

    sendTelemetry('/message/sendText');
  }

  private async initNewSession(
    instance: any,
    remoteJid: string,
    dify: Dify,
    settings: DifySetting,
    session: IntegrationSession,
    content: string,
    pushName?: string,
  ) {
    const data = await this.createNewSession(instance, {
      remoteJid,
      pushName,
      botId: dify.id,
    });

    if (data.session) {
      session = data.session;
    }

    await this.sendMessageToBot(instance, session, settings, dify, remoteJid, pushName, content);

    return;
  }

  public async processDify(
    instance: any,
    remoteJid: string,
    dify: Dify,
    session: IntegrationSession,
    settings: DifySetting,
    content: string,
    pushName?: string,
  ) {
    if (session && session.status !== 'opened') {
      return;
    }

    if (session && settings.expire && settings.expire > 0) {
      const now = Date.now();

      const sessionUpdatedAt = new Date(session.updatedAt).getTime();

      const diff = now - sessionUpdatedAt;

      const diffInMinutes = Math.floor(diff / 1000 / 60);

      if (diffInMinutes > settings.expire) {
        if (settings.keepOpen) {
          await this.prismaRepository.integrationSession.update({
            where: {
              id: session.id,
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.prismaRepository.integrationSession.deleteMany({
            where: {
              botId: dify.id,
              remoteJid: remoteJid,
            },
          });
        }

        await this.initNewSession(instance, remoteJid, dify, settings, session, content, pushName);
        return;
      }
    }

    if (!session) {
      await this.initNewSession(instance, remoteJid, dify, settings, session, content, pushName);
      return;
    }

    await this.prismaRepository.integrationSession.update({
      where: {
        id: session.id,
      },
      data: {
        status: 'opened',
        awaitUser: false,
      },
    });

    if (!content) {
      if (settings.unknownMessage) {
        this.waMonitor.waInstances[instance.instanceName].textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: settings.delayMessage || 1000,
            text: settings.unknownMessage,
          },
          false,
        );

        sendTelemetry('/message/sendText');
      }
      return;
    }

    if (settings.keywordFinish && content.toLowerCase() === settings.keywordFinish.toLowerCase()) {
      if (settings.keepOpen) {
        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'closed',
          },
        });
      } else {
        await this.prismaRepository.integrationSession.deleteMany({
          where: {
            botId: dify.id,
            remoteJid: remoteJid,
          },
        });
      }
      return;
    }

    await this.sendMessageToBot(instance, session, settings, dify, remoteJid, pushName, content);

    return;
  }
}



================================================
FILE: src/api/integrations/chatbot/dify/validate/dify.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const difySchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    enabled: { type: 'boolean' },
    description: { type: 'string' },
    botType: { type: 'string', enum: ['chatBot', 'textGenerator', 'agent', 'workflow'] },
    apiUrl: { type: 'string' },
    apiKey: { type: 'string' },
    triggerType: { type: 'string', enum: ['all', 'keyword', 'none', 'advanced'] },
    triggerOperator: { type: 'string', enum: ['equals', 'contains', 'startsWith', 'endsWith', 'regex'] },
    triggerValue: { type: 'string' },
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    keepOpen: { type: 'boolean' },
    debounceTime: { type: 'integer' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
    splitMessages: { type: 'boolean' },
    timePerChar: { type: 'integer' },
  },
  required: ['enabled', 'botType', 'triggerType'],
  ...isNotEmpty('enabled', 'botType', 'triggerType'),
};

export const difyStatusSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    status: { type: 'string', enum: ['opened', 'closed', 'paused', 'delete'] },
  },
  required: ['remoteJid', 'status'],
  ...isNotEmpty('remoteJid', 'status'),
};

export const difySettingSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    keepOpen: { type: 'boolean' },
    debounceTime: { type: 'integer' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
    difyIdFallback: { type: 'string' },
    splitMessages: { type: 'boolean' },
    timePerChar: { type: 'integer' },
  },
  required: [
    'expire',
    'keywordFinish',
    'delayMessage',
    'unknownMessage',
    'listeningFromMe',
    'stopBotFromMe',
    'keepOpen',
    'debounceTime',
    'ignoreJids',
    'splitMessages',
    'timePerChar',
  ],
  ...isNotEmpty(
    'expire',
    'keywordFinish',
    'delayMessage',
    'unknownMessage',
    'listeningFromMe',
    'stopBotFromMe',
    'keepOpen',
    'debounceTime',
    'ignoreJids',
    'splitMessages',
    'timePerChar',
  ),
};

export const difyIgnoreJidSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    action: { type: 'string', enum: ['add', 'remove'] },
  },
  required: ['remoteJid', 'action'],
  ...isNotEmpty('remoteJid', 'action'),
};



================================================
FILE: src/api/integrations/chatbot/evolutionBot/controllers/evolutionBot.controller.ts
================================================
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Logger } from '@config/logger.config';
import { EvolutionBot } from '@prisma/client';
import { getConversationMessage } from '@utils/getConversationMessage';

import { ChatbotController, ChatbotControllerInterface, EmitData } from '../../chatbot.controller';
import { EvolutionBotDto } from '../dto/evolutionBot.dto';
import { EvolutionBotService } from '../services/evolutionBot.service';

export class EvolutionBotController extends ChatbotController implements ChatbotControllerInterface {
  constructor(
    private readonly evolutionBotService: EvolutionBotService,
    prismaRepository: PrismaRepository,
    waMonitor: WAMonitoringService,
  ) {
    super(prismaRepository, waMonitor);

    this.botRepository = this.prismaRepository.evolutionBot;
    this.settingsRepository = this.prismaRepository.evolutionBotSetting;
    this.sessionRepository = this.prismaRepository.integrationSession;
  }

  public readonly logger = new Logger('EvolutionBotController');

  integrationEnabled: boolean;
  botRepository: any;
  settingsRepository: any;
  sessionRepository: any;
  userMessageDebounce: { [key: string]: { message: string; timeoutId: NodeJS.Timeout } } = {};

  // Bots
  public async createBot(instance: InstanceDto, data: EvolutionBotDto) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    if (
      !data.expire ||
      !data.keywordFinish ||
      !data.delayMessage ||
      !data.unknownMessage ||
      !data.listeningFromMe ||
      !data.stopBotFromMe ||
      !data.keepOpen ||
      !data.debounceTime ||
      !data.ignoreJids ||
      !data.splitMessages ||
      !data.timePerChar
    ) {
      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (data.expire === undefined || data.expire === null) data.expire = defaultSettingCheck.expire;
      if (data.keywordFinish === undefined || data.keywordFinish === null)
        data.keywordFinish = defaultSettingCheck.keywordFinish;
      if (data.delayMessage === undefined || data.delayMessage === null)
        data.delayMessage = defaultSettingCheck.delayMessage;
      if (data.unknownMessage === undefined || data.unknownMessage === null)
        data.unknownMessage = defaultSettingCheck.unknownMessage;
      if (data.listeningFromMe === undefined || data.listeningFromMe === null)
        data.listeningFromMe = defaultSettingCheck.listeningFromMe;
      if (data.stopBotFromMe === undefined || data.stopBotFromMe === null)
        data.stopBotFromMe = defaultSettingCheck.stopBotFromMe;
      if (data.keepOpen === undefined || data.keepOpen === null) data.keepOpen = defaultSettingCheck.keepOpen;
      if (data.debounceTime === undefined || data.debounceTime === null)
        data.debounceTime = defaultSettingCheck.debounceTime;
      if (data.ignoreJids === undefined || data.ignoreJids === null) data.ignoreJids = defaultSettingCheck.ignoreJids;
      if (data.splitMessages === undefined || data.splitMessages === null)
        data.splitMessages = defaultSettingCheck?.splitMessages ?? false;
      if (data.timePerChar === undefined || data.timePerChar === null)
        data.timePerChar = defaultSettingCheck?.timePerChar ?? 0;

      if (!defaultSettingCheck) {
        await this.settings(instance, {
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        });
      }
    }

    const checkTriggerAll = await this.botRepository.findFirst({
      where: {
        enabled: true,
        triggerType: 'all',
        instanceId: instanceId,
      },
    });

    if (checkTriggerAll && data.triggerType === 'all') {
      throw new Error('You already have a dify with an "All" trigger, you cannot have more bots while it is active');
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: {
        instanceId: instanceId,
        apiUrl: data.apiUrl,
        apiKey: data.apiKey,
      },
    });

    if (checkDuplicate) {
      throw new Error('Dify already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.create({
        data: {
          enabled: data?.enabled,
          description: data.description,
          apiUrl: data.apiUrl,
          apiKey: data.apiKey,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          instanceId: instanceId,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error creating bot');
    }
  }

  public async findBot(instance: InstanceDto) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bots = await this.botRepository.findMany({
      where: {
        instanceId: instanceId,
      },
    });

    if (!bots.length) {
      return null;
    }

    return bots;
  }

  public async fetchBot(instance: InstanceDto, botId: string) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Bot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Bot not found');
    }

    return bot;
  }

  public async updateBot(instance: InstanceDto, botId: string, data: EvolutionBotDto) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Bot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Bot not found');
    }

    if (data.triggerType === 'all') {
      const checkTriggerAll = await this.botRepository.findFirst({
        where: {
          enabled: true,
          triggerType: 'all',
          id: {
            not: botId,
          },
          instanceId: instanceId,
        },
      });

      if (checkTriggerAll) {
        throw new Error('You already have a bot with an "All" trigger, you cannot have more bots while it is active');
      }
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: {
        id: {
          not: botId,
        },
        instanceId: instanceId,
        apiUrl: data.apiUrl,
        apiKey: data.apiKey,
      },
    });

    if (checkDuplicate) {
      throw new Error('Bot already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          id: { not: botId },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          id: { not: botId },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.update({
        where: {
          id: botId,
        },
        data: {
          enabled: data?.enabled,
          description: data.description,
          apiUrl: data.apiUrl,
          apiKey: data.apiKey,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          instanceId: instanceId,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error updating bot');
    }
  }

  public async deleteBot(instance: InstanceDto, botId: string) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Bot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Bot not found');
    }
    try {
      await this.prismaRepository.integrationSession.deleteMany({
        where: {
          botId: botId,
        },
      });

      await this.botRepository.delete({
        where: {
          id: botId,
        },
      });

      return { bot: { id: botId } };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error deleting bot');
    }
  }

  // Settings
  public async settings(instance: InstanceDto, data: any) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (settings) {
        const updateSettings = await this.settingsRepository.update({
          where: {
            id: settings.id,
          },
          data: {
            expire: data.expire,
            keywordFinish: data.keywordFinish,
            delayMessage: data.delayMessage,
            unknownMessage: data.unknownMessage,
            listeningFromMe: data.listeningFromMe,
            stopBotFromMe: data.stopBotFromMe,
            keepOpen: data.keepOpen,
            debounceTime: data.debounceTime,
            botIdFallback: data.botIdFallback,
            ignoreJids: data.ignoreJids,
            splitMessages: data.splitMessages,
            timePerChar: data.timePerChar,
          },
        });

        return {
          expire: updateSettings.expire,
          keywordFinish: updateSettings.keywordFinish,
          delayMessage: updateSettings.delayMessage,
          unknownMessage: updateSettings.unknownMessage,
          listeningFromMe: updateSettings.listeningFromMe,
          stopBotFromMe: updateSettings.stopBotFromMe,
          keepOpen: updateSettings.keepOpen,
          debounceTime: updateSettings.debounceTime,
          botIdFallback: updateSettings.botIdFallback,
          ignoreJids: updateSettings.ignoreJids,
          splitMessages: updateSettings.splitMessages,
          timePerChar: updateSettings.timePerChar,
        };
      }

      const newSetttings = await this.settingsRepository.create({
        data: {
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          botIdFallback: data.botIdFallback,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
          instanceId: instanceId,
        },
      });

      return {
        expire: newSetttings.expire,
        keywordFinish: newSetttings.keywordFinish,
        delayMessage: newSetttings.delayMessage,
        unknownMessage: newSetttings.unknownMessage,
        listeningFromMe: newSetttings.listeningFromMe,
        stopBotFromMe: newSetttings.stopBotFromMe,
        keepOpen: newSetttings.keepOpen,
        debounceTime: newSetttings.debounceTime,
        botIdFallback: newSetttings.botIdFallback,
        ignoreJids: newSetttings.ignoreJids,
        splitMessages: newSetttings.splitMessages,
        timePerChar: newSetttings.timePerChar,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  public async fetchSettings(instance: InstanceDto) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
        include: {
          Fallback: true,
        },
      });

      if (!settings) {
        return {
          expire: 0,
          keywordFinish: '',
          delayMessage: 0,
          unknownMessage: '',
          listeningFromMe: false,
          stopBotFromMe: false,
          keepOpen: false,
          ignoreJids: [],
          splitMessages: false,
          timePerChar: 0,
          botIdFallback: '',
          fallback: null,
        };
      }

      return {
        expire: settings.expire,
        keywordFinish: settings.keywordFinish,
        delayMessage: settings.delayMessage,
        unknownMessage: settings.unknownMessage,
        listeningFromMe: settings.listeningFromMe,
        stopBotFromMe: settings.stopBotFromMe,
        keepOpen: settings.keepOpen,
        ignoreJids: settings.ignoreJids,
        splitMessages: settings.splitMessages,
        timePerChar: settings.timePerChar,
        botIdFallback: settings.botIdFallback,
        fallback: settings.Fallback,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching default settings');
    }
  }

  // Sessions
  public async changeStatus(instance: InstanceDto, data: any) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId,
        },
      });

      const remoteJid = data.remoteJid;
      const status = data.status;

      if (status === 'delete') {
        await this.sessionRepository.deleteMany({
          where: {
            remoteJid: remoteJid,
            botId: { not: null },
          },
        });

        return { bot: { remoteJid: remoteJid, status: status } };
      }

      if (status === 'closed') {
        if (defaultSettingCheck?.keepOpen) {
          await this.sessionRepository.updateMany({
            where: {
              remoteJid: remoteJid,
              botId: { not: null },
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.sessionRepository.deleteMany({
            where: {
              remoteJid: remoteJid,
              botId: { not: null },
            },
          });
        }

        return { bot: { ...instance, bot: { remoteJid: remoteJid, status: status } } };
      } else {
        const session = await this.sessionRepository.updateMany({
          where: {
            instanceId: instanceId,
            remoteJid: remoteJid,
            botId: { not: null },
          },
          data: {
            status: status,
          },
        });

        const botData = {
          remoteJid: remoteJid,
          status: status,
          session,
        };

        return { bot: { ...instance, bot: botData } };
      }
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error changing status');
    }
  }

  public async fetchSessions(instance: InstanceDto, botId: string, remoteJid?: string) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const bot = await this.botRepository.findFirst({
        where: {
          id: botId,
        },
      });

      if (bot && bot.instanceId !== instanceId) {
        throw new Error('Dify not found');
      }

      return await this.sessionRepository.findMany({
        where: {
          instanceId: instanceId,
          remoteJid,
          botId: bot ? botId : { not: null },
          type: 'evolution',
        },
      });
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching sessions');
    }
  }

  public async ignoreJid(instance: InstanceDto, data: IgnoreJidDto) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (!settings) {
        throw new Error('Settings not found');
      }

      let ignoreJids: any = settings?.ignoreJids || [];

      if (data.action === 'add') {
        if (ignoreJids.includes(data.remoteJid)) return { ignoreJids: ignoreJids };

        ignoreJids.push(data.remoteJid);
      } else {
        ignoreJids = ignoreJids.filter((jid) => jid !== data.remoteJid);
      }

      const updateSettings = await this.settingsRepository.update({
        where: {
          id: settings.id,
        },
        data: {
          ignoreJids: ignoreJids,
        },
      });

      return {
        ignoreJids: updateSettings.ignoreJids,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  // Emit
  public async emit({ instance, remoteJid, msg }: EmitData) {
    try {
      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instance.instanceId,
        },
      });

      if (this.checkIgnoreJids(settings?.ignoreJids, remoteJid)) return;

      const session = await this.getSession(remoteJid, instance);

      const content = getConversationMessage(msg);

      let findBot = (await this.findBotTrigger(this.botRepository, content, instance, session)) as EvolutionBot;

      if (!findBot) {
        const fallback = await this.settingsRepository.findFirst({
          where: {
            instanceId: instance.instanceId,
          },
        });

        if (fallback?.botIdFallback) {
          const findFallback = await this.botRepository.findFirst({
            where: {
              id: fallback.botIdFallback,
            },
          });

          findBot = findFallback;
        } else {
          return;
        }
      }

      let expire = findBot?.expire;
      let keywordFinish = findBot?.keywordFinish;
      let delayMessage = findBot?.delayMessage;
      let unknownMessage = findBot?.unknownMessage;
      let listeningFromMe = findBot?.listeningFromMe;
      let stopBotFromMe = findBot?.stopBotFromMe;
      let keepOpen = findBot?.keepOpen;
      let debounceTime = findBot?.debounceTime;
      let ignoreJids = findBot?.ignoreJids;
      let splitMessages = findBot?.splitMessages;
      let timePerChar = findBot?.timePerChar;

      if (expire === undefined || expire === null) expire = settings.expire;
      if (keywordFinish === undefined || keywordFinish === null) keywordFinish = settings.keywordFinish;
      if (delayMessage === undefined || delayMessage === null) delayMessage = settings.delayMessage;
      if (unknownMessage === undefined || unknownMessage === null) unknownMessage = settings.unknownMessage;
      if (listeningFromMe === undefined || listeningFromMe === null) listeningFromMe = settings.listeningFromMe;
      if (stopBotFromMe === undefined || stopBotFromMe === null) stopBotFromMe = settings.stopBotFromMe;
      if (keepOpen === undefined || keepOpen === null) keepOpen = settings.keepOpen;
      if (debounceTime === undefined || debounceTime === null) debounceTime = settings.debounceTime;
      if (ignoreJids === undefined || ignoreJids === null) ignoreJids = settings.ignoreJids;
      if (splitMessages === undefined || splitMessages === null) splitMessages = settings?.splitMessages ?? false;
      if (timePerChar === undefined || timePerChar === null) timePerChar = settings?.timePerChar ?? 0;

      const key = msg.key as {
        id: string;
        remoteJid: string;
        fromMe: boolean;
        participant: string;
      };

      if (stopBotFromMe && key.fromMe && session) {
        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'paused',
          },
        });
        return;
      }

      if (!listeningFromMe && key.fromMe) {
        return;
      }

      if (session && !session.awaitUser) {
        return;
      }

      if (debounceTime && debounceTime > 0) {
        this.processDebounce(this.userMessageDebounce, content, remoteJid, debounceTime, async (debouncedContent) => {
          await this.evolutionBotService.processBot(
            this.waMonitor.waInstances[instance.instanceName],
            remoteJid,
            findBot,
            session,
            {
              ...settings,
              expire,
              keywordFinish,
              delayMessage,
              unknownMessage,
              listeningFromMe,
              stopBotFromMe,
              keepOpen,
              debounceTime,
              ignoreJids,
              splitMessages,
              timePerChar,
            },
            debouncedContent,
            msg?.pushName,
          );
        });
      } else {
        await this.evolutionBotService.processBot(
          this.waMonitor.waInstances[instance.instanceName],
          remoteJid,
          findBot,
          session,
          {
            ...settings,
            expire,
            keywordFinish,
            delayMessage,
            unknownMessage,
            listeningFromMe,
            stopBotFromMe,
            keepOpen,
            debounceTime,
            ignoreJids,
            splitMessages,
            timePerChar,
          },
          content,
          msg?.pushName,
        );
      }

      return;
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }
}



================================================
FILE: src/api/integrations/chatbot/evolutionBot/dto/evolutionBot.dto.ts
================================================
import { TriggerOperator, TriggerType } from '@prisma/client';

export class EvolutionBotDto {
  enabled?: boolean;
  description?: string;
  apiUrl?: string;
  apiKey?: string;
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  triggerType?: TriggerType;
  triggerOperator?: TriggerOperator;
  triggerValue?: string;
  ignoreJids?: any;
  splitMessages?: boolean;
  timePerChar?: number;
}

export class EvolutionBotSettingDto {
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  botIdFallback?: string;
  ignoreJids?: any;
  splitMessages?: boolean;
  timePerChar?: number;
}



================================================
FILE: src/api/integrations/chatbot/evolutionBot/routes/evolutionBot.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { HttpStatus } from '@api/routes/index.router';
import { evolutionBotController } from '@api/server.module';
import { instanceSchema } from '@validate/instance.schema';
import { RequestHandler, Router } from 'express';

import { EvolutionBotDto, EvolutionBotSettingDto } from '../dto/evolutionBot.dto';
import {
  evolutionBotIgnoreJidSchema,
  evolutionBotSchema,
  evolutionBotSettingSchema,
  evolutionBotStatusSchema,
} from '../validate/evolutionBot.schema';

export class EvolutionBotRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('create'), ...guards, async (req, res) => {
        const response = await this.dataValidate<EvolutionBotDto>({
          request: req,
          schema: evolutionBotSchema,
          ClassRef: EvolutionBotDto,
          execute: (instance, data) => evolutionBotController.createBot(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => evolutionBotController.findBot(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetch/:evolutionBotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => evolutionBotController.fetchBot(instance, req.params.evolutionBotId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .put(this.routerPath('update/:evolutionBotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<EvolutionBotDto>({
          request: req,
          schema: evolutionBotSchema,
          ClassRef: EvolutionBotDto,
          execute: (instance, data) => evolutionBotController.updateBot(instance, req.params.evolutionBotId, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .delete(this.routerPath('delete/:evolutionBotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => evolutionBotController.deleteBot(instance, req.params.evolutionBotId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('settings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<EvolutionBotSettingDto>({
          request: req,
          schema: evolutionBotSettingSchema,
          ClassRef: EvolutionBotSettingDto,
          execute: (instance, data) => evolutionBotController.settings(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSettings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => evolutionBotController.fetchSettings(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('changeStatus'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: evolutionBotStatusSchema,
          ClassRef: InstanceDto,
          execute: (instance, data) => evolutionBotController.changeStatus(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSessions/:evolutionBotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => evolutionBotController.fetchSessions(instance, req.params.evolutionBotId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('ignoreJid'), ...guards, async (req, res) => {
        const response = await this.dataValidate<IgnoreJidDto>({
          request: req,
          schema: evolutionBotIgnoreJidSchema,
          ClassRef: IgnoreJidDto,
          execute: (instance, data) => evolutionBotController.ignoreJid(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/chatbot/evolutionBot/services/evolutionBot.service.ts
================================================
/* eslint-disable @typescript-eslint/no-unused-vars */
import { InstanceDto } from '@api/dto/instance.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Integration } from '@api/types/wa.types';
import { Auth, ConfigService, HttpServer } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { EvolutionBot, EvolutionBotSetting, IntegrationSession } from '@prisma/client';
import { sendTelemetry } from '@utils/sendTelemetry';
import axios from 'axios';

export class EvolutionBotService {
  constructor(
    private readonly waMonitor: WAMonitoringService,
    private readonly configService: ConfigService,
    private readonly prismaRepository: PrismaRepository,
  ) {}

  private readonly logger = new Logger('EvolutionBotService');

  public async createNewSession(instance: InstanceDto, data: any) {
    try {
      const session = await this.prismaRepository.integrationSession.create({
        data: {
          remoteJid: data.remoteJid,
          pushName: data.pushName,
          sessionId: data.remoteJid,
          status: 'opened',
          awaitUser: false,
          botId: data.botId,
          instanceId: instance.instanceId,
          type: 'evolution',
        },
      });

      return { session };
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }

  private isImageMessage(content: string) {
    return content.includes('imageMessage');
  }

  private async sendMessageToBot(
    instance: any,
    session: IntegrationSession,
    bot: EvolutionBot,
    remoteJid: string,
    pushName: string,
    content: string,
  ) {
    const payload: any = {
      inputs: {
        sessionId: session.id,
        remoteJid: remoteJid,
        pushName: pushName,
        instanceName: instance.instanceName,
        serverUrl: this.configService.get<HttpServer>('SERVER').URL,
        apiKey: this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY,
      },
      query: content,
      conversation_id: session.sessionId === remoteJid ? undefined : session.sessionId,
      user: remoteJid,
    };

    if (this.isImageMessage(content)) {
      const contentSplit = content.split('|');

      payload.files = [
        {
          type: 'image',
          url: contentSplit[1].split('?')[0],
        },
      ];
      payload.query = contentSplit[2] || content;
    }

    if (instance.integration === Integration.WHATSAPP_BAILEYS) {
      await instance.client.presenceSubscribe(remoteJid);
      await instance.client.sendPresenceUpdate('composing', remoteJid);
    }

    let headers: any = {
      'Content-Type': 'application/json',
    };

    if (bot.apiKey) {
      headers = {
        ...headers,
        Authorization: `Bearer ${bot.apiKey}`,
      };
    }

    const response = await axios.post(bot.apiUrl, payload, {
      headers,
    });

    if (instance.integration === Integration.WHATSAPP_BAILEYS)
      await instance.client.sendPresenceUpdate('paused', remoteJid);

    const message = response?.data?.message;

    return message;
  }

  private async sendMessageWhatsApp(
    instance: any,
    remoteJid: string,
    session: IntegrationSession,
    settings: EvolutionBotSetting,
    message: string,
  ) {
    const linkRegex = /(!?)\[(.*?)\]\((.*?)\)/g;

    let textBuffer = '';
    let lastIndex = 0;

    let match: RegExpExecArray | null;

    const getMediaType = (url: string): string | null => {
      const extension = url.split('.').pop()?.toLowerCase();
      const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'];
      const audioExtensions = ['mp3', 'wav', 'aac', 'ogg'];
      const videoExtensions = ['mp4', 'avi', 'mkv', 'mov'];
      const documentExtensions = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt'];

      if (imageExtensions.includes(extension || '')) return 'image';
      if (audioExtensions.includes(extension || '')) return 'audio';
      if (videoExtensions.includes(extension || '')) return 'video';
      if (documentExtensions.includes(extension || '')) return 'document';
      return null;
    };

    while ((match = linkRegex.exec(message)) !== null) {
      const [fullMatch, exclMark, altText, url] = match;
      const mediaType = getMediaType(url);

      const beforeText = message.slice(lastIndex, match.index);
      if (beforeText) {
        textBuffer += beforeText;
      }

      if (mediaType) {
        const splitMessages = settings.splitMessages ?? false;
        const timePerChar = settings.timePerChar ?? 0;
        const minDelay = 1000;
        const maxDelay = 20000;

        if (textBuffer.trim()) {
          if (splitMessages) {
            const multipleMessages = textBuffer.trim().split('\n\n');

            for (let index = 0; index < multipleMessages.length; index++) {
              const message = multipleMessages[index];

              const delay = Math.min(Math.max(message.length * timePerChar, minDelay), maxDelay);

              if (instance.integration === Integration.WHATSAPP_BAILEYS) {
                await instance.client.presenceSubscribe(remoteJid);
                await instance.client.sendPresenceUpdate('composing', remoteJid);
              }

              await new Promise<void>((resolve) => {
                setTimeout(async () => {
                  await instance.textMessage(
                    {
                      number: remoteJid.split('@')[0],
                      delay: settings?.delayMessage || 1000,
                      text: message,
                    },
                    false,
                  );
                  resolve();
                }, delay);
              });

              if (instance.integration === Integration.WHATSAPP_BAILEYS) {
                await instance.client.sendPresenceUpdate('paused', remoteJid);
              }
            }
          } else {
            await instance.textMessage(
              {
                number: remoteJid.split('@')[0],
                delay: settings?.delayMessage || 1000,
                text: textBuffer.trim(),
              },
              false,
            );
          }
          textBuffer = '';
        }

        if (mediaType === 'audio') {
          await instance.audioWhatsapp({
            number: remoteJid.split('@')[0],
            delay: settings?.delayMessage || 1000,
            audio: url,
            caption: altText,
          });
        } else {
          await instance.mediaMessage(
            {
              number: remoteJid.split('@')[0],
              delay: settings?.delayMessage || 1000,
              mediatype: mediaType,
              media: url,
              caption: altText,
            },
            null,
            false,
          );
        }
      } else {
        textBuffer += `[${altText}](${url})`;
      }

      lastIndex = linkRegex.lastIndex;
    }

    if (lastIndex < message.length) {
      const remainingText = message.slice(lastIndex);
      if (remainingText.trim()) {
        textBuffer += remainingText;
      }
    }

    const splitMessages = settings.splitMessages ?? false;
    const timePerChar = settings.timePerChar ?? 0;
    const minDelay = 1000;
    const maxDelay = 20000;

    if (textBuffer.trim()) {
      if (splitMessages) {
        const multipleMessages = textBuffer.trim().split('\n\n');

        for (let index = 0; index < multipleMessages.length; index++) {
          const message = multipleMessages[index];

          const delay = Math.min(Math.max(message.length * timePerChar, minDelay), maxDelay);

          if (instance.integration === Integration.WHATSAPP_BAILEYS) {
            await instance.client.presenceSubscribe(remoteJid);
            await instance.client.sendPresenceUpdate('composing', remoteJid);
          }

          await new Promise<void>((resolve) => {
            setTimeout(async () => {
              await instance.textMessage(
                {
                  number: remoteJid.split('@')[0],
                  delay: settings?.delayMessage || 1000,
                  text: message,
                },
                false,
              );
              resolve();
            }, delay);
          });

          if (instance.integration === Integration.WHATSAPP_BAILEYS) {
            await instance.client.sendPresenceUpdate('paused', remoteJid);
          }
        }
      } else {
        await instance.textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: settings?.delayMessage || 1000,
            text: textBuffer.trim(),
          },
          false,
        );
      }
      textBuffer = '';
    }

    sendTelemetry('/message/sendText');

    await this.prismaRepository.integrationSession.update({
      where: {
        id: session.id,
      },
      data: {
        status: 'opened',
        awaitUser: true,
      },
    });
  }

  private async initNewSession(
    instance: any,
    remoteJid: string,
    bot: EvolutionBot,
    settings: EvolutionBotSetting,
    session: IntegrationSession,
    content: string,
    pushName?: string,
  ) {
    const data = await this.createNewSession(instance, {
      remoteJid,
      pushName,
      botId: bot.id,
    });

    if (data.session) {
      session = data.session;
    }

    const message = await this.sendMessageToBot(instance, session, bot, remoteJid, pushName, content);

    if (!message) return;

    await this.sendMessageWhatsApp(instance, remoteJid, session, settings, message);

    return;
  }

  public async processBot(
    instance: any,
    remoteJid: string,
    bot: EvolutionBot,
    session: IntegrationSession,
    settings: EvolutionBotSetting,
    content: string,
    pushName?: string,
  ) {
    if (session && session.status !== 'opened') {
      return;
    }

    if (session && settings.expire && settings.expire > 0) {
      const now = Date.now();

      const sessionUpdatedAt = new Date(session.updatedAt).getTime();

      const diff = now - sessionUpdatedAt;

      const diffInMinutes = Math.floor(diff / 1000 / 60);

      if (diffInMinutes > settings.expire) {
        if (settings.keepOpen) {
          await this.prismaRepository.integrationSession.update({
            where: {
              id: session.id,
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.prismaRepository.integrationSession.deleteMany({
            where: {
              botId: bot.id,
              remoteJid: remoteJid,
            },
          });
        }

        await this.initNewSession(instance, remoteJid, bot, settings, session, content, pushName);
        return;
      }
    }

    if (!session) {
      await this.initNewSession(instance, remoteJid, bot, settings, session, content, pushName);
      return;
    }

    await this.prismaRepository.integrationSession.update({
      where: {
        id: session.id,
      },
      data: {
        status: 'opened',
        awaitUser: false,
      },
    });

    if (!content) {
      if (settings.unknownMessage) {
        this.waMonitor.waInstances[instance.instanceName].textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: settings.delayMessage || 1000,
            text: settings.unknownMessage,
          },
          false,
        );

        sendTelemetry('/message/sendText');
      }
      return;
    }

    if (settings.keywordFinish && content.toLowerCase() === settings.keywordFinish.toLowerCase()) {
      if (settings.keepOpen) {
        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'closed',
          },
        });
      } else {
        await this.prismaRepository.integrationSession.deleteMany({
          where: {
            botId: bot.id,
            remoteJid: remoteJid,
          },
        });
      }
      return;
    }

    const message = await this.sendMessageToBot(instance, session, bot, remoteJid, pushName, content);

    if (!message) return;

    await this.sendMessageWhatsApp(instance, remoteJid, session, settings, message);

    return;
  }
}



================================================
FILE: src/api/integrations/chatbot/evolutionBot/validate/evolutionBot.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const evolutionBotSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    enabled: { type: 'boolean' },
    description: { type: 'string' },
    apiUrl: { type: 'string' },
    apiKey: { type: 'string' },
    triggerType: { type: 'string', enum: ['all', 'keyword', 'none', 'advanced'] },
    triggerOperator: { type: 'string', enum: ['equals', 'contains', 'startsWith', 'endsWith', 'regex'] },
    triggerValue: { type: 'string' },
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    keepOpen: { type: 'boolean' },
    debounceTime: { type: 'integer' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
    splitMessages: { type: 'boolean' },
    timePerChar: { type: 'integer' },
  },
  required: ['enabled', 'apiUrl', 'triggerType'],
  ...isNotEmpty('enabled', 'apiUrl', 'triggerType'),
};

export const evolutionBotStatusSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    status: { type: 'string', enum: ['opened', 'closed', 'paused', 'delete'] },
  },
  required: ['remoteJid', 'status'],
  ...isNotEmpty('remoteJid', 'status'),
};

export const evolutionBotSettingSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    keepOpen: { type: 'boolean' },
    debounceTime: { type: 'integer' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
    botIdFallback: { type: 'string' },
    splitMessages: { type: 'boolean' },
    timePerChar: { type: 'integer' },
  },
  required: [
    'expire',
    'keywordFinish',
    'delayMessage',
    'unknownMessage',
    'listeningFromMe',
    'stopBotFromMe',
    'keepOpen',
    'debounceTime',
    'ignoreJids',
    'splitMessages',
    'timePerChar',
  ],
  ...isNotEmpty(
    'expire',
    'keywordFinish',
    'delayMessage',
    'unknownMessage',
    'listeningFromMe',
    'stopBotFromMe',
    'keepOpen',
    'debounceTime',
    'ignoreJids',
    'splitMessages',
    'timePerChar',
  ),
};

export const evolutionBotIgnoreJidSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    action: { type: 'string', enum: ['add', 'remove'] },
  },
  required: ['remoteJid', 'action'],
  ...isNotEmpty('remoteJid', 'action'),
};



================================================
FILE: src/api/integrations/chatbot/flowise/controllers/flowise.controller.ts
================================================
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Logger } from '@config/logger.config';
import { Flowise } from '@prisma/client';
import { getConversationMessage } from '@utils/getConversationMessage';

import { ChatbotController, ChatbotControllerInterface, EmitData } from '../../chatbot.controller';
import { FlowiseDto } from '../dto/flowise.dto';
import { FlowiseService } from '../services/flowise.service';

export class FlowiseController extends ChatbotController implements ChatbotControllerInterface {
  constructor(
    private readonly flowiseService: FlowiseService,
    prismaRepository: PrismaRepository,
    waMonitor: WAMonitoringService,
  ) {
    super(prismaRepository, waMonitor);

    this.botRepository = this.prismaRepository.flowise;
    this.settingsRepository = this.prismaRepository.flowiseSetting;
    this.sessionRepository = this.prismaRepository.integrationSession;
  }

  public readonly logger = new Logger('FlowiseController');

  integrationEnabled: boolean;
  botRepository: any;
  settingsRepository: any;
  sessionRepository: any;
  userMessageDebounce: { [key: string]: { message: string; timeoutId: NodeJS.Timeout } } = {};

  // Bots
  public async createBot(instance: InstanceDto, data: FlowiseDto) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    if (
      !data.expire ||
      !data.keywordFinish ||
      !data.delayMessage ||
      !data.unknownMessage ||
      !data.listeningFromMe ||
      !data.stopBotFromMe ||
      !data.keepOpen ||
      !data.debounceTime ||
      !data.ignoreJids ||
      !data.splitMessages ||
      !data.timePerChar
    ) {
      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (data.expire === undefined || data.expire === null) data.expire = defaultSettingCheck.expire;
      if (data.keywordFinish === undefined || data.keywordFinish === null)
        data.keywordFinish = defaultSettingCheck.keywordFinish;
      if (data.delayMessage === undefined || data.delayMessage === null)
        data.delayMessage = defaultSettingCheck.delayMessage;
      if (data.unknownMessage === undefined || data.unknownMessage === null)
        data.unknownMessage = defaultSettingCheck.unknownMessage;
      if (data.listeningFromMe === undefined || data.listeningFromMe === null)
        data.listeningFromMe = defaultSettingCheck.listeningFromMe;
      if (data.stopBotFromMe === undefined || data.stopBotFromMe === null)
        data.stopBotFromMe = defaultSettingCheck.stopBotFromMe;
      if (data.keepOpen === undefined || data.keepOpen === null) data.keepOpen = defaultSettingCheck.keepOpen;
      if (data.debounceTime === undefined || data.debounceTime === null)
        data.debounceTime = defaultSettingCheck.debounceTime;
      if (data.ignoreJids === undefined || data.ignoreJids === null) data.ignoreJids = defaultSettingCheck.ignoreJids;
      if (data.splitMessages === undefined || data.splitMessages === null)
        data.splitMessages = defaultSettingCheck?.splitMessages ?? false;
      if (data.timePerChar === undefined || data.timePerChar === null)
        data.timePerChar = defaultSettingCheck?.timePerChar ?? 0;

      if (!defaultSettingCheck) {
        await this.settings(instance, {
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        });
      }
    }

    const checkTriggerAll = await this.botRepository.findFirst({
      where: {
        enabled: true,
        triggerType: 'all',
        instanceId: instanceId,
      },
    });

    if (checkTriggerAll && data.triggerType === 'all') {
      throw new Error('You already have a Flowise with an "All" trigger, you cannot have more bots while it is active');
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: {
        instanceId: instanceId,
        apiUrl: data.apiUrl,
        apiKey: data.apiKey,
      },
    });

    if (checkDuplicate) {
      throw new Error('Flowise already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.create({
        data: {
          enabled: data?.enabled,
          description: data.description,
          apiUrl: data.apiUrl,
          apiKey: data.apiKey,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          instanceId: instanceId,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error creating bot');
    }
  }

  public async findBot(instance: InstanceDto) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bots = await this.botRepository.findMany({
      where: {
        instanceId: instanceId,
      },
    });

    if (!bots.length) {
      return null;
    }

    return bots;
  }

  public async fetchBot(instance: InstanceDto, botId: string) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Bot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Bot not found');
    }

    return bot;
  }

  public async updateBot(instance: InstanceDto, botId: string, data: FlowiseDto) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Bot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Bot not found');
    }

    if (data.triggerType === 'all') {
      const checkTriggerAll = await this.botRepository.findFirst({
        where: {
          enabled: true,
          triggerType: 'all',
          id: {
            not: botId,
          },
          instanceId: instanceId,
        },
      });

      if (checkTriggerAll) {
        throw new Error('You already have a bot with an "All" trigger, you cannot have more bots while it is active');
      }
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: {
        id: {
          not: botId,
        },
        instanceId: instanceId,
        apiUrl: data.apiUrl,
        apiKey: data.apiKey,
      },
    });

    if (checkDuplicate) {
      throw new Error('Bot already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          id: { not: botId },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          id: { not: botId },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.update({
        where: {
          id: botId,
        },
        data: {
          enabled: data?.enabled,
          description: data.description,
          apiUrl: data.apiUrl,
          apiKey: data.apiKey,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          instanceId: instanceId,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error updating bot');
    }
  }

  public async deleteBot(instance: InstanceDto, botId: string) {
    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Bot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Bot not found');
    }
    try {
      await this.prismaRepository.integrationSession.deleteMany({
        where: {
          botId: botId,
        },
      });

      await this.botRepository.delete({
        where: {
          id: botId,
        },
      });

      return { bot: { id: botId } };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error deleting bot');
    }
  }

  // Settings
  public async settings(instance: InstanceDto, data: any) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (settings) {
        const updateSettings = await this.settingsRepository.update({
          where: {
            id: settings.id,
          },
          data: {
            expire: data.expire,
            keywordFinish: data.keywordFinish,
            delayMessage: data.delayMessage,
            unknownMessage: data.unknownMessage,
            listeningFromMe: data.listeningFromMe,
            stopBotFromMe: data.stopBotFromMe,
            keepOpen: data.keepOpen,
            debounceTime: data.debounceTime,
            flowiseIdFallback: data.flowiseIdFallback,
            ignoreJids: data.ignoreJids,
            splitMessages: data.splitMessages,
            timePerChar: data.timePerChar,
          },
        });

        return {
          expire: updateSettings.expire,
          keywordFinish: updateSettings.keywordFinish,
          delayMessage: updateSettings.delayMessage,
          unknownMessage: updateSettings.unknownMessage,
          listeningFromMe: updateSettings.listeningFromMe,
          stopBotFromMe: updateSettings.stopBotFromMe,
          keepOpen: updateSettings.keepOpen,
          debounceTime: updateSettings.debounceTime,
          flowiseIdFallback: updateSettings.flowiseIdFallback,
          ignoreJids: updateSettings.ignoreJids,
          splitMessages: updateSettings.splitMessages,
          timePerChar: updateSettings.timePerChar,
        };
      }

      const newSetttings = await this.settingsRepository.create({
        data: {
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          flowiseIdFallback: data.flowiseIdFallback,
          ignoreJids: data.ignoreJids,
          instanceId: instanceId,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return {
        expire: newSetttings.expire,
        keywordFinish: newSetttings.keywordFinish,
        delayMessage: newSetttings.delayMessage,
        unknownMessage: newSetttings.unknownMessage,
        listeningFromMe: newSetttings.listeningFromMe,
        stopBotFromMe: newSetttings.stopBotFromMe,
        keepOpen: newSetttings.keepOpen,
        debounceTime: newSetttings.debounceTime,
        flowiseIdFallback: newSetttings.flowiseIdFallback,
        ignoreJids: newSetttings.ignoreJids,
        splitMessages: newSetttings.splitMessages,
        timePerChar: newSetttings.timePerChar,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  public async fetchSettings(instance: InstanceDto) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
        include: {
          Fallback: true,
        },
      });

      if (!settings) {
        return {
          expire: 0,
          keywordFinish: '',
          delayMessage: 0,
          unknownMessage: '',
          listeningFromMe: false,
          stopBotFromMe: false,
          keepOpen: false,
          ignoreJids: [],
          splitMessages: false,
          timePerChar: 0,
          flowiseIdFallback: '',
          fallback: null,
        };
      }

      return {
        expire: settings.expire,
        keywordFinish: settings.keywordFinish,
        delayMessage: settings.delayMessage,
        unknownMessage: settings.unknownMessage,
        listeningFromMe: settings.listeningFromMe,
        stopBotFromMe: settings.stopBotFromMe,
        keepOpen: settings.keepOpen,
        ignoreJids: settings.ignoreJids,
        splitMessages: settings.splitMessages,
        timePerChar: settings.timePerChar,
        flowiseIdFallback: settings.flowiseIdFallback,
        fallback: settings.Fallback,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching default settings');
    }
  }

  // Sessions
  public async changeStatus(instance: InstanceDto, data: any) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId,
        },
      });

      const remoteJid = data.remoteJid;
      const status = data.status;

      if (status === 'delete') {
        await this.sessionRepository.deleteMany({
          where: {
            remoteJid: remoteJid,
            botId: { not: null },
          },
        });

        return { bot: { remoteJid: remoteJid, status: status } };
      }

      if (status === 'closed') {
        if (defaultSettingCheck?.keepOpen) {
          await this.sessionRepository.updateMany({
            where: {
              remoteJid: remoteJid,
              botId: { not: null },
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.sessionRepository.deleteMany({
            where: {
              remoteJid: remoteJid,
              botId: { not: null },
            },
          });
        }

        return { bot: { ...instance, bot: { remoteJid: remoteJid, status: status } } };
      } else {
        const session = await this.sessionRepository.updateMany({
          where: {
            instanceId: instanceId,
            remoteJid: remoteJid,
            botId: { not: null },
          },
          data: {
            status: status,
          },
        });

        const botData = {
          remoteJid: remoteJid,
          status: status,
          session,
        };

        return { bot: { ...instance, bot: botData } };
      }
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error changing status');
    }
  }

  public async fetchSessions(instance: InstanceDto, botId: string, remoteJid?: string) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const bot = await this.botRepository.findFirst({
        where: {
          id: botId,
        },
      });

      if (bot && bot.instanceId !== instanceId) {
        throw new Error('Dify not found');
      }

      return await this.sessionRepository.findMany({
        where: {
          instanceId: instanceId,
          remoteJid,
          botId: bot ? botId : { not: null },
          type: 'flowise',
        },
      });
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching sessions');
    }
  }

  public async ignoreJid(instance: InstanceDto, data: IgnoreJidDto) {
    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (!settings) {
        throw new Error('Settings not found');
      }

      let ignoreJids: any = settings?.ignoreJids || [];

      if (data.action === 'add') {
        if (ignoreJids.includes(data.remoteJid)) return { ignoreJids: ignoreJids };

        ignoreJids.push(data.remoteJid);
      } else {
        ignoreJids = ignoreJids.filter((jid) => jid !== data.remoteJid);
      }

      const updateSettings = await this.settingsRepository.update({
        where: {
          id: settings.id,
        },
        data: {
          ignoreJids: ignoreJids,
        },
      });

      return {
        ignoreJids: updateSettings.ignoreJids,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  // Emit
  public async emit({ instance, remoteJid, msg }: EmitData) {
    try {
      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instance.instanceId,
        },
      });

      if (this.checkIgnoreJids(settings?.ignoreJids, remoteJid)) return;

      const session = await this.getSession(remoteJid, instance);

      const content = getConversationMessage(msg);

      let findBot = (await this.findBotTrigger(this.botRepository, content, instance, session)) as Flowise;

      if (!findBot) {
        const fallback = await this.settingsRepository.findFirst({
          where: {
            instanceId: instance.instanceId,
          },
        });

        if (fallback?.flowiseIdFallback) {
          const findFallback = await this.botRepository.findFirst({
            where: {
              id: fallback.flowiseIdFallback,
            },
          });

          findBot = findFallback;
        } else {
          return;
        }
      }

      let expire = findBot?.expire;
      let keywordFinish = findBot?.keywordFinish;
      let delayMessage = findBot?.delayMessage;
      let unknownMessage = findBot?.unknownMessage;
      let listeningFromMe = findBot?.listeningFromMe;
      let stopBotFromMe = findBot?.stopBotFromMe;
      let keepOpen = findBot?.keepOpen;
      let debounceTime = findBot?.debounceTime;
      let ignoreJids = findBot?.ignoreJids;
      let splitMessages = findBot?.splitMessages;
      let timePerChar = findBot?.timePerChar;

      if (expire === undefined || expire === null) expire = settings.expire;
      if (keywordFinish === undefined || keywordFinish === null) keywordFinish = settings.keywordFinish;
      if (delayMessage === undefined || delayMessage === null) delayMessage = settings.delayMessage;
      if (unknownMessage === undefined || unknownMessage === null) unknownMessage = settings.unknownMessage;
      if (listeningFromMe === undefined || listeningFromMe === null) listeningFromMe = settings.listeningFromMe;
      if (stopBotFromMe === undefined || stopBotFromMe === null) stopBotFromMe = settings.stopBotFromMe;
      if (keepOpen === undefined || keepOpen === null) keepOpen = settings.keepOpen;
      if (debounceTime === undefined || debounceTime === null) debounceTime = settings.debounceTime;
      if (ignoreJids === undefined || ignoreJids === null) ignoreJids = settings.ignoreJids;
      if (splitMessages === undefined || splitMessages === null) splitMessages = settings?.splitMessages ?? false;
      if (timePerChar === undefined || timePerChar === null) timePerChar = settings?.timePerChar ?? 0;

      const key = msg.key as {
        id: string;
        remoteJid: string;
        fromMe: boolean;
        participant: string;
      };

      if (stopBotFromMe && key.fromMe && session) {
        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'paused',
          },
        });
        return;
      }

      if (!listeningFromMe && key.fromMe) {
        return;
      }

      if (session && !session.awaitUser) {
        return;
      }

      if (debounceTime && debounceTime > 0) {
        this.processDebounce(this.userMessageDebounce, content, remoteJid, debounceTime, async (debouncedContent) => {
          await this.flowiseService.processBot(
            this.waMonitor.waInstances[instance.instanceName],
            remoteJid,
            findBot,
            session,
            {
              ...settings,
              expire,
              keywordFinish,
              delayMessage,
              unknownMessage,
              listeningFromMe,
              stopBotFromMe,
              keepOpen,
              debounceTime,
              ignoreJids,
              splitMessages,
              timePerChar,
            },
            debouncedContent,
            msg?.pushName,
          );
        });
      } else {
        await this.flowiseService.processBot(
          this.waMonitor.waInstances[instance.instanceName],
          remoteJid,
          findBot,
          session,
          {
            ...settings,
            expire,
            keywordFinish,
            delayMessage,
            unknownMessage,
            listeningFromMe,
            stopBotFromMe,
            keepOpen,
            debounceTime,
            ignoreJids,
            splitMessages,
            timePerChar,
          },
          content,
          msg?.pushName,
        );
      }

      return;
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }
}



================================================
FILE: src/api/integrations/chatbot/flowise/dto/flowise.dto.ts
================================================
import { TriggerOperator, TriggerType } from '@prisma/client';

export class FlowiseDto {
  enabled?: boolean;
  description?: string;
  apiUrl?: string;
  apiKey?: string;
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  triggerType?: TriggerType;
  triggerOperator?: TriggerOperator;
  triggerValue?: string;
  ignoreJids?: any;
  splitMessages?: boolean;
  timePerChar?: number;
}

export class FlowiseSettingDto {
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  flowiseIdFallback?: string;
  ignoreJids?: any;
  splitMessages?: boolean;
  timePerChar?: number;
}



================================================
FILE: src/api/integrations/chatbot/flowise/routes/flowise.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { HttpStatus } from '@api/routes/index.router';
import { flowiseController } from '@api/server.module';
import { instanceSchema } from '@validate/instance.schema';
import { RequestHandler, Router } from 'express';

import { FlowiseDto, FlowiseSettingDto } from '../dto/flowise.dto';
import {
  flowiseIgnoreJidSchema,
  flowiseSchema,
  flowiseSettingSchema,
  flowiseStatusSchema,
} from '../validate/flowise.schema';

export class FlowiseRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('create'), ...guards, async (req, res) => {
        const response = await this.dataValidate<FlowiseDto>({
          request: req,
          schema: flowiseSchema,
          ClassRef: FlowiseDto,
          execute: (instance, data) => flowiseController.createBot(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => flowiseController.findBot(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetch/:flowiseId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => flowiseController.fetchBot(instance, req.params.flowiseId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .put(this.routerPath('update/:flowiseId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<FlowiseDto>({
          request: req,
          schema: flowiseSchema,
          ClassRef: FlowiseDto,
          execute: (instance, data) => flowiseController.updateBot(instance, req.params.flowiseId, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .delete(this.routerPath('delete/:flowiseId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => flowiseController.deleteBot(instance, req.params.flowiseId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('settings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<FlowiseSettingDto>({
          request: req,
          schema: flowiseSettingSchema,
          ClassRef: FlowiseSettingDto,
          execute: (instance, data) => flowiseController.settings(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSettings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => flowiseController.fetchSettings(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('changeStatus'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: flowiseStatusSchema,
          ClassRef: InstanceDto,
          execute: (instance, data) => flowiseController.changeStatus(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSessions/:flowiseId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => flowiseController.fetchSessions(instance, req.params.flowiseId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('ignoreJid'), ...guards, async (req, res) => {
        const response = await this.dataValidate<IgnoreJidDto>({
          request: req,
          schema: flowiseIgnoreJidSchema,
          ClassRef: IgnoreJidDto,
          execute: (instance, data) => flowiseController.ignoreJid(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/chatbot/flowise/services/flowise.service.ts
================================================
/* eslint-disable @typescript-eslint/no-unused-vars */
import { InstanceDto } from '@api/dto/instance.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Integration } from '@api/types/wa.types';
import { Auth, ConfigService, HttpServer } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { Flowise, FlowiseSetting, IntegrationSession } from '@prisma/client';
import { sendTelemetry } from '@utils/sendTelemetry';
import axios from 'axios';

export class FlowiseService {
  constructor(
    private readonly waMonitor: WAMonitoringService,
    private readonly configService: ConfigService,
    private readonly prismaRepository: PrismaRepository,
  ) {}

  private readonly logger = new Logger('FlowiseService');

  public async createNewSession(instance: InstanceDto, data: any) {
    try {
      const session = await this.prismaRepository.integrationSession.create({
        data: {
          remoteJid: data.remoteJid,
          pushName: data.pushName,
          sessionId: data.remoteJid,
          status: 'opened',
          awaitUser: false,
          botId: data.botId,
          instanceId: instance.instanceId,
          type: 'flowise',
        },
      });

      return { session };
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }

  private isImageMessage(content: string) {
    return content.includes('imageMessage');
  }

  private async sendMessageToBot(instance: any, bot: Flowise, remoteJid: string, pushName: string, content: string) {
    const payload: any = {
      question: content,
      overrideConfig: {
        sessionId: remoteJid,
        vars: {
          remoteJid: remoteJid,
          pushName: pushName,
          instanceName: instance.instanceName,
          serverUrl: this.configService.get<HttpServer>('SERVER').URL,
          apiKey: this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY,
        },
      },
    };

    if (this.isImageMessage(content)) {
      const contentSplit = content.split('|');

      payload.uploads = [
        {
          data: contentSplit[1].split('?')[0],
          type: 'url',
          name: 'Flowise.png',
          mime: 'image/png',
        },
      ];
      payload.question = contentSplit[2] || content;
    }

    if (instance.integration === Integration.WHATSAPP_BAILEYS) {
      await instance.client.presenceSubscribe(remoteJid);
      await instance.client.sendPresenceUpdate('composing', remoteJid);
    }

    let headers: any = {
      'Content-Type': 'application/json',
    };

    if (bot.apiKey) {
      headers = {
        ...headers,
        Authorization: `Bearer ${bot.apiKey}`,
      };
    }

    const endpoint = bot.apiUrl;

    if (!endpoint) return null;

    const response = await axios.post(endpoint, payload, {
      headers,
    });

    if (instance.integration === Integration.WHATSAPP_BAILEYS)
      await instance.client.sendPresenceUpdate('paused', remoteJid);

    const message = response?.data?.text;

    return message;
  }

  private async sendMessageWhatsApp(
    instance: any,
    remoteJid: string,
    session: IntegrationSession,
    settings: FlowiseSetting,
    message: string,
  ) {
    const linkRegex = /(!?)\[(.*?)\]\((.*?)\)/g;

    let textBuffer = '';
    let lastIndex = 0;

    let match: RegExpExecArray | null;

    const getMediaType = (url: string): string | null => {
      const extension = url.split('.').pop()?.toLowerCase();
      const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'];
      const audioExtensions = ['mp3', 'wav', 'aac', 'ogg'];
      const videoExtensions = ['mp4', 'avi', 'mkv', 'mov'];
      const documentExtensions = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt'];

      if (imageExtensions.includes(extension || '')) return 'image';
      if (audioExtensions.includes(extension || '')) return 'audio';
      if (videoExtensions.includes(extension || '')) return 'video';
      if (documentExtensions.includes(extension || '')) return 'document';
      return null;
    };

    while ((match = linkRegex.exec(message)) !== null) {
      const [fullMatch, exclMark, altText, url] = match;
      const mediaType = getMediaType(url);

      const beforeText = message.slice(lastIndex, match.index);
      if (beforeText) {
        textBuffer += beforeText;
      }

      if (mediaType) {
        const splitMessages = settings.splitMessages ?? false;
        const timePerChar = settings.timePerChar ?? 0;
        const minDelay = 1000;
        const maxDelay = 20000;

        if (textBuffer.trim()) {
          if (splitMessages) {
            const multipleMessages = textBuffer.trim().split('\n\n');

            for (let index = 0; index < multipleMessages.length; index++) {
              const message = multipleMessages[index];

              const delay = Math.min(Math.max(message.length * timePerChar, minDelay), maxDelay);

              if (instance.integration === Integration.WHATSAPP_BAILEYS) {
                await instance.client.presenceSubscribe(remoteJid);
                await instance.client.sendPresenceUpdate('composing', remoteJid);
              }

              await new Promise<void>((resolve) => {
                setTimeout(async () => {
                  await instance.textMessage(
                    {
                      number: remoteJid.split('@')[0],
                      delay: settings?.delayMessage || 1000,
                      text: message,
                    },
                    false,
                  );
                  resolve();
                }, delay);
              });

              if (instance.integration === Integration.WHATSAPP_BAILEYS) {
                await instance.client.sendPresenceUpdate('paused', remoteJid);
              }
            }
          } else {
            await instance.textMessage(
              {
                number: remoteJid.split('@')[0],
                delay: settings?.delayMessage || 1000,
                text: textBuffer.trim(),
              },
              false,
            );
          }
          textBuffer = '';
        }

        if (mediaType === 'audio') {
          await instance.audioWhatsapp({
            number: remoteJid.split('@')[0],
            delay: settings?.delayMessage || 1000,
            audio: url,
            caption: altText,
          });
        } else {
          await instance.mediaMessage(
            {
              number: remoteJid.split('@')[0],
              delay: settings?.delayMessage || 1000,
              mediatype: mediaType,
              media: url,
              caption: altText,
            },
            null,
            false,
          );
        }
      } else {
        textBuffer += `[${altText}](${url})`;
      }

      lastIndex = linkRegex.lastIndex;
    }

    if (lastIndex < message.length) {
      const remainingText = message.slice(lastIndex);
      if (remainingText.trim()) {
        textBuffer += remainingText;
      }
    }

    const splitMessages = settings.splitMessages ?? false;
    const timePerChar = settings.timePerChar ?? 0;
    const minDelay = 1000;
    const maxDelay = 20000;

    if (textBuffer.trim()) {
      if (splitMessages) {
        const multipleMessages = textBuffer.trim().split('\n\n');

        for (let index = 0; index < multipleMessages.length; index++) {
          const message = multipleMessages[index];

          const delay = Math.min(Math.max(message.length * timePerChar, minDelay), maxDelay);

          if (instance.integration === Integration.WHATSAPP_BAILEYS) {
            await instance.client.presenceSubscribe(remoteJid);
            await instance.client.sendPresenceUpdate('composing', remoteJid);
          }

          await new Promise<void>((resolve) => {
            setTimeout(async () => {
              await instance.textMessage(
                {
                  number: remoteJid.split('@')[0],
                  delay: settings?.delayMessage || 1000,
                  text: message,
                },
                false,
              );
              resolve();
            }, delay);
          });

          if (instance.integration === Integration.WHATSAPP_BAILEYS) {
            await instance.client.sendPresenceUpdate('paused', remoteJid);
          }
        }
      } else {
        await instance.textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: settings?.delayMessage || 1000,
            text: textBuffer.trim(),
          },
          false,
        );
      }
      textBuffer = '';
    }

    sendTelemetry('/message/sendText');

    await this.prismaRepository.integrationSession.update({
      where: {
        id: session.id,
      },
      data: {
        status: 'opened',
        awaitUser: true,
      },
    });

    return;
  }

  private async initNewSession(
    instance: any,
    remoteJid: string,
    bot: Flowise,
    settings: FlowiseSetting,
    session: IntegrationSession,
    content: string,
    pushName?: string,
  ) {
    const data = await this.createNewSession(instance, {
      remoteJid,
      pushName,
      botId: bot.id,
    });

    if (data.session) {
      session = data.session;
    }

    const message = await this.sendMessageToBot(instance, bot, remoteJid, pushName, content);

    await this.sendMessageWhatsApp(instance, remoteJid, session, settings, message);

    return;
  }

  public async processBot(
    instance: any,
    remoteJid: string,
    bot: Flowise,
    session: IntegrationSession,
    settings: FlowiseSetting,
    content: string,
    pushName?: string,
  ) {
    if (session && session.status !== 'opened') {
      return;
    }

    if (session && settings.expire && settings.expire > 0) {
      const now = Date.now();

      const sessionUpdatedAt = new Date(session.updatedAt).getTime();

      const diff = now - sessionUpdatedAt;

      const diffInMinutes = Math.floor(diff / 1000 / 60);

      if (diffInMinutes > settings.expire) {
        if (settings.keepOpen) {
          await this.prismaRepository.integrationSession.update({
            where: {
              id: session.id,
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.prismaRepository.integrationSession.deleteMany({
            where: {
              botId: bot.id,
              remoteJid: remoteJid,
            },
          });
        }

        await this.initNewSession(instance, remoteJid, bot, settings, session, content, pushName);
        return;
      }
    }

    if (!session) {
      await this.initNewSession(instance, remoteJid, bot, settings, session, content, pushName);
      return;
    }

    await this.prismaRepository.integrationSession.update({
      where: {
        id: session.id,
      },
      data: {
        status: 'opened',
        awaitUser: false,
      },
    });

    if (!content) {
      if (settings.unknownMessage) {
        this.waMonitor.waInstances[instance.instanceName].textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: settings.delayMessage || 1000,
            text: settings.unknownMessage,
          },
          false,
        );

        sendTelemetry('/message/sendText');
      }
      return;
    }

    if (settings.keywordFinish && content.toLowerCase() === settings.keywordFinish.toLowerCase()) {
      if (settings.keepOpen) {
        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'closed',
          },
        });
      } else {
        await this.prismaRepository.integrationSession.deleteMany({
          where: {
            botId: bot.id,
            remoteJid: remoteJid,
          },
        });
      }
      return;
    }

    const message = await this.sendMessageToBot(instance, bot, remoteJid, pushName, content);

    await this.sendMessageWhatsApp(instance, remoteJid, session, settings, message);

    return;
  }
}



================================================
FILE: src/api/integrations/chatbot/flowise/validate/flowise.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const flowiseSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    enabled: { type: 'boolean' },
    description: { type: 'string' },
    apiUrl: { type: 'string' },
    apiKey: { type: 'string' },
    triggerType: { type: 'string', enum: ['all', 'keyword', 'none', 'advanced'] },
    triggerOperator: { type: 'string', enum: ['equals', 'contains', 'startsWith', 'endsWith', 'regex'] },
    triggerValue: { type: 'string' },
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    keepOpen: { type: 'boolean' },
    debounceTime: { type: 'integer' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
  },
  required: ['enabled', 'apiUrl', 'triggerType'],
  ...isNotEmpty('enabled', 'apiUrl', 'triggerType'),
};

export const flowiseStatusSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    status: { type: 'string', enum: ['opened', 'closed', 'paused', 'delete'] },
  },
  required: ['remoteJid', 'status'],
  ...isNotEmpty('remoteJid', 'status'),
};

export const flowiseSettingSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    keepOpen: { type: 'boolean' },
    debounceTime: { type: 'integer' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
    botIdFallback: { type: 'string' },
  },
  required: [
    'expire',
    'keywordFinish',
    'delayMessage',
    'unknownMessage',
    'listeningFromMe',
    'stopBotFromMe',
    'keepOpen',
    'debounceTime',
    'ignoreJids',
  ],
  ...isNotEmpty(
    'expire',
    'keywordFinish',
    'delayMessage',
    'unknownMessage',
    'listeningFromMe',
    'stopBotFromMe',
    'keepOpen',
    'debounceTime',
    'ignoreJids',
  ),
};

export const flowiseIgnoreJidSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    action: { type: 'string', enum: ['add', 'remove'] },
  },
  required: ['remoteJid', 'action'],
  ...isNotEmpty('remoteJid', 'action'),
};



================================================
FILE: src/api/integrations/chatbot/openai/controllers/openai.controller.ts
================================================
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { OpenaiCredsDto, OpenaiDto } from '@api/integrations/chatbot/openai/dto/openai.dto';
import { OpenaiService } from '@api/integrations/chatbot/openai/services/openai.service';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { configService, Openai } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { BadRequestException } from '@exceptions';
import { OpenaiBot } from '@prisma/client';
import { getConversationMessage } from '@utils/getConversationMessage';
import OpenAI from 'openai';

import { ChatbotController, ChatbotControllerInterface, EmitData } from '../../chatbot.controller';

export class OpenaiController extends ChatbotController implements ChatbotControllerInterface {
  constructor(
    private readonly openaiService: OpenaiService,
    prismaRepository: PrismaRepository,
    waMonitor: WAMonitoringService,
  ) {
    super(prismaRepository, waMonitor);

    this.botRepository = this.prismaRepository.openaiBot;
    this.settingsRepository = this.prismaRepository.openaiSetting;
    this.sessionRepository = this.prismaRepository.integrationSession;
    this.credsRepository = this.prismaRepository.openaiCreds;
  }

  public readonly logger = new Logger('OpenaiController');

  integrationEnabled = configService.get<Openai>('OPENAI').ENABLED;
  botRepository: any;
  settingsRepository: any;
  sessionRepository: any;
  userMessageDebounce: { [key: string]: { message: string; timeoutId: NodeJS.Timeout } } = {};
  private client: OpenAI;
  private credsRepository: any;

  // Credentials
  public async createOpenaiCreds(instance: InstanceDto, data: OpenaiCredsDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    if (!data.apiKey) throw new Error('API Key is required');
    if (!data.name) throw new Error('Name is required');

    try {
      const creds = await this.credsRepository.create({
        data: {
          name: data.name,
          apiKey: data.apiKey,
          instanceId: instanceId,
        },
      });

      return creds;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error creating openai creds');
    }
  }

  public async findOpenaiCreds(instance: InstanceDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const creds = await this.credsRepository.findMany({
      where: {
        instanceId: instanceId,
      },
      include: {
        OpenaiAssistant: true,
      },
    });

    return creds;
  }

  public async deleteCreds(instance: InstanceDto, openaiCredsId: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const creds = await this.credsRepository.findFirst({
      where: {
        id: openaiCredsId,
      },
    });

    if (!creds) {
      throw new Error('Openai Creds not found');
    }

    if (creds.instanceId !== instanceId) {
      throw new Error('Openai Creds not found');
    }

    try {
      await this.credsRepository.delete({
        where: {
          id: openaiCredsId,
        },
      });

      return { openaiCreds: { id: openaiCredsId } };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error deleting openai creds');
    }
  }

  // Models
  public async getModels(instance: InstanceDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    if (!instanceId) throw new Error('Instance not found');

    const defaultSettings = await this.settingsRepository.findFirst({
      where: {
        instanceId: instanceId,
      },
      include: {
        OpenaiCreds: true,
      },
    });

    if (!defaultSettings) throw new Error('Settings not found');

    const { apiKey } = defaultSettings.OpenaiCreds;

    try {
      this.client = new OpenAI({ apiKey });

      const models: any = await this.client.models.list();

      return models?.body?.data;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching models');
    }
  }

  // Bots
  public async createBot(instance: InstanceDto, data: OpenaiDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    if (
      !data.openaiCredsId ||
      !data.expire ||
      !data.keywordFinish ||
      !data.delayMessage ||
      !data.unknownMessage ||
      !data.listeningFromMe ||
      !data.stopBotFromMe ||
      !data.keepOpen ||
      !data.debounceTime ||
      !data.ignoreJids ||
      !data.splitMessages ||
      !data.timePerChar
    ) {
      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (data.expire === undefined || data.expire === null) data.expire = defaultSettingCheck.expire;
      if (data.keywordFinish === undefined || data.keywordFinish === null)
        data.keywordFinish = defaultSettingCheck.keywordFinish;
      if (data.delayMessage === undefined || data.delayMessage === null)
        data.delayMessage = defaultSettingCheck.delayMessage;
      if (data.unknownMessage === undefined || data.unknownMessage === null)
        data.unknownMessage = defaultSettingCheck.unknownMessage;
      if (data.listeningFromMe === undefined || data.listeningFromMe === null)
        data.listeningFromMe = defaultSettingCheck.listeningFromMe;
      if (data.stopBotFromMe === undefined || data.stopBotFromMe === null)
        data.stopBotFromMe = defaultSettingCheck.stopBotFromMe;
      if (data.keepOpen === undefined || data.keepOpen === null) data.keepOpen = defaultSettingCheck.keepOpen;
      if (data.debounceTime === undefined || data.debounceTime === null)
        data.debounceTime = defaultSettingCheck.debounceTime;
      if (data.ignoreJids === undefined || data.ignoreJids === null) data.ignoreJids = defaultSettingCheck.ignoreJids;
      if (data.splitMessages === undefined || data.splitMessages === null)
        data.splitMessages = defaultSettingCheck?.splitMessages ?? false;
      if (data.timePerChar === undefined || data.timePerChar === null)
        data.timePerChar = defaultSettingCheck?.timePerChar ?? 0;

      if (!data.openaiCredsId) {
        throw new Error('Openai Creds Id is required');
      }

      if (!defaultSettingCheck) {
        await this.settings(instance, {
          openaiCredsId: data.openaiCredsId,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        });
      }
    }

    const checkTriggerAll = await this.botRepository.findFirst({
      where: {
        enabled: true,
        triggerType: 'all',
        instanceId: instanceId,
      },
    });

    if (checkTriggerAll && data.triggerType === 'all') {
      throw new Error('You already have a openai with an "All" trigger, you cannot have more bots while it is active');
    }

    let whereDuplication: any = {
      instanceId: instanceId,
    };

    if (data.botType === 'assistant') {
      if (!data.assistantId) throw new Error('Assistant ID is required');

      whereDuplication = {
        ...whereDuplication,
        assistantId: data.assistantId,
        botType: data.botType,
      };
    } else if (data.botType === 'chatCompletion') {
      if (!data.model) throw new Error('Model is required');
      if (!data.maxTokens) throw new Error('Max tokens is required');

      whereDuplication = {
        ...whereDuplication,
        model: data.model,
        maxTokens: data.maxTokens,
        botType: data.botType,
      };
    } else {
      throw new Error('Bot type is required');
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: whereDuplication,
    });

    if (checkDuplicate) {
      throw new Error('Openai Bot already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.create({
        data: {
          enabled: data?.enabled,
          description: data.description,
          openaiCredsId: data.openaiCredsId,
          botType: data.botType,
          assistantId: data.assistantId,
          functionUrl: data.functionUrl,
          model: data.model,
          systemMessages: data.systemMessages,
          assistantMessages: data.assistantMessages,
          userMessages: data.userMessages,
          maxTokens: data.maxTokens,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          instanceId: instanceId,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error creating openai bot');
    }
  }

  public async findBot(instance: InstanceDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bots = await this.botRepository.findMany({
      where: {
        instanceId,
      },
    });

    if (!bots.length) {
      return null;
    }

    return bots;
  }

  public async fetchBot(instance: InstanceDto, botId: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Openai Bot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Openai Bot not found');
    }

    return bot;
  }

  public async updateBot(instance: InstanceDto, botId: string, data: OpenaiDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Openai Bot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Openai Bot not found');
    }

    if (data.triggerType === 'all') {
      const checkTriggerAll = await this.botRepository.findFirst({
        where: {
          enabled: true,
          triggerType: 'all',
          id: {
            not: botId,
          },
          instanceId: instanceId,
        },
      });

      if (checkTriggerAll) {
        throw new Error(
          'You already have a openai bot with an "All" trigger, you cannot have more bots while it is active',
        );
      }
    }

    let whereDuplication: any = {
      id: {
        not: botId,
      },
      instanceId: instanceId,
    };

    if (data.botType === 'assistant') {
      if (!data.assistantId) throw new Error('Assistant ID is required');

      whereDuplication = {
        ...whereDuplication,
        assistantId: data.assistantId,
      };
    } else if (data.botType === 'chatCompletion') {
      if (!data.model) throw new Error('Model is required');
      if (!data.maxTokens) throw new Error('Max tokens is required');

      whereDuplication = {
        ...whereDuplication,
        model: data.model,
        maxTokens: data.maxTokens,
      };
    } else {
      throw new Error('Bot type is required');
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: whereDuplication,
    });

    if (checkDuplicate) {
      throw new Error('Openai Bot already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          id: { not: botId },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          id: { not: botId },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.update({
        where: {
          id: botId,
        },
        data: {
          enabled: data?.enabled,
          description: data.description,
          openaiCredsId: data.openaiCredsId,
          botType: data.botType,
          assistantId: data.assistantId,
          functionUrl: data.functionUrl,
          model: data.model,
          systemMessages: data.systemMessages,
          assistantMessages: data.assistantMessages,
          userMessages: data.userMessages,
          maxTokens: data.maxTokens,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          instanceId: instanceId,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error updating openai bot');
    }
  }

  public async deleteBot(instance: InstanceDto, botId: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Openai bot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Openai bot not found');
    }
    try {
      await this.sessionRepository.deleteMany({
        where: {
          botId: botId,
        },
      });

      await this.botRepository.delete({
        where: {
          id: botId,
        },
      });

      return { bot: { id: botId } };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error deleting openai bot');
    }
  }

  // Settings
  public async settings(instance: InstanceDto, data: any) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (settings) {
        const updateSettings = await this.settingsRepository.update({
          where: {
            id: settings.id,
          },
          data: {
            openaiCredsId: data.openaiCredsId,
            expire: data.expire,
            keywordFinish: data.keywordFinish,
            delayMessage: data.delayMessage,
            unknownMessage: data.unknownMessage,
            listeningFromMe: data.listeningFromMe,
            stopBotFromMe: data.stopBotFromMe,
            keepOpen: data.keepOpen,
            debounceTime: data.debounceTime,
            speechToText: data.speechToText,
            openaiIdFallback: data.openaiIdFallback,
            ignoreJids: data.ignoreJids,
            splitMessages: data.splitMessages,
            timePerChar: data.timePerChar,
          },
        });

        return {
          openaiCredsId: updateSettings.openaiCredsId,
          expire: updateSettings.expire,
          keywordFinish: updateSettings.keywordFinish,
          delayMessage: updateSettings.delayMessage,
          unknownMessage: updateSettings.unknownMessage,
          listeningFromMe: updateSettings.listeningFromMe,
          stopBotFromMe: updateSettings.stopBotFromMe,
          keepOpen: updateSettings.keepOpen,
          debounceTime: updateSettings.debounceTime,
          speechToText: updateSettings.speechToText,
          openaiIdFallback: updateSettings.openaiIdFallback,
          ignoreJids: updateSettings.ignoreJids,
          splitMessages: updateSettings.splitMessages,
          timePerChar: updateSettings.timePerChar,
        };
      }

      const newSetttings = await this.settingsRepository.create({
        data: {
          openaiCredsId: data.openaiCredsId,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          openaiIdFallback: data.openaiIdFallback,
          ignoreJids: data.ignoreJids,
          speechToText: data.speechToText,
          instanceId: instanceId,
          splitMessages: data.splitMessages,
          timePerChar: data.timePerChar,
        },
      });

      return {
        openaiCredsId: newSetttings.openaiCredsId,
        expire: newSetttings.expire,
        keywordFinish: newSetttings.keywordFinish,
        delayMessage: newSetttings.delayMessage,
        unknownMessage: newSetttings.unknownMessage,
        listeningFromMe: newSetttings.listeningFromMe,
        stopBotFromMe: newSetttings.stopBotFromMe,
        keepOpen: newSetttings.keepOpen,
        debounceTime: newSetttings.debounceTime,
        openaiIdFallback: newSetttings.openaiIdFallback,
        ignoreJids: newSetttings.ignoreJids,
        speechToText: newSetttings.speechToText,
        splitMessages: newSetttings.splitMessages,
        timePerChar: newSetttings.timePerChar,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  public async fetchSettings(instance: InstanceDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    try {
      const instanceId = (
        await this.prismaRepository.instance.findFirst({
          select: { id: true },
          where: {
            name: instance.instanceName,
          },
        })
      )?.id;

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
        include: {
          Fallback: true,
        },
      });

      if (!settings) {
        return {
          openaiCredsId: null,
          expire: 0,
          keywordFinish: '',
          delayMessage: 0,
          unknownMessage: '',
          listeningFromMe: false,
          stopBotFromMe: false,
          keepOpen: false,
          ignoreJids: [],
          splitMessages: false,
          timePerChar: 0,
          openaiIdFallback: null,
          speechToText: false,
          fallback: null,
        };
      }

      return {
        openaiCredsId: settings.openaiCredsId,
        expire: settings.expire,
        keywordFinish: settings.keywordFinish,
        delayMessage: settings.delayMessage,
        unknownMessage: settings.unknownMessage,
        listeningFromMe: settings.listeningFromMe,
        stopBotFromMe: settings.stopBotFromMe,
        keepOpen: settings.keepOpen,
        ignoreJids: settings.ignoreJids,
        splitMessages: settings.splitMessages,
        timePerChar: settings.timePerChar,
        openaiIdFallback: settings.openaiIdFallback,
        speechToText: settings.speechToText,
        fallback: settings.Fallback,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching default settings');
    }
  }

  // Sessions
  public async changeStatus(instance: InstanceDto, data: any) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId,
        },
      });

      const remoteJid = data.remoteJid;
      const status = data.status;

      if (status === 'delete') {
        await this.sessionRepository.deleteMany({
          where: {
            remoteJid: remoteJid,
            botId: { not: null },
          },
        });

        return { openai: { remoteJid: remoteJid, status: status } };
      }

      if (status === 'closed') {
        if (defaultSettingCheck?.keepOpen) {
          await this.sessionRepository.updateMany({
            where: {
              remoteJid: remoteJid,
              botId: { not: null },
              status: { not: 'closed' },
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.sessionRepository.deleteMany({
            where: {
              remoteJid: remoteJid,
            },
          });
        }

        return { openai: { ...instance, openai: { remoteJid: remoteJid, status: status } } };
      } else {
        const session = await this.sessionRepository.updateMany({
          where: {
            instanceId: instanceId,
            remoteJid: remoteJid,
            botId: { not: null },
          },
          data: {
            status: status,
          },
        });

        const openaiData = {
          remoteJid: remoteJid,
          status: status,
          session,
        };

        return { openai: { ...instance, openai: openaiData } };
      }
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error changing status');
    }
  }

  public async fetchSessions(instance: InstanceDto, botId: string, remoteJid?: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const openaiBot = await this.botRepository.findFirst({
        where: {
          id: botId,
        },
      });

      if (openaiBot && openaiBot.instanceId !== instanceId) {
        throw new Error('Openai Bot not found');
      }

      return await this.sessionRepository.findMany({
        where: {
          instanceId: instanceId,
          remoteJid,
          botId: openaiBot ? botId : { not: null },
          type: 'openai',
        },
      });
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching sessions');
    }
  }

  public async ignoreJid(instance: InstanceDto, data: IgnoreJidDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Openai is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (!settings) {
        throw new Error('Settings not found');
      }

      let ignoreJids: any = settings?.ignoreJids || [];

      if (data.action === 'add') {
        if (ignoreJids.includes(data.remoteJid)) return { ignoreJids: ignoreJids };

        ignoreJids.push(data.remoteJid);
      } else {
        ignoreJids = ignoreJids.filter((jid) => jid !== data.remoteJid);
      }

      const updateSettings = await this.settingsRepository.update({
        where: {
          id: settings.id,
        },
        data: {
          ignoreJids: ignoreJids,
        },
      });

      return {
        ignoreJids: updateSettings.ignoreJids,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  // Emit
  public async emit({ instance, remoteJid, msg, pushName }: EmitData) {
    if (!this.integrationEnabled) return;

    try {
      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instance.instanceId,
        },
      });

      if (this.checkIgnoreJids(settings?.ignoreJids, remoteJid)) return;

      let session = await this.getSession(remoteJid, instance);

      const content = getConversationMessage(msg);

      let findBot = (await this.findBotTrigger(this.botRepository, content, instance, session)) as OpenaiBot;

      if (!findBot) {
        const fallback = await this.settingsRepository.findFirst({
          where: {
            instanceId: instance.instanceId,
          },
        });

        if (fallback?.openaiIdFallback) {
          const findFallback = await this.botRepository.findFirst({
            where: {
              id: fallback.openaiIdFallback,
            },
          });

          findBot = findFallback;
        } else {
          return;
        }
      }

      let expire = findBot?.expire;
      let keywordFinish = findBot?.keywordFinish;
      let delayMessage = findBot?.delayMessage;
      let unknownMessage = findBot?.unknownMessage;
      let listeningFromMe = findBot?.listeningFromMe;
      let stopBotFromMe = findBot?.stopBotFromMe;
      let keepOpen = findBot?.keepOpen;
      let debounceTime = findBot?.debounceTime;
      let ignoreJids = findBot?.ignoreJids;
      let splitMessages = findBot?.splitMessages;
      let timePerChar = findBot?.timePerChar;

      if (expire === undefined || expire === null) expire = settings.expire;
      if (keywordFinish === undefined || keywordFinish === null) keywordFinish = settings.keywordFinish;
      if (delayMessage === undefined || delayMessage === null) delayMessage = settings.delayMessage;
      if (unknownMessage === undefined || unknownMessage === null) unknownMessage = settings.unknownMessage;
      if (listeningFromMe === undefined || listeningFromMe === null) listeningFromMe = settings.listeningFromMe;
      if (stopBotFromMe === undefined || stopBotFromMe === null) stopBotFromMe = settings.stopBotFromMe;
      if (keepOpen === undefined || keepOpen === null) keepOpen = settings.keepOpen;
      if (debounceTime === undefined || debounceTime === null) debounceTime = settings.debounceTime;
      if (ignoreJids === undefined || ignoreJids === null) ignoreJids = settings.ignoreJids;
      if (splitMessages === undefined || splitMessages === null) splitMessages = settings?.splitMessages ?? false;
      if (timePerChar === undefined || timePerChar === null) timePerChar = settings?.timePerChar ?? 0;

      const key = msg.key as {
        id: string;
        remoteJid: string;
        fromMe: boolean;
        participant: string;
      };

      if (stopBotFromMe && key.fromMe && session) {
        session = await this.sessionRepository.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'paused',
          },
        });
      }

      if (!listeningFromMe && key.fromMe) {
        return;
      }

      if (session && !session.awaitUser) {
        return;
      }

      if (debounceTime && debounceTime > 0) {
        this.processDebounce(this.userMessageDebounce, content, remoteJid, debounceTime, async (debouncedContent) => {
          if (findBot.botType === 'assistant') {
            await this.openaiService.processOpenaiAssistant(
              this.waMonitor.waInstances[instance.instanceName],
              remoteJid,
              pushName,
              key.fromMe,
              findBot,
              session,
              {
                ...settings,
                expire,
                keywordFinish,
                delayMessage,
                unknownMessage,
                listeningFromMe,
                stopBotFromMe,
                keepOpen,
                debounceTime,
                ignoreJids,
                splitMessages,
                timePerChar,
              },
              debouncedContent,
            );
          }

          if (findBot.botType === 'chatCompletion') {
            await this.openaiService.processOpenaiChatCompletion(
              this.waMonitor.waInstances[instance.instanceName],
              remoteJid,
              pushName,
              findBot,
              session,
              {
                ...settings,
                expire,
                keywordFinish,
                delayMessage,
                unknownMessage,
                listeningFromMe,
                stopBotFromMe,
                keepOpen,
                debounceTime,
                ignoreJids,
                splitMessages,
                timePerChar,
              },
              debouncedContent,
            );
          }
        });
      } else {
        if (findBot.botType === 'assistant') {
          await this.openaiService.processOpenaiAssistant(
            this.waMonitor.waInstances[instance.instanceName],
            remoteJid,
            pushName,
            key.fromMe,
            findBot,
            session,
            settings,
            content,
          );
        }

        if (findBot.botType === 'chatCompletion') {
          await this.openaiService.processOpenaiChatCompletion(
            this.waMonitor.waInstances[instance.instanceName],
            remoteJid,
            pushName,
            findBot,
            session,
            settings,
            content,
          );
        }
      }

      return;
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }
}



================================================
FILE: src/api/integrations/chatbot/openai/dto/openai.dto.ts
================================================
import { TriggerOperator, TriggerType } from '@prisma/client';

export class OpenaiCredsDto {
  name: string;
  apiKey: string;
}

export class OpenaiDto {
  enabled?: boolean;
  description?: string;
  openaiCredsId: string;
  botType?: string;
  assistantId?: string;
  functionUrl?: string;
  model?: string;
  systemMessages?: string[];
  assistantMessages?: string[];
  userMessages?: string[];
  maxTokens?: number;
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  triggerType?: TriggerType;
  triggerOperator?: TriggerOperator;
  triggerValue?: string;
  ignoreJids?: any;
  splitMessages?: boolean;
  timePerChar?: number;
}

export class OpenaiSettingDto {
  openaiCredsId?: string;
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  openaiIdFallback?: string;
  ignoreJids?: any;
  speechToText?: boolean;
  splitMessages?: boolean;
  timePerChar?: number;
}



================================================
FILE: src/api/integrations/chatbot/openai/routes/openai.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { OpenaiCredsDto, OpenaiDto, OpenaiSettingDto } from '@api/integrations/chatbot/openai/dto/openai.dto';
import { HttpStatus } from '@api/routes/index.router';
import { openaiController } from '@api/server.module';
import {
  instanceSchema,
  openaiCredsSchema,
  openaiIgnoreJidSchema,
  openaiSchema,
  openaiSettingSchema,
  openaiStatusSchema,
} from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

export class OpenaiRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('creds'), ...guards, async (req, res) => {
        const response = await this.dataValidate<OpenaiCredsDto>({
          request: req,
          schema: openaiCredsSchema,
          ClassRef: OpenaiCredsDto,
          execute: (instance, data) => openaiController.createOpenaiCreds(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('creds'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => openaiController.findOpenaiCreds(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .delete(this.routerPath('creds/:openaiCredsId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => openaiController.deleteCreds(instance, req.params.openaiCredsId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('create'), ...guards, async (req, res) => {
        const response = await this.dataValidate<OpenaiDto>({
          request: req,
          schema: openaiSchema,
          ClassRef: OpenaiDto,
          execute: (instance, data) => openaiController.createBot(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => openaiController.findBot(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetch/:openaiBotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => openaiController.fetchBot(instance, req.params.openaiBotId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .put(this.routerPath('update/:openaiBotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<OpenaiDto>({
          request: req,
          schema: openaiSchema,
          ClassRef: OpenaiDto,
          execute: (instance, data) => openaiController.updateBot(instance, req.params.openaiBotId, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .delete(this.routerPath('delete/:openaiBotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => openaiController.deleteBot(instance, req.params.openaiBotId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('settings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<OpenaiSettingDto>({
          request: req,
          schema: openaiSettingSchema,
          ClassRef: OpenaiSettingDto,
          execute: (instance, data) => openaiController.settings(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSettings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => openaiController.fetchSettings(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('changeStatus'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: openaiStatusSchema,
          ClassRef: InstanceDto,
          execute: (instance, data) => openaiController.changeStatus(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSessions/:openaiBotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => openaiController.fetchSessions(instance, req.params.openaiBotId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('ignoreJid'), ...guards, async (req, res) => {
        const response = await this.dataValidate<IgnoreJidDto>({
          request: req,
          schema: openaiIgnoreJidSchema,
          ClassRef: IgnoreJidDto,
          execute: (instance, data) => openaiController.ignoreJid(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('getModels'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => openaiController.getModels(instance),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/chatbot/openai/services/openai.service.ts
================================================
/* eslint-disable @typescript-eslint/no-unused-vars */
import { InstanceDto } from '@api/dto/instance.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Integration } from '@api/types/wa.types';
import { ConfigService, Language } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { IntegrationSession, OpenaiBot, OpenaiCreds, OpenaiSetting } from '@prisma/client';
import { sendTelemetry } from '@utils/sendTelemetry';
import axios from 'axios';
import { downloadMediaMessage } from 'baileys';
import FormData from 'form-data';
import OpenAI from 'openai';
import P from 'pino';

export class OpenaiService {
  constructor(
    private readonly waMonitor: WAMonitoringService,
    private readonly configService: ConfigService,
    private readonly prismaRepository: PrismaRepository,
  ) {}

  private client: OpenAI;

  private readonly logger = new Logger('OpenaiService');

  private async sendMessageToBot(instance: any, openaiBot: OpenaiBot, remoteJid: string, content: string) {
    const systemMessages: any = openaiBot.systemMessages;

    const messagesSystem: any[] = systemMessages.map((message) => {
      return {
        role: 'system',
        content: message,
      };
    });

    const assistantMessages: any = openaiBot.assistantMessages;

    const messagesAssistant: any[] = assistantMessages.map((message) => {
      return {
        role: 'assistant',
        content: message,
      };
    });

    const userMessages: any = openaiBot.userMessages;

    const messagesUser: any[] = userMessages.map((message) => {
      return {
        role: 'user',
        content: message,
      };
    });

    const messageData: any = {
      role: 'user',
      content: [{ type: 'text', text: content }],
    };

    if (this.isImageMessage(content)) {
      const contentSplit = content.split('|');

      const url = contentSplit[1].split('?')[0];

      messageData.content = [
        { type: 'text', text: contentSplit[2] || content },
        {
          type: 'image_url',
          image_url: {
            url: url,
          },
        },
      ];
    }

    const messages: any[] = [...messagesSystem, ...messagesAssistant, ...messagesUser, messageData];

    if (instance.integration === Integration.WHATSAPP_BAILEYS) {
      await instance.client.presenceSubscribe(remoteJid);
      await instance.client.sendPresenceUpdate('composing', remoteJid);
    }

    const completions = await this.client.chat.completions.create({
      model: openaiBot.model,
      messages: messages,
      max_tokens: openaiBot.maxTokens,
    });

    if (instance.integration === Integration.WHATSAPP_BAILEYS)
      await instance.client.sendPresenceUpdate('paused', remoteJid);

    const message = completions.choices[0].message.content;

    return message;
  }

  private async sendMessageToAssistant(
    instance: any,
    openaiBot: OpenaiBot,
    remoteJid: string,
    pushName: string,
    fromMe: boolean,
    content: string,
    threadId: string,
  ) {
    const messageData: any = {
      role: fromMe ? 'assistant' : 'user',
      content: [{ type: 'text', text: content }],
    };

    if (this.isImageMessage(content)) {
      const contentSplit = content.split('|');

      const url = contentSplit[1].split('?')[0];

      messageData.content = [
        { type: 'text', text: contentSplit[2] || content },
        {
          type: 'image_url',
          image_url: {
            url: url,
          },
        },
      ];
    }

    await this.client.beta.threads.messages.create(threadId, messageData);

    if (fromMe) {
      sendTelemetry('/message/sendText');
      return;
    }

    const runAssistant = await this.client.beta.threads.runs.create(threadId, {
      assistant_id: openaiBot.assistantId,
    });

    if (instance.integration === Integration.WHATSAPP_BAILEYS) {
      await instance.client.presenceSubscribe(remoteJid);
      await instance.client.sendPresenceUpdate('composing', remoteJid);
    }

    const response = await this.getAIResponse(threadId, runAssistant.id, openaiBot.functionUrl, remoteJid, pushName);

    if (instance.integration === Integration.WHATSAPP_BAILEYS)
      await instance.client.sendPresenceUpdate('paused', remoteJid);

    const message = response?.data[0].content[0].text.value;

    return message;
  }

  private async sendMessageWhatsapp(
    instance: any,
    session: IntegrationSession,
    remoteJid: string,
    settings: OpenaiSetting,
    message: string,
  ) {
    const linkRegex = /(!?)\[(.*?)\]\((.*?)\)/g;

    let textBuffer = '';
    let lastIndex = 0;

    let match: RegExpExecArray | null;

    const getMediaType = (url: string): string | null => {
      const extension = url.split('.').pop()?.toLowerCase();
      const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'];
      const audioExtensions = ['mp3', 'wav', 'aac', 'ogg'];
      const videoExtensions = ['mp4', 'avi', 'mkv', 'mov'];
      const documentExtensions = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt'];

      if (imageExtensions.includes(extension || '')) return 'image';
      if (audioExtensions.includes(extension || '')) return 'audio';
      if (videoExtensions.includes(extension || '')) return 'video';
      if (documentExtensions.includes(extension || '')) return 'document';
      return null;
    };

    while ((match = linkRegex.exec(message)) !== null) {
      const [fullMatch, exclMark, altText, url] = match;
      const mediaType = getMediaType(url);

      const beforeText = message.slice(lastIndex, match.index);
      if (beforeText) {
        textBuffer += beforeText;
      }

      if (mediaType) {
        const splitMessages = settings.splitMessages ?? false;
        const timePerChar = settings.timePerChar ?? 0;
        const minDelay = 1000;
        const maxDelay = 20000;

        if (textBuffer.trim()) {
          if (splitMessages) {
            const multipleMessages = textBuffer.trim().split('\n\n');

            for (let index = 0; index < multipleMessages.length; index++) {
              const message = multipleMessages[index];

              const delay = Math.min(Math.max(message.length * timePerChar, minDelay), maxDelay);

              if (instance.integration === Integration.WHATSAPP_BAILEYS) {
                await instance.client.presenceSubscribe(remoteJid);
                await instance.client.sendPresenceUpdate('composing', remoteJid);
              }

              await new Promise<void>((resolve) => {
                setTimeout(async () => {
                  await instance.textMessage(
                    {
                      number: remoteJid.split('@')[0],
                      delay: settings?.delayMessage || 1000,
                      text: message,
                    },
                    false,
                  );
                  resolve();
                }, delay);
              });

              if (instance.integration === Integration.WHATSAPP_BAILEYS) {
                await instance.client.sendPresenceUpdate('paused', remoteJid);
              }
            }
          } else {
            await instance.textMessage(
              {
                number: remoteJid.split('@')[0],
                delay: settings?.delayMessage || 1000,
                text: textBuffer.trim(),
              },
              false,
            );
          }
          textBuffer = '';
        }

        if (mediaType === 'audio') {
          await instance.audioWhatsapp({
            number: remoteJid.split('@')[0],
            delay: settings?.delayMessage || 1000,
            audio: url,
            caption: altText,
          });
        } else {
          await instance.mediaMessage(
            {
              number: remoteJid.split('@')[0],
              delay: settings?.delayMessage || 1000,
              mediatype: mediaType,
              media: url,
              caption: altText,
            },
            null,
            false,
          );
        }
      } else {
        textBuffer += `[${altText}](${url})`;
      }

      lastIndex = linkRegex.lastIndex;
    }

    if (lastIndex < message.length) {
      const remainingText = message.slice(lastIndex);
      if (remainingText.trim()) {
        textBuffer += remainingText;
      }
    }

    const splitMessages = settings.splitMessages ?? false;
    const timePerChar = settings.timePerChar ?? 0;
    const minDelay = 1000;
    const maxDelay = 20000;

    if (textBuffer.trim()) {
      if (splitMessages) {
        const multipleMessages = textBuffer.trim().split('\n\n');

        for (let index = 0; index < multipleMessages.length; index++) {
          const message = multipleMessages[index];

          const delay = Math.min(Math.max(message.length * timePerChar, minDelay), maxDelay);

          if (instance.integration === Integration.WHATSAPP_BAILEYS) {
            await instance.client.presenceSubscribe(remoteJid);
            await instance.client.sendPresenceUpdate('composing', remoteJid);
          }

          await new Promise<void>((resolve) => {
            setTimeout(async () => {
              await instance.textMessage(
                {
                  number: remoteJid.split('@')[0],
                  delay: settings?.delayMessage || 1000,
                  text: message,
                },
                false,
              );
              resolve();
            }, delay);
          });

          if (instance.integration === Integration.WHATSAPP_BAILEYS) {
            await instance.client.sendPresenceUpdate('paused', remoteJid);
          }
        }
      } else {
        await instance.textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: settings?.delayMessage || 1000,
            text: textBuffer.trim(),
          },
          false,
        );
      }
      textBuffer = '';
    }

    sendTelemetry('/message/sendText');

    await this.prismaRepository.integrationSession.update({
      where: {
        id: session.id,
      },
      data: {
        status: 'opened',
        awaitUser: true,
      },
    });
  }

  public async createAssistantNewSession(instance: InstanceDto, data: any) {
    if (data.remoteJid === 'status@broadcast') return;

    const creds = await this.prismaRepository.openaiCreds.findFirst({
      where: {
        id: data.openaiCredsId,
      },
    });

    if (!creds) throw new Error('Openai Creds not found');

    try {
      this.client = new OpenAI({
        apiKey: creds.apiKey,
      });

      const threadId = (await this.client.beta.threads.create({})).id;

      let session = null;
      if (threadId) {
        session = await this.prismaRepository.integrationSession.create({
          data: {
            remoteJid: data.remoteJid,
            pushName: data.pushName,
            sessionId: threadId,
            status: 'opened',
            awaitUser: false,
            botId: data.botId,
            instanceId: instance.instanceId,
            type: 'openai',
          },
        });
      }
      return { session };
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }

  private async initAssistantNewSession(
    instance: any,
    remoteJid: string,
    pushName: string,
    fromMe: boolean,
    openaiBot: OpenaiBot,
    settings: OpenaiSetting,
    session: IntegrationSession,
    content: string,
  ) {
    const data = await this.createAssistantNewSession(instance, {
      remoteJid,
      pushName,
      openaiCredsId: openaiBot.openaiCredsId,
      botId: openaiBot.id,
    });

    if (data.session) {
      session = data.session;
    }

    const message = await this.sendMessageToAssistant(
      instance,
      openaiBot,
      remoteJid,
      pushName,
      fromMe,
      content,
      session.sessionId,
    );

    await this.sendMessageWhatsapp(instance, session, remoteJid, settings, message);

    return;
  }

  private isJSON(str: string): boolean {
    try {
      JSON.parse(str);
      return true;
    } catch (e) {
      return false;
    }
  }

  private async getAIResponse(
    threadId: string,
    runId: string,
    functionUrl: string,
    remoteJid: string,
    pushName: string,
  ) {
    const getRun = await this.client.beta.threads.runs.retrieve(threadId, runId);
    let toolCalls;
    switch (getRun.status) {
      case 'requires_action':
        toolCalls = getRun?.required_action?.submit_tool_outputs?.tool_calls;

        if (toolCalls) {
          for (const toolCall of toolCalls) {
            const id = toolCall.id;
            const functionName = toolCall?.function?.name;
            const functionArgument = this.isJSON(toolCall?.function?.arguments)
              ? JSON.parse(toolCall?.function?.arguments)
              : toolCall?.function?.arguments;

            let output = null;

            try {
              const { data } = await axios.post(functionUrl, {
                name: functionName,
                arguments: { ...functionArgument, remoteJid, pushName },
              });

              output = JSON.stringify(data)
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t');
            } catch (error) {
              output = JSON.stringify(error)
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t');
            }

            await this.client.beta.threads.runs.submitToolOutputs(threadId, runId, {
              tool_outputs: [
                {
                  tool_call_id: id,
                  output,
                },
              ],
            });
          }
        }

        return this.getAIResponse(threadId, runId, functionUrl, remoteJid, pushName);
      case 'queued':
        await new Promise((resolve) => setTimeout(resolve, 1000));
        return this.getAIResponse(threadId, runId, functionUrl, remoteJid, pushName);
      case 'in_progress':
        await new Promise((resolve) => setTimeout(resolve, 1000));
        return this.getAIResponse(threadId, runId, functionUrl, remoteJid, pushName);
      case 'completed':
        return await this.client.beta.threads.messages.list(threadId, {
          run_id: runId,
          limit: 1,
        });
    }
  }

  private isImageMessage(content: string) {
    return content.includes('imageMessage');
  }

  public async processOpenaiAssistant(
    instance: any,
    remoteJid: string,
    pushName: string,
    fromMe: boolean,
    openaiBot: OpenaiBot,
    session: IntegrationSession,
    settings: OpenaiSetting,
    content: string,
  ) {
    if (session && session.status === 'closed') {
      return;
    }

    if (session && settings.expire && settings.expire > 0) {
      const now = Date.now();

      const sessionUpdatedAt = new Date(session.updatedAt).getTime();

      const diff = now - sessionUpdatedAt;

      const diffInMinutes = Math.floor(diff / 1000 / 60);

      if (diffInMinutes > settings.expire) {
        if (settings.keepOpen) {
          await this.prismaRepository.integrationSession.update({
            where: {
              id: session.id,
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.prismaRepository.integrationSession.deleteMany({
            where: {
              botId: openaiBot.id,
              remoteJid: remoteJid,
            },
          });
        }

        await this.initAssistantNewSession(
          instance,
          remoteJid,
          pushName,
          fromMe,
          openaiBot,
          settings,
          session,
          content,
        );
        return;
      }
    }

    if (!session) {
      await this.initAssistantNewSession(instance, remoteJid, pushName, fromMe, openaiBot, settings, session, content);
      return;
    }

    if (session.status !== 'paused')
      await this.prismaRepository.integrationSession.update({
        where: {
          id: session.id,
        },
        data: {
          status: 'opened',
          awaitUser: false,
        },
      });

    if (!content) {
      if (settings.unknownMessage) {
        this.waMonitor.waInstances[instance.instanceName].textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: settings.delayMessage || 1000,
            text: settings.unknownMessage,
          },
          false,
        );

        sendTelemetry('/message/sendText');
      }
      return;
    }

    if (settings.keywordFinish && content.toLowerCase() === settings.keywordFinish.toLowerCase()) {
      if (settings.keepOpen) {
        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'closed',
          },
        });
      } else {
        await this.prismaRepository.integrationSession.deleteMany({
          where: {
            botId: openaiBot.id,
            remoteJid: remoteJid,
          },
        });
      }
      return;
    }

    const creds = await this.prismaRepository.openaiCreds.findFirst({
      where: {
        id: openaiBot.openaiCredsId,
      },
    });

    if (!creds) throw new Error('Openai Creds not found');

    this.client = new OpenAI({
      apiKey: creds.apiKey,
    });

    const threadId = session.sessionId;

    const message = await this.sendMessageToAssistant(
      instance,
      openaiBot,
      remoteJid,
      pushName,
      fromMe,
      content,
      threadId,
    );

    await this.sendMessageWhatsapp(instance, session, remoteJid, settings, message);

    return;
  }

  public async createChatCompletionNewSession(instance: InstanceDto, data: any) {
    if (data.remoteJid === 'status@broadcast') return;

    const id = Math.floor(Math.random() * 10000000000).toString();

    const creds = await this.prismaRepository.openaiCreds.findFirst({
      where: {
        id: data.openaiCredsId,
      },
    });

    if (!creds) throw new Error('Openai Creds not found');

    try {
      const session = await this.prismaRepository.integrationSession.create({
        data: {
          remoteJid: data.remoteJid,
          pushName: data.pushName,
          sessionId: id,
          status: 'opened',
          awaitUser: false,
          botId: data.botId,
          instanceId: instance.instanceId,
          type: 'openai',
        },
      });

      return { session, creds };
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }

  private async initChatCompletionNewSession(
    instance: any,
    remoteJid: string,
    pushName: string,
    openaiBot: OpenaiBot,
    settings: OpenaiSetting,
    session: IntegrationSession,
    content: string,
  ) {
    const data = await this.createChatCompletionNewSession(instance, {
      remoteJid,
      pushName,
      openaiCredsId: openaiBot.openaiCredsId,
      botId: openaiBot.id,
    });

    session = data.session;

    const creds = data.creds;

    this.client = new OpenAI({
      apiKey: creds.apiKey,
    });

    const message = await this.sendMessageToBot(instance, openaiBot, remoteJid, content);

    await this.sendMessageWhatsapp(instance, session, remoteJid, settings, message);

    return;
  }

  public async processOpenaiChatCompletion(
    instance: any,
    remoteJid: string,
    pushName: string,
    openaiBot: OpenaiBot,
    session: IntegrationSession,
    settings: OpenaiSetting,
    content: string,
  ) {
    if (session && session.status !== 'opened') {
      return;
    }

    if (session && settings.expire && settings.expire > 0) {
      const now = Date.now();

      const sessionUpdatedAt = new Date(session.updatedAt).getTime();

      const diff = now - sessionUpdatedAt;

      const diffInMinutes = Math.floor(diff / 1000 / 60);

      if (diffInMinutes > settings.expire) {
        if (settings.keepOpen) {
          await this.prismaRepository.integrationSession.update({
            where: {
              id: session.id,
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.prismaRepository.integrationSession.deleteMany({
            where: {
              botId: openaiBot.id,
              remoteJid: remoteJid,
            },
          });
        }

        await this.initChatCompletionNewSession(instance, remoteJid, pushName, openaiBot, settings, session, content);
        return;
      }
    }

    if (!session) {
      await this.initChatCompletionNewSession(instance, remoteJid, pushName, openaiBot, settings, session, content);
      return;
    }

    await this.prismaRepository.integrationSession.update({
      where: {
        id: session.id,
      },
      data: {
        status: 'opened',
        awaitUser: false,
      },
    });

    if (!content) {
      if (settings.unknownMessage) {
        this.waMonitor.waInstances[instance.instanceName].textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: settings.delayMessage || 1000,
            text: settings.unknownMessage,
          },
          false,
        );

        sendTelemetry('/message/sendText');
      }
      return;
    }

    if (settings.keywordFinish && content.toLowerCase() === settings.keywordFinish.toLowerCase()) {
      if (settings.keepOpen) {
        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'closed',
          },
        });
      } else {
        await this.prismaRepository.integrationSession.deleteMany({
          where: {
            botId: openaiBot.id,
            remoteJid: remoteJid,
          },
        });
      }
      return;
    }

    const creds = await this.prismaRepository.openaiCreds.findFirst({
      where: {
        id: openaiBot.openaiCredsId,
      },
    });

    if (!creds) throw new Error('Openai Creds not found');

    this.client = new OpenAI({
      apiKey: creds.apiKey,
    });

    const message = await this.sendMessageToBot(instance, openaiBot, remoteJid, content);

    await this.sendMessageWhatsapp(instance, session, remoteJid, settings, message);

    return;
  }

  public async speechToText(creds: OpenaiCreds, msg: any, updateMediaMessage: any) {
    let audio;

    if (msg?.message?.mediaUrl) {
      audio = await axios.get(msg.message.mediaUrl, { responseType: 'arraybuffer' }).then((response) => {
        return Buffer.from(response.data, 'binary');
      });
    } else {
      audio = await downloadMediaMessage(
        { key: msg.key, message: msg?.message },
        'buffer',
        {},
        {
          logger: P({ level: 'error' }) as any,
          reuploadRequest: updateMediaMessage,
        },
      );
    }

    const lang = this.configService.get<Language>('LANGUAGE').includes('pt')
      ? 'pt'
      : this.configService.get<Language>('LANGUAGE');

    const formData = new FormData();

    formData.append('file', audio, 'audio.ogg');
    formData.append('model', 'whisper-1');
    formData.append('language', lang);

    const response = await axios.post('https://api.openai.com/v1/audio/transcriptions', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
        Authorization: `Bearer ${creds.apiKey}`,
      },
    });

    return response?.data?.text;
  }
}



================================================
FILE: src/api/integrations/chatbot/openai/validate/openai.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const openaiSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    enabled: { type: 'boolean' },
    description: { type: 'string' },
    openaiCredsId: { type: 'string' },
    botType: { type: 'string', enum: ['assistant', 'chatCompletion'] },
    assistantId: { type: 'string' },
    functionUrl: { type: 'string' },
    model: { type: 'string' },
    systemMessages: { type: 'array', items: { type: 'string' } },
    assistantMessages: { type: 'array', items: { type: 'string' } },
    userMessages: { type: 'array', items: { type: 'string' } },
    maxTokens: { type: 'integer' },
    triggerType: { type: 'string', enum: ['all', 'keyword', 'none', 'advanced'] },
    triggerOperator: { type: 'string', enum: ['equals', 'contains', 'startsWith', 'endsWith', 'regex'] },
    triggerValue: { type: 'string' },
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    keepOpen: { type: 'boolean' },
    debounceTime: { type: 'integer' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
  },
  required: ['enabled', 'openaiCredsId', 'botType', 'triggerType'],
  ...isNotEmpty('enabled', 'openaiCredsId', 'botType', 'triggerType'),
};

export const openaiCredsSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    name: { type: 'string' },
    apiKey: { type: 'string' },
  },
  required: ['name', 'apiKey'],
  ...isNotEmpty('name', 'apiKey'),
};

export const openaiStatusSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    status: { type: 'string', enum: ['opened', 'closed', 'paused', 'delete'] },
  },
  required: ['remoteJid', 'status'],
  ...isNotEmpty('remoteJid', 'status'),
};

export const openaiSettingSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    openaiCredsId: { type: 'string' },
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    keepOpen: { type: 'boolean' },
    debounceTime: { type: 'integer' },
    speechToText: { type: 'boolean' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
    openaiIdFallback: { type: 'string' },
  },
  required: [
    'openaiCredsId',
    'expire',
    'keywordFinish',
    'delayMessage',
    'unknownMessage',
    'listeningFromMe',
    'stopBotFromMe',
    'keepOpen',
    'debounceTime',
    'ignoreJids',
  ],
  ...isNotEmpty(
    'openaiCredsId',
    'expire',
    'keywordFinish',
    'delayMessage',
    'unknownMessage',
    'listeningFromMe',
    'stopBotFromMe',
    'keepOpen',
    'debounceTime',
    'ignoreJids',
  ),
};

export const openaiIgnoreJidSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    action: { type: 'string', enum: ['add', 'remove'] },
  },
  required: ['remoteJid', 'action'],
  ...isNotEmpty('remoteJid', 'action'),
};



================================================
FILE: src/api/integrations/chatbot/typebot/controllers/typebot.controller.ts
================================================
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { TypebotDto } from '@api/integrations/chatbot/typebot/dto/typebot.dto';
import { TypebotService } from '@api/integrations/chatbot/typebot/services/typebot.service';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Events } from '@api/types/wa.types';
import { configService, Typebot } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { BadRequestException } from '@exceptions';
import { Typebot as TypebotModel } from '@prisma/client';
import { getConversationMessage } from '@utils/getConversationMessage';
import axios from 'axios';

import { ChatbotController, ChatbotControllerInterface } from '../../chatbot.controller';

export class TypebotController extends ChatbotController implements ChatbotControllerInterface {
  constructor(
    private readonly typebotService: TypebotService,
    prismaRepository: PrismaRepository,
    waMonitor: WAMonitoringService,
  ) {
    super(prismaRepository, waMonitor);

    this.botRepository = this.prismaRepository.typebot;
    this.settingsRepository = this.prismaRepository.typebotSetting;
    this.sessionRepository = this.prismaRepository.integrationSession;
  }

  public readonly logger = new Logger('TypebotController');

  integrationEnabled = configService.get<Typebot>('TYPEBOT').ENABLED;
  botRepository: any;
  settingsRepository: any;
  sessionRepository: any;
  userMessageDebounce: { [key: string]: { message: string; timeoutId: NodeJS.Timeout } } = {};

  // Bots
  public async createBot(instance: InstanceDto, data: TypebotDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    if (
      !data.expire ||
      !data.keywordFinish ||
      !data.delayMessage ||
      !data.unknownMessage ||
      !data.listeningFromMe ||
      !data.stopBotFromMe ||
      !data.keepOpen ||
      !data.debounceTime ||
      !data.ignoreJids
    ) {
      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (!data.expire) data.expire = defaultSettingCheck?.expire || 0;
      if (!data.keywordFinish) data.keywordFinish = defaultSettingCheck?.keywordFinish || '#SAIR';
      if (!data.delayMessage) data.delayMessage = defaultSettingCheck?.delayMessage || 1000;
      if (!data.unknownMessage) data.unknownMessage = defaultSettingCheck?.unknownMessage || 'Desculpe, não entendi';
      if (!data.listeningFromMe) data.listeningFromMe = defaultSettingCheck?.listeningFromMe || false;
      if (!data.stopBotFromMe) data.stopBotFromMe = defaultSettingCheck?.stopBotFromMe || false;
      if (!data.keepOpen) data.keepOpen = defaultSettingCheck?.keepOpen || false;
      if (!data.debounceTime) data.debounceTime = defaultSettingCheck?.debounceTime || 0;
      if (!data.ignoreJids) data.ignoreJids = defaultSettingCheck?.ignoreJids || [];

      if (!defaultSettingCheck) {
        await this.settings(instance, {
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          ignoreJids: data.ignoreJids,
        });
      }
    }

    const checkTriggerAll = await this.botRepository.findFirst({
      where: {
        enabled: true,
        triggerType: 'all',
        instanceId: instanceId,
      },
    });

    if (checkTriggerAll && data.triggerType === 'all') {
      throw new Error('You already have a typebot with an "All" trigger, you cannot have more bots while it is active');
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: {
        url: data.url,
        typebot: data.typebot,
        instanceId: instanceId,
      },
    });

    if (checkDuplicate) {
      throw new Error('Typebot already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.create({
        data: {
          enabled: data?.enabled,
          description: data.description,
          url: data.url,
          typebot: data.typebot,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          instanceId: instanceId,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error creating typebot');
    }
  }

  public async findBot(instance: InstanceDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bots = await this.botRepository.findMany({
      where: {
        instanceId: instanceId,
      },
    });

    if (!bots.length) {
      return null;
    }

    return bots;
  }

  public async fetchBot(instance: InstanceDto, botId: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const bot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!bot) {
      throw new Error('Typebot not found');
    }

    if (bot.instanceId !== instanceId) {
      throw new Error('Typebot not found');
    }

    return bot;
  }

  public async updateBot(instance: InstanceDto, botId: string, data: TypebotDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const typebot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!typebot) {
      throw new Error('Typebot not found');
    }

    if (typebot.instanceId !== instanceId) {
      throw new Error('Typebot not found');
    }

    if (data.triggerType === 'all') {
      const checkTriggerAll = await this.botRepository.findFirst({
        where: {
          enabled: true,
          triggerType: 'all',
          id: {
            not: botId,
          },
          instanceId: instanceId,
        },
      });

      if (checkTriggerAll) {
        throw new Error(
          'You already have a typebot with an "All" trigger, you cannot have more bots while it is active',
        );
      }
    }

    const checkDuplicate = await this.botRepository.findFirst({
      where: {
        url: data.url,
        typebot: data.typebot,
        id: {
          not: botId,
        },
        instanceId: instanceId,
      },
    });

    if (checkDuplicate) {
      throw new Error('Typebot already exists');
    }

    if (data.triggerType === 'keyword') {
      if (!data.triggerOperator || !data.triggerValue) {
        throw new Error('Trigger operator and value are required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          id: {
            not: botId,
          },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    if (data.triggerType === 'advanced') {
      if (!data.triggerValue) {
        throw new Error('Trigger value is required');
      }

      const checkDuplicate = await this.botRepository.findFirst({
        where: {
          triggerValue: data.triggerValue,
          id: { not: botId },
          instanceId: instanceId,
        },
      });

      if (checkDuplicate) {
        throw new Error('Trigger already exists');
      }
    }

    try {
      const bot = await this.botRepository.update({
        where: {
          id: botId,
        },
        data: {
          enabled: data?.enabled,
          description: data.description,
          url: data.url,
          typebot: data.typebot,
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          triggerType: data.triggerType,
          triggerOperator: data.triggerOperator,
          triggerValue: data.triggerValue,
          ignoreJids: data.ignoreJids,
        },
      });

      return bot;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error updating typebot');
    }
  }

  public async deleteBot(instance: InstanceDto, botId: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    const instanceId = await this.prismaRepository.instance
      .findFirst({
        where: {
          name: instance.instanceName,
        },
      })
      .then((instance) => instance.id);

    const typebot = await this.botRepository.findFirst({
      where: {
        id: botId,
      },
    });

    if (!typebot) {
      throw new Error('Typebot not found');
    }

    if (typebot.instanceId !== instanceId) {
      throw new Error('Typebot not found');
    }
    try {
      await this.prismaRepository.integrationSession.deleteMany({
        where: {
          botId: botId,
        },
      });

      await this.botRepository.delete({
        where: {
          id: botId,
        },
      });

      return { typebot: { id: botId } };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error deleting typebot');
    }
  }

  // Settings
  public async settings(instance: InstanceDto, data: any) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (settings) {
        const updateSettings = await this.settingsRepository.update({
          where: {
            id: settings.id,
          },
          data: {
            expire: data.expire,
            keywordFinish: data.keywordFinish,
            delayMessage: data.delayMessage,
            unknownMessage: data.unknownMessage,
            listeningFromMe: data.listeningFromMe,
            stopBotFromMe: data.stopBotFromMe,
            keepOpen: data.keepOpen,
            debounceTime: data.debounceTime,
            typebotIdFallback: data.typebotIdFallback,
            ignoreJids: data.ignoreJids,
          },
        });

        return {
          expire: updateSettings.expire,
          keywordFinish: updateSettings.keywordFinish,
          delayMessage: updateSettings.delayMessage,
          unknownMessage: updateSettings.unknownMessage,
          listeningFromMe: updateSettings.listeningFromMe,
          stopBotFromMe: updateSettings.stopBotFromMe,
          keepOpen: updateSettings.keepOpen,
          debounceTime: updateSettings.debounceTime,
          typebotIdFallback: updateSettings.typebotIdFallback,
          ignoreJids: updateSettings.ignoreJids,
        };
      }

      const newSetttings = await this.settingsRepository.create({
        data: {
          expire: data.expire,
          keywordFinish: data.keywordFinish,
          delayMessage: data.delayMessage,
          unknownMessage: data.unknownMessage,
          listeningFromMe: data.listeningFromMe,
          stopBotFromMe: data.stopBotFromMe,
          keepOpen: data.keepOpen,
          debounceTime: data.debounceTime,
          typebotIdFallback: data.typebotIdFallback,
          ignoreJids: data.ignoreJids,
          instanceId: instanceId,
        },
      });

      return {
        expire: newSetttings.expire,
        keywordFinish: newSetttings.keywordFinish,
        delayMessage: newSetttings.delayMessage,
        unknownMessage: newSetttings.unknownMessage,
        listeningFromMe: newSetttings.listeningFromMe,
        stopBotFromMe: newSetttings.stopBotFromMe,
        keepOpen: newSetttings.keepOpen,
        debounceTime: newSetttings.debounceTime,
        typebotIdFallback: newSetttings.typebotIdFallback,
        ignoreJids: newSetttings.ignoreJids,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  public async fetchSettings(instance: InstanceDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
        include: {
          Fallback: true,
        },
      });

      if (!settings) {
        return {
          expire: 0,
          keywordFinish: '',
          delayMessage: 0,
          unknownMessage: '',
          listeningFromMe: false,
          stopBotFromMe: false,
          keepOpen: false,
          ignoreJids: [],
          typebotIdFallback: null,
          fallback: null,
        };
      }

      return {
        expire: settings.expire,
        keywordFinish: settings.keywordFinish,
        delayMessage: settings.delayMessage,
        unknownMessage: settings.unknownMessage,
        listeningFromMe: settings.listeningFromMe,
        stopBotFromMe: settings.stopBotFromMe,
        keepOpen: settings.keepOpen,
        ignoreJids: settings.ignoreJids,
        typebotIdFallback: settings.typebotIdFallback,
        fallback: settings.Fallback,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching default settings');
    }
  }

  // Sessions
  public async startBot(instance: InstanceDto, data: any) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    if (data.remoteJid === 'status@broadcast') return;

    const instanceData = await this.prismaRepository.instance.findFirst({
      where: {
        name: instance.instanceName,
      },
    });

    if (!instanceData) throw new Error('Instance not found');

    const remoteJid = data.remoteJid;
    const url = data.url;
    const typebot = data.typebot;
    const startSession = data.startSession;
    const variables = data.variables;
    let expire = data?.typebot?.expire;
    let keywordFinish = data?.typebot?.keywordFinish;
    let delayMessage = data?.typebot?.delayMessage;
    let unknownMessage = data?.typebot?.unknownMessage;
    let listeningFromMe = data?.typebot?.listeningFromMe;
    let stopBotFromMe = data?.typebot?.stopBotFromMe;
    let keepOpen = data?.typebot?.keepOpen;
    let debounceTime = data?.typebot?.debounceTime;
    let ignoreJids = data?.typebot?.ignoreJids;

    const defaultSettingCheck = await this.settingsRepository.findFirst({
      where: {
        instanceId: instanceData.id,
      },
    });

    if (this.checkIgnoreJids(defaultSettingCheck?.ignoreJids, remoteJid)) throw new Error('Jid not allowed');

    if (
      !expire ||
      !keywordFinish ||
      !delayMessage ||
      !unknownMessage ||
      !listeningFromMe ||
      !stopBotFromMe ||
      !keepOpen ||
      !debounceTime ||
      !ignoreJids
    ) {
      if (expire === undefined || expire === null) expire = defaultSettingCheck.expire;
      if (keywordFinish === undefined || keywordFinish === null) keywordFinish = defaultSettingCheck.keywordFinish;
      if (delayMessage === undefined || delayMessage === null) delayMessage = defaultSettingCheck.delayMessage;
      if (unknownMessage === undefined || unknownMessage === null) unknownMessage = defaultSettingCheck.unknownMessage;
      if (listeningFromMe === undefined || listeningFromMe === null)
        listeningFromMe = defaultSettingCheck.listeningFromMe;
      if (stopBotFromMe === undefined || stopBotFromMe === null) stopBotFromMe = defaultSettingCheck.stopBotFromMe;
      if (keepOpen === undefined || keepOpen === null) keepOpen = defaultSettingCheck.keepOpen;
      if (debounceTime === undefined || debounceTime === null) debounceTime = defaultSettingCheck.debounceTime;
      if (ignoreJids === undefined || ignoreJids === null) ignoreJids = defaultSettingCheck.ignoreJids;

      if (!defaultSettingCheck) {
        await this.settings(instance, {
          expire: expire,
          keywordFinish: keywordFinish,
          delayMessage: delayMessage,
          unknownMessage: unknownMessage,
          listeningFromMe: listeningFromMe,
          stopBotFromMe: stopBotFromMe,
          keepOpen: keepOpen,
          debounceTime: debounceTime,
          ignoreJids: ignoreJids,
        });
      }
    }

    const prefilledVariables: any = {};

    if (variables?.length) {
      variables.forEach((variable: { name: string | number; value: string }) => {
        prefilledVariables[variable.name] = variable.value;
      });
    }

    if (startSession) {
      let findBot: any = await this.botRepository.findFirst({
        where: {
          url: url,
          typebot: typebot,
          instanceId: instanceData.id,
        },
      });

      if (!findBot) {
        findBot = await this.botRepository.create({
          data: {
            enabled: true,
            url: url,
            typebot: typebot,
            instanceId: instanceData.id,
            expire: expire,
            keywordFinish: keywordFinish,
            delayMessage: delayMessage,
            unknownMessage: unknownMessage,
            listeningFromMe: listeningFromMe,
            stopBotFromMe: stopBotFromMe,
            keepOpen: keepOpen,
          },
        });
      }

      await this.prismaRepository.integrationSession.deleteMany({
        where: {
          remoteJid: remoteJid,
          instanceId: instanceData.id,
          botId: { not: null },
        },
      });

      await this.typebotService.processTypebot(
        instanceData,
        remoteJid,
        null,
        null,
        findBot,
        url,
        expire,
        typebot,
        keywordFinish,
        delayMessage,
        unknownMessage,
        listeningFromMe,
        stopBotFromMe,
        keepOpen,
        'init',
        prefilledVariables,
      );
    } else {
      const id = Math.floor(Math.random() * 10000000000).toString();

      try {
        const version = configService.get<Typebot>('TYPEBOT').API_VERSION;
        let url: string;
        let reqData: {};
        if (version === 'latest') {
          url = `${data.url}/api/v1/typebots/${data.typebot}/startChat`;

          reqData = {
            prefilledVariables: prefilledVariables,
          };
        } else {
          url = `${data.url}/api/v1/sendMessage`;

          reqData = {
            startParams: {
              publicId: data.typebot,
              prefilledVariables: prefilledVariables,
            },
          };
        }
        const request = await axios.post(url, reqData);

        await this.typebotService.sendWAMessage(
          instanceData,
          null,
          {
            expire: expire,
            keywordFinish: keywordFinish,
            delayMessage: delayMessage,
            unknownMessage: unknownMessage,
            listeningFromMe: listeningFromMe,
            stopBotFromMe: stopBotFromMe,
            keepOpen: keepOpen,
          },
          remoteJid,
          request.data.messages,
          request.data.input,
          request.data.clientSideActions,
        );

        this.waMonitor.waInstances[instance.instanceName].sendDataWebhook(Events.TYPEBOT_START, {
          remoteJid: remoteJid,
          url: url,
          typebot: typebot,
          variables: variables,
          sessionId: id,
        });
      } catch (error) {
        this.logger.error(error);
        return;
      }
    }

    return {
      typebot: {
        ...instance,
        typebot: {
          url: url,
          remoteJid: remoteJid,
          typebot: typebot,
          prefilledVariables: prefilledVariables,
        },
      },
    };
  }

  public async changeStatus(instance: InstanceDto, data: any) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const remoteJid = data.remoteJid;
      const status = data.status;

      const defaultSettingCheck = await this.settingsRepository.findFirst({
        where: {
          instanceId,
        },
      });

      if (status === 'delete') {
        await this.sessionRepository.deleteMany({
          where: {
            remoteJid: remoteJid,
            instanceId: instanceId,
            botId: { not: null },
          },
        });

        return { typebot: { ...instance, typebot: { remoteJid: remoteJid, status: status } } };
      }

      if (status === 'closed') {
        if (defaultSettingCheck?.keepOpen) {
          await this.sessionRepository.updateMany({
            where: {
              instanceId: instanceId,
              remoteJid: remoteJid,
              botId: { not: null },
            },
            data: {
              status: status,
            },
          });
        } else {
          await this.sessionRepository.deleteMany({
            where: {
              remoteJid: remoteJid,
              instanceId: instanceId,
              botId: { not: null },
            },
          });
        }

        return { typebot: { ...instance, typebot: { remoteJid: remoteJid, status: status } } };
      }

      const session = await this.sessionRepository.updateMany({
        where: {
          instanceId: instanceId,
          remoteJid: remoteJid,
          botId: { not: null },
        },
        data: {
          status: status,
        },
      });

      const typebotData = {
        remoteJid: remoteJid,
        status: status,
        session,
      };

      this.waMonitor.waInstances[instance.instanceName].sendDataWebhook(Events.TYPEBOT_CHANGE_STATUS, typebotData);

      return { typebot: { ...instance, typebot: typebotData } };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error changing status');
    }
  }

  public async fetchSessions(instance: InstanceDto, botId: string, remoteJid?: string) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const typebot = await this.botRepository.findFirst({
        where: {
          id: botId,
        },
      });

      if (typebot && typebot.instanceId !== instanceId) {
        throw new Error('Typebot not found');
      }

      return await this.sessionRepository.findMany({
        where: {
          instanceId: instanceId,
          remoteJid,
          botId: botId ?? { not: null },
          type: 'typebot',
        },
      });
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error fetching sessions');
    }
  }

  public async ignoreJid(instance: InstanceDto, data: IgnoreJidDto) {
    if (!this.integrationEnabled) throw new BadRequestException('Typebot is disabled');

    try {
      const instanceId = await this.prismaRepository.instance
        .findFirst({
          where: {
            name: instance.instanceName,
          },
        })
        .then((instance) => instance.id);

      const settings = await this.settingsRepository.findFirst({
        where: {
          instanceId: instanceId,
        },
      });

      if (!settings) {
        throw new Error('Settings not found');
      }

      let ignoreJids: any = settings?.ignoreJids || [];

      if (data.action === 'add') {
        if (ignoreJids.includes(data.remoteJid)) return { ignoreJids: ignoreJids };

        ignoreJids.push(data.remoteJid);
      } else {
        ignoreJids = ignoreJids.filter((jid) => jid !== data.remoteJid);
      }

      const updateSettings = await this.settingsRepository.update({
        where: {
          id: settings.id,
        },
        data: {
          ignoreJids: ignoreJids,
        },
      });

      return {
        ignoreJids: updateSettings.ignoreJids,
      };
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error setting default settings');
    }
  }

  public async emit({
    instance,
    remoteJid,
    msg,
  }: {
    instance: InstanceDto;
    remoteJid: string;
    msg: any;
    pushName?: string;
  }) {
    if (!this.integrationEnabled) return;

    try {
      const instanceData = await this.prismaRepository.instance.findFirst({
        where: {
          name: instance.instanceName,
        },
      });

      if (!instanceData) throw new Error('Instance not found');

      const session = await this.getSession(remoteJid, instance);

      const content = getConversationMessage(msg);

      let findBot = (await this.findBotTrigger(this.botRepository, content, instance, session)) as TypebotModel;

      if (!findBot) {
        const fallback = await this.settingsRepository.findFirst({
          where: {
            instanceId: instance.instanceId,
          },
        });

        if (fallback?.typebotIdFallback) {
          const findFallback = await this.botRepository.findFirst({
            where: {
              id: fallback.typebotIdFallback,
            },
          });

          findBot = findFallback;
        } else {
          return;
        }
      }

      const settings = await this.prismaRepository.typebotSetting.findFirst({
        where: {
          instanceId: instance.instanceId,
        },
      });

      const url = findBot?.url;
      const typebot = findBot?.typebot;
      let expire = findBot?.expire;
      let keywordFinish = findBot?.keywordFinish;
      let delayMessage = findBot?.delayMessage;
      let unknownMessage = findBot?.unknownMessage;
      let listeningFromMe = findBot?.listeningFromMe;
      let stopBotFromMe = findBot?.stopBotFromMe;
      let keepOpen = findBot?.keepOpen;
      let debounceTime = findBot?.debounceTime;
      let ignoreJids = findBot?.ignoreJids;

      if (expire === undefined || expire === null) expire = settings.expire;
      if (keywordFinish === undefined || keywordFinish === null) keywordFinish = settings.keywordFinish;
      if (delayMessage === undefined || delayMessage === null) delayMessage = settings.delayMessage;
      if (unknownMessage === undefined || unknownMessage === null) unknownMessage = settings.unknownMessage;
      if (listeningFromMe === undefined || listeningFromMe === null) listeningFromMe = settings.listeningFromMe;
      if (stopBotFromMe === undefined || stopBotFromMe === null) stopBotFromMe = settings.stopBotFromMe;
      if (keepOpen === undefined || keepOpen === null) keepOpen = settings.keepOpen;
      if (debounceTime === undefined || debounceTime === null) debounceTime = settings.debounceTime;
      if (ignoreJids === undefined || ignoreJids === null) ignoreJids = settings.ignoreJids;

      if (this.checkIgnoreJids(ignoreJids, remoteJid)) return;

      const key = msg.key as {
        id: string;
        remoteJid: string;
        fromMe: boolean;
        participant: string;
      };

      if (stopBotFromMe && key.fromMe && session) {
        await this.sessionRepository.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'paused',
          },
        });
        return;
      }

      if (!listeningFromMe && key.fromMe) {
        return;
      }

      if (session && !session.awaitUser) {
        return;
      }

      if (debounceTime && debounceTime > 0) {
        this.processDebounce(this.userMessageDebounce, content, remoteJid, debounceTime, async (debouncedContent) => {
          await this.typebotService.processTypebot(
            instanceData,
            remoteJid,
            msg,
            session,
            findBot,
            url,
            expire,
            typebot,
            keywordFinish,
            delayMessage,
            unknownMessage,
            listeningFromMe,
            stopBotFromMe,
            keepOpen,
            debouncedContent,
          );
        });
      } else {
        await this.typebotService.processTypebot(
          instanceData,
          remoteJid,
          msg,
          session,
          findBot,
          url,
          expire,
          typebot,
          keywordFinish,
          delayMessage,
          unknownMessage,
          listeningFromMe,
          stopBotFromMe,
          keepOpen,
          content,
        );
      }

      if (session && !session.awaitUser) return;
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }
}



================================================
FILE: src/api/integrations/chatbot/typebot/dto/typebot.dto.ts
================================================
import { TriggerOperator, TriggerType } from '@prisma/client';

export class PrefilledVariables {
  remoteJid?: string;
  pushName?: string;
  messageType?: string;
  additionalData?: { [key: string]: any };
}

export class TypebotDto {
  enabled?: boolean;
  description?: string;
  url: string;
  typebot?: string;
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  triggerType?: TriggerType;
  triggerOperator?: TriggerOperator;
  triggerValue?: string;
  ignoreJids?: any;
}

export class TypebotSettingDto {
  expire?: number;
  keywordFinish?: string;
  delayMessage?: number;
  unknownMessage?: string;
  listeningFromMe?: boolean;
  stopBotFromMe?: boolean;
  keepOpen?: boolean;
  debounceTime?: number;
  typebotIdFallback?: string;
  ignoreJids?: any;
}



================================================
FILE: src/api/integrations/chatbot/typebot/routes/typebot.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { IgnoreJidDto } from '@api/dto/chatbot.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { TypebotDto, TypebotSettingDto } from '@api/integrations/chatbot/typebot/dto/typebot.dto';
import { HttpStatus } from '@api/routes/index.router';
import { typebotController } from '@api/server.module';
import {
  instanceSchema,
  typebotIgnoreJidSchema,
  typebotSchema,
  typebotSettingSchema,
  typebotStartSchema,
  typebotStatusSchema,
} from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

export class TypebotRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('create'), ...guards, async (req, res) => {
        const response = await this.dataValidate<TypebotDto>({
          request: req,
          schema: typebotSchema,
          ClassRef: TypebotDto,
          execute: (instance, data) => typebotController.createBot(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => typebotController.findBot(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetch/:typebotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => typebotController.fetchBot(instance, req.params.typebotId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .put(this.routerPath('update/:typebotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<TypebotDto>({
          request: req,
          schema: typebotSchema,
          ClassRef: TypebotDto,
          execute: (instance, data) => typebotController.updateBot(instance, req.params.typebotId, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .delete(this.routerPath('delete/:typebotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => typebotController.deleteBot(instance, req.params.typebotId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('settings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<TypebotSettingDto>({
          request: req,
          schema: typebotSettingSchema,
          ClassRef: TypebotSettingDto,
          execute: (instance, data) => typebotController.settings(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSettings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => typebotController.fetchSettings(instance),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('start'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: typebotStartSchema,
          ClassRef: InstanceDto,
          execute: (instance, data) => typebotController.startBot(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('changeStatus'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: typebotStatusSchema,
          ClassRef: InstanceDto,
          execute: (instance, data) => typebotController.changeStatus(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchSessions/:typebotId'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => typebotController.fetchSessions(instance, req.params.typebotId),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('ignoreJid'), ...guards, async (req, res) => {
        const response = await this.dataValidate<IgnoreJidDto>({
          request: req,
          schema: typebotIgnoreJidSchema,
          ClassRef: IgnoreJidDto,
          execute: (instance, data) => typebotController.ignoreJid(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/chatbot/typebot/services/typebot.service.ts
================================================
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Auth, ConfigService, HttpServer, Typebot } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { Instance, IntegrationSession, Message, Typebot as TypebotModel } from '@prisma/client';
import { getConversationMessage } from '@utils/getConversationMessage';
import { sendTelemetry } from '@utils/sendTelemetry';
import axios from 'axios';

export class TypebotService {
  constructor(
    private readonly waMonitor: WAMonitoringService,
    private readonly configService: ConfigService,
    private readonly prismaRepository: PrismaRepository,
  ) {}

  private readonly logger = new Logger('TypebotService');

  public async createNewSession(instance: Instance, data: any) {
    if (data.remoteJid === 'status@broadcast') return;
    const id = Math.floor(Math.random() * 10000000000).toString();

    try {
      const version = this.configService.get<Typebot>('TYPEBOT').API_VERSION;
      let url: string;
      let reqData: {};
      if (version === 'latest') {
        url = `${data.url}/api/v1/typebots/${data.typebot}/startChat`;

        reqData = {
          prefilledVariables: {
            ...data.prefilledVariables,
            remoteJid: data.remoteJid,
            pushName: data.pushName || data.prefilledVariables?.pushName || '',
            instanceName: instance.name,
            serverUrl: this.configService.get<HttpServer>('SERVER').URL,
            apiKey: this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY,
            ownerJid: instance.number,
          },
        };
      } else {
        url = `${data.url}/api/v1/sendMessage`;

        reqData = {
          startParams: {
            publicId: data.typebot,
            prefilledVariables: {
              ...data.prefilledVariables,
              remoteJid: data.remoteJid,
              pushName: data.pushName || data.prefilledVariables?.pushName || '',
              instanceName: instance.name,
              serverUrl: this.configService.get<HttpServer>('SERVER').URL,
              apiKey: this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY,
              ownerJid: instance.number,
            },
          },
        };
      }
      const request = await axios.post(url, reqData);

      let session = null;
      if (request?.data?.sessionId) {
        session = await this.prismaRepository.integrationSession.create({
          data: {
            remoteJid: data.remoteJid,
            pushName: data.pushName || '',
            sessionId: `${id}-${request.data.sessionId}`,
            status: 'opened',
            parameters: {
              ...data.prefilledVariables,
              remoteJid: data.remoteJid,
              pushName: data.pushName || '',
              instanceName: instance.name,
              serverUrl: this.configService.get<HttpServer>('SERVER').URL,
              apiKey: this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY,
              ownerJid: instance.number,
            },
            awaitUser: false,
            botId: data.botId,
            instanceId: instance.id,
            type: 'typebot',
          },
        });
      }
      return { ...request.data, session };
    } catch (error) {
      this.logger.error(error);
      return;
    }
  }

  public async sendWAMessage(
    instance: Instance,
    session: IntegrationSession,
    settings: {
      expire: number;
      keywordFinish: string;
      delayMessage: number;
      unknownMessage: string;
      listeningFromMe: boolean;
      stopBotFromMe: boolean;
      keepOpen: boolean;
    },
    remoteJid: string,
    messages: any,
    input: any,
    clientSideActions: any,
  ) {
    processMessages(
      this.waMonitor.waInstances[instance.name],
      session,
      settings,
      messages,
      input,
      clientSideActions,
      applyFormatting,
      this.prismaRepository,
    ).catch((err) => {
      console.error('Erro ao processar mensagens:', err);
    });

    function findItemAndGetSecondsToWait(array, targetId) {
      if (!array) return null;

      for (const item of array) {
        if (item.lastBubbleBlockId === targetId) {
          return item.wait?.secondsToWaitFor;
        }
      }
      return null;
    }

    function applyFormatting(element) {
      let text = '';

      if (element.text) {
        text += element.text;
      }

      if (element.children && element.type !== 'a') {
        for (const child of element.children) {
          text += applyFormatting(child);
        }
      }

      if (element.type === 'p' && element.type !== 'inline-variable') {
        text = text.trim() + '\n';
      }

      if (element.type === 'inline-variable') {
        text = text.trim();
      }

      if (element.type === 'ol') {
        text =
          '\n' +
          text
            .split('\n')
            .map((line, index) => (line ? `${index + 1}. ${line}` : ''))
            .join('\n');
      }

      if (element.type === 'li') {
        text = text
          .split('\n')
          .map((line) => (line ? `  ${line}` : ''))
          .join('\n');
      }

      let formats = '';

      if (element.bold) {
        formats += '*';
      }

      if (element.italic) {
        formats += '_';
      }

      if (element.underline) {
        formats += '~';
      }

      let formattedText = `${formats}${text}${formats.split('').reverse().join('')}`;

      if (element.url) {
        formattedText = element.children[0]?.text ? `[${formattedText}]\n(${element.url})` : `${element.url}`;
      }

      return formattedText;
    }

    async function processMessages(
      instance: any,
      session: IntegrationSession,
      settings: {
        expire: number;
        keywordFinish: string;
        delayMessage: number;
        unknownMessage: string;
        listeningFromMe: boolean;
        stopBotFromMe: boolean;
        keepOpen: boolean;
      },
      messages: any,
      input: any,
      clientSideActions: any,
      applyFormatting: any,
      prismaRepository: PrismaRepository,
    ) {
      for (const message of messages) {
        if (message.type === 'text') {
          let formattedText = '';

          for (const richText of message.content.richText) {
            for (const element of richText.children) {
              formattedText += applyFormatting(element);
            }
            formattedText += '\n';
          }

          formattedText = formattedText.replace(/\*\*/g, '').replace(/__/, '').replace(/~~/, '').replace(/\n$/, '');

          formattedText = formattedText.replace(/\n$/, '');

          if (formattedText.includes('[list]')) {
            const listJson = {
              number: remoteJid.split('@')[0],
              title: '',
              description: '',
              buttonText: '',
              footerText: '',
              sections: [],
            };

            const titleMatch = formattedText.match(/\[title\]([\s\S]*?)(?=\[description\])/);
            const descriptionMatch = formattedText.match(/\[description\]([\s\S]*?)(?=\[buttonText\])/);
            const buttonTextMatch = formattedText.match(/\[buttonText\]([\s\S]*?)(?=\[footerText\])/);
            const footerTextMatch = formattedText.match(/\[footerText\]([\s\S]*?)(?=\[menu\])/);

            if (titleMatch) listJson.title = titleMatch[1].trim();
            if (descriptionMatch) listJson.description = descriptionMatch[1].trim();
            if (buttonTextMatch) listJson.buttonText = buttonTextMatch[1].trim();
            if (footerTextMatch) listJson.footerText = footerTextMatch[1].trim();

            const menuContent = formattedText.match(/\[menu\]([\s\S]*?)\[\/menu\]/)?.[1];
            if (menuContent) {
              const sections = menuContent.match(/\[section\]([\s\S]*?)(?=\[section\]|\[\/section\]|\[\/menu\])/g);
              if (sections) {
                sections.forEach((section) => {
                  const sectionTitle = section.match(/title: (.*?)(?:\n|$)/)?.[1]?.trim();
                  const rows = section.match(/\[row\]([\s\S]*?)(?=\[row\]|\[\/row\]|\[\/section\]|\[\/menu\])/g);

                  const sectionData = {
                    title: sectionTitle,
                    rows:
                      rows?.map((row) => ({
                        title: row.match(/title: (.*?)(?:\n|$)/)?.[1]?.trim(),
                        description: row.match(/description: (.*?)(?:\n|$)/)?.[1]?.trim(),
                        rowId: row.match(/rowId: (.*?)(?:\n|$)/)?.[1]?.trim(),
                      })) || [],
                  };

                  listJson.sections.push(sectionData);
                });
              }
            }

            await instance.listMessage(listJson);
          } else if (formattedText.includes('[buttons]')) {
            const buttonJson = {
              number: remoteJid.split('@')[0],
              thumbnailUrl: undefined,
              title: '',
              description: '',
              footer: '',
              buttons: [],
            };

            const thumbnailUrlMatch = formattedText.match(/\[thumbnailUrl\]([\s\S]*?)(?=\[title\])/);
            const titleMatch = formattedText.match(/\[title\]([\s\S]*?)(?=\[description\])/);
            const descriptionMatch = formattedText.match(/\[description\]([\s\S]*?)(?=\[footer\])/);
            const footerMatch = formattedText.match(/\[footer\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url))/);

            if (titleMatch) buttonJson.title = titleMatch[1].trim();
            if (thumbnailUrlMatch) buttonJson.thumbnailUrl = thumbnailUrlMatch[1].trim();
            if (descriptionMatch) buttonJson.description = descriptionMatch[1].trim();
            if (footerMatch) buttonJson.footer = footerMatch[1].trim();

            const buttonTypes = {
              reply: /\[reply\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
              pix: /\[pix\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
              copy: /\[copy\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
              call: /\[call\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
              url: /\[url\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
            };

            for (const [type, pattern] of Object.entries(buttonTypes)) {
              let match;
              while ((match = pattern.exec(formattedText)) !== null) {
                const content = match[1].trim();
                const button: any = { type };

                switch (type) {
                  case 'pix':
                    button.currency = content.match(/currency: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.name = content.match(/name: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.keyType = content.match(/keyType: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.key = content.match(/key: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;

                  case 'reply':
                    button.displayText = content.match(/displayText: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.id = content.match(/id: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;

                  case 'copy':
                    button.displayText = content.match(/displayText: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.copyCode = content.match(/copyCode: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;

                  case 'call':
                    button.displayText = content.match(/displayText: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.phoneNumber = content.match(/phone: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;

                  case 'url':
                    button.displayText = content.match(/displayText: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.url = content.match(/url: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;
                }

                if (Object.keys(button).length > 1) {
                  buttonJson.buttons.push(button);
                }
              }
            }

            await instance.buttonMessage(buttonJson);
          } else {
            await instance.textMessage(
              {
                number: remoteJid.split('@')[0],
                delay: settings?.delayMessage || 1000,
                text: formattedText,
              },
              false,
            );
          }

          sendTelemetry('/message/sendText');
        }

        if (message.type === 'image') {
          await instance.mediaMessage(
            {
              number: remoteJid.split('@')[0],
              delay: settings?.delayMessage || 1000,
              mediatype: 'image',
              media: message.content.url,
            },
            null,
            false,
          );

          sendTelemetry('/message/sendMedia');
        }

        if (message.type === 'video') {
          await instance.mediaMessage(
            {
              number: remoteJid.split('@')[0],
              delay: settings?.delayMessage || 1000,
              mediatype: 'video',
              media: message.content.url,
            },
            null,
            false,
          );

          sendTelemetry('/message/sendMedia');
        }

        if (message.type === 'audio') {
          await instance.audioWhatsapp(
            {
              number: remoteJid.split('@')[0],
              delay: settings?.delayMessage || 1000,
              encoding: true,
              audio: message.content.url,
            },
            false,
          );

          sendTelemetry('/message/sendWhatsAppAudio');
        }

        const wait = findItemAndGetSecondsToWait(clientSideActions, message.id);

        if (wait) {
          await new Promise((resolve) => setTimeout(resolve, wait * 1000));
        }
      }

      console.log('input', input);
      if (input) {
        if (input.type === 'choice input') {
          let formattedText = '';

          const items = input.items;

          for (const item of items) {
            formattedText += `▶️ ${item.content}\n`;
          }

          formattedText = formattedText.replace(/\n$/, '');

          if (formattedText.includes('[list]')) {
            const listJson = {
              number: remoteJid.split('@')[0],
              title: '',
              description: '',
              buttonText: '',
              footerText: '',
              sections: [],
            };

            const titleMatch = formattedText.match(/\[title\]([\s\S]*?)(?=\[description\])/);
            const descriptionMatch = formattedText.match(/\[description\]([\s\S]*?)(?=\[buttonText\])/);
            const buttonTextMatch = formattedText.match(/\[buttonText\]([\s\S]*?)(?=\[footerText\])/);
            const footerTextMatch = formattedText.match(/\[footerText\]([\s\S]*?)(?=\[menu\])/);

            if (titleMatch) listJson.title = titleMatch[1].trim();
            if (descriptionMatch) listJson.description = descriptionMatch[1].trim();
            if (buttonTextMatch) listJson.buttonText = buttonTextMatch[1].trim();
            if (footerTextMatch) listJson.footerText = footerTextMatch[1].trim();

            const menuContent = formattedText.match(/\[menu\]([\s\S]*?)\[\/menu\]/)?.[1];
            if (menuContent) {
              const sections = menuContent.match(/\[section\]([\s\S]*?)(?=\[section\]|\[\/section\]|\[\/menu\])/g);
              if (sections) {
                sections.forEach((section) => {
                  const sectionTitle = section.match(/title: (.*?)(?:\n|$)/)?.[1]?.trim();
                  const rows = section.match(/\[row\]([\s\S]*?)(?=\[row\]|\[\/row\]|\[\/section\]|\[\/menu\])/g);

                  const sectionData = {
                    title: sectionTitle,
                    rows:
                      rows?.map((row) => ({
                        title: row.match(/title: (.*?)(?:\n|$)/)?.[1]?.trim(),
                        description: row.match(/description: (.*?)(?:\n|$)/)?.[1]?.trim(),
                        rowId: row.match(/rowId: (.*?)(?:\n|$)/)?.[1]?.trim(),
                      })) || [],
                  };

                  listJson.sections.push(sectionData);
                });
              }
            }

            await instance.listMessage(listJson);
          } else if (formattedText.includes('[buttons]')) {
            const buttonJson = {
              number: remoteJid.split('@')[0],
              thumbnailUrl: undefined,
              title: '',
              description: '',
              footer: '',
              buttons: [],
            };

            const thumbnailUrlMatch = formattedText.match(/\[thumbnailUrl\]([\s\S]*?)(?=\[title\])/);
            const titleMatch = formattedText.match(/\[title\]([\s\S]*?)(?=\[description\])/);
            const descriptionMatch = formattedText.match(/\[description\]([\s\S]*?)(?=\[footer\])/);
            const footerMatch = formattedText.match(/\[footer\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url))/);

            if (titleMatch) buttonJson.title = titleMatch[1].trim();
            if (thumbnailUrlMatch) buttonJson.thumbnailUrl = thumbnailUrlMatch[1].trim();
            if (descriptionMatch) buttonJson.description = descriptionMatch[1].trim();
            if (footerMatch) buttonJson.footer = footerMatch[1].trim();

            const buttonTypes = {
              reply: /\[reply\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
              pix: /\[pix\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
              copy: /\[copy\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
              call: /\[call\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
              url: /\[url\]([\s\S]*?)(?=\[(?:reply|pix|copy|call|url)|$)/g,
            };

            for (const [type, pattern] of Object.entries(buttonTypes)) {
              let match;
              while ((match = pattern.exec(formattedText)) !== null) {
                const content = match[1].trim();
                const button: any = { type };

                switch (type) {
                  case 'pix':
                    button.currency = content.match(/currency: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.name = content.match(/name: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.keyType = content.match(/keyType: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.key = content.match(/key: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;

                  case 'reply':
                    button.displayText = content.match(/displayText: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.id = content.match(/id: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;

                  case 'copy':
                    button.displayText = content.match(/displayText: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.copyCode = content.match(/copyCode: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;

                  case 'call':
                    button.displayText = content.match(/displayText: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.phoneNumber = content.match(/phone: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;

                  case 'url':
                    button.displayText = content.match(/displayText: (.*?)(?:\n|$)/)?.[1]?.trim();
                    button.url = content.match(/url: (.*?)(?:\n|$)/)?.[1]?.trim();
                    break;
                }

                if (Object.keys(button).length > 1) {
                  buttonJson.buttons.push(button);
                }
              }
            }

            await instance.buttonMessage(buttonJson);
          } else {
            await instance.textMessage(
              {
                number: remoteJid.split('@')[0],
                delay: settings?.delayMessage || 1000,
                text: formattedText,
              },
              false,
            );
          }

          sendTelemetry('/message/sendText');
        }

        await prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            awaitUser: true,
          },
        });
      } else {
        if (!settings?.keepOpen) {
          await prismaRepository.integrationSession.deleteMany({
            where: {
              id: session.id,
            },
          });
        } else {
          await prismaRepository.integrationSession.update({
            where: {
              id: session.id,
            },
            data: {
              status: 'closed',
            },
          });
        }
      }
    }
  }

  public async processTypebot(
    instance: Instance,
    remoteJid: string,
    msg: Message,
    session: IntegrationSession,
    findTypebot: TypebotModel,
    url: string,
    expire: number,
    typebot: string,
    keywordFinish: string,
    delayMessage: number,
    unknownMessage: string,
    listeningFromMe: boolean,
    stopBotFromMe: boolean,
    keepOpen: boolean,
    content: string,
    prefilledVariables?: any,
  ) {
    if (session && expire && expire > 0) {
      const now = Date.now();

      const sessionUpdatedAt = new Date(session.updatedAt).getTime();

      const diff = now - sessionUpdatedAt;

      const diffInMinutes = Math.floor(diff / 1000 / 60);

      if (diffInMinutes > expire) {
        if (keepOpen) {
          await this.prismaRepository.integrationSession.update({
            where: {
              id: session.id,
            },
            data: {
              status: 'closed',
            },
          });
        } else {
          await this.prismaRepository.integrationSession.deleteMany({
            where: {
              botId: findTypebot.id,
              remoteJid: remoteJid,
            },
          });
        }

        const data = await this.createNewSession(instance, {
          enabled: findTypebot?.enabled,
          url: url,
          typebot: typebot,
          expire: expire,
          keywordFinish: keywordFinish,
          delayMessage: delayMessage,
          unknownMessage: unknownMessage,
          listeningFromMe: listeningFromMe,
          remoteJid: remoteJid,
          pushName: msg.pushName,
          botId: findTypebot.id,
          prefilledVariables: prefilledVariables,
        });

        if (data.session) {
          session = data.session;
        }

        if (data.messages.length === 0) {
          const content = getConversationMessage(msg.message);

          if (!content) {
            if (unknownMessage) {
              this.waMonitor.waInstances[instance.name].textMessage(
                {
                  number: remoteJid.split('@')[0],
                  delay: delayMessage || 1000,
                  text: unknownMessage,
                },
                false,
              );

              sendTelemetry('/message/sendText');
            }
            return;
          }

          if (keywordFinish && content.toLowerCase() === keywordFinish.toLowerCase()) {
            if (keepOpen) {
              await this.prismaRepository.integrationSession.update({
                where: {
                  id: session.id,
                },
                data: {
                  status: 'closed',
                },
              });
            } else {
              await this.prismaRepository.integrationSession.deleteMany({
                where: {
                  botId: findTypebot.id,
                  remoteJid: remoteJid,
                },
              });
            }
            return;
          }

          try {
            const version = this.configService.get<Typebot>('TYPEBOT').API_VERSION;
            let urlTypebot: string;
            let reqData: {};
            if (version === 'latest') {
              urlTypebot = `${url}/api/v1/sessions/${data.sessionId}/continueChat`;
              reqData = {
                message: content,
              };
            } else {
              urlTypebot = `${url}/api/v1/sendMessage`;
              reqData = {
                message: content,
                sessionId: data.sessionId,
              };
            }

            const request = await axios.post(urlTypebot, reqData);

            await this.sendWAMessage(
              instance,
              session,
              {
                expire: expire,
                keywordFinish: keywordFinish,
                delayMessage: delayMessage,
                unknownMessage: unknownMessage,
                listeningFromMe: listeningFromMe,
                stopBotFromMe: stopBotFromMe,
                keepOpen: keepOpen,
              },
              remoteJid,
              request.data.messages,
              request.data.input,
              request.data.clientSideActions,
            );
          } catch (error) {
            this.logger.error(error);
            return;
          }
        }

        await this.sendWAMessage(
          instance,
          session,
          {
            expire: expire,
            keywordFinish: keywordFinish,
            delayMessage: delayMessage,
            unknownMessage: unknownMessage,
            listeningFromMe: listeningFromMe,
            stopBotFromMe: stopBotFromMe,
            keepOpen: keepOpen,
          },
          remoteJid,
          data.messages,
          data.input,
          data.clientSideActions,
        );

        return;
      }
    }

    if (session && session.status !== 'opened') {
      return;
    }

    if (!session) {
      const data = await this.createNewSession(instance, {
        enabled: findTypebot?.enabled,
        url: url,
        typebot: typebot,
        expire: expire,
        keywordFinish: keywordFinish,
        delayMessage: delayMessage,
        unknownMessage: unknownMessage,
        listeningFromMe: listeningFromMe,
        remoteJid: remoteJid,
        pushName: msg?.pushName,
        botId: findTypebot.id,
        prefilledVariables: prefilledVariables,
      });

      if (data?.session) {
        session = data.session;
      }

      await this.sendWAMessage(
        instance,
        session,
        {
          expire: expire,
          keywordFinish: keywordFinish,
          delayMessage: delayMessage,
          unknownMessage: unknownMessage,
          listeningFromMe: listeningFromMe,
          stopBotFromMe: stopBotFromMe,
          keepOpen: keepOpen,
        },
        remoteJid,
        data?.messages,
        data?.input,
        data?.clientSideActions,
      );

      if (data.messages.length === 0) {
        if (!content) {
          if (unknownMessage) {
            this.waMonitor.waInstances[instance.name].textMessage(
              {
                number: remoteJid.split('@')[0],
                delay: delayMessage || 1000,
                text: unknownMessage,
              },
              false,
            );

            sendTelemetry('/message/sendText');
          }
          return;
        }

        if (keywordFinish && content.toLowerCase() === keywordFinish.toLowerCase()) {
          if (keepOpen) {
            await this.prismaRepository.integrationSession.update({
              where: {
                id: session.id,
              },
              data: {
                status: 'closed',
              },
            });
          } else {
            await this.prismaRepository.integrationSession.deleteMany({
              where: {
                botId: findTypebot.id,
                remoteJid: remoteJid,
              },
            });
          }

          return;
        }

        let request: any;
        try {
          const version = this.configService.get<Typebot>('TYPEBOT').API_VERSION;
          let urlTypebot: string;
          let reqData: {};
          if (version === 'latest') {
            urlTypebot = `${url}/api/v1/sessions/${data.sessionId}/continueChat`;
            reqData = {
              message: content,
            };
          } else {
            urlTypebot = `${url}/api/v1/sendMessage`;
            reqData = {
              message: content,
              sessionId: data.sessionId,
            };
          }
          request = await axios.post(urlTypebot, reqData);

          await this.sendWAMessage(
            instance,
            session,
            {
              expire: expire,
              keywordFinish: keywordFinish,
              delayMessage: delayMessage,
              unknownMessage: unknownMessage,
              listeningFromMe: listeningFromMe,
              stopBotFromMe: stopBotFromMe,
              keepOpen: keepOpen,
            },
            remoteJid,
            request.data.messages,
            request.data.input,
            request.data.clientSideActions,
          );
        } catch (error) {
          this.logger.error(error);
          return;
        }
      }
      return;
    }

    await this.prismaRepository.integrationSession.update({
      where: {
        id: session.id,
      },
      data: {
        status: 'opened',
        awaitUser: false,
      },
    });

    if (!content) {
      if (unknownMessage) {
        this.waMonitor.waInstances[instance.name].textMessage(
          {
            number: remoteJid.split('@')[0],
            delay: delayMessage || 1000,
            text: unknownMessage,
          },
          false,
        );

        sendTelemetry('/message/sendText');
      }
      return;
    }

    if (keywordFinish && content.toLowerCase() === keywordFinish.toLowerCase()) {
      if (keepOpen) {
        await this.prismaRepository.integrationSession.update({
          where: {
            id: session.id,
          },
          data: {
            status: 'closed',
          },
        });
      } else {
        await this.prismaRepository.integrationSession.deleteMany({
          where: {
            botId: findTypebot.id,
            remoteJid: remoteJid,
          },
        });
      }
      return;
    }

    const version = this.configService.get<Typebot>('TYPEBOT').API_VERSION;
    let urlTypebot: string;
    let reqData: {};
    if (version === 'latest') {
      urlTypebot = `${url}/api/v1/sessions/${session.sessionId.split('-')[1]}/continueChat`;
      reqData = {
        message: content,
      };
    } else {
      urlTypebot = `${url}/api/v1/sendMessage`;
      reqData = {
        message: content,
        sessionId: session.sessionId.split('-')[1],
      };
    }
    const request = await axios.post(urlTypebot, reqData);

    await this.sendWAMessage(
      instance,
      session,
      {
        expire: expire,
        keywordFinish: keywordFinish,
        delayMessage: delayMessage,
        unknownMessage: unknownMessage,
        listeningFromMe: listeningFromMe,
        stopBotFromMe: stopBotFromMe,
        keepOpen: keepOpen,
      },
      remoteJid,
      request?.data?.messages,
      request?.data?.input,
      request?.data?.clientSideActions,
    );

    return;
  }
}



================================================
FILE: src/api/integrations/chatbot/typebot/validate/typebot.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const typebotSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    enabled: { type: 'boolean' },
    description: { type: 'string' },
    url: { type: 'string' },
    typebot: { type: 'string' },
    triggerType: { type: 'string', enum: ['all', 'keyword', 'none', 'advanced'] },
    triggerOperator: { type: 'string', enum: ['equals', 'contains', 'startsWith', 'endsWith', 'regex'] },
    triggerValue: { type: 'string' },
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
  },
  required: ['enabled', 'url', 'typebot', 'triggerType'],
  ...isNotEmpty('enabled', 'url', 'typebot', 'triggerType'),
};

export const typebotStatusSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    status: { type: 'string', enum: ['opened', 'closed', 'paused', 'delete'] },
  },
  required: ['remoteJid', 'status'],
  ...isNotEmpty('remoteJid', 'status'),
};

export const typebotStartSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    url: { type: 'string' },
    typebot: { type: 'string' },
  },
  required: ['remoteJid', 'url', 'typebot'],
  ...isNotEmpty('remoteJid', 'url', 'typebot'),
};

export const typebotSettingSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    expire: { type: 'integer' },
    keywordFinish: { type: 'string' },
    delayMessage: { type: 'integer' },
    unknownMessage: { type: 'string' },
    listeningFromMe: { type: 'boolean' },
    stopBotFromMe: { type: 'boolean' },
    keepOpen: { type: 'boolean' },
    debounceTime: { type: 'integer' },
    typebotIdFallback: { type: 'string' },
    ignoreJids: { type: 'array', items: { type: 'string' } },
  },
  required: ['expire', 'keywordFinish', 'delayMessage', 'unknownMessage', 'listeningFromMe', 'stopBotFromMe'],
  ...isNotEmpty('expire', 'keywordFinish', 'delayMessage', 'unknownMessage', 'listeningFromMe', 'stopBotFromMe'),
};

export const typebotIgnoreJidSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    remoteJid: { type: 'string' },
    action: { type: 'string', enum: ['add', 'remove'] },
  },
  required: ['remoteJid', 'action'],
  ...isNotEmpty('remoteJid', 'action'),
};



================================================
FILE: src/api/integrations/event/event.controller.ts
================================================
import { EventDto } from '@api/integrations/event/event.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { wa } from '@api/types/wa.types';

export type EmitData = {
  instanceName: string;
  origin: string;
  event: string;
  data: any;
  serverUrl: string;
  dateTime: string;
  sender: string;
  apiKey?: string;
  local?: boolean;
  integration?: string[];
};

export interface EventControllerInterface {
  set(instanceName: string, data: any): Promise<any>;
  get(instanceName: string): Promise<any>;
  emit({ instanceName, origin, event, data, serverUrl, dateTime, sender, apiKey, local }: EmitData): Promise<void>;
}

export class EventController {
  public prismaRepository: PrismaRepository;
  protected waMonitor: WAMonitoringService;
  private integrationStatus: boolean;
  private integrationName: string;

  constructor(
    prismaRepository: PrismaRepository,
    waMonitor: WAMonitoringService,
    integrationStatus: boolean,
    integrationName: string,
  ) {
    this.prisma = prismaRepository;
    this.monitor = waMonitor;
    this.status = integrationStatus;
    this.name = integrationName;
  }

  public set prisma(prisma: PrismaRepository) {
    this.prismaRepository = prisma;
  }

  public get prisma() {
    return this.prismaRepository;
  }

  public set monitor(waMonitor: WAMonitoringService) {
    this.waMonitor = waMonitor;
  }

  public get monitor() {
    return this.waMonitor;
  }

  public set name(name: string) {
    this.integrationName = name;
  }

  public get name() {
    return this.integrationName;
  }

  public set status(status: boolean) {
    this.integrationStatus = status;
  }

  public get status() {
    return this.integrationStatus;
  }

  public async set(instanceName: string, data: EventDto): Promise<wa.LocalEvent> {
    if (!this.status) {
      return;
    }

    if (!data[this.name]?.enabled) {
      data[this.name].events = [];
    } else {
      if (0 === data[this.name].events.length) {
        data[this.name].events = EventController.events;
      }
    }

    return this.prisma[this.name].upsert({
      where: {
        instanceId: this.monitor.waInstances[instanceName].instanceId,
      },
      update: {
        enabled: data[this.name]?.enabled,
        events: data[this.name].events,
      },
      create: {
        enabled: data[this.name]?.enabled,
        events: data[this.name].events,
        instanceId: this.monitor.waInstances[instanceName].instanceId,
      },
    });
  }

  public async get(instanceName: string): Promise<wa.LocalEvent> {
    if (!this.status) {
      return;
    }

    if (undefined === this.monitor.waInstances[instanceName]) {
      return null;
    }

    const data = await this.prisma[this.name].findUnique({
      where: {
        instanceId: this.monitor.waInstances[instanceName].instanceId,
      },
    });

    if (!data) {
      return null;
    }

    return data;
  }

  public static readonly events = [
    'APPLICATION_STARTUP',
    'QRCODE_UPDATED',
    'MESSAGES_SET',
    'MESSAGES_UPSERT',
    'MESSAGES_EDITED',
    'MESSAGES_UPDATE',
    'MESSAGES_DELETE',
    'SEND_MESSAGE',
    'CONTACTS_SET',
    'CONTACTS_UPSERT',
    'CONTACTS_UPDATE',
    'PRESENCE_UPDATE',
    'CHATS_SET',
    'CHATS_UPSERT',
    'CHATS_UPDATE',
    'CHATS_DELETE',
    'GROUPS_UPSERT',
    'GROUP_UPDATE',
    'GROUP_PARTICIPANTS_UPDATE',
    'CONNECTION_UPDATE',
    'LABELS_EDIT',
    'LABELS_ASSOCIATION',
    'CALL',
    'TYPEBOT_START',
    'TYPEBOT_CHANGE_STATUS',
    'REMOVE_INSTANCE',
    'LOGOUT_INSTANCE',
  ];
}



================================================
FILE: src/api/integrations/event/event.dto.ts
================================================
import { Constructor } from '@api/integrations/integration.dto';
import { JsonValue } from '@prisma/client/runtime/library';

export class EventDto {
  webhook?: {
    enabled?: boolean;
    events?: string[];
    url?: string;
    headers?: JsonValue;
    byEvents?: boolean;
    base64?: boolean;
  };

  websocket?: {
    enabled?: boolean;
    events?: string[];
  };

  sqs?: {
    enabled?: boolean;
    events?: string[];
  };

  rabbitmq?: {
    enabled?: boolean;
    events?: string[];
  };

  pusher?: {
    enabled?: boolean;
    appId?: string;
    key?: string;
    secret?: string;
    cluster?: string;
    useTLS?: boolean;
    events?: string[];
  };
}

export function EventInstanceMixin<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    webhook?: {
      enabled?: boolean;
      events?: string[];
      headers?: JsonValue;
      url?: string;
      byEvents?: boolean;
      base64?: boolean;
    };

    websocket?: {
      enabled?: boolean;
      events?: string[];
    };

    sqs?: {
      enabled?: boolean;
      events?: string[];
    };

    rabbitmq?: {
      enabled?: boolean;
      events?: string[];
    };

    pusher?: {
      enabled?: boolean;
      appId?: string;
      key?: string;
      secret?: string;
      cluster?: string;
      useTLS?: boolean;
      events?: string[];
    };
  };
}



================================================
FILE: src/api/integrations/event/event.manager.ts
================================================
import { PusherController } from '@api/integrations/event/pusher/pusher.controller';
import { RabbitmqController } from '@api/integrations/event/rabbitmq/rabbitmq.controller';
import { SqsController } from '@api/integrations/event/sqs/sqs.controller';
import { WebhookController } from '@api/integrations/event/webhook/webhook.controller';
import { WebsocketController } from '@api/integrations/event/websocket/websocket.controller';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { Server } from 'http';

export class EventManager {
  private prismaRepository: PrismaRepository;
  private waMonitor: WAMonitoringService;
  private websocketController: WebsocketController;
  private webhookController: WebhookController;
  private rabbitmqController: RabbitmqController;
  private sqsController: SqsController;
  private pusherController: PusherController;

  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    this.prisma = prismaRepository;
    this.monitor = waMonitor;

    this.websocket = new WebsocketController(prismaRepository, waMonitor);
    this.webhook = new WebhookController(prismaRepository, waMonitor);
    this.rabbitmq = new RabbitmqController(prismaRepository, waMonitor);
    this.sqs = new SqsController(prismaRepository, waMonitor);
    this.pusher = new PusherController(prismaRepository, waMonitor);
  }

  public set prisma(prisma: PrismaRepository) {
    this.prismaRepository = prisma;
  }

  public get prisma() {
    return this.prismaRepository;
  }

  public set monitor(waMonitor: WAMonitoringService) {
    this.waMonitor = waMonitor;
  }

  public get monitor() {
    return this.waMonitor;
  }

  public set websocket(websocket: WebsocketController) {
    this.websocketController = websocket;
  }

  public get websocket() {
    return this.websocketController;
  }

  public set webhook(webhook: WebhookController) {
    this.webhookController = webhook;
  }

  public get webhook() {
    return this.webhookController;
  }

  public set rabbitmq(rabbitmq: RabbitmqController) {
    this.rabbitmqController = rabbitmq;
  }

  public get rabbitmq() {
    return this.rabbitmqController;
  }

  public set sqs(sqs: SqsController) {
    this.sqsController = sqs;
  }

  public get sqs() {
    return this.sqsController;
  }

  public set pusher(pusher: PusherController) {
    this.pusherController = pusher;
  }
  public get pusher() {
    return this.pusherController;
  }

  public init(httpServer: Server): void {
    this.websocket.init(httpServer);
    this.rabbitmq.init();
    this.sqs.init();
    this.pusher.init();
  }

  public async emit(eventData: {
    instanceName: string;
    origin: string;
    event: string;
    data: Object;
    serverUrl: string;
    dateTime: string;
    sender: string;
    apiKey?: string;
    local?: boolean;
    integration?: string[];
  }): Promise<void> {
    await this.websocket.emit(eventData);
    await this.rabbitmq.emit(eventData);
    await this.sqs.emit(eventData);
    await this.webhook.emit(eventData);
    await this.pusher.emit(eventData);
  }

  public async setInstance(instanceName: string, data: any): Promise<any> {
    if (data.websocket)
      await this.websocket.set(instanceName, {
        websocket: {
          enabled: true,
          events: data.websocket?.events,
        },
      });

    if (data.rabbitmq)
      await this.rabbitmq.set(instanceName, {
        rabbitmq: {
          enabled: true,
          events: data.rabbitmq?.events,
        },
      });

    if (data.sqs)
      await this.sqs.set(instanceName, {
        sqs: {
          enabled: true,
          events: data.sqs?.events,
        },
      });

    if (data.webhook)
      await this.webhook.set(instanceName, {
        webhook: {
          enabled: true,
          events: data.webhook?.events,
          url: data.webhook?.url,
          headers: data.webhook?.headers,
          base64: data.webhook?.base64,
          byEvents: data.webhook?.byEvents,
        },
      });

    if (data.pusher)
      await this.pusher.set(instanceName, {
        pusher: {
          enabled: true,
          events: data.pusher?.events,
          appId: data.pusher?.appId,
          key: data.pusher?.key,
          secret: data.pusher?.secret,
          cluster: data.pusher?.cluster,
          useTLS: data.pusher?.useTLS,
        },
      });
  }
}



================================================
FILE: src/api/integrations/event/event.router.ts
================================================
import { PusherRouter } from '@api/integrations/event/pusher/pusher.router';
import { RabbitmqRouter } from '@api/integrations/event/rabbitmq/rabbitmq.router';
import { SqsRouter } from '@api/integrations/event/sqs/sqs.router';
import { WebhookRouter } from '@api/integrations/event/webhook/webhook.router';
import { WebsocketRouter } from '@api/integrations/event/websocket/websocket.router';
import { Router } from 'express';

export class EventRouter {
  public readonly router: Router;

  constructor(configService: any, ...guards: any[]) {
    this.router = Router();

    this.router.use('/webhook', new WebhookRouter(configService, ...guards).router);
    this.router.use('/websocket', new WebsocketRouter(...guards).router);
    this.router.use('/rabbitmq', new RabbitmqRouter(...guards).router);
    this.router.use('/pusher', new PusherRouter(...guards).router);
    this.router.use('/sqs', new SqsRouter(...guards).router);
  }
}



================================================
FILE: src/api/integrations/event/event.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

import { EventController } from './event.controller';

export * from '@api/integrations/event/pusher/pusher.schema';
export * from '@api/integrations/event/webhook/webhook.schema';

export const eventSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    websocket: {
      $ref: '#/$defs/event',
    },
    rabbitmq: {
      $ref: '#/$defs/event',
    },
    sqs: {
      $ref: '#/$defs/event',
    },
  },
  $defs: {
    event: {
      type: 'object',
      properties: {
        enabled: { type: 'boolean', enum: [true, false] },
        events: {
          type: 'array',
          minItems: 0,
          items: {
            type: 'string',
            enum: EventController.events,
          },
        },
      },
      required: ['enabled'],
    },
  },
};



================================================
FILE: src/api/integrations/event/pusher/pusher.controller.ts
================================================
import { EventDto } from '@api/integrations/event/event.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { wa } from '@api/types/wa.types';
import { configService, Log, Pusher as ConfigPusher } from '@config/env.config';
import { Logger } from '@config/logger.config';
import Pusher from 'pusher';

import { EmitData, EventController, EventControllerInterface } from '../event.controller';
export class PusherController extends EventController implements EventControllerInterface {
  private readonly logger = new Logger('PusherController');
  private pusherClients: { [instanceName: string]: Pusher } = {};
  private globalPusherClient: Pusher | null = null;
  private pusherConfig: ConfigPusher = configService.get<ConfigPusher>('PUSHER');
  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    super(prismaRepository, waMonitor, configService.get<ConfigPusher>('PUSHER')?.ENABLED, 'pusher');
    this.init();
  }
  public async init(): Promise<void> {
    if (!this.status) {
      return;
    }
    if (this.pusherConfig.GLOBAL?.ENABLED) {
      const { APP_ID, KEY, SECRET, CLUSTER, USE_TLS } = this.pusherConfig.GLOBAL;
      if (APP_ID && KEY && SECRET && CLUSTER) {
        this.globalPusherClient = new Pusher({
          appId: APP_ID,
          key: KEY,
          secret: SECRET,
          cluster: CLUSTER,
          useTLS: USE_TLS,
        });
        this.logger.info('Pusher global client initialized');
      }
    }
    const instances = await this.prismaRepository.instance.findMany({
      where: {
        Pusher: {
          isNot: null,
        },
      },
      include: {
        Pusher: true,
      },
    });
    instances.forEach((instance) => {
      if (
        instance.Pusher.enabled &&
        instance.Pusher.appId &&
        instance.Pusher.key &&
        instance.Pusher.secret &&
        instance.Pusher.cluster
      ) {
        this.pusherClients[instance.name] = new Pusher({
          appId: instance.Pusher.appId,
          key: instance.Pusher.key,
          secret: instance.Pusher.secret,
          cluster: instance.Pusher.cluster,
          useTLS: instance.Pusher.useTLS,
        });
        this.logger.info(`Pusher client initialized for instance ${instance.name}`);
      } else {
        delete this.pusherClients[instance.name];
        this.logger.warn(`Pusher client disabled or misconfigured for instance ${instance.name}`);
      }
    });
  }
  override async set(instanceName: string, data: EventDto): Promise<wa.LocalPusher> {
    if (!data.pusher?.enabled) {
      data.pusher.events = [];
    } else if (data.pusher.events.length === 0) {
      data.pusher.events = EventController.events;
    }
    const instance = await this.prisma.pusher.upsert({
      where: {
        instanceId: this.monitor.waInstances[instanceName].instanceId,
      },
      update: {
        enabled: data.pusher.enabled,
        events: data.pusher.events,
        appId: data.pusher.appId,
        key: data.pusher.key,
        secret: data.pusher.secret,
        cluster: data.pusher.cluster,
        useTLS: data.pusher.useTLS,
      },
      create: {
        enabled: data.pusher.enabled,
        events: data.pusher.events,
        instanceId: this.monitor.waInstances[instanceName].instanceId,
        appId: data.pusher.appId,
        key: data.pusher.key,
        secret: data.pusher.secret,
        cluster: data.pusher.cluster,
        useTLS: data.pusher.useTLS,
      },
    });
    if (instance.enabled && instance.appId && instance.key && instance.secret && instance.cluster) {
      this.pusherClients[instanceName] = new Pusher({
        appId: instance.appId,
        key: instance.key,
        secret: instance.secret,
        cluster: instance.cluster,
        useTLS: instance.useTLS,
      });
      this.logger.info(`Pusher client initialized for instance ${instanceName}`);
    } else {
      delete this.pusherClients[instanceName];
      this.logger.warn(`Pusher client disabled or misconfigured for instance ${instanceName}`);
    }
    return instance;
  }
  public async emit({
    instanceName,
    origin,
    event,
    data,
    serverUrl,
    dateTime,
    sender,
    apiKey,
    local,
    integration,
  }: EmitData): Promise<void> {
    if (integration && !integration.includes('pusher')) {
      return;
    }
    if (!this.status) {
      return;
    }
    const instance = (await this.get(instanceName)) as wa.LocalPusher;
    const we = event.replace(/[.-]/gm, '_').toUpperCase();
    const enabledLog = configService.get<Log>('LOG').LEVEL.includes('WEBHOOKS');
    const eventName = event.replace(/_/g, '.').toLowerCase();
    const pusherData = {
      event,
      instance: instanceName,
      data,
      destination: instance?.appId || this.pusherConfig.GLOBAL?.APP_ID,
      date_time: dateTime,
      sender,
      server_url: serverUrl,
      apikey: apiKey,
    };
    if (event == 'qrcode.updated') {
      delete pusherData.data.qrcode.base64;
    }
    const payload = JSON.stringify(pusherData);
    const payloadSize = Buffer.byteLength(payload, 'utf8');
    const MAX_SIZE = 10240;
    if (payloadSize > MAX_SIZE) {
      this.logger.error({
        local: `${origin}.sendData-Pusher`,
        message: 'Payload size exceeds Pusher limit',
        event,
        instanceName,
        payloadSize,
      });
      return;
    }
    if (local && instance && instance.enabled) {
      const pusherLocalEvents = instance.events;
      if (Array.isArray(pusherLocalEvents) && pusherLocalEvents.includes(we)) {
        if (enabledLog) {
          this.logger.log({
            local: `${origin}.sendData-Pusher`,
            appId: instance.appId,
            ...pusherData,
          });
        }
        try {
          const pusher = this.pusherClients[instanceName];
          if (pusher) {
            pusher.trigger(instanceName, eventName, pusherData);
          } else {
            this.logger.error(`Pusher client not found for instance ${instanceName}`);
          }
        } catch (error) {
          this.logger.error({
            local: `${origin}.sendData-Pusher`,
            message: error?.message,
            error,
          });
        }
      }
    }
    if (this.pusherConfig.GLOBAL?.ENABLED) {
      const globalEvents = this.pusherConfig.EVENTS;
      if (globalEvents[we]) {
        if (enabledLog) {
          this.logger.log({
            local: `${origin}.sendData-Pusher-Global`,
            appId: this.pusherConfig.GLOBAL?.APP_ID,
            ...pusherData,
          });
        }
        try {
          if (this.globalPusherClient) {
            this.globalPusherClient.trigger(instanceName, eventName, pusherData);
          } else {
            this.logger.error('Global Pusher client not initialized');
          }
        } catch (error) {
          this.logger.error({
            local: `${origin}.sendData-Pusher-Global`,
            message: error?.message,
            error,
          });
        }
      }
    }
  }
}



================================================
FILE: src/api/integrations/event/pusher/pusher.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { EventDto } from '@api/integrations/event/event.dto';
import { HttpStatus } from '@api/routes/index.router';
import { eventManager } from '@api/server.module';
import { instanceSchema, pusherSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';
export class PusherRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('set'), ...guards, async (req, res) => {
        const response = await this.dataValidate<EventDto>({
          request: req,
          schema: pusherSchema,
          ClassRef: EventDto,
          execute: (instance, data) => eventManager.pusher.set(instance.instanceName, data),
        });
        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => eventManager.pusher.get(instance.instanceName),
        });
        res.status(HttpStatus.OK).json(response);
      });
  }
  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/event/pusher/pusher.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

import { EventController } from '../event.controller';
const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};
export const pusherSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    pusher: {
      type: 'object',
      properties: {
        enabled: { type: 'boolean' },
        appId: { type: 'string' },
        key: { type: 'string' },
        secret: { type: 'string' },
        cluster: { type: 'string' },
        useTLS: { type: 'boolean' },
        events: {
          type: 'array',
          minItems: 0,
          items: {
            type: 'string',
            enum: EventController.events,
          },
        },
      },
      required: ['enabled', 'appId', 'key', 'secret', 'cluster', 'useTLS'],
      ...isNotEmpty('enabled', 'appId', 'key', 'secret', 'cluster', 'useTLS'),
    },
  },
  required: ['pusher'],
};



================================================
FILE: src/api/integrations/event/rabbitmq/rabbitmq.controller.ts
================================================
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { configService, Log, Rabbitmq } from '@config/env.config';
import { Logger } from '@config/logger.config';
import * as amqp from 'amqplib/callback_api';

import { EmitData, EventController, EventControllerInterface } from '../event.controller';

export class RabbitmqController extends EventController implements EventControllerInterface {
  public amqpChannel: amqp.Channel | null = null;
  private readonly logger = new Logger('RabbitmqController');

  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    super(prismaRepository, waMonitor, configService.get<Rabbitmq>('RABBITMQ')?.ENABLED, 'rabbitmq');
  }

  public async init(): Promise<void> {
    if (!this.status) {
      return;
    }

    await new Promise<void>((resolve, reject) => {
      const uri = configService.get<Rabbitmq>('RABBITMQ').URI;
      const rabbitmqExchangeName = configService.get<Rabbitmq>('RABBITMQ').EXCHANGE_NAME;

      amqp.connect(uri, (error, connection) => {
        if (error) {
          reject(error);

          return;
        }

        connection.createChannel((channelError, channel) => {
          if (channelError) {
            reject(channelError);

            return;
          }

          const exchangeName = rabbitmqExchangeName;

          channel.assertExchange(exchangeName, 'topic', {
            durable: true,
            autoDelete: false,
          });

          this.amqpChannel = channel;

          this.logger.info('AMQP initialized');

          resolve();
        });
      });
    }).then(() => {
      if (configService.get<Rabbitmq>('RABBITMQ')?.GLOBAL_ENABLED) this.initGlobalQueues();
    });
  }

  private set channel(channel: amqp.Channel) {
    this.amqpChannel = channel;
  }

  public get channel(): amqp.Channel {
    return this.amqpChannel;
  }

  public async emit({
    instanceName,
    origin,
    event,
    data,
    serverUrl,
    dateTime,
    sender,
    apiKey,
    integration,
  }: EmitData): Promise<void> {
    if (integration && !integration.includes('rabbitmq')) {
      return;
    }

    if (!this.status) {
      return;
    }

    const instanceRabbitmq = await this.get(instanceName);
    const rabbitmqLocal = instanceRabbitmq?.events;
    const rabbitmqGlobal = configService.get<Rabbitmq>('RABBITMQ').GLOBAL_ENABLED;
    const rabbitmqEvents = configService.get<Rabbitmq>('RABBITMQ').EVENTS;
    const prefixKey = configService.get<Rabbitmq>('RABBITMQ').PREFIX_KEY;
    const rabbitmqExchangeName = configService.get<Rabbitmq>('RABBITMQ').EXCHANGE_NAME;
    const we = event.replace(/[.-]/gm, '_').toUpperCase();
    const logEnabled = configService.get<Log>('LOG').LEVEL.includes('WEBHOOKS');

    const message = {
      event,
      instance: instanceName,
      data,
      server_url: serverUrl,
      date_time: dateTime,
      sender,
      apikey: apiKey,
    };

    if (instanceRabbitmq?.enabled && this.amqpChannel) {
      if (Array.isArray(rabbitmqLocal) && rabbitmqLocal.includes(we)) {
        const exchangeName = instanceName ?? rabbitmqExchangeName;

        let retry = 0;

        while (retry < 3) {
          try {
            await this.amqpChannel.assertExchange(exchangeName, 'topic', {
              durable: true,
              autoDelete: false,
            });

            const eventName = event.replace(/_/g, '.').toLowerCase();

            const queueName = `${instanceName}.${eventName}`;

            await this.amqpChannel.assertQueue(queueName, {
              durable: true,
              autoDelete: false,
              arguments: {
                'x-queue-type': 'quorum',
              },
            });

            await this.amqpChannel.bindQueue(queueName, exchangeName, eventName);

            await this.amqpChannel.publish(exchangeName, event, Buffer.from(JSON.stringify(message)));

            if (logEnabled) {
              const logData = {
                local: `${origin}.sendData-RabbitMQ`,
                ...message,
              };

              this.logger.log(logData);
            }

            break;
          } catch (error) {
            retry++;
          }
        }
      }
    }

    if (rabbitmqGlobal && rabbitmqEvents[we] && this.amqpChannel) {
      const exchangeName = rabbitmqExchangeName;

      let retry = 0;

      while (retry < 3) {
        try {
          await this.amqpChannel.assertExchange(exchangeName, 'topic', {
            durable: true,
            autoDelete: false,
          });

          const queueName = prefixKey
            ? `${prefixKey}.${event.replace(/_/g, '.').toLowerCase()}`
            : event.replace(/_/g, '.').toLowerCase();

          await this.amqpChannel.assertQueue(queueName, {
            durable: true,
            autoDelete: false,
            arguments: {
              'x-queue-type': 'quorum',
            },
          });

          await this.amqpChannel.bindQueue(queueName, exchangeName, event);

          await this.amqpChannel.publish(exchangeName, event, Buffer.from(JSON.stringify(message)));

          if (logEnabled) {
            const logData = {
              local: `${origin}.sendData-RabbitMQ-Global`,
              ...message,
            };

            this.logger.log(logData);
          }

          break;
        } catch (error) {
          retry++;
        }
      }
    }
  }

  private async initGlobalQueues(): Promise<void> {
    this.logger.info('Initializing global queues');

    const rabbitmqExchangeName = configService.get<Rabbitmq>('RABBITMQ').EXCHANGE_NAME;
    const events = configService.get<Rabbitmq>('RABBITMQ').EVENTS;
    const prefixKey = configService.get<Rabbitmq>('RABBITMQ').PREFIX_KEY;

    if (!events) {
      this.logger.warn('No events to initialize on AMQP');

      return;
    }

    const eventKeys = Object.keys(events);

    eventKeys.forEach((event) => {
      if (events[event] === false) return;

      const queueName =
        prefixKey !== ''
          ? `${prefixKey}.${event.replace(/_/g, '.').toLowerCase()}`
          : `${event.replace(/_/g, '.').toLowerCase()}`;
      const exchangeName = rabbitmqExchangeName;

      this.amqpChannel.assertExchange(exchangeName, 'topic', {
        durable: true,
        autoDelete: false,
      });

      this.amqpChannel.assertQueue(queueName, {
        durable: true,
        autoDelete: false,
        arguments: {
          'x-queue-type': 'quorum',
        },
      });

      this.amqpChannel.bindQueue(queueName, exchangeName, event);
    });
  }
}



================================================
FILE: src/api/integrations/event/rabbitmq/rabbitmq.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { EventDto } from '@api/integrations/event/event.dto';
import { HttpStatus } from '@api/routes/index.router';
import { eventManager } from '@api/server.module';
import { eventSchema, instanceSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

export class RabbitmqRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('set'), ...guards, async (req, res) => {
        const response = await this.dataValidate<EventDto>({
          request: req,
          schema: eventSchema,
          ClassRef: EventDto,
          execute: (instance, data) => eventManager.rabbitmq.set(instance.instanceName, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => eventManager.rabbitmq.get(instance.instanceName),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/event/sqs/sqs.controller.ts
================================================
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { SQS } from '@aws-sdk/client-sqs';
import { configService, Log, Sqs } from '@config/env.config';
import { Logger } from '@config/logger.config';

import { EmitData, EventController, EventControllerInterface } from '../event.controller';

export class SqsController extends EventController implements EventControllerInterface {
  private sqs: SQS;
  private readonly logger = new Logger('SqsController');

  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    super(prismaRepository, waMonitor, configService.get<Sqs>('SQS')?.ENABLED, 'sqs');
  }

  public init(): void {
    if (!this.status) {
      return;
    }

    new Promise<void>((resolve) => {
      const awsConfig = configService.get<Sqs>('SQS');

      this.sqs = new SQS({
        credentials: {
          accessKeyId: awsConfig.ACCESS_KEY_ID,
          secretAccessKey: awsConfig.SECRET_ACCESS_KEY,
        },

        region: awsConfig.REGION,
      });

      this.logger.info('SQS initialized');

      resolve();
    });
  }

  private set channel(sqs: SQS) {
    this.sqs = sqs;
  }

  public get channel(): SQS {
    return this.sqs;
  }

  public async emit({
    instanceName,
    origin,
    event,
    data,
    serverUrl,
    dateTime,
    sender,
    apiKey,
    integration,
  }: EmitData): Promise<void> {
    if (integration && !integration.includes('sqs')) {
      return;
    }

    if (!this.status) {
      return;
    }

    const instanceSqs = await this.get(instanceName);
    const sqsLocal = instanceSqs?.events;
    const we = event.replace(/[.-]/gm, '_').toUpperCase();

    if (instanceSqs?.enabled) {
      if (this.sqs) {
        if (Array.isArray(sqsLocal) && sqsLocal.includes(we)) {
          const eventFormatted = `${event.replace('.', '_').toLowerCase()}`;
          const queueName = `${instanceName}_${eventFormatted}.fifo`;
          const sqsConfig = configService.get<Sqs>('SQS');
          const sqsUrl = `https://sqs.${sqsConfig.REGION}.amazonaws.com/${sqsConfig.ACCOUNT_ID}/${queueName}`;

          const message = {
            event,
            instance: instanceName,
            data,
            server_url: serverUrl,
            date_time: dateTime,
            sender,
            apikey: apiKey,
          };

          const params = {
            MessageBody: JSON.stringify(message),
            MessageGroupId: 'evolution',
            MessageDeduplicationId: `${instanceName}_${eventFormatted}_${Date.now()}`,
            QueueUrl: sqsUrl,
          };

          this.sqs.sendMessage(params, (err) => {
            if (err) {
              this.logger.error({
                local: `${origin}.sendData-SQS`,
                message: err?.message,
                hostName: err?.hostname,
                code: err?.code,
                stack: err?.stack,
                name: err?.name,
                url: queueName,
                server_url: serverUrl,
              });
            } else {
              if (configService.get<Log>('LOG').LEVEL.includes('WEBHOOKS')) {
                const logData = {
                  local: `${origin}.sendData-SQS`,
                  ...message,
                };

                this.logger.log(logData);
              }
            }
          });
        }
      }
    }
  }

  public async initQueues(instanceName: string, events: string[]) {
    if (!events || !events.length) return;

    const queues = events.map((event) => {
      return `${event.replace(/_/g, '_').toLowerCase()}`;
    });

    queues.forEach((event) => {
      const queueName = `${instanceName}_${event}.fifo`;

      this.sqs.createQueue(
        {
          QueueName: queueName,
          Attributes: {
            FifoQueue: 'true',
          },
        },
        (err, data) => {
          if (err) {
            this.logger.error(`Error creating queue ${queueName}: ${err.message}`);
          } else {
            this.logger.info(`Queue ${queueName} created: ${data.QueueUrl}`);
          }
        },
      );
    });
  }

  public async removeQueues(instanceName: string, events: any) {
    const eventsArray = Array.isArray(events) ? events.map((event) => String(event)) : [];
    if (!events || !eventsArray.length) return;

    const queues = eventsArray.map((event) => {
      return `${event.replace(/_/g, '_').toLowerCase()}`;
    });

    queues.forEach((event) => {
      const queueName = `${instanceName}_${event}.fifo`;

      this.sqs.getQueueUrl(
        {
          QueueName: queueName,
        },
        (err, data) => {
          if (err) {
            this.logger.error(`Error getting queue URL for ${queueName}: ${err.message}`);
          } else {
            const queueUrl = data.QueueUrl;

            this.sqs.deleteQueue(
              {
                QueueUrl: queueUrl,
              },
              (deleteErr) => {
                if (deleteErr) {
                  this.logger.error(`Error deleting queue ${queueName}: ${deleteErr.message}`);
                } else {
                  this.logger.info(`Queue ${queueName} deleted`);
                }
              },
            );
          }
        },
      );
    });
  }
}



================================================
FILE: src/api/integrations/event/sqs/sqs.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { EventDto } from '@api/integrations/event/event.dto';
import { HttpStatus } from '@api/routes/index.router';
import { eventManager } from '@api/server.module';
import { eventSchema, instanceSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

export class SqsRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('set'), ...guards, async (req, res) => {
        const response = await this.dataValidate<EventDto>({
          request: req,
          schema: eventSchema,
          ClassRef: EventDto,
          execute: (instance, data) => eventManager.sqs.set(instance.instanceName, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => eventManager.sqs.get(instance.instanceName),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/event/webhook/webhook.controller.ts
================================================
import { EventDto } from '@api/integrations/event/event.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { wa } from '@api/types/wa.types';
import { configService, Log, Webhook } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { BadRequestException } from '@exceptions';
import axios, { AxiosInstance } from 'axios';
import { isURL } from 'class-validator';

import { EmitData, EventController, EventControllerInterface } from '../event.controller';

export class WebhookController extends EventController implements EventControllerInterface {
  private readonly logger = new Logger('WebhookController');

  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    super(prismaRepository, waMonitor, true, 'webhook');
  }

  override async set(instanceName: string, data: EventDto): Promise<wa.LocalWebHook> {
    if (!isURL(data.webhook.url, { require_tld: false })) {
      throw new BadRequestException('Invalid "url" property');
    }

    if (!data.webhook?.enabled) {
      data.webhook.events = [];
    } else {
      if (0 === data.webhook.events.length) {
        data.webhook.events = EventController.events;
      }
    }

    return this.prisma.webhook.upsert({
      where: {
        instanceId: this.monitor.waInstances[instanceName].instanceId,
      },
      update: {
        enabled: data.webhook?.enabled,
        events: data.webhook?.events,
        url: data.webhook?.url,
        headers: data.webhook?.headers,
        webhookBase64: data.webhook.base64,
        webhookByEvents: data.webhook.byEvents,
      },
      create: {
        enabled: data.webhook?.enabled,
        events: data.webhook?.events,
        instanceId: this.monitor.waInstances[instanceName].instanceId,
        url: data.webhook?.url,
        headers: data.webhook?.headers,
        webhookBase64: data.webhook.base64,
        webhookByEvents: data.webhook.byEvents,
      },
    });
  }

  public async emit({
    instanceName,
    origin,
    event,
    data,
    serverUrl,
    dateTime,
    sender,
    apiKey,
    local,
    integration,
  }: EmitData): Promise<void> {
    if (integration && !integration.includes('webhook')) {
      return;
    }

    const instance = (await this.get(instanceName)) as wa.LocalWebHook;

    const webhookConfig = configService.get<Webhook>('WEBHOOK');
    const webhookLocal = instance?.events;
    const webhookHeaders = instance?.headers;
    const we = event.replace(/[.-]/gm, '_').toUpperCase();
    const transformedWe = we.replace(/_/gm, '-').toLowerCase();
    const enabledLog = configService.get<Log>('LOG').LEVEL.includes('WEBHOOKS');

    const webhookData = {
      event,
      instance: instanceName,
      data,
      destination: instance?.url || `${webhookConfig.GLOBAL.URL}/${transformedWe}`,
      date_time: dateTime,
      sender,
      server_url: serverUrl,
      apikey: apiKey,
    };

    if (local && instance?.enabled) {
      if (Array.isArray(webhookLocal) && webhookLocal.includes(we)) {
        let baseURL: string;

        if (instance?.webhookByEvents) {
          baseURL = `${instance?.url}/${transformedWe}`;
        } else {
          baseURL = instance?.url;
        }

        if (enabledLog) {
          const logData = {
            local: `${origin}.sendData-Webhook`,
            url: baseURL,
            ...webhookData,
          };

          this.logger.log(logData);
        }

        try {
          if (instance?.enabled && isURL(instance.url, { require_tld: false })) {
            const httpService = axios.create({
              baseURL,
              headers: webhookHeaders as Record<string, string> | undefined,
            });

            await this.retryWebhookRequest(httpService, webhookData, `${origin}.sendData-Webhook`, baseURL, serverUrl);
          }
        } catch (error) {
          this.logger.error({
            local: `${origin}.sendData-Webhook`,
            message: `Todas as tentativas falharam: ${error?.message}`,
            hostName: error?.hostname,
            syscall: error?.syscall,
            code: error?.code,
            error: error?.errno,
            stack: error?.stack,
            name: error?.name,
            url: baseURL,
            server_url: serverUrl,
          });
        }
      }
    }

    if (webhookConfig.GLOBAL?.ENABLED) {
      if (webhookConfig.EVENTS[we]) {
        let globalURL = webhookConfig.GLOBAL.URL;

        if (webhookConfig.GLOBAL.WEBHOOK_BY_EVENTS) {
          globalURL = `${globalURL}/${transformedWe}`;
        }

        if (enabledLog) {
          const logData = {
            local: `${origin}.sendData-Webhook-Global`,
            url: globalURL,
            ...webhookData,
          };

          this.logger.log(logData);
        }

        try {
          if (isURL(globalURL)) {
            const httpService = axios.create({ baseURL: globalURL });

            await this.retryWebhookRequest(
              httpService,
              webhookData,
              `${origin}.sendData-Webhook-Global`,
              globalURL,
              serverUrl,
            );
          }
        } catch (error) {
          this.logger.error({
            local: `${origin}.sendData-Webhook-Global`,
            message: `Todas as tentativas falharam: ${error?.message}`,
            hostName: error?.hostname,
            syscall: error?.syscall,
            code: error?.code,
            error: error?.errno,
            stack: error?.stack,
            name: error?.name,
            url: globalURL,
            server_url: serverUrl,
          });
        }
      }
    }
  }

  private async retryWebhookRequest(
    httpService: AxiosInstance,
    webhookData: any,
    origin: string,
    baseURL: string,
    serverUrl: string,
    maxRetries = 10,
    delaySeconds = 30,
  ): Promise<void> {
    let attempts = 0;

    while (attempts < maxRetries) {
      try {
        await httpService.post('', webhookData);
        if (attempts > 0) {
          this.logger.log({
            local: `${origin}`,
            message: `Sucesso no envio após ${attempts + 1} tentativas`,
            url: baseURL,
          });
        }
        return;
      } catch (error) {
        attempts++;

        this.logger.error({
          local: `${origin}`,
          message: `Tentativa ${attempts}/${maxRetries} falhou: ${error?.message}`,
          hostName: error?.hostname,
          syscall: error?.syscall,
          code: error?.code,
          error: error?.errno,
          stack: error?.stack,
          name: error?.name,
          url: baseURL,
          server_url: serverUrl,
        });

        if (attempts === maxRetries) {
          throw error;
        }

        await new Promise((resolve) => setTimeout(resolve, delaySeconds * 1000));
      }
    }
  }
}



================================================
FILE: src/api/integrations/event/webhook/webhook.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { EventDto } from '@api/integrations/event/event.dto';
import { HttpStatus } from '@api/routes/index.router';
import { eventManager } from '@api/server.module';
import { ConfigService } from '@config/env.config';
import { instanceSchema, webhookSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

export class WebhookRouter extends RouterBroker {
  constructor(
    readonly configService: ConfigService,
    ...guards: RequestHandler[]
  ) {
    super();
    this.router
      .post(this.routerPath('set'), ...guards, async (req, res) => {
        const response = await this.dataValidate<EventDto>({
          request: req,
          schema: webhookSchema,
          ClassRef: EventDto,
          execute: (instance, data) => eventManager.webhook.set(instance.instanceName, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => eventManager.webhook.get(instance.instanceName),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/event/webhook/webhook.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

import { EventController } from '../event.controller';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const webhookSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    webhook: {
      type: 'object',
      properties: {
        enabled: { type: 'boolean' },
        url: { type: 'string' },
        headers: { type: 'object' },
        byEvents: { type: 'boolean' },
        base64: { type: 'boolean' },
        events: {
          type: 'array',
          minItems: 0,
          items: {
            type: 'string',
            enum: EventController.events,
          },
        },
      },
      required: ['enabled', 'url'],
      ...isNotEmpty('enabled', 'url'),
    },
  },
  required: ['webhook'],
};



================================================
FILE: src/api/integrations/event/websocket/websocket.controller.ts
================================================
import { PrismaRepository } from '@api/repository/repository.service';
import { WAMonitoringService } from '@api/services/monitor.service';
import { configService, Cors, Log, Websocket } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { Server } from 'http';
import { Server as SocketIO } from 'socket.io';

import { EmitData, EventController, EventControllerInterface } from '../event.controller';

export class WebsocketController extends EventController implements EventControllerInterface {
  private io: SocketIO;
  private corsConfig: Array<any>;
  private readonly logger = new Logger('WebsocketController');

  constructor(prismaRepository: PrismaRepository, waMonitor: WAMonitoringService) {
    super(prismaRepository, waMonitor, configService.get<Websocket>('WEBSOCKET')?.ENABLED, 'websocket');

    this.cors = configService.get<Cors>('CORS').ORIGIN;
  }

  public init(httpServer: Server): void {
    if (!this.status) {
      return;
    }

    this.socket = new SocketIO(httpServer, {
      cors: {
        origin: this.cors,
      },
    });

    this.socket.on('connection', (socket) => {
      this.logger.info('User connected');

      socket.on('disconnect', () => {
        this.logger.info('User disconnected');
      });

      socket.on('sendNode', async (data) => {
        try {
          await this.waMonitor.waInstances[data.instanceId].baileysSendNode(data.stanza);
          this.logger.info('Node sent successfully');
        } catch (error) {
          this.logger.error('Error sending node:');
          this.logger.error(error);
        }
      });
    });

    this.logger.info('Socket.io initialized');
  }

  private set cors(cors: Array<any>) {
    this.corsConfig = cors;
  }

  private get cors(): string | Array<any> {
    return this.corsConfig?.includes('*') ? '*' : this.corsConfig;
  }

  private set socket(socket: SocketIO) {
    this.io = socket;
  }

  public get socket(): SocketIO {
    return this.io;
  }

  public async emit({
    instanceName,
    origin,
    event,
    data,
    serverUrl,
    dateTime,
    sender,
    apiKey,
    integration,
  }: EmitData): Promise<void> {
    if (integration && !integration.includes('websocket')) {
      return;
    }

    if (!this.status) {
      return;
    }

    const configEv = event.replace(/[.-]/gm, '_').toUpperCase();
    const logEnabled = configService.get<Log>('LOG').LEVEL.includes('WEBSOCKET');
    const message = {
      event,
      instance: instanceName,
      data,
      server_url: serverUrl,
      date_time: dateTime,
      sender,
      apikey: apiKey,
    };

    if (configService.get<Websocket>('WEBSOCKET')?.GLOBAL_EVENTS) {
      this.socket.emit(event, message);

      if (logEnabled) {
        this.logger.log({
          local: `${origin}.sendData-WebsocketGlobal`,
          ...message,
        });
      }
    }

    try {
      const instance = await this.get(instanceName);

      if (!instance?.enabled) {
        return;
      }

      if (Array.isArray(instance?.events) && instance?.events.includes(configEv)) {
        this.socket.of(`/${instanceName}`).emit(event, message);

        if (logEnabled) {
          this.logger.log({
            local: `${origin}.sendData-Websocket`,
            ...message,
          });
        }
      }
    } catch (err) {
      if (logEnabled) {
        this.logger.log(err);
      }
    }
  }
}



================================================
FILE: src/api/integrations/event/websocket/websocket.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { EventDto } from '@api/integrations/event/event.dto';
import { HttpStatus } from '@api/routes/index.router';
import { eventManager } from '@api/server.module';
import { eventSchema, instanceSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

export class WebsocketRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('set'), ...guards, async (req, res) => {
        const response = await this.dataValidate<EventDto>({
          request: req,
          schema: eventSchema,
          ClassRef: EventDto,
          execute: (instance, data) => eventManager.websocket.set(instance.instanceName, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => eventManager.websocket.get(instance.instanceName),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/storage/storage.router.ts
================================================
import { S3Router } from '@api/integrations/storage/s3/routes/s3.router';
import { Router } from 'express';

export class StorageRouter {
  public readonly router: Router;

  constructor(...guards: any[]) {
    this.router = Router();

    this.router.use('/s3', new S3Router(...guards).router);
  }
}



================================================
FILE: src/api/integrations/storage/s3/controllers/s3.controller.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { MediaDto } from '@api/integrations/storage/s3/dto/media.dto';
import { S3Service } from '@api/integrations/storage/s3/services/s3.service';

export class S3Controller {
  constructor(private readonly s3Service: S3Service) {}

  public async getMedia(instance: InstanceDto, data: MediaDto) {
    return this.s3Service.getMedia(instance, data);
  }

  public async getMediaUrl(instance: InstanceDto, data: MediaDto) {
    return this.s3Service.getMediaUrl(instance, data);
  }
}



================================================
FILE: src/api/integrations/storage/s3/dto/media.dto.ts
================================================
export class MediaDto {
  id?: string;
  type?: string;
  messageId?: number;
  expiry?: number;
}



================================================
FILE: src/api/integrations/storage/s3/libs/minio.server.ts
================================================
import { ConfigService, S3 } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { BadRequestException } from '@exceptions';
import * as MinIo from 'minio';
import { join } from 'path';
import { Readable, Transform } from 'stream';

const logger = new Logger('S3 Service');

const BUCKET = new ConfigService().get<S3>('S3');

interface Metadata extends MinIo.ItemBucketMetadata {
  'Content-Type': string;
}

const minioClient = (() => {
  if (BUCKET?.ENABLE) {
    return new MinIo.Client({
      endPoint: BUCKET.ENDPOINT,
      port: BUCKET.PORT,
      useSSL: BUCKET.USE_SSL,
      accessKey: BUCKET.ACCESS_KEY,
      secretKey: BUCKET.SECRET_KEY,
      region: BUCKET.REGION,
    });
  }
})();

const bucketName = process.env.S3_BUCKET;

const bucketExists = async () => {
  if (minioClient) {
    try {
      const list = await minioClient.listBuckets();
      return list.find((bucket) => bucket.name === bucketName);
    } catch (error) {
      return false;
    }
  }
};

const setBucketPolicy = async () => {
  if (minioClient) {
    const policy = {
      Version: '2012-10-17',
      Statement: [
        {
          Effect: 'Allow',
          Principal: '*',
          Action: ['s3:GetObject'],
          Resource: [`arn:aws:s3:::${bucketName}/*`],
        },
      ],
    };
    await minioClient.setBucketPolicy(bucketName, JSON.stringify(policy));
  }
};

const createBucket = async () => {
  if (minioClient) {
    try {
      const exists = await bucketExists();
      if (!exists) {
        await minioClient.makeBucket(bucketName);
      }

      await setBucketPolicy();

      logger.info(`S3 Bucket ${bucketName} - ON`);
      return true;
    } catch (error) {
      logger.error('S3 ERROR:');
      logger.error(error);
      return false;
    }
  }
};

createBucket();

const uploadFile = async (fileName: string, file: Buffer | Transform | Readable, size: number, metadata: Metadata) => {
  if (minioClient) {
    const objectName = join('evolution-api', fileName);
    try {
      metadata['custom-header-application'] = 'evolution-api';
      return await minioClient.putObject(bucketName, objectName, file, size, metadata);
    } catch (error) {
      logger.error(error);
      return error;
    }
  }
};

const getObjectUrl = async (fileName: string, expiry?: number) => {
  if (minioClient) {
    try {
      const objectName = join('evolution-api', fileName);
      if (expiry) {
        return await minioClient.presignedGetObject(bucketName, objectName, expiry);
      }
      return await minioClient.presignedGetObject(bucketName, objectName);
    } catch (error) {
      throw new BadRequestException(error?.message);
    }
  }
};

const uploadTempFile = async (
  folder: string,
  fileName: string,
  file: Buffer | Transform | Readable,
  size: number,
  metadata: Metadata,
) => {
  if (minioClient) {
    const objectName = join(folder, fileName);
    try {
      metadata['custom-header-application'] = 'evolution-api';
      return await minioClient.putObject(bucketName, objectName, file, size, metadata);
    } catch (error) {
      logger.error(error);
      return error;
    }
  }
};

const deleteFile = async (folder: string, fileName: string) => {
  if (minioClient) {
    const objectName = join(folder, fileName);
    try {
      return await minioClient.removeObject(bucketName, objectName);
    } catch (error) {
      logger.error(error);
      return error;
    }
  }
};

export { BUCKET, deleteFile, getObjectUrl, uploadFile, uploadTempFile };



================================================
FILE: src/api/integrations/storage/s3/routes/s3.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { MediaDto } from '@api/integrations/storage/s3/dto/media.dto';
import { s3Schema, s3UrlSchema } from '@api/integrations/storage/s3/validate/s3.schema';
import { HttpStatus } from '@api/routes/index.router';
import { s3Controller } from '@api/server.module';
import { RequestHandler, Router } from 'express';

export class S3Router extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('getMedia'), ...guards, async (req, res) => {
        const response = await this.dataValidate<MediaDto>({
          request: req,
          schema: s3Schema,
          ClassRef: MediaDto,
          execute: (instance, data) => s3Controller.getMedia(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('getMediaUrl'), ...guards, async (req, res) => {
        const response = await this.dataValidate<MediaDto>({
          request: req,
          schema: s3UrlSchema,
          ClassRef: MediaDto,
          execute: (instance, data) => s3Controller.getMediaUrl(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/integrations/storage/s3/services/s3.service.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { MediaDto } from '@api/integrations/storage/s3/dto/media.dto';
import { getObjectUrl } from '@api/integrations/storage/s3/libs/minio.server';
import { PrismaRepository } from '@api/repository/repository.service';
import { Logger } from '@config/logger.config';
import { BadRequestException } from '@exceptions';

export class S3Service {
  constructor(private readonly prismaRepository: PrismaRepository) {}

  private readonly logger = new Logger('S3Service');

  public async getMedia(instance: InstanceDto, query?: MediaDto) {
    try {
      const where: any = {
        instanceId: instance.instanceId,
        ...query,
      };

      const media = await this.prismaRepository.media.findMany({
        where,
        select: {
          id: true,
          fileName: true,
          type: true,
          mimetype: true,
          createdAt: true,
          Message: true,
        },
      });

      if (!media || media.length === 0) {
        throw 'Media not found';
      }

      return media;
    } catch (error) {
      throw new BadRequestException(error);
    }
  }

  public async getMediaUrl(instance: InstanceDto, data: MediaDto) {
    const media = (await this.getMedia(instance, { id: data.id }))[0];
    const mediaUrl = await getObjectUrl(media.fileName, data.expiry);
    return {
      mediaUrl,
      ...media,
    };
  }
}



================================================
FILE: src/api/integrations/storage/s3/validate/s3.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const s3Schema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    id: { type: 'string' },
    type: { type: 'string' },
    messageId: { type: 'integer' },
  },
  ...isNotEmpty('id', 'type', 'messageId'),
};

export const s3UrlSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    id: { type: 'string', pattern: '\\d+', minLength: 1 },
    expiry: { type: 'string', pattern: '\\d+', minLength: 1 },
  },
  ...isNotEmpty('id'),
  required: ['id'],
};



================================================
FILE: src/api/provider/sessions.ts
================================================
import { Auth, ConfigService, ProviderSession } from '@config/env.config';
import { Logger } from '@config/logger.config';
import axios from 'axios';
import { execSync } from 'child_process';

type ResponseSuccess = { status: number; data?: any };
type ResponseProvider = Promise<[ResponseSuccess?, Error?]>;

export class ProviderFiles {
  constructor(private readonly configService: ConfigService) {
    this.baseUrl = `http://${this.config.HOST}:${this.config.PORT}/session/${this.config.PREFIX}`;
    this.globalApiToken = this.configService.get<Auth>('AUTHENTICATION').API_KEY.KEY;
  }

  private readonly logger = new Logger('ProviderFiles');

  private baseUrl: string;
  private globalApiToken: string;

  private readonly config = Object.freeze(this.configService.get<ProviderSession>('PROVIDER'));

  get isEnabled() {
    return !!this.config?.ENABLED;
  }

  public async onModuleInit() {
    if (this.config.ENABLED) {
      const url = `http://${this.config.HOST}:${this.config.PORT}`;
      try {
        const response = await axios.options(url + '/ping');
        if (response?.data != 'pong') {
          throw new Error('Offline file provider.');
        }

        await axios.post(`${url}/session`, { group: this.config.PREFIX }, { headers: { apikey: this.globalApiToken } });
      } catch (error) {
        this.logger.error(['Failed to connect to the file server', error?.message, error?.stack]);
        const pid = process.pid;
        execSync(`kill -9 ${pid}`);
      }
    }
  }

  public async onModuleDestroy() {
    //
  }

  public async create(instance: string): ResponseProvider {
    try {
      const response = await axios.post(
        `${this.baseUrl}`,
        {
          instance,
        },
        { headers: { apikey: this.globalApiToken } },
      );
      return [{ status: response.status, data: response?.data }];
    } catch (error) {
      return [
        {
          status: error?.response?.status,
          data: error?.response?.data,
        },
        error,
      ];
    }
  }

  public async write(instance: string, key: string, data: any): ResponseProvider {
    try {
      const response = await axios.post(`${this.baseUrl}/${instance}/${key}`, data, {
        headers: { apikey: this.globalApiToken },
      });
      return [{ status: response.status, data: response?.data }];
    } catch (error) {
      return [
        {
          status: error?.response?.status,
          data: error?.response?.data,
        },
        error,
      ];
    }
  }

  public async read(instance: string, key: string): ResponseProvider {
    try {
      const response = await axios.get(`${this.baseUrl}/${instance}/${key}`, {
        headers: { apikey: this.globalApiToken },
      });
      return [{ status: response.status, data: response?.data }];
    } catch (error) {
      return [
        {
          status: error?.response?.status,
          data: error?.response?.data,
        },
        error,
      ];
    }
  }

  public async delete(instance: string, key: string): ResponseProvider {
    try {
      const response = await axios.delete(`${this.baseUrl}/${instance}/${key}`, {
        headers: { apikey: this.globalApiToken },
      });
      return [{ status: response.status, data: response?.data }];
    } catch (error) {
      return [
        {
          status: error?.response?.status,
          data: error?.response?.data,
        },
        error,
      ];
    }
  }

  public async allInstances(): ResponseProvider {
    try {
      const response = await axios.get(`${this.baseUrl}/list-instances`, { headers: { apikey: this.globalApiToken } });
      return [{ status: response.status, data: response?.data as string[] }];
    } catch (error) {
      return [
        {
          status: error?.response?.status,
          data: error?.response?.data,
        },
        error,
      ];
    }
  }

  public async removeSession(instance: string): ResponseProvider {
    try {
      const response = await axios.delete(`${this.baseUrl}/${instance}`, { headers: { apikey: this.globalApiToken } });
      return [{ status: response.status, data: response?.data }];
    } catch (error) {
      return [
        {
          status: error?.response?.status,
          data: error?.response?.data,
        },
        error,
      ];
    }
  }
}



================================================
FILE: src/api/repository/repository.service.ts
================================================
import { ConfigService } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { PrismaClient } from '@prisma/client';

export class Query<T> {
  where?: T;
  sort?: 'asc' | 'desc';
  page?: number;
  offset?: number;
}

export class PrismaRepository extends PrismaClient {
  constructor(private readonly configService: ConfigService) {
    super();
  }

  private readonly logger = new Logger('PrismaRepository');

  public async onModuleInit() {
    await this.$connect();
    this.logger.info('Repository:Prisma - ON');
  }

  public async onModuleDestroy() {
    await this.$disconnect();
    this.logger.warn('Repository:Prisma - OFF');
  }
}



================================================
FILE: src/api/routes/call.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { OfferCallDto } from '@api/dto/call.dto';
import { callController } from '@api/server.module';
import { offerCallSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

import { HttpStatus } from './index.router';

export class CallRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router.post(this.routerPath('offer'), ...guards, async (req, res) => {
      const response = await this.dataValidate<OfferCallDto>({
        request: req,
        schema: offerCallSchema,
        ClassRef: OfferCallDto,
        execute: (instance, data) => callController.offerCall(instance, data),
      });

      return res.status(HttpStatus.CREATED).json(response);
    });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/routes/chat.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import {
  ArchiveChatDto,
  BlockUserDto,
  DeleteMessage,
  getBase64FromMediaMessageDto,
  MarkChatUnreadDto,
  NumberDto,
  PrivacySettingDto,
  ProfileNameDto,
  ProfilePictureDto,
  ProfileStatusDto,
  ReadMessageDto,
  SendPresenceDto,
  UpdateMessageDto,
  WhatsAppNumberDto,
} from '@api/dto/chat.dto';
import { InstanceDto } from '@api/dto/instance.dto';
import { Query } from '@api/repository/repository.service';
import { chatController } from '@api/server.module';
import { Contact, Message, MessageUpdate } from '@prisma/client';
import {
  archiveChatSchema,
  blockUserSchema,
  contactValidateSchema,
  deleteMessageSchema,
  markChatUnreadSchema,
  messageUpSchema,
  messageValidateSchema,
  presenceSchema,
  privacySettingsSchema,
  profileNameSchema,
  profilePictureSchema,
  profileSchema,
  profileStatusSchema,
  readMessageSchema,
  updateMessageSchema,
  whatsappNumberSchema,
} from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

import { HttpStatus } from './index.router';

export class ChatRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('whatsappNumbers'), ...guards, async (req, res) => {
        const response = await this.dataValidate<WhatsAppNumberDto>({
          request: req,
          schema: whatsappNumberSchema,
          ClassRef: WhatsAppNumberDto,
          execute: (instance, data) => chatController.whatsappNumber(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('markMessageAsRead'), ...guards, async (req, res) => {
        const response = await this.dataValidate<ReadMessageDto>({
          request: req,
          schema: readMessageSchema,
          ClassRef: ReadMessageDto,
          execute: (instance, data) => chatController.readMessage(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('archiveChat'), ...guards, async (req, res) => {
        const response = await this.dataValidate<ArchiveChatDto>({
          request: req,
          schema: archiveChatSchema,
          ClassRef: ArchiveChatDto,
          execute: (instance, data) => chatController.archiveChat(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('markChatUnread'), ...guards, async (req, res) => {
        const response = await this.dataValidate<MarkChatUnreadDto>({
          request: req,
          schema: markChatUnreadSchema,
          ClassRef: MarkChatUnreadDto,
          execute: (instance, data) => chatController.markChatUnread(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .delete(this.routerPath('deleteMessageForEveryone'), ...guards, async (req, res) => {
        const response = await this.dataValidate<DeleteMessage>({
          request: req,
          schema: deleteMessageSchema,
          ClassRef: DeleteMessage,
          execute: (instance, data) => chatController.deleteMessage(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('fetchProfilePictureUrl'), ...guards, async (req, res) => {
        const response = await this.dataValidate<NumberDto>({
          request: req,
          schema: profilePictureSchema,
          ClassRef: NumberDto,
          execute: (instance, data) => chatController.fetchProfilePicture(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('getBase64FromMediaMessage'), ...guards, async (req, res) => {
        const response = await this.dataValidate<getBase64FromMediaMessageDto>({
          request: req,
          schema: null,
          ClassRef: getBase64FromMediaMessageDto,
          execute: (instance, data) => chatController.getBase64FromMediaMessage(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      // TODO: corrigir updateMessage para medias tambem
      .post(this.routerPath('updateMessage'), ...guards, async (req, res) => {
        const response = await this.dataValidate<UpdateMessageDto>({
          request: req,
          schema: updateMessageSchema,
          ClassRef: UpdateMessageDto,
          execute: (instance, data) => chatController.updateMessage(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('sendPresence'), ...guards, async (req, res) => {
        const response = await this.dataValidate<null>({
          request: req,
          schema: presenceSchema,
          ClassRef: SendPresenceDto,
          execute: (instance, data) => chatController.sendPresence(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('updateBlockStatus'), ...guards, async (req, res) => {
        const response = await this.dataValidate<BlockUserDto>({
          request: req,
          schema: blockUserSchema,
          ClassRef: BlockUserDto,
          execute: (instance, data) => chatController.blockUser(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('findContacts'), ...guards, async (req, res) => {
        const response = await this.dataValidate<Query<Contact>>({
          request: req,
          schema: contactValidateSchema,
          ClassRef: Query<Contact>,
          execute: (instance, data) => chatController.fetchContacts(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('findMessages'), ...guards, async (req, res) => {
        const response = await this.dataValidate<Query<Message>>({
          request: req,
          schema: messageValidateSchema,
          ClassRef: Query<Message>,
          execute: (instance, data) => chatController.fetchMessages(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('findStatusMessage'), ...guards, async (req, res) => {
        const response = await this.dataValidate<Query<MessageUpdate>>({
          request: req,
          schema: messageUpSchema,
          ClassRef: Query<MessageUpdate>,
          execute: (instance, data) => chatController.fetchStatusMessage(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('findChats'), ...guards, async (req, res) => {
        const response = await this.dataValidate<Query<Contact>>({
          request: req,
          schema: contactValidateSchema,
          ClassRef: Query<Contact>,
          execute: (instance, data) => chatController.fetchChats(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      // Profile routes
      .post(this.routerPath('fetchBusinessProfile'), ...guards, async (req, res) => {
        const response = await this.dataValidate<ProfilePictureDto>({
          request: req,
          schema: profilePictureSchema,
          ClassRef: ProfilePictureDto,
          execute: (instance, data) => chatController.fetchBusinessProfile(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('fetchProfile'), ...guards, async (req, res) => {
        const response = await this.dataValidate<NumberDto>({
          request: req,
          schema: profileSchema,
          ClassRef: NumberDto,
          execute: (instance, data) => chatController.fetchProfile(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })

      .post(this.routerPath('updateProfileName'), ...guards, async (req, res) => {
        const response = await this.dataValidate<ProfileNameDto>({
          request: req,
          schema: profileNameSchema,
          ClassRef: ProfileNameDto,
          execute: (instance, data) => chatController.updateProfileName(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('updateProfileStatus'), ...guards, async (req, res) => {
        const response = await this.dataValidate<ProfileStatusDto>({
          request: req,
          schema: profileStatusSchema,
          ClassRef: ProfileStatusDto,
          execute: (instance, data) => chatController.updateProfileStatus(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('updateProfilePicture'), ...guards, async (req, res) => {
        const response = await this.dataValidate<ProfilePictureDto>({
          request: req,
          schema: profilePictureSchema,
          ClassRef: ProfilePictureDto,
          execute: (instance, data) => chatController.updateProfilePicture(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .delete(this.routerPath('removeProfilePicture'), ...guards, async (req, res) => {
        const response = await this.dataValidate<ProfilePictureDto>({
          request: req,
          schema: profilePictureSchema,
          ClassRef: ProfilePictureDto,
          execute: (instance) => chatController.removeProfilePicture(instance),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchPrivacySettings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: null,
          ClassRef: InstanceDto,
          execute: (instance) => chatController.fetchPrivacySettings(instance),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('updatePrivacySettings'), ...guards, async (req, res) => {
        const response = await this.dataValidate<PrivacySettingDto>({
          request: req,
          schema: privacySettingsSchema,
          ClassRef: PrivacySettingDto,
          execute: (instance, data) => chatController.updatePrivacySettings(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/routes/group.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import {
  AcceptGroupInvite,
  CreateGroupDto,
  GetParticipant,
  GroupDescriptionDto,
  GroupInvite,
  GroupJid,
  GroupPictureDto,
  GroupSendInvite,
  GroupSubjectDto,
  GroupToggleEphemeralDto,
  GroupUpdateParticipantDto,
  GroupUpdateSettingDto,
} from '@api/dto/group.dto';
import { groupController } from '@api/server.module';
import {
  AcceptGroupInviteSchema,
  createGroupSchema,
  getParticipantsSchema,
  groupInviteSchema,
  groupJidSchema,
  groupSendInviteSchema,
  toggleEphemeralSchema,
  updateGroupDescriptionSchema,
  updateGroupPictureSchema,
  updateGroupSubjectSchema,
  updateParticipantsSchema,
  updateSettingsSchema,
} from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

import { HttpStatus } from './index.router';

export class GroupRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('create'), ...guards, async (req, res) => {
        const response = await this.dataValidate<CreateGroupDto>({
          request: req,
          schema: createGroupSchema,
          ClassRef: CreateGroupDto,
          execute: (instance, data) => groupController.createGroup(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('updateGroupSubject'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupSubjectDto>({
          request: req,
          schema: updateGroupSubjectSchema,
          ClassRef: GroupSubjectDto,
          execute: (instance, data) => groupController.updateGroupSubject(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('updateGroupPicture'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupPictureDto>({
          request: req,
          schema: updateGroupPictureSchema,
          ClassRef: GroupPictureDto,
          execute: (instance, data) => groupController.updateGroupPicture(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('updateGroupDescription'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupDescriptionDto>({
          request: req,
          schema: updateGroupDescriptionSchema,
          ClassRef: GroupDescriptionDto,
          execute: (instance, data) => groupController.updateGroupDescription(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('findGroupInfos'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupJid>({
          request: req,
          schema: groupJidSchema,
          ClassRef: GroupJid,
          execute: (instance, data) => groupController.findGroupInfo(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchAllGroups'), ...guards, async (req, res) => {
        const response = await this.getParticipantsValidate<GetParticipant>({
          request: req,
          schema: getParticipantsSchema,
          ClassRef: GetParticipant,
          execute: (instance, data) => groupController.fetchAllGroups(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('participants'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupJid>({
          request: req,
          schema: groupJidSchema,
          ClassRef: GroupJid,
          execute: (instance, data) => groupController.findParticipants(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('inviteCode'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupJid>({
          request: req,
          schema: groupJidSchema,
          ClassRef: GroupJid,
          execute: (instance, data) => groupController.inviteCode(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('inviteInfo'), ...guards, async (req, res) => {
        const response = await this.inviteCodeValidate<GroupInvite>({
          request: req,
          schema: groupInviteSchema,
          ClassRef: GroupInvite,
          execute: (instance, data) => groupController.inviteInfo(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('acceptInviteCode'), ...guards, async (req, res) => {
        const response = await this.inviteCodeValidate<AcceptGroupInvite>({
          request: req,
          schema: AcceptGroupInviteSchema,
          ClassRef: AcceptGroupInvite,
          execute: (instance, data) => groupController.acceptInviteCode(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('sendInvite'), ...guards, async (req, res) => {
        const response = await this.groupNoValidate<GroupSendInvite>({
          request: req,
          schema: groupSendInviteSchema,
          ClassRef: GroupSendInvite,
          execute: (instance, data) => groupController.sendInvite(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('revokeInviteCode'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupJid>({
          request: req,
          schema: groupJidSchema,
          ClassRef: GroupJid,
          execute: (instance, data) => groupController.revokeInviteCode(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('updateParticipant'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupUpdateParticipantDto>({
          request: req,
          schema: updateParticipantsSchema,
          ClassRef: GroupUpdateParticipantDto,
          execute: (instance, data) => groupController.updateGParticipate(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('updateSetting'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupUpdateSettingDto>({
          request: req,
          schema: updateSettingsSchema,
          ClassRef: GroupUpdateSettingDto,
          execute: (instance, data) => groupController.updateGSetting(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('toggleEphemeral'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupToggleEphemeralDto>({
          request: req,
          schema: toggleEphemeralSchema,
          ClassRef: GroupToggleEphemeralDto,
          execute: (instance, data) => groupController.toggleEphemeral(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .delete(this.routerPath('leaveGroup'), ...guards, async (req, res) => {
        const response = await this.groupValidate<GroupJid>({
          request: req,
          schema: {},
          ClassRef: GroupJid,
          execute: (instance, data) => groupController.leaveGroup(instance, data),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/routes/index.router.ts
================================================
import { authGuard } from '@api/guards/auth.guard';
import { instanceExistsGuard, instanceLoggedGuard } from '@api/guards/instance.guard';
import Telemetry from '@api/guards/telemetry.guard';
import { ChannelRouter } from '@api/integrations/channel/channel.router';
import { ChatbotRouter } from '@api/integrations/chatbot/chatbot.router';
import { EventRouter } from '@api/integrations/event/event.router';
import { StorageRouter } from '@api/integrations/storage/storage.router';
import { configService } from '@config/env.config';
import { Router } from 'express';
import fs from 'fs';
import mimeTypes from 'mime-types';
import path from 'path';

import { CallRouter } from './call.router';
import { ChatRouter } from './chat.router';
import { GroupRouter } from './group.router';
import { InstanceRouter } from './instance.router';
import { LabelRouter } from './label.router';
import { ProxyRouter } from './proxy.router';
import { MessageRouter } from './sendMessage.router';
import { SettingsRouter } from './settings.router';
import { TemplateRouter } from './template.router';
import { ViewsRouter } from './view.router';

enum HttpStatus {
  OK = 200,
  CREATED = 201,
  NOT_FOUND = 404,
  FORBIDDEN = 403,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401,
  INTERNAL_SERVER_ERROR = 500,
}

const router: Router = Router();
const serverConfig = configService.get('SERVER');
const guards = [instanceExistsGuard, instanceLoggedGuard, authGuard['apikey']];

const telemetry = new Telemetry();

const packageJson = JSON.parse(fs.readFileSync('./package.json', 'utf8'));

if (!serverConfig.DISABLE_MANAGER) router.use('/manager', new ViewsRouter().router);

router.get('/assets/*', (req, res) => {
  const fileName = req.params[0];
  const basePath = path.join(process.cwd(), 'manager', 'dist');

  const filePath = path.join(basePath, 'assets/', fileName);

  if (fs.existsSync(filePath)) {
    res.set('Content-Type', mimeTypes.lookup(filePath) || 'text/css');
    res.send(fs.readFileSync(filePath));
  } else {
    res.status(404).send('File not found');
  }
});

router
  .use((req, res, next) => telemetry.collectTelemetry(req, res, next))

  .get('/', (req, res) => {
    res.status(HttpStatus.OK).json({
      status: HttpStatus.OK,
      message: 'Welcome to the Evolution API, it is working!',
      version: packageJson.version,
      clientName: process.env.DATABASE_CONNECTION_CLIENT_NAME,
      manager: !serverConfig.DISABLE_MANAGER ? `${req.protocol}://${req.get('host')}/manager` : undefined,
      documentation: `https://doc.evolution-api.com`,
    });
  })
  .post('/verify-creds', authGuard['apikey'], async (req, res) => {
    return res.status(HttpStatus.OK).json({
      status: HttpStatus.OK,
      message: 'Credentials are valid',
      facebookAppId: process.env.FACEBOOK_APP_ID,
      facebookConfigId: process.env.FACEBOOK_CONFIG_ID,
      facebookUserToken: process.env.FACEBOOK_USER_TOKEN,
    });
  })
  .use('/instance', new InstanceRouter(configService, ...guards).router)
  .use('/message', new MessageRouter(...guards).router)
  .use('/call', new CallRouter(...guards).router)
  .use('/chat', new ChatRouter(...guards).router)
  .use('/group', new GroupRouter(...guards).router)
  .use('/template', new TemplateRouter(configService, ...guards).router)
  .use('/settings', new SettingsRouter(...guards).router)
  .use('/proxy', new ProxyRouter(...guards).router)
  .use('/label', new LabelRouter(...guards).router)
  .use('', new ChannelRouter(configService, ...guards).router)
  .use('', new EventRouter(configService, ...guards).router)
  .use('', new ChatbotRouter(...guards).router)
  .use('', new StorageRouter(...guards).router);

export { HttpStatus, router };



================================================
FILE: src/api/routes/instance.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto, SetPresenceDto } from '@api/dto/instance.dto';
import { instanceController } from '@api/server.module';
import { ConfigService } from '@config/env.config';
import { instanceSchema, presenceOnlySchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

import { HttpStatus } from './index.router';

export class InstanceRouter extends RouterBroker {
  constructor(
    readonly configService: ConfigService,
    ...guards: RequestHandler[]
  ) {
    super();
    this.router
      .post('/create', ...guards, async (req, res) => {
        console.log('create instance', req.body);
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => instanceController.createInstance(instance),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('restart'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: null,
          ClassRef: InstanceDto,
          execute: (instance) => instanceController.restartInstance(instance),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('connect'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: null,
          ClassRef: InstanceDto,
          execute: (instance) => instanceController.connectToWhatsapp(instance),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('connectionState'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: null,
          ClassRef: InstanceDto,
          execute: (instance) => instanceController.connectionState(instance),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .get(this.routerPath('fetchInstances', false), ...guards, async (req, res) => {
        const key = req.get('apikey');

        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: null,
          ClassRef: InstanceDto,
          execute: (instance) => instanceController.fetchInstances(instance, key),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('setPresence'), ...guards, async (req, res) => {
        const response = await this.dataValidate<null>({
          request: req,
          schema: presenceOnlySchema,
          ClassRef: SetPresenceDto,
          execute: (instance, data) => instanceController.setPresence(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .delete(this.routerPath('logout'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: null,
          ClassRef: InstanceDto,
          execute: (instance) => instanceController.logout(instance),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .delete(this.routerPath('delete'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: null,
          ClassRef: InstanceDto,
          execute: (instance) => instanceController.deleteInstance(instance),
        });

        return res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/routes/label.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { HandleLabelDto, LabelDto } from '@api/dto/label.dto';
import { labelController } from '@api/server.module';
import { handleLabelSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

import { HttpStatus } from './index.router';

export class LabelRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .get(this.routerPath('findLabels'), ...guards, async (req, res) => {
        const response = await this.dataValidate<LabelDto>({
          request: req,
          schema: null,
          ClassRef: LabelDto,
          execute: (instance) => labelController.fetchLabels(instance),
        });

        return res.status(HttpStatus.OK).json(response);
      })
      .post(this.routerPath('handleLabel'), ...guards, async (req, res) => {
        const response = await this.dataValidate<HandleLabelDto>({
          request: req,
          schema: handleLabelSchema,
          ClassRef: HandleLabelDto,
          execute: (instance, data) => labelController.handleLabel(instance, data),
        });

        return res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/routes/proxy.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { ProxyDto } from '@api/dto/proxy.dto';
import { proxyController } from '@api/server.module';
import { instanceSchema, proxySchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

import { HttpStatus } from './index.router';

export class ProxyRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('set'), ...guards, async (req, res) => {
        const response = await this.dataValidate<ProxyDto>({
          request: req,
          schema: proxySchema,
          ClassRef: ProxyDto,
          execute: (instance, data) => proxyController.createProxy(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => proxyController.findProxy(instance),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/routes/sendMessage.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import {
  SendAudioDto,
  SendButtonsDto,
  SendContactDto,
  SendListDto,
  SendLocationDto,
  SendMediaDto,
  SendPollDto,
  SendPtvDto,
  SendReactionDto,
  SendStatusDto,
  SendStickerDto,
  SendTemplateDto,
  SendTextDto,
} from '@api/dto/sendMessage.dto';
import { sendMessageController } from '@api/server.module';
import {
  audioMessageSchema,
  buttonsMessageSchema,
  contactMessageSchema,
  listMessageSchema,
  locationMessageSchema,
  mediaMessageSchema,
  pollMessageSchema,
  ptvMessageSchema,
  reactionMessageSchema,
  statusMessageSchema,
  stickerMessageSchema,
  templateMessageSchema,
  textMessageSchema,
} from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';
import multer from 'multer';

import { HttpStatus } from './index.router';

const upload = multer({ storage: multer.memoryStorage() });

export class MessageRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('sendTemplate'), ...guards, async (req, res) => {
        const response = await this.dataValidate<SendTemplateDto>({
          request: req,
          schema: templateMessageSchema,
          ClassRef: SendTemplateDto,
          execute: (instance, data) => sendMessageController.sendTemplate(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendText'), ...guards, async (req, res) => {
        const response = await this.dataValidate<SendTextDto>({
          request: req,
          schema: textMessageSchema,
          ClassRef: SendTextDto,
          execute: (instance, data) => sendMessageController.sendText(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendMedia'), ...guards, upload.single('file'), async (req, res) => {
        const bodyData = req.body;

        const response = await this.dataValidate<SendMediaDto>({
          request: req,
          schema: mediaMessageSchema,
          ClassRef: SendMediaDto,
          execute: (instance) => sendMessageController.sendMedia(instance, bodyData, req.file as any),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendPtv'), ...guards, upload.single('file'), async (req, res) => {
        const bodyData = req.body;

        const response = await this.dataValidate<SendPtvDto>({
          request: req,
          schema: ptvMessageSchema,
          ClassRef: SendPtvDto,
          execute: (instance) => sendMessageController.sendPtv(instance, bodyData, req.file as any),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendWhatsAppAudio'), ...guards, upload.single('file'), async (req, res) => {
        const bodyData = req.body;

        const response = await this.dataValidate<SendAudioDto>({
          request: req,
          schema: audioMessageSchema,
          ClassRef: SendMediaDto,
          execute: (instance) => sendMessageController.sendWhatsAppAudio(instance, bodyData, req.file as any),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      // TODO: Revisar funcionamento do envio de Status
      .post(this.routerPath('sendStatus'), ...guards, upload.single('file'), async (req, res) => {
        const bodyData = req.body;

        const response = await this.dataValidate<SendStatusDto>({
          request: req,
          schema: statusMessageSchema,
          ClassRef: SendStatusDto,
          execute: (instance) => sendMessageController.sendStatus(instance, bodyData, req.file as any),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendSticker'), ...guards, upload.single('file'), async (req, res) => {
        const bodyData = req.body;

        const response = await this.dataValidate<SendStickerDto>({
          request: req,
          schema: stickerMessageSchema,
          ClassRef: SendStickerDto,
          execute: (instance) => sendMessageController.sendSticker(instance, bodyData, req.file as any),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendLocation'), ...guards, async (req, res) => {
        const response = await this.dataValidate<SendLocationDto>({
          request: req,
          schema: locationMessageSchema,
          ClassRef: SendLocationDto,
          execute: (instance, data) => sendMessageController.sendLocation(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendContact'), ...guards, async (req, res) => {
        const response = await this.dataValidate<SendContactDto>({
          request: req,
          schema: contactMessageSchema,
          ClassRef: SendContactDto,
          execute: (instance, data) => sendMessageController.sendContact(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendReaction'), ...guards, async (req, res) => {
        const response = await this.dataValidate<SendReactionDto>({
          request: req,
          schema: reactionMessageSchema,
          ClassRef: SendReactionDto,
          execute: (instance, data) => sendMessageController.sendReaction(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendPoll'), ...guards, async (req, res) => {
        const response = await this.dataValidate<SendPollDto>({
          request: req,
          schema: pollMessageSchema,
          ClassRef: SendPollDto,
          execute: (instance, data) => sendMessageController.sendPoll(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendList'), ...guards, async (req, res) => {
        const response = await this.dataValidate<SendListDto>({
          request: req,
          schema: listMessageSchema,
          ClassRef: SendListDto,
          execute: (instance, data) => sendMessageController.sendList(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      })
      .post(this.routerPath('sendButtons'), ...guards, async (req, res) => {
        const response = await this.dataValidate<SendButtonsDto>({
          request: req,
          schema: buttonsMessageSchema,
          ClassRef: SendButtonsDto,
          execute: (instance, data) => sendMessageController.sendButtons(instance, data),
        });

        return res.status(HttpStatus.CREATED).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/routes/settings.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { SettingsDto } from '@api/dto/settings.dto';
import { settingsController } from '@api/server.module';
import { settingsSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

import { HttpStatus } from './index.router';

export class SettingsRouter extends RouterBroker {
  constructor(...guards: RequestHandler[]) {
    super();
    this.router
      .post(this.routerPath('set'), ...guards, async (req, res) => {
        const response = await this.dataValidate<SettingsDto>({
          request: req,
          schema: settingsSchema,
          ClassRef: SettingsDto,
          execute: (instance, data) => settingsController.createSettings(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: null,
          ClassRef: InstanceDto,
          execute: (instance) => settingsController.findSettings(instance),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/routes/template.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import { InstanceDto } from '@api/dto/instance.dto';
import { TemplateDto } from '@api/dto/template.dto';
import { templateController } from '@api/server.module';
import { ConfigService } from '@config/env.config';
import { instanceSchema, templateSchema } from '@validate/validate.schema';
import { RequestHandler, Router } from 'express';

import { HttpStatus } from './index.router';

export class TemplateRouter extends RouterBroker {
  constructor(
    readonly configService: ConfigService,
    ...guards: RequestHandler[]
  ) {
    super();
    this.router
      .post(this.routerPath('create'), ...guards, async (req, res) => {
        const response = await this.dataValidate<TemplateDto>({
          request: req,
          schema: templateSchema,
          ClassRef: TemplateDto,
          execute: (instance, data) => templateController.createTemplate(instance, data),
        });

        res.status(HttpStatus.CREATED).json(response);
      })
      .get(this.routerPath('find'), ...guards, async (req, res) => {
        const response = await this.dataValidate<InstanceDto>({
          request: req,
          schema: instanceSchema,
          ClassRef: InstanceDto,
          execute: (instance) => templateController.findTemplate(instance),
        });

        res.status(HttpStatus.OK).json(response);
      });
  }

  public readonly router: Router = Router();
}



================================================
FILE: src/api/routes/view.router.ts
================================================
import { RouterBroker } from '@api/abstract/abstract.router';
import express, { Router } from 'express';
import path from 'path';

export class ViewsRouter extends RouterBroker {
  public readonly router: Router;

  constructor() {
    super();
    this.router = Router();

    const basePath = path.join(process.cwd(), 'manager', 'dist');
    const indexPath = path.join(basePath, 'index.html');

    this.router.use(express.static(basePath));

    this.router.get('*', (req, res) => {
      res.sendFile(indexPath);
    });
  }
}



================================================
FILE: src/api/services/auth.service.ts
================================================
import { PrismaRepository } from '@api/repository/repository.service';
import { BadRequestException } from '@exceptions';

export class AuthService {
  constructor(private readonly prismaRepository: PrismaRepository) {}

  public async checkDuplicateToken(token: string) {
    if (!token) {
      return true;
    }

    const instances = await this.prismaRepository.instance.findMany({
      where: { token },
    });

    if (instances.length > 0) {
      throw new BadRequestException('Token already exists');
    }

    return true;
  }
}



================================================
FILE: src/api/services/cache.service.ts
================================================
import { ICache } from '@api/abstract/abstract.cache';
import { Logger } from '@config/logger.config';
import { BufferJSON } from 'baileys';

export class CacheService {
  private readonly logger = new Logger('CacheService');

  constructor(private readonly cache: ICache) {
    if (cache) {
      this.logger.verbose(`cacheservice created using cache engine: ${cache.constructor?.name}`);
    } else {
      this.logger.verbose(`cacheservice disabled`);
    }
  }

  async get(key: string): Promise<any> {
    if (!this.cache) {
      return;
    }
    return this.cache.get(key);
  }

  public async hGet(key: string, field: string) {
    if (!this.cache) {
      return null;
    }
    try {
      const data = await this.cache.hGet(key, field);

      if (data) {
        return JSON.parse(data, BufferJSON.reviver);
      }

      return null;
    } catch (error) {
      this.logger.error(error);
      return null;
    }
  }

  async set(key: string, value: any, ttl?: number) {
    if (!this.cache) {
      return;
    }
    this.cache.set(key, value, ttl);
  }

  public async hSet(key: string, field: string, value: any) {
    if (!this.cache) {
      return;
    }
    try {
      const json = JSON.stringify(value, BufferJSON.replacer);

      await this.cache.hSet(key, field, json);
    } catch (error) {
      this.logger.error(error);
    }
  }

  async has(key: string) {
    if (!this.cache) {
      return;
    }
    return this.cache.has(key);
  }

  async delete(key: string) {
    if (!this.cache) {
      return;
    }
    return this.cache.delete(key);
  }

  async hDelete(key: string, field: string) {
    if (!this.cache) {
      return false;
    }
    try {
      await this.cache.hDelete(key, field);
      return true;
    } catch (error) {
      this.logger.error(error);
      return false;
    }
  }

  async deleteAll(appendCriteria?: string) {
    if (!this.cache) {
      return;
    }
    return this.cache.deleteAll(appendCriteria);
  }

  async keys(appendCriteria?: string) {
    if (!this.cache) {
      return;
    }
    return this.cache.keys(appendCriteria);
  }
}



================================================
FILE: src/api/services/channel.service.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { ProxyDto } from '@api/dto/proxy.dto';
import { SettingsDto } from '@api/dto/settings.dto';
import { ChatwootDto } from '@api/integrations/chatbot/chatwoot/dto/chatwoot.dto';
import { ChatwootService } from '@api/integrations/chatbot/chatwoot/services/chatwoot.service';
import { DifyService } from '@api/integrations/chatbot/dify/services/dify.service';
import { OpenaiService } from '@api/integrations/chatbot/openai/services/openai.service';
import { TypebotService } from '@api/integrations/chatbot/typebot/services/typebot.service';
import { PrismaRepository, Query } from '@api/repository/repository.service';
import { eventManager, waMonitor } from '@api/server.module';
import { Events, wa } from '@api/types/wa.types';
import { Auth, Chatwoot, ConfigService, HttpServer } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { NotFoundException } from '@exceptions';
import { Contact, Message, Prisma } from '@prisma/client';
import { createJid } from '@utils/createJid';
import { WASocket } from 'baileys';
import { isArray } from 'class-validator';
import EventEmitter2 from 'eventemitter2';
import { v4 } from 'uuid';

import { CacheService } from './cache.service';

export class ChannelStartupService {
  constructor(
    public readonly configService: ConfigService,
    public readonly eventEmitter: EventEmitter2,
    public readonly prismaRepository: PrismaRepository,
    public readonly chatwootCache: CacheService,
  ) {}

  public readonly logger = new Logger('ChannelStartupService');

  public client: WASocket;
  public readonly instance: wa.Instance = {};
  public readonly localChatwoot: wa.LocalChatwoot = {};
  public readonly localProxy: wa.LocalProxy = {};
  public readonly localSettings: wa.LocalSettings = {};
  public readonly localWebhook: wa.LocalWebHook = {};

  public chatwootService = new ChatwootService(
    waMonitor,
    this.configService,
    this.prismaRepository,
    this.chatwootCache,
  );

  public typebotService = new TypebotService(waMonitor, this.configService, this.prismaRepository);

  public openaiService = new OpenaiService(waMonitor, this.configService, this.prismaRepository);

  public difyService = new DifyService(waMonitor, this.configService, this.prismaRepository);

  public setInstance(instance: InstanceDto) {
    this.logger.setInstance(instance.instanceName);

    this.instance.name = instance.instanceName;
    this.instance.id = instance.instanceId;
    this.instance.integration = instance.integration;
    this.instance.number = instance.number;
    this.instance.token = instance.token;
    this.instance.businessId = instance.businessId;

    if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED && this.localChatwoot?.enabled) {
      this.chatwootService.eventWhatsapp(
        Events.STATUS_INSTANCE,
        { instanceName: this.instance.name },
        {
          instance: this.instance.name,
          status: 'created',
        },
      );
    }
  }

  public set instanceName(name: string) {
    this.logger.setInstance(name);

    if (!name) {
      this.instance.name = v4();
      return;
    }
    this.instance.name = name;
  }

  public get instanceName() {
    return this.instance.name;
  }

  public set instanceId(id: string) {
    if (!id) {
      this.instance.id = v4();
      return;
    }
    this.instance.id = id;
  }

  public get instanceId() {
    return this.instance.id;
  }

  public set integration(integration: string) {
    this.instance.integration = integration;
  }

  public get integration() {
    return this.instance.integration;
  }

  public set number(number: string) {
    this.instance.number = number;
  }

  public get number() {
    return this.instance.number;
  }

  public set token(token: string) {
    this.instance.token = token;
  }

  public get token() {
    return this.instance.token;
  }

  public get wuid() {
    return this.instance.wuid;
  }

  public async loadWebhook() {
    const data = await this.prismaRepository.webhook.findUnique({
      where: {
        instanceId: this.instanceId,
      },
    });

    this.localWebhook.enabled = data?.enabled;
    this.localWebhook.webhookBase64 = data?.webhookBase64;
  }

  public async loadSettings() {
    const data = await this.prismaRepository.setting.findUnique({
      where: {
        instanceId: this.instanceId,
      },
    });

    this.localSettings.rejectCall = data?.rejectCall;
    this.localSettings.msgCall = data?.msgCall;
    this.localSettings.groupsIgnore = data?.groupsIgnore;
    this.localSettings.alwaysOnline = data?.alwaysOnline;
    this.localSettings.readMessages = data?.readMessages;
    this.localSettings.readStatus = data?.readStatus;
    this.localSettings.syncFullHistory = data?.syncFullHistory;
    this.localSettings.wavoipToken = data?.wavoipToken;
  }

  public async setSettings(data: SettingsDto) {
    await this.prismaRepository.setting.upsert({
      where: {
        instanceId: this.instanceId,
      },
      update: {
        rejectCall: data.rejectCall,
        msgCall: data.msgCall,
        groupsIgnore: data.groupsIgnore,
        alwaysOnline: data.alwaysOnline,
        readMessages: data.readMessages,
        readStatus: data.readStatus,
        syncFullHistory: data.syncFullHistory,
        wavoipToken: data.wavoipToken,
      },
      create: {
        rejectCall: data.rejectCall,
        msgCall: data.msgCall,
        groupsIgnore: data.groupsIgnore,
        alwaysOnline: data.alwaysOnline,
        readMessages: data.readMessages,
        readStatus: data.readStatus,
        syncFullHistory: data.syncFullHistory,
        wavoipToken: data.wavoipToken,
        instanceId: this.instanceId,
      },
    });

    this.localSettings.rejectCall = data?.rejectCall;
    this.localSettings.msgCall = data?.msgCall;
    this.localSettings.groupsIgnore = data?.groupsIgnore;
    this.localSettings.alwaysOnline = data?.alwaysOnline;
    this.localSettings.readMessages = data?.readMessages;
    this.localSettings.readStatus = data?.readStatus;
    this.localSettings.syncFullHistory = data?.syncFullHistory;
    this.localSettings.wavoipToken = data?.wavoipToken;

    if (this.localSettings.wavoipToken && this.localSettings.wavoipToken.length > 0) {
      this.client.ws.close();
      this.client.ws.connect();
    }
  }

  public async findSettings() {
    const data = await this.prismaRepository.setting.findUnique({
      where: {
        instanceId: this.instanceId,
      },
    });

    if (!data) {
      return null;
    }

    return {
      rejectCall: data.rejectCall,
      msgCall: data.msgCall,
      groupsIgnore: data.groupsIgnore,
      alwaysOnline: data.alwaysOnline,
      readMessages: data.readMessages,
      readStatus: data.readStatus,
      syncFullHistory: data.syncFullHistory,
      wavoipToken: data.wavoipToken,
    };
  }

  public async loadChatwoot() {
    if (!this.configService.get<Chatwoot>('CHATWOOT').ENABLED) {
      return;
    }

    const data = await this.prismaRepository.chatwoot.findUnique({
      where: {
        instanceId: this.instanceId,
      },
    });

    this.localChatwoot.enabled = data?.enabled;
    this.localChatwoot.accountId = data?.accountId;
    this.localChatwoot.token = data?.token;
    this.localChatwoot.url = data?.url;
    this.localChatwoot.nameInbox = data?.nameInbox;
    this.localChatwoot.signMsg = data?.signMsg;
    this.localChatwoot.signDelimiter = data?.signDelimiter;
    this.localChatwoot.number = data?.number;
    this.localChatwoot.reopenConversation = data?.reopenConversation;
    this.localChatwoot.conversationPending = data?.conversationPending;
    this.localChatwoot.mergeBrazilContacts = data?.mergeBrazilContacts;
    this.localChatwoot.importContacts = data?.importContacts;
    this.localChatwoot.importMessages = data?.importMessages;
    this.localChatwoot.daysLimitImportMessages = data?.daysLimitImportMessages;
  }

  public async setChatwoot(data: ChatwootDto) {
    if (!this.configService.get<Chatwoot>('CHATWOOT').ENABLED) {
      return;
    }

    const chatwoot = await this.prismaRepository.chatwoot.findUnique({
      where: {
        instanceId: this.instanceId,
      },
    });

    if (chatwoot) {
      await this.prismaRepository.chatwoot.update({
        where: {
          instanceId: this.instanceId,
        },
        data: {
          enabled: data?.enabled,
          accountId: data.accountId,
          token: data.token,
          url: data.url,
          nameInbox: data.nameInbox,
          signMsg: data.signMsg,
          signDelimiter: data.signMsg ? data.signDelimiter : null,
          number: data.number,
          reopenConversation: data.reopenConversation,
          conversationPending: data.conversationPending,
          mergeBrazilContacts: data.mergeBrazilContacts,
          importContacts: data.importContacts,
          importMessages: data.importMessages,
          daysLimitImportMessages: data.daysLimitImportMessages,
          organization: data.organization,
          logo: data.logo,
          ignoreJids: data.ignoreJids,
        },
      });

      Object.assign(this.localChatwoot, { ...data, signDelimiter: data.signMsg ? data.signDelimiter : null });

      this.clearCacheChatwoot();
      return;
    }

    await this.prismaRepository.chatwoot.create({
      data: {
        enabled: data?.enabled,
        accountId: data.accountId,
        token: data.token,
        url: data.url,
        nameInbox: data.nameInbox,
        signMsg: data.signMsg,
        number: data.number,
        reopenConversation: data.reopenConversation,
        conversationPending: data.conversationPending,
        mergeBrazilContacts: data.mergeBrazilContacts,
        importContacts: data.importContacts,
        importMessages: data.importMessages,
        daysLimitImportMessages: data.daysLimitImportMessages,
        organization: data.organization,
        logo: data.logo,
        ignoreJids: data.ignoreJids,
        instanceId: this.instanceId,
      },
    });

    Object.assign(this.localChatwoot, { ...data, signDelimiter: data.signMsg ? data.signDelimiter : null });

    this.clearCacheChatwoot();
  }

  public async findChatwoot(): Promise<ChatwootDto | null> {
    if (!this.configService.get<Chatwoot>('CHATWOOT').ENABLED) {
      return null;
    }

    const data = await this.prismaRepository.chatwoot.findUnique({
      where: {
        instanceId: this.instanceId,
      },
    });

    if (!data) {
      return null;
    }

    const ignoreJidsArray = Array.isArray(data.ignoreJids) ? data.ignoreJids.map((event) => String(event)) : [];

    return {
      enabled: data?.enabled,
      accountId: data.accountId,
      token: data.token,
      url: data.url,
      nameInbox: data.nameInbox,
      signMsg: data.signMsg,
      signDelimiter: data.signDelimiter || null,
      reopenConversation: data.reopenConversation,
      conversationPending: data.conversationPending,
      mergeBrazilContacts: data.mergeBrazilContacts,
      importContacts: data.importContacts,
      importMessages: data.importMessages,
      daysLimitImportMessages: data.daysLimitImportMessages,
      organization: data.organization,
      logo: data.logo,
      ignoreJids: ignoreJidsArray,
    };
  }

  public clearCacheChatwoot() {
    if (this.localChatwoot?.enabled) {
      this.chatwootService.getCache()?.deleteAll(this.instanceName);
    }
  }

  public async loadProxy() {
    this.localProxy.enabled = false;

    if (process.env.PROXY_HOST) {
      this.localProxy.enabled = true;
      this.localProxy.host = process.env.PROXY_HOST;
      this.localProxy.port = process.env.PROXY_PORT || '80';
      this.localProxy.protocol = process.env.PROXY_PROTOCOL || 'http';
      this.localProxy.username = process.env.PROXY_USERNAME;
      this.localProxy.password = process.env.PROXY_PASSWORD;
    }

    const data = await this.prismaRepository.proxy.findUnique({
      where: {
        instanceId: this.instanceId,
      },
    });

    if (data?.enabled) {
      this.localProxy.enabled = true;
      this.localProxy.host = data?.host;
      this.localProxy.port = data?.port;
      this.localProxy.protocol = data?.protocol;
      this.localProxy.username = data?.username;
      this.localProxy.password = data?.password;
    }
  }

  public async setProxy(data: ProxyDto) {
    await this.prismaRepository.proxy.upsert({
      where: {
        instanceId: this.instanceId,
      },
      update: {
        enabled: data?.enabled,
        host: data.host,
        port: data.port,
        protocol: data.protocol,
        username: data.username,
        password: data.password,
      },
      create: {
        enabled: data?.enabled,
        host: data.host,
        port: data.port,
        protocol: data.protocol,
        username: data.username,
        password: data.password,
        instanceId: this.instanceId,
      },
    });

    Object.assign(this.localProxy, data);
  }

  public async findProxy() {
    const data = await this.prismaRepository.proxy.findUnique({
      where: {
        instanceId: this.instanceId,
      },
    });

    if (!data) {
      throw new NotFoundException('Proxy not found');
    }

    return data;
  }

  public async sendDataWebhook<T = any>(event: Events, data: T, local = true, integration?: string[]) {
    const serverUrl = this.configService.get<HttpServer>('SERVER').URL;
    const tzoffset = new Date().getTimezoneOffset() * 60000; //offset in milliseconds
    const localISOTime = new Date(Date.now() - tzoffset).toISOString();
    const now = localISOTime;

    const expose = this.configService.get<Auth>('AUTHENTICATION').EXPOSE_IN_FETCH_INSTANCES;

    const instanceApikey = this.token || 'Apikey not found';

    await eventManager.emit({
      instanceName: this.instance.name,
      origin: ChannelStartupService.name,
      event,
      data,
      serverUrl,
      dateTime: now,
      sender: this.wuid,
      apiKey: expose && instanceApikey ? instanceApikey : null,
      local,
      integration,
    });
  }

  // Check if the number is MX or AR
  public formatMXOrARNumber(jid: string): string {
    const countryCode = jid.substring(0, 2);

    if (Number(countryCode) === 52 || Number(countryCode) === 54) {
      if (jid.length === 13) {
        const number = countryCode + jid.substring(3);
        return number;
      }

      return jid;
    }
    return jid;
  }

  // Check if the number is br
  public formatBRNumber(jid: string) {
    const regexp = new RegExp(/^(\d{2})(\d{2})\d{1}(\d{8})$/);
    if (regexp.test(jid)) {
      const match = regexp.exec(jid);
      if (match && match[1] === '55') {
        const joker = Number.parseInt(match[3][0]);
        const ddd = Number.parseInt(match[2]);
        if (joker < 7 || ddd < 31) {
          return match[0];
        }
        return match[1] + match[2] + match[3];
      }
      return jid;
    } else {
      return jid;
    }
  }

  public async fetchContacts(query: Query<Contact>) {
    const remoteJid = query?.where?.remoteJid
      ? query?.where?.remoteJid.includes('@')
        ? query.where?.remoteJid
        : createJid(query.where?.remoteJid)
      : null;

    const where = {
      instanceId: this.instanceId,
    };

    if (remoteJid) {
      where['remoteJid'] = remoteJid;
    }

    return await this.prismaRepository.contact.findMany({
      where,
    });
  }

  public cleanMessageData(message: any) {
    if (!message) return message;

    const cleanedMessage = { ...message };

    const mediaUrl = cleanedMessage.message.mediaUrl;

    delete cleanedMessage.message.base64;

    if (cleanedMessage.message) {
      // Limpa imageMessage
      if (cleanedMessage.message.imageMessage) {
        cleanedMessage.message.imageMessage = {
          caption: cleanedMessage.message.imageMessage.caption,
        };
      }

      // Limpa videoMessage
      if (cleanedMessage.message.videoMessage) {
        cleanedMessage.message.videoMessage = {
          caption: cleanedMessage.message.videoMessage.caption,
        };
      }

      // Limpa audioMessage
      if (cleanedMessage.message.audioMessage) {
        cleanedMessage.message.audioMessage = {
          seconds: cleanedMessage.message.audioMessage.seconds,
        };
      }

      // Limpa stickerMessage
      if (cleanedMessage.message.stickerMessage) {
        cleanedMessage.message.stickerMessage = {};
      }

      // Limpa documentMessage
      if (cleanedMessage.message.documentMessage) {
        cleanedMessage.message.documentMessage = {
          caption: cleanedMessage.message.documentMessage.caption,
          name: cleanedMessage.message.documentMessage.name,
        };
      }

      // Limpa documentWithCaptionMessage
      if (cleanedMessage.message.documentWithCaptionMessage) {
        cleanedMessage.message.documentWithCaptionMessage = {
          caption: cleanedMessage.message.documentWithCaptionMessage.caption,
          name: cleanedMessage.message.documentWithCaptionMessage.name,
        };
      }
    }

    if (mediaUrl) cleanedMessage.message.mediaUrl = mediaUrl;

    return cleanedMessage;
  }

  public async fetchMessages(query: Query<Message>) {
    const keyFilters = query?.where?.key as {
      id?: string;
      fromMe?: boolean;
      remoteJid?: string;
      participants?: string;
    };

    const timestampFilter = {};
    if (query?.where?.messageTimestamp) {
      if (query.where.messageTimestamp['gte'] && query.where.messageTimestamp['lte']) {
        timestampFilter['messageTimestamp'] = {
          gte: Math.floor(new Date(query.where.messageTimestamp['gte']).getTime() / 1000),
          lte: Math.floor(new Date(query.where.messageTimestamp['lte']).getTime() / 1000),
        };
      }
    }

    const count = await this.prismaRepository.message.count({
      where: {
        instanceId: this.instanceId,
        id: query?.where?.id,
        source: query?.where?.source,
        messageType: query?.where?.messageType,
        ...timestampFilter,
        AND: [
          keyFilters?.id ? { key: { path: ['id'], equals: keyFilters?.id } } : {},
          keyFilters?.fromMe ? { key: { path: ['fromMe'], equals: keyFilters?.fromMe } } : {},
          keyFilters?.remoteJid ? { key: { path: ['remoteJid'], equals: keyFilters?.remoteJid } } : {},
          keyFilters?.participants ? { key: { path: ['participants'], equals: keyFilters?.participants } } : {},
        ],
      },
    });

    if (!query?.offset) {
      query.offset = 50;
    }

    if (!query?.page) {
      query.page = 1;
    }

    const messages = await this.prismaRepository.message.findMany({
      where: {
        instanceId: this.instanceId,
        id: query?.where?.id,
        source: query?.where?.source,
        messageType: query?.where?.messageType,
        ...timestampFilter,
        AND: [
          keyFilters?.id ? { key: { path: ['id'], equals: keyFilters?.id } } : {},
          keyFilters?.fromMe ? { key: { path: ['fromMe'], equals: keyFilters?.fromMe } } : {},
          keyFilters?.remoteJid ? { key: { path: ['remoteJid'], equals: keyFilters?.remoteJid } } : {},
          keyFilters?.participants ? { key: { path: ['participants'], equals: keyFilters?.participants } } : {},
        ],
      },
      orderBy: {
        messageTimestamp: 'desc',
      },
      skip: query.offset * (query?.page === 1 ? 0 : (query?.page as number) - 1),
      take: query.offset,
      select: {
        id: true,
        key: true,
        pushName: true,
        messageType: true,
        message: true,
        messageTimestamp: true,
        instanceId: true,
        source: true,
        contextInfo: true,
        MessageUpdate: {
          select: {
            status: true,
          },
        },
      },
    });

    return {
      messages: {
        total: count,
        pages: Math.ceil(count / query.offset),
        currentPage: query.page,
        records: messages,
      },
    };
  }

  public async fetchStatusMessage(query: any) {
    return await this.prismaRepository.messageUpdate.findMany({
      where: {
        instanceId: this.instanceId,
        remoteJid: query.where?.remoteJid,
        keyId: query.where?.id,
      },
      skip: query.offset * (query?.page === 1 ? 0 : (query?.page as number) - 1),
      take: query.offset,
    });
  }

  public async fetchChats(query: any) {
    const remoteJid = query?.where?.remoteJid
      ? query?.where?.remoteJid.includes('@')
        ? query.where?.remoteJid
        : createJid(query.where?.remoteJid)
      : null;

    const where = {
      instanceId: this.instanceId,
    };

    if (remoteJid) {
      where['remoteJid'] = remoteJid;
    }

    const timestampFilter =
      query?.where?.messageTimestamp?.gte && query?.where?.messageTimestamp?.lte
        ? Prisma.sql`
          AND "Message"."messageTimestamp" >= ${Math.floor(new Date(query.where.messageTimestamp.gte).getTime() / 1000)}
          AND "Message"."messageTimestamp" <= ${Math.floor(new Date(query.where.messageTimestamp.lte).getTime() / 1000)}`
        : Prisma.sql``;

    const results = await this.prismaRepository.$queryRaw`
        WITH rankedMessages AS (
          SELECT DISTINCT ON ("Contact"."remoteJid")
            "Contact"."id",
            "Contact"."remoteJid",
            "Contact"."pushName",
            "Contact"."profilePicUrl",
            COALESCE(
              to_timestamp("Message"."messageTimestamp"::double precision), 
              "Contact"."updatedAt"
            ) as "updatedAt",
            "Chat"."createdAt" as "windowStart",
            "Chat"."createdAt" + INTERVAL '24 hours' as "windowExpires",
            CASE 
              WHEN "Chat"."createdAt" + INTERVAL '24 hours' > NOW() THEN true 
              ELSE false 
            END as "windowActive",
            "Message"."id" AS lastMessageId,
            "Message"."key" AS lastMessage_key,
            "Message"."pushName" AS lastMessagePushName,
            "Message"."participant" AS lastMessageParticipant,
            "Message"."messageType" AS lastMessageMessageType,
            "Message"."message" AS lastMessageMessage,
            "Message"."contextInfo" AS lastMessageContextInfo,
            "Message"."source" AS lastMessageSource,
            "Message"."messageTimestamp" AS lastMessageMessageTimestamp,
            "Message"."instanceId" AS lastMessageInstanceId,
            "Message"."sessionId" AS lastMessageSessionId,
            "Message"."status" AS lastMessageStatus
          FROM "Contact"
          INNER JOIN "Message" ON "Message"."key"->>'remoteJid' = "Contact"."remoteJid"
          LEFT JOIN "Chat" ON "Chat"."remoteJid" = "Contact"."remoteJid" 
            AND "Chat"."instanceId" = "Contact"."instanceId"
          WHERE 
            "Contact"."instanceId" = ${this.instanceId}
            AND "Message"."instanceId" = ${this.instanceId}
            ${remoteJid ? Prisma.sql`AND "Contact"."remoteJid" = ${remoteJid}` : Prisma.sql``}
            ${timestampFilter}
          ORDER BY 
            "Contact"."remoteJid",
            "Message"."messageTimestamp" DESC
        )
        SELECT * FROM rankedMessages
        ORDER BY "updatedAt" DESC NULLS LAST;
    `;

    if (results && isArray(results) && results.length > 0) {
      const mappedResults = results.map((contact) => {
        const lastMessage = contact.lastMessageId
          ? {
              id: contact.lastMessageId,
              key: contact.lastMessageKey,
              pushName: contact.lastMessagePushName,
              participant: contact.lastMessageParticipant,
              messageType: contact.lastMessageMessageType,
              message: contact.lastMessageMessage,
              contextInfo: contact.lastMessageContextInfo,
              source: contact.lastMessageSource,
              messageTimestamp: contact.lastMessageMessageTimestamp,
              instanceId: contact.lastMessageInstanceId,
              sessionId: contact.lastMessageSessionId,
              status: contact.lastMessageStatus,
            }
          : undefined;

        return {
          id: contact.id,
          remoteJid: contact.remoteJid,
          pushName: contact.pushName,
          profilePicUrl: contact.profilePicUrl,
          updatedAt: contact.updatedAt,
          windowStart: contact.windowStart,
          windowExpires: contact.windowExpires,
          windowActive: contact.windowActive,
          lastMessage: lastMessage ? this.cleanMessageData(lastMessage) : undefined,
        };
      });

      return mappedResults;
    }

    return [];
  }
}



================================================
FILE: src/api/services/monitor.service.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { ProviderFiles } from '@api/provider/sessions';
import { PrismaRepository } from '@api/repository/repository.service';
import { channelController } from '@api/server.module';
import { Events, Integration } from '@api/types/wa.types';
import { CacheConf, Chatwoot, ConfigService, Database, DelInstance, ProviderSession } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { INSTANCE_DIR, STORE_DIR } from '@config/path.config';
import { NotFoundException } from '@exceptions';
import { execSync } from 'child_process';
import EventEmitter2 from 'eventemitter2';
import { rmSync } from 'fs';
import { join } from 'path';

import { CacheService } from './cache.service';

export class WAMonitoringService {
  constructor(
    private readonly eventEmitter: EventEmitter2,
    private readonly configService: ConfigService,
    private readonly prismaRepository: PrismaRepository,
    private readonly providerFiles: ProviderFiles,
    private readonly cache: CacheService,
    private readonly chatwootCache: CacheService,
    private readonly baileysCache: CacheService,
  ) {
    this.removeInstance();
    this.noConnection();

    Object.assign(this.db, configService.get<Database>('DATABASE'));
    Object.assign(this.redis, configService.get<CacheConf>('CACHE'));
  }

  private readonly db: Partial<Database> = {};
  private readonly redis: Partial<CacheConf> = {};

  private readonly logger = new Logger('WAMonitoringService');
  public readonly waInstances: Record<string, any> = {};

  private readonly providerSession = Object.freeze(this.configService.get<ProviderSession>('PROVIDER'));

  public delInstanceTime(instance: string) {
    const time = this.configService.get<DelInstance>('DEL_INSTANCE');
    if (typeof time === 'number' && time > 0) {
      setTimeout(
        async () => {
          if (this.waInstances[instance]?.connectionStatus?.state !== 'open') {
            if (this.waInstances[instance]?.connectionStatus?.state === 'connecting') {
              if ((await this.waInstances[instance].integration) === Integration.WHATSAPP_BAILEYS) {
                await this.waInstances[instance]?.client?.logout('Log out instance: ' + instance);
                this.waInstances[instance]?.client?.ws?.close();
                this.waInstances[instance]?.client?.end(undefined);
              }
              this.eventEmitter.emit('remove.instance', instance, 'inner');
            } else {
              this.eventEmitter.emit('remove.instance', instance, 'inner');
            }
          }
        },
        1000 * 60 * time,
      );
    }
  }

  public async instanceInfo(instanceNames?: string[]): Promise<any> {
    if (instanceNames && instanceNames.length > 0) {
      const inexistentInstances = instanceNames ? instanceNames.filter((instance) => !this.waInstances[instance]) : [];

      if (inexistentInstances.length > 0) {
        throw new NotFoundException(
          `Instance${inexistentInstances.length > 1 ? 's' : ''} "${inexistentInstances.join(', ')}" not found`,
        );
      }
    }

    const clientName = this.configService.get<Database>('DATABASE').CONNECTION.CLIENT_NAME;

    const where =
      instanceNames && instanceNames.length > 0
        ? {
            name: {
              in: instanceNames,
            },
            clientName,
          }
        : { clientName };

    const instances = await this.prismaRepository.instance.findMany({
      where,
      include: {
        Chatwoot: true,
        Proxy: true,
        Rabbitmq: true,
        Sqs: true,
        Websocket: true,
        Setting: true,
        _count: {
          select: {
            Message: true,
            Contact: true,
            Chat: true,
          },
        },
      },
    });

    return instances;
  }

  public async instanceInfoById(instanceId?: string, number?: string) {
    let instanceName: string;
    if (instanceId) {
      instanceName = await this.prismaRepository.instance.findFirst({ where: { id: instanceId } }).then((r) => r?.name);
      if (!instanceName) {
        throw new NotFoundException(`Instance "${instanceId}" not found`);
      }
    } else if (number) {
      instanceName = await this.prismaRepository.instance.findFirst({ where: { number } }).then((r) => r?.name);
      if (!instanceName) {
        throw new NotFoundException(`Instance "${number}" not found`);
      }
    }

    if (!instanceName) {
      throw new NotFoundException(`Instance "${instanceId}" not found`);
    }

    if (instanceName && !this.waInstances[instanceName]) {
      throw new NotFoundException(`Instance "${instanceName}" not found`);
    }

    const instanceNames = instanceName ? [instanceName] : null;

    return this.instanceInfo(instanceNames);
  }

  public async cleaningUp(instanceName: string) {
    let instanceDbId: string;
    if (this.db.SAVE_DATA.INSTANCE) {
      const findInstance = await this.prismaRepository.instance.findFirst({
        where: { name: instanceName },
      });

      if (findInstance) {
        const instance = await this.prismaRepository.instance.update({
          where: { name: instanceName },
          data: { connectionStatus: 'close' },
        });

        rmSync(join(INSTANCE_DIR, instance.id), { recursive: true, force: true });

        instanceDbId = instance.id;
        await this.prismaRepository.session.deleteMany({ where: { sessionId: instance.id } });
      }
    }

    if (this.redis.REDIS.ENABLED && this.redis.REDIS.SAVE_INSTANCES) {
      await this.cache.delete(instanceName);
      if (instanceDbId) {
        await this.cache.delete(instanceDbId);
      }
    }

    if (this.providerSession?.ENABLED) {
      await this.providerFiles.removeSession(instanceName);
    }
  }

  public async cleaningStoreData(instanceName: string) {
    if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED) {
      execSync(`rm -rf ${join(STORE_DIR, 'chatwoot', instanceName + '*')}`);
    }

    const instance = await this.prismaRepository.instance.findFirst({
      where: { name: instanceName },
    });

    if (!instance) return;

    rmSync(join(INSTANCE_DIR, instance.id), { recursive: true, force: true });

    await this.prismaRepository.session.deleteMany({ where: { sessionId: instance.id } });

    await this.prismaRepository.chat.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.contact.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.messageUpdate.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.message.deleteMany({ where: { instanceId: instance.id } });

    await this.prismaRepository.webhook.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.chatwoot.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.proxy.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.rabbitmq.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.sqs.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.integrationSession.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.typebot.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.websocket.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.setting.deleteMany({ where: { instanceId: instance.id } });
    await this.prismaRepository.label.deleteMany({ where: { instanceId: instance.id } });

    await this.prismaRepository.instance.delete({ where: { name: instanceName } });
  }

  public async loadInstance() {
    try {
      if (this.providerSession?.ENABLED) {
        await this.loadInstancesFromProvider();
      } else if (this.db.SAVE_DATA.INSTANCE) {
        await this.loadInstancesFromDatabasePostgres();
      } else if (this.redis.REDIS.ENABLED && this.redis.REDIS.SAVE_INSTANCES) {
        await this.loadInstancesFromRedis();
      }
    } catch (error) {
      this.logger.error(error);
    }
  }

  public async saveInstance(data: any) {
    try {
      const clientName = await this.configService.get<Database>('DATABASE').CONNECTION.CLIENT_NAME;
      await this.prismaRepository.instance.create({
        data: {
          id: data.instanceId,
          name: data.instanceName,
          ownerJid: data.ownerJid,
          profileName: data.profileName,
          profilePicUrl: data.profilePicUrl,
          connectionStatus:
            data.integration && data.integration === Integration.WHATSAPP_BAILEYS ? 'close' : (data.status ?? 'open'),
          number: data.number,
          integration: data.integration || Integration.WHATSAPP_BAILEYS,
          token: data.hash,
          clientName: clientName,
          businessId: data.businessId,
        },
      });
    } catch (error) {
      this.logger.error(error);
    }
  }

  public deleteInstance(instanceName: string) {
    try {
      this.eventEmitter.emit('remove.instance', instanceName, 'inner');
    } catch (error) {
      this.logger.error(error);
    }
  }

  private async setInstance(instanceData: InstanceDto) {
    const instance = channelController.init(instanceData, {
      configService: this.configService,
      eventEmitter: this.eventEmitter,
      prismaRepository: this.prismaRepository,
      cache: this.cache,
      chatwootCache: this.chatwootCache,
      baileysCache: this.baileysCache,
      providerFiles: this.providerFiles,
    });

    if (!instance) return;

    instance.setInstance({
      instanceId: instanceData.instanceId,
      instanceName: instanceData.instanceName,
      integration: instanceData.integration,
      token: instanceData.token,
      number: instanceData.number,
      businessId: instanceData.businessId,
    });

    await instance.connectToWhatsapp();

    this.waInstances[instanceData.instanceName] = instance;
  }

  private async loadInstancesFromRedis() {
    const keys = await this.cache.keys();

    if (keys?.length > 0) {
      await Promise.all(
        keys.map(async (k) => {
          const instanceData = await this.prismaRepository.instance.findUnique({
            where: { id: k.split(':')[1] },
          });

          if (!instanceData) {
            return;
          }

          const instance = {
            instanceId: k.split(':')[1],
            instanceName: k.split(':')[2],
            integration: instanceData.integration,
            token: instanceData.token,
            number: instanceData.number,
            businessId: instanceData.businessId,
          };

          this.setInstance(instance);
        }),
      );
    }
  }

  private async loadInstancesFromDatabasePostgres() {
    const clientName = await this.configService.get<Database>('DATABASE').CONNECTION.CLIENT_NAME;

    const instances = await this.prismaRepository.instance.findMany({
      where: { clientName: clientName },
    });

    if (instances.length === 0) {
      return;
    }

    await Promise.all(
      instances.map(async (instance) => {
        this.setInstance({
          instanceId: instance.id,
          instanceName: instance.name,
          integration: instance.integration,
          token: instance.token,
          number: instance.number,
          businessId: instance.businessId,
        });
      }),
    );
  }

  private async loadInstancesFromProvider() {
    const [instances] = await this.providerFiles.allInstances();

    if (!instances?.data) {
      return;
    }

    await Promise.all(
      instances?.data?.map(async (instanceId: string) => {
        const instance = await this.prismaRepository.instance.findUnique({
          where: { id: instanceId },
        });

        this.setInstance({
          instanceId: instance.id,
          instanceName: instance.name,
          integration: instance.integration,
          token: instance.token,
          businessId: instance.businessId,
        });
      }),
    );
  }

  private removeInstance() {
    this.eventEmitter.on('remove.instance', async (instanceName: string) => {
      try {
        await this.waInstances[instanceName]?.sendDataWebhook(Events.REMOVE_INSTANCE, null);

        this.cleaningUp(instanceName);
        this.cleaningStoreData(instanceName);
      } finally {
        this.logger.warn(`Instance "${instanceName}" - REMOVED`);
      }

      try {
        delete this.waInstances[instanceName];
      } catch (error) {
        this.logger.error(error);
      }
    });
    this.eventEmitter.on('logout.instance', async (instanceName: string) => {
      try {
        await this.waInstances[instanceName]?.sendDataWebhook(Events.LOGOUT_INSTANCE, null);

        if (this.configService.get<Chatwoot>('CHATWOOT').ENABLED) {
          this.waInstances[instanceName]?.clearCacheChatwoot();
        }

        this.cleaningUp(instanceName);
      } finally {
        this.logger.warn(`Instance "${instanceName}" - LOGOUT`);
      }
    });
  }

  private noConnection() {
    this.eventEmitter.on('no.connection', async (instanceName) => {
      try {
        await this.waInstances[instanceName]?.client?.logout('Log out instance: ' + instanceName);

        this.waInstances[instanceName]?.client?.ws?.close();

        this.waInstances[instanceName].instance.qrcode = { count: 0 };
        this.waInstances[instanceName].stateConnection.state = 'close';
      } catch (error) {
        this.logger.error({
          localError: 'noConnection',
          warn: 'Error deleting instance from memory.',
          error,
        });
      } finally {
        this.logger.warn(`Instance "${instanceName}" - NOT CONNECTION`);
      }
    });
  }
}



================================================
FILE: src/api/services/proxy.service.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { ProxyDto } from '@api/dto/proxy.dto';
import { Logger } from '@config/logger.config';
import { Proxy } from '@prisma/client';

import { WAMonitoringService } from './monitor.service';

export class ProxyService {
  constructor(private readonly waMonitor: WAMonitoringService) {}

  private readonly logger = new Logger('ProxyService');

  public create(instance: InstanceDto, data: ProxyDto) {
    this.waMonitor.waInstances[instance.instanceName].setProxy(data);

    return { proxy: { ...instance, proxy: data } };
  }

  public async find(instance: InstanceDto): Promise<Proxy> {
    try {
      const result = await this.waMonitor.waInstances[instance.instanceName].findProxy();

      if (Object.keys(result).length === 0) {
        throw new Error('Proxy not found');
      }

      return result;
    } catch (error) {
      return null;
    }
  }
}



================================================
FILE: src/api/services/settings.service.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { SettingsDto } from '@api/dto/settings.dto';
import { Logger } from '@config/logger.config';

import { WAMonitoringService } from './monitor.service';

export class SettingsService {
  constructor(private readonly waMonitor: WAMonitoringService) {}

  private readonly logger = new Logger('SettingsService');

  public async create(instance: InstanceDto, data: SettingsDto) {
    await this.waMonitor.waInstances[instance.instanceName].setSettings(data);

    return { settings: { ...instance, settings: data } };
  }

  public async find(instance: InstanceDto): Promise<SettingsDto> {
    try {
      const result = await this.waMonitor.waInstances[instance.instanceName].findSettings();

      if (Object.keys(result).length === 0) {
        throw new Error('Settings not found');
      }

      return result;
    } catch (error) {
      return null;
    }
  }
}



================================================
FILE: src/api/services/template.service.ts
================================================
import { InstanceDto } from '@api/dto/instance.dto';
import { TemplateDto } from '@api/dto/template.dto';
import { PrismaRepository } from '@api/repository/repository.service';
import { ConfigService, WaBusiness } from '@config/env.config';
import { Logger } from '@config/logger.config';
import axios from 'axios';

import { WAMonitoringService } from './monitor.service';

export class TemplateService {
  constructor(
    private readonly waMonitor: WAMonitoringService,
    public readonly prismaRepository: PrismaRepository,
    private readonly configService: ConfigService,
  ) {}

  private readonly logger = new Logger('TemplateService');

  private businessId: string;
  private token: string;

  public async find(instance: InstanceDto) {
    const getInstance = await this.waMonitor.waInstances[instance.instanceName].instance;

    if (!getInstance) {
      throw new Error('Instance not found');
    }

    this.businessId = getInstance.businessId;
    this.token = getInstance.token;

    const response = await this.requestTemplate({}, 'GET');

    if (!response) {
      throw new Error('Error to create template');
    }

    return response.data;
  }

  public async create(instance: InstanceDto, data: TemplateDto) {
    try {
      const getInstance = await this.waMonitor.waInstances[instance.instanceName].instance;

      if (!getInstance) {
        throw new Error('Instance not found');
      }

      this.businessId = getInstance.businessId;
      this.token = getInstance.token;

      const postData = {
        name: data.name,
        category: data.category,
        allow_category_change: data.allowCategoryChange,
        language: data.language,
        components: data.components,
      };

      const response = await this.requestTemplate(postData, 'POST');

      if (!response || response.error) {
        throw new Error('Error to create template');
      }

      const template = await this.prismaRepository.template.create({
        data: {
          templateId: response.id,
          name: data.name,
          template: response,
          webhookUrl: data.webhookUrl,
          instanceId: getInstance.id,
        },
      });

      return template;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Error to create template');
    }
  }

  private async requestTemplate(data: any, method: string) {
    try {
      let urlServer = this.configService.get<WaBusiness>('WA_BUSINESS').URL;
      const version = this.configService.get<WaBusiness>('WA_BUSINESS').VERSION;
      urlServer = `${urlServer}/${version}/${this.businessId}/message_templates`;
      const headers = { 'Content-Type': 'application/json', Authorization: `Bearer ${this.token}` };
      if (method === 'GET') {
        const result = await axios.get(urlServer, { headers });
        return result.data;
      } else if (method === 'POST') {
        const result = await axios.post(urlServer, data, { headers });
        return result.data;
      }
    } catch (e) {
      this.logger.error(e.response.data);
      return e.response.data.error;
    }
  }
}



================================================
FILE: src/api/types/wa.types.ts
================================================
/* eslint-disable @typescript-eslint/no-namespace */
import { JsonValue } from '@prisma/client/runtime/library';
import { AuthenticationState, WAConnectionState } from 'baileys';

export enum Events {
  APPLICATION_STARTUP = 'application.startup',
  INSTANCE_CREATE = 'instance.create',
  INSTANCE_DELETE = 'instance.delete',
  QRCODE_UPDATED = 'qrcode.updated',
  CONNECTION_UPDATE = 'connection.update',
  STATUS_INSTANCE = 'status.instance',
  MESSAGES_SET = 'messages.set',
  MESSAGES_UPSERT = 'messages.upsert',
  MESSAGES_EDITED = 'messages.edited',
  MESSAGES_UPDATE = 'messages.update',
  MESSAGES_DELETE = 'messages.delete',
  SEND_MESSAGE = 'send.message',
  CONTACTS_SET = 'contacts.set',
  CONTACTS_UPSERT = 'contacts.upsert',
  CONTACTS_UPDATE = 'contacts.update',
  PRESENCE_UPDATE = 'presence.update',
  CHATS_SET = 'chats.set',
  CHATS_UPDATE = 'chats.update',
  CHATS_UPSERT = 'chats.upsert',
  CHATS_DELETE = 'chats.delete',
  GROUPS_UPSERT = 'groups.upsert',
  GROUPS_UPDATE = 'groups.update',
  GROUP_PARTICIPANTS_UPDATE = 'group-participants.update',
  CALL = 'call',
  TYPEBOT_START = 'typebot.start',
  TYPEBOT_CHANGE_STATUS = 'typebot.change-status',
  LABELS_EDIT = 'labels.edit',
  LABELS_ASSOCIATION = 'labels.association',
  CREDS_UPDATE = 'creds.update',
  MESSAGING_HISTORY_SET = 'messaging-history.set',
  REMOVE_INSTANCE = 'remove.instance',
  LOGOUT_INSTANCE = 'logout.instance',
}

export declare namespace wa {
  export type QrCode = {
    count?: number;
    pairingCode?: string;
    base64?: string;
    code?: string;
  };

  export type Instance = {
    id?: string;
    qrcode?: QrCode;
    pairingCode?: string;
    authState?: { state: AuthenticationState; saveCreds: () => void };
    name?: string;
    wuid?: string;
    profileName?: string;
    profilePictureUrl?: string;
    token?: string;
    number?: string;
    integration?: string;
    businessId?: string;
  };

  export type LocalChatwoot = {
    enabled?: boolean;
    accountId?: string;
    token?: string;
    url?: string;
    nameInbox?: string;
    signMsg?: boolean;
    signDelimiter?: string;
    number?: string;
    reopenConversation?: boolean;
    conversationPending?: boolean;
    mergeBrazilContacts?: boolean;
    importContacts?: boolean;
    importMessages?: boolean;
    daysLimitImportMessages?: number;
  };

  export type LocalSettings = {
    rejectCall?: boolean;
    msgCall?: string;
    groupsIgnore?: boolean;
    alwaysOnline?: boolean;
    readMessages?: boolean;
    readStatus?: boolean;
    syncFullHistory?: boolean;
    wavoipToken?: string;
  };

  export type LocalEvent = {
    enabled?: boolean;
    events?: JsonValue;
  };

  export type LocalWebHook = LocalEvent & {
    url?: string;
    headers?: JsonValue;
    webhookByEvents?: boolean;
    webhookBase64?: boolean;
  };

  export type LocalPusher = LocalEvent & {
    appId?: string;
    key?: string;
    secret?: string;
    cluster?: string;
    useTLS?: boolean;
  };

  type Session = {
    remoteJid?: string;
    sessionId?: string;
    createdAt?: number;
  };

  export type LocalProxy = {
    enabled?: boolean;
    host?: string;
    port?: string;
    protocol?: string;
    username?: string;
    password?: string;
  };

  export type StateConnection = {
    instance?: string;
    state?: WAConnectionState | 'refused';
    statusReason?: number;
  };

  export type StatusMessage = 'ERROR' | 'PENDING' | 'SERVER_ACK' | 'DELIVERY_ACK' | 'READ' | 'DELETED' | 'PLAYED';
}

export const TypeMediaMessage = [
  'imageMessage',
  'documentMessage',
  'audioMessage',
  'videoMessage',
  'stickerMessage',
  'ptvMessage',
];

export const MessageSubtype = [
  'ephemeralMessage',
  'documentWithCaptionMessage',
  'viewOnceMessage',
  'viewOnceMessageV2',
];

export const Integration = {
  WHATSAPP_BUSINESS: 'WHATSAPP-BUSINESS',
  WHATSAPP_BAILEYS: 'WHATSAPP-BAILEYS',
  EVOLUTION: 'EVOLUTION',
};



================================================
FILE: src/cache/cacheengine.ts
================================================
import { ICache } from '@api/abstract/abstract.cache';
import { CacheConf, ConfigService } from '@config/env.config';
import { Logger } from '@config/logger.config';

import { LocalCache } from './localcache';
import { RedisCache } from './rediscache';

const logger = new Logger('CacheEngine');

export class CacheEngine {
  private engine: ICache;

  constructor(
    private readonly configService: ConfigService,
    module: string,
  ) {
    const cacheConf = configService.get<CacheConf>('CACHE');

    if (cacheConf?.REDIS?.ENABLED && cacheConf?.REDIS?.URI !== '') {
      logger.verbose(`RedisCache initialized for ${module}`);
      this.engine = new RedisCache(configService, module);
    } else if (cacheConf?.LOCAL?.ENABLED) {
      logger.verbose(`LocalCache initialized for ${module}`);
      this.engine = new LocalCache(configService, module);
    }
  }

  public getEngine() {
    return this.engine;
  }
}



================================================
FILE: src/cache/localcache.ts
================================================
import { ICache } from '@api/abstract/abstract.cache';
import { CacheConf, CacheConfLocal, ConfigService } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { BufferJSON } from 'baileys';
import NodeCache from 'node-cache';

export class LocalCache implements ICache {
  private readonly logger = new Logger('LocalCache');
  private conf: CacheConfLocal;
  static localCache = new NodeCache();

  constructor(
    private readonly configService: ConfigService,
    private readonly module: string,
  ) {
    this.conf = this.configService.get<CacheConf>('CACHE')?.LOCAL;
  }

  async get(key: string): Promise<any> {
    return LocalCache.localCache.get(this.buildKey(key));
  }

  async set(key: string, value: any, ttl?: number) {
    return LocalCache.localCache.set(this.buildKey(key), value, ttl || this.conf.TTL);
  }

  async has(key: string) {
    return LocalCache.localCache.has(this.buildKey(key));
  }

  async delete(key: string) {
    return LocalCache.localCache.del(this.buildKey(key));
  }

  async deleteAll(appendCriteria?: string) {
    const keys = await this.keys(appendCriteria);
    if (!keys?.length) {
      return 0;
    }

    return LocalCache.localCache.del(keys);
  }

  async keys(appendCriteria?: string) {
    const filter = `${this.buildKey('')}${appendCriteria ? `${appendCriteria}:` : ''}`;

    return LocalCache.localCache.keys().filter((key) => key.substring(0, filter.length) === filter);
  }

  buildKey(key: string) {
    return `${this.module}:${key}`;
  }

  async hGet(key: string, field: string) {
    try {
      const data = LocalCache.localCache.get(this.buildKey(key)) as Object;

      if (data && field in data) {
        return JSON.parse(data[field], BufferJSON.reviver);
      }

      return null;
    } catch (error) {
      this.logger.error(error);
    }
  }

  async hSet(key: string, field: string, value: any) {
    try {
      const json = JSON.stringify(value, BufferJSON.replacer);

      let hash = LocalCache.localCache.get(this.buildKey(key));

      if (!hash) {
        hash = {};
      }

      hash[field] = json;
      LocalCache.localCache.set(this.buildKey(key), hash);
    } catch (error) {
      this.logger.error(error);
    }
  }

  async hDelete(key: string, field: string) {
    try {
      const data = LocalCache.localCache.get(this.buildKey(key)) as Object;

      if (data && field in data) {
        delete data[field];
        LocalCache.localCache.set(this.buildKey(key), data);
        return 1;
      }

      return 0;
    } catch (error) {
      this.logger.error(error);
    }
  }
}



================================================
FILE: src/cache/rediscache.client.ts
================================================
import { CacheConf, CacheConfRedis, configService } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { createClient, RedisClientType } from 'redis';

class Redis {
  private logger = new Logger('Redis');
  private client: RedisClientType = null;
  private conf: CacheConfRedis;
  private connected = false;

  constructor() {
    this.conf = configService.get<CacheConf>('CACHE')?.REDIS;
  }

  getConnection(): RedisClientType {
    if (this.connected) {
      return this.client;
    } else {
      this.client = createClient({
        url: this.conf.URI,
      });

      this.client.on('connect', () => {
        this.logger.verbose('redis connecting');
      });

      this.client.on('ready', () => {
        this.logger.verbose('redis ready');
        this.connected = true;
      });

      this.client.on('error', () => {
        this.logger.error('redis disconnected');
        this.connected = false;
      });

      this.client.on('end', () => {
        this.logger.verbose('redis connection ended');
        this.connected = false;
      });

      try {
        this.client.connect();
        this.connected = true;
      } catch (e) {
        this.connected = false;
        this.logger.error('redis connect exception caught: ' + e);
        return null;
      }

      return this.client;
    }
  }
}

export const redisClient = new Redis();



================================================
FILE: src/cache/rediscache.ts
================================================
import { ICache } from '@api/abstract/abstract.cache';
import { CacheConf, CacheConfRedis, ConfigService } from '@config/env.config';
import { Logger } from '@config/logger.config';
import { BufferJSON } from 'baileys';
import { RedisClientType } from 'redis';

import { redisClient } from './rediscache.client';

export class RedisCache implements ICache {
  private readonly logger = new Logger('RedisCache');
  private client: RedisClientType;
  private conf: CacheConfRedis;

  constructor(
    private readonly configService: ConfigService,
    private readonly module: string,
  ) {
    this.conf = this.configService.get<CacheConf>('CACHE')?.REDIS;
    this.client = redisClient.getConnection();
  }
  async get(key: string): Promise<any> {
    try {
      return JSON.parse(await this.client.get(this.buildKey(key)));
    } catch (error) {
      this.logger.error(error);
    }
  }

  async hGet(key: string, field: string) {
    try {
      const data = await this.client.hGet(this.buildKey(key), field);

      if (data) {
        return JSON.parse(data, BufferJSON.reviver);
      }

      return null;
    } catch (error) {
      this.logger.error(error);
    }
  }

  async set(key: string, value: any, ttl?: number) {
    try {
      await this.client.setEx(this.buildKey(key), ttl || this.conf?.TTL, JSON.stringify(value));
    } catch (error) {
      this.logger.error(error);
    }
  }

  async hSet(key: string, field: string, value: any) {
    try {
      const json = JSON.stringify(value, BufferJSON.replacer);

      await this.client.hSet(this.buildKey(key), field, json);
    } catch (error) {
      this.logger.error(error);
    }
  }

  async has(key: string) {
    try {
      return (await this.client.exists(this.buildKey(key))) > 0;
    } catch (error) {
      this.logger.error(error);
    }
  }

  async delete(key: string) {
    try {
      return await this.client.del(this.buildKey(key));
    } catch (error) {
      this.logger.error(error);
    }
  }

  async hDelete(key: string, field: string) {
    try {
      return await this.client.hDel(this.buildKey(key), field);
    } catch (error) {
      this.logger.error(error);
    }
  }

  async deleteAll(appendCriteria?: string) {
    try {
      const keys = await this.keys(appendCriteria);
      if (!keys?.length) {
        return 0;
      }

      return await this.client.del(keys);
    } catch (error) {
      this.logger.error(error);
    }
  }

  async keys(appendCriteria?: string) {
    try {
      const match = `${this.buildKey('')}${appendCriteria ? `${appendCriteria}:` : ''}*`;
      const keys = [];
      for await (const key of this.client.scanIterator({
        MATCH: match,
        COUNT: 100,
      })) {
        keys.push(key);
      }

      return [...new Set(keys)];
    } catch (error) {
      this.logger.error(error);
    }
  }

  buildKey(key: string) {
    return `${this.conf?.PREFIX_KEY}:${this.module}:${key}`;
  }
}



================================================
FILE: src/config/env.config.ts
================================================
import { isBooleanString } from 'class-validator';
import dotenv from 'dotenv';

dotenv.config();

export type HttpServer = {
  TYPE: 'http' | 'https';
  PORT: number;
  URL: string;
  DISABLE_DOCS: boolean;
  DISABLE_MANAGER: boolean;
};

export type HttpMethods = 'POST' | 'GET' | 'PUT' | 'DELETE';
export type Cors = {
  ORIGIN: string[];
  METHODS: HttpMethods[];
  CREDENTIALS: boolean;
};

export type LogBaileys = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace';

export type LogLevel = 'ERROR' | 'WARN' | 'DEBUG' | 'INFO' | 'LOG' | 'VERBOSE' | 'DARK' | 'WEBHOOKS' | 'WEBSOCKET';

export type Log = {
  LEVEL: LogLevel[];
  COLOR: boolean;
  BAILEYS: LogBaileys;
};

export type ProviderSession = {
  ENABLED: boolean;
  HOST: string;
  PORT: string;
  PREFIX: string;
};

export type SaveData = {
  INSTANCE: boolean;
  HISTORIC: boolean;
  NEW_MESSAGE: boolean;
  MESSAGE_UPDATE: boolean;
  CONTACTS: boolean;
  CHATS: boolean;
  LABELS: boolean;
  IS_ON_WHATSAPP: boolean;
  IS_ON_WHATSAPP_DAYS: number;
};

export type DBConnection = {
  URI: string;
  CLIENT_NAME: string;
};
export type Database = {
  CONNECTION: DBConnection;
  PROVIDER: string;
  SAVE_DATA: SaveData;
  DELETE_DATA: DeleteData;
};

export type DeleteData = {
  LOGICAL_MESSAGE_DELETE: boolean;
};
export type EventsRabbitmq = {
  APPLICATION_STARTUP: boolean;
  INSTANCE_CREATE: boolean;
  INSTANCE_DELETE: boolean;
  QRCODE_UPDATED: boolean;
  MESSAGES_SET: boolean;
  MESSAGES_UPSERT: boolean;
  MESSAGES_EDITED: boolean;
  MESSAGES_UPDATE: boolean;
  MESSAGES_DELETE: boolean;
  SEND_MESSAGE: boolean;
  CONTACTS_SET: boolean;
  CONTACTS_UPDATE: boolean;
  CONTACTS_UPSERT: boolean;
  PRESENCE_UPDATE: boolean;
  CHATS_SET: boolean;
  CHATS_UPDATE: boolean;
  CHATS_DELETE: boolean;
  CHATS_UPSERT: boolean;
  CONNECTION_UPDATE: boolean;
  LABELS_EDIT: boolean;
  LABELS_ASSOCIATION: boolean;
  GROUPS_UPSERT: boolean;
  GROUP_UPDATE: boolean;
  GROUP_PARTICIPANTS_UPDATE: boolean;
  CALL: boolean;
  TYPEBOT_START: boolean;
  TYPEBOT_CHANGE_STATUS: boolean;
};

export type Rabbitmq = {
  ENABLED: boolean;
  URI: string;
  EXCHANGE_NAME: string;
  GLOBAL_ENABLED: boolean;
  EVENTS: EventsRabbitmq;
  PREFIX_KEY: string;
};

export type Sqs = {
  ENABLED: boolean;
  ACCESS_KEY_ID: string;
  SECRET_ACCESS_KEY: string;
  ACCOUNT_ID: string;
  REGION: string;
};

export type Websocket = {
  ENABLED: boolean;
  GLOBAL_EVENTS: boolean;
};

export type WaBusiness = {
  TOKEN_WEBHOOK: string;
  URL: string;
  VERSION: string;
  LANGUAGE: string;
};

export type EventsWebhook = {
  APPLICATION_STARTUP: boolean;
  INSTANCE_CREATE: boolean;
  INSTANCE_DELETE: boolean;
  QRCODE_UPDATED: boolean;
  MESSAGES_SET: boolean;
  MESSAGES_UPSERT: boolean;
  MESSAGES_EDITED: boolean;
  MESSAGES_UPDATE: boolean;
  MESSAGES_DELETE: boolean;
  SEND_MESSAGE: boolean;
  CONTACTS_SET: boolean;
  CONTACTS_UPDATE: boolean;
  CONTACTS_UPSERT: boolean;
  PRESENCE_UPDATE: boolean;
  CHATS_SET: boolean;
  CHATS_UPDATE: boolean;
  CHATS_DELETE: boolean;
  CHATS_UPSERT: boolean;
  CONNECTION_UPDATE: boolean;
  LABELS_EDIT: boolean;
  LABELS_ASSOCIATION: boolean;
  GROUPS_UPSERT: boolean;
  GROUP_UPDATE: boolean;
  GROUP_PARTICIPANTS_UPDATE: boolean;
  CALL: boolean;
  TYPEBOT_START: boolean;
  TYPEBOT_CHANGE_STATUS: boolean;
  ERRORS: boolean;
  ERRORS_WEBHOOK: string;
};

export type EventsPusher = {
  APPLICATION_STARTUP: boolean;
  INSTANCE_CREATE: boolean;
  INSTANCE_DELETE: boolean;
  QRCODE_UPDATED: boolean;
  MESSAGES_SET: boolean;
  MESSAGES_UPSERT: boolean;
  MESSAGES_EDITED: boolean;
  MESSAGES_UPDATE: boolean;
  MESSAGES_DELETE: boolean;
  SEND_MESSAGE: boolean;
  CONTACTS_SET: boolean;
  CONTACTS_UPDATE: boolean;
  CONTACTS_UPSERT: boolean;
  PRESENCE_UPDATE: boolean;
  CHATS_SET: boolean;
  CHATS_UPDATE: boolean;
  CHATS_DELETE: boolean;
  CHATS_UPSERT: boolean;
  CONNECTION_UPDATE: boolean;
  LABELS_EDIT: boolean;
  LABELS_ASSOCIATION: boolean;
  GROUPS_UPSERT: boolean;
  GROUP_UPDATE: boolean;
  GROUP_PARTICIPANTS_UPDATE: boolean;
  CALL: boolean;
  TYPEBOT_START: boolean;
  TYPEBOT_CHANGE_STATUS: boolean;
};

export type ApiKey = { KEY: string };

export type Auth = {
  API_KEY: ApiKey;
  EXPOSE_IN_FETCH_INSTANCES: boolean;
};

export type DelInstance = number | boolean;

export type Language = string | 'en';

export type GlobalWebhook = {
  URL: string;
  ENABLED: boolean;
  WEBHOOK_BY_EVENTS: boolean;
};

export type GlobalPusher = {
  ENABLED: boolean;
  APP_ID: string;
  KEY: string;
  SECRET: string;
  CLUSTER: string;
  USE_TLS: boolean;
};

export type CacheConfRedis = {
  ENABLED: boolean;
  URI: string;
  PREFIX_KEY: string;
  TTL: number;
  SAVE_INSTANCES: boolean;
};
export type CacheConfLocal = {
  ENABLED: boolean;
  TTL: number;
};
export type SslConf = { PRIVKEY: string; FULLCHAIN: string };
export type Webhook = { GLOBAL?: GlobalWebhook; EVENTS: EventsWebhook };
export type Pusher = { ENABLED: boolean; GLOBAL?: GlobalPusher; EVENTS: EventsPusher };
export type ConfigSessionPhone = { CLIENT: string; NAME: string; VERSION: string };
export type QrCode = { LIMIT: number; COLOR: string };
export type Typebot = { ENABLED: boolean; API_VERSION: string; SEND_MEDIA_BASE64: boolean };
export type Chatwoot = {
  ENABLED: boolean;
  MESSAGE_DELETE: boolean;
  MESSAGE_READ: boolean;
  BOT_CONTACT: boolean;
  IMPORT: {
    DATABASE: {
      CONNECTION: {
        URI: string;
      };
    };
    PLACEHOLDER_MEDIA_MESSAGE: boolean;
  };
};
export type Openai = { ENABLED: boolean; API_KEY_GLOBAL?: string };
export type Dify = { ENABLED: boolean };

export type S3 = {
  ACCESS_KEY: string;
  SECRET_KEY: string;
  ENDPOINT: string;
  BUCKET_NAME: string;
  ENABLE: boolean;
  PORT?: number;
  USE_SSL?: boolean;
  REGION?: string;
};

export type CacheConf = { REDIS: CacheConfRedis; LOCAL: CacheConfLocal };
export type Production = boolean;

export interface Env {
  SERVER: HttpServer;
  CORS: Cors;
  SSL_CONF: SslConf;
  PROVIDER: ProviderSession;
  DATABASE: Database;
  RABBITMQ: Rabbitmq;
  SQS: Sqs;
  WEBSOCKET: Websocket;
  WA_BUSINESS: WaBusiness;
  LOG: Log;
  DEL_INSTANCE: DelInstance;
  DEL_TEMP_INSTANCES: boolean;
  LANGUAGE: Language;
  WEBHOOK: Webhook;
  PUSHER: Pusher;
  CONFIG_SESSION_PHONE: ConfigSessionPhone;
  QRCODE: QrCode;
  TYPEBOT: Typebot;
  CHATWOOT: Chatwoot;
  OPENAI: Openai;
  DIFY: Dify;
  CACHE: CacheConf;
  S3?: S3;
  AUTHENTICATION: Auth;
  PRODUCTION?: Production;
}

export type Key = keyof Env;

export class ConfigService {
  constructor() {
    this.loadEnv();
  }

  private env: Env;

  public get<T = any>(key: Key) {
    return this.env[key] as T;
  }

  private loadEnv() {
    this.env = this.envProcess();
    this.env.PRODUCTION = process.env?.NODE_ENV === 'PROD';
    if (process.env?.DOCKER_ENV === 'true') {
      this.env.SERVER.TYPE = process.env.SERVER_TYPE as 'http' | 'http';
      this.env.SERVER.PORT = Number.parseInt(process.env.SERVER_PORT) || 8080;
    }
  }

  private envProcess(): Env {
    return {
      SERVER: {
        TYPE: (process.env.SERVER_TYPE as 'http' | 'https') || 'http',
        PORT: Number.parseInt(process.env.SERVER_PORT) || 8080,
        URL: process.env.SERVER_URL,
        DISABLE_DOCS: process.env?.SERVER_DISABLE_DOCS === 'true',
        DISABLE_MANAGER: process.env?.SERVER_DISABLE_MANAGER === 'true',
      },
      CORS: {
        ORIGIN: process.env.CORS_ORIGIN?.split(',') || ['*'],
        METHODS:
          (process.env.CORS_METHODS?.split(',') as HttpMethods[]) ||
          (['POST', 'GET', 'PUT', 'DELETE'] as HttpMethods[]),
        CREDENTIALS: process.env?.CORS_CREDENTIALS === 'true',
      },
      SSL_CONF: {
        PRIVKEY: process.env?.SSL_CONF_PRIVKEY || '',
        FULLCHAIN: process.env?.SSL_CONF_FULLCHAIN || '',
      },
      PROVIDER: {
        ENABLED: process.env?.PROVIDER_ENABLED === 'true',
        HOST: process.env.PROVIDER_HOST,
        PORT: process.env?.PROVIDER_PORT || '5656',
        PREFIX: process.env?.PROVIDER_PREFIX || 'evolution',
      },
      DATABASE: {
        CONNECTION: {
          URI: process.env.DATABASE_CONNECTION_URI || '',
          CLIENT_NAME: process.env.DATABASE_CONNECTION_CLIENT_NAME || 'evolution',
        },
        PROVIDER: process.env.DATABASE_PROVIDER || 'postgresql',
        SAVE_DATA: {
          INSTANCE: process.env?.DATABASE_SAVE_DATA_INSTANCE === 'true',
          NEW_MESSAGE: process.env?.DATABASE_SAVE_DATA_NEW_MESSAGE === 'true',
          MESSAGE_UPDATE: process.env?.DATABASE_SAVE_MESSAGE_UPDATE === 'true',
          CONTACTS: process.env?.DATABASE_SAVE_DATA_CONTACTS === 'true',
          CHATS: process.env?.DATABASE_SAVE_DATA_CHATS === 'true',
          HISTORIC: process.env?.DATABASE_SAVE_DATA_HISTORIC === 'true',
          LABELS: process.env?.DATABASE_SAVE_DATA_LABELS === 'true',
          IS_ON_WHATSAPP: process.env?.DATABASE_SAVE_IS_ON_WHATSAPP === 'true',
          IS_ON_WHATSAPP_DAYS: Number.parseInt(process.env?.DATABASE_SAVE_IS_ON_WHATSAPP_DAYS ?? '7'),
        },
        DELETE_DATA: {
          LOGICAL_MESSAGE_DELETE: process.env?.DATABASE_DELETE_MESSAGE === 'true',
        },
      },
      RABBITMQ: {
        ENABLED: process.env?.RABBITMQ_ENABLED === 'true',
        GLOBAL_ENABLED: process.env?.RABBITMQ_GLOBAL_ENABLED === 'true',
        PREFIX_KEY: process.env?.RABBITMQ_PREFIX_KEY || 'evolution',
        EXCHANGE_NAME: process.env?.RABBITMQ_EXCHANGE_NAME || 'evolution_exchange',
        URI: process.env.RABBITMQ_URI || '',
        EVENTS: {
          APPLICATION_STARTUP: process.env?.RABBITMQ_EVENTS_APPLICATION_STARTUP === 'true',
          INSTANCE_CREATE: process.env?.RABBITMQ_EVENTS_INSTANCE_CREATE === 'true',
          INSTANCE_DELETE: process.env?.RABBITMQ_EVENTS_INSTANCE_DELETE === 'true',
          QRCODE_UPDATED: process.env?.RABBITMQ_EVENTS_QRCODE_UPDATED === 'true',
          MESSAGES_SET: process.env?.RABBITMQ_EVENTS_MESSAGES_SET === 'true',
          MESSAGES_UPSERT: process.env?.RABBITMQ_EVENTS_MESSAGES_UPSERT === 'true',
          MESSAGES_EDITED: process.env?.RABBITMQ_EVENTS_MESSAGES_EDITED === 'true',
          MESSAGES_UPDATE: process.env?.RABBITMQ_EVENTS_MESSAGES_UPDATE === 'true',
          MESSAGES_DELETE: process.env?.RABBITMQ_EVENTS_MESSAGES_DELETE === 'true',
          SEND_MESSAGE: process.env?.RABBITMQ_EVENTS_SEND_MESSAGE === 'true',
          CONTACTS_SET: process.env?.RABBITMQ_EVENTS_CONTACTS_SET === 'true',
          CONTACTS_UPDATE: process.env?.RABBITMQ_EVENTS_CONTACTS_UPDATE === 'true',
          CONTACTS_UPSERT: process.env?.RABBITMQ_EVENTS_CONTACTS_UPSERT === 'true',
          PRESENCE_UPDATE: process.env?.RABBITMQ_EVENTS_PRESENCE_UPDATE === 'true',
          CHATS_SET: process.env?.RABBITMQ_EVENTS_CHATS_SET === 'true',
          CHATS_UPDATE: process.env?.RABBITMQ_EVENTS_CHATS_UPDATE === 'true',
          CHATS_UPSERT: process.env?.RABBITMQ_EVENTS_CHATS_UPSERT === 'true',
          CHATS_DELETE: process.env?.RABBITMQ_EVENTS_CHATS_DELETE === 'true',
          CONNECTION_UPDATE: process.env?.RABBITMQ_EVENTS_CONNECTION_UPDATE === 'true',
          LABELS_EDIT: process.env?.RABBITMQ_EVENTS_LABELS_EDIT === 'true',
          LABELS_ASSOCIATION: process.env?.RABBITMQ_EVENTS_LABELS_ASSOCIATION === 'true',
          GROUPS_UPSERT: process.env?.RABBITMQ_EVENTS_GROUPS_UPSERT === 'true',
          GROUP_UPDATE: process.env?.RABBITMQ_EVENTS_GROUPS_UPDATE === 'true',
          GROUP_PARTICIPANTS_UPDATE: process.env?.RABBITMQ_EVENTS_GROUP_PARTICIPANTS_UPDATE === 'true',
          CALL: process.env?.RABBITMQ_EVENTS_CALL === 'true',
          TYPEBOT_START: process.env?.RABBITMQ_EVENTS_TYPEBOT_START === 'true',
          TYPEBOT_CHANGE_STATUS: process.env?.RABBITMQ_EVENTS_TYPEBOT_CHANGE_STATUS === 'true',
        },
      },
      SQS: {
        ENABLED: process.env?.SQS_ENABLED === 'true',
        ACCESS_KEY_ID: process.env.SQS_ACCESS_KEY_ID || '',
        SECRET_ACCESS_KEY: process.env.SQS_SECRET_ACCESS_KEY || '',
        ACCOUNT_ID: process.env.SQS_ACCOUNT_ID || '',
        REGION: process.env.SQS_REGION || '',
      },
      WEBSOCKET: {
        ENABLED: process.env?.WEBSOCKET_ENABLED === 'true',
        GLOBAL_EVENTS: process.env?.WEBSOCKET_GLOBAL_EVENTS === 'true',
      },
      PUSHER: {
        ENABLED: process.env?.PUSHER_ENABLED === 'true',
        GLOBAL: {
          ENABLED: process.env?.PUSHER_GLOBAL_ENABLED === 'true',
          APP_ID: process.env?.PUSHER_GLOBAL_APP_ID || '',
          KEY: process.env?.PUSHER_GLOBAL_KEY || '',
          SECRET: process.env?.PUSHER_GLOBAL_SECRET || '',
          CLUSTER: process.env?.PUSHER_GLOBAL_CLUSTER || '',
          USE_TLS: process.env?.PUSHER_GLOBAL_USE_TLS === 'true',
        },
        EVENTS: {
          APPLICATION_STARTUP: process.env?.PUSHER_EVENTS_APPLICATION_STARTUP === 'true',
          INSTANCE_CREATE: process.env?.PUSHER_EVENTS_INSTANCE_CREATE === 'true',
          INSTANCE_DELETE: process.env?.PUSHER_EVENTS_INSTANCE_DELETE === 'true',
          QRCODE_UPDATED: process.env?.PUSHER_EVENTS_QRCODE_UPDATED === 'true',
          MESSAGES_SET: process.env?.PUSHER_EVENTS_MESSAGES_SET === 'true',
          MESSAGES_UPSERT: process.env?.PUSHER_EVENTS_MESSAGES_UPSERT === 'true',
          MESSAGES_EDITED: process.env?.PUSHER_EVENTS_MESSAGES_EDITED === 'true',
          MESSAGES_UPDATE: process.env?.PUSHER_EVENTS_MESSAGES_UPDATE === 'true',
          MESSAGES_DELETE: process.env?.PUSHER_EVENTS_MESSAGES_DELETE === 'true',
          SEND_MESSAGE: process.env?.PUSHER_EVENTS_SEND_MESSAGE === 'true',
          CONTACTS_SET: process.env?.PUSHER_EVENTS_CONTACTS_SET === 'true',
          CONTACTS_UPDATE: process.env?.PUSHER_EVENTS_CONTACTS_UPDATE === 'true',
          CONTACTS_UPSERT: process.env?.PUSHER_EVENTS_CONTACTS_UPSERT === 'true',
          PRESENCE_UPDATE: process.env?.PUSHER_EVENTS_PRESENCE_UPDATE === 'true',
          CHATS_SET: process.env?.PUSHER_EVENTS_CHATS_SET === 'true',
          CHATS_UPDATE: process.env?.PUSHER_EVENTS_CHATS_UPDATE === 'true',
          CHATS_UPSERT: process.env?.PUSHER_EVENTS_CHATS_UPSERT === 'true',
          CHATS_DELETE: process.env?.PUSHER_EVENTS_CHATS_DELETE === 'true',
          CONNECTION_UPDATE: process.env?.PUSHER_EVENTS_CONNECTION_UPDATE === 'true',
          LABELS_EDIT: process.env?.PUSHER_EVENTS_LABELS_EDIT === 'true',
          LABELS_ASSOCIATION: process.env?.PUSHER_EVENTS_LABELS_ASSOCIATION === 'true',
          GROUPS_UPSERT: process.env?.PUSHER_EVENTS_GROUPS_UPSERT === 'true',
          GROUP_UPDATE: process.env?.PUSHER_EVENTS_GROUPS_UPDATE === 'true',
          GROUP_PARTICIPANTS_UPDATE: process.env?.PUSHER_EVENTS_GROUP_PARTICIPANTS_UPDATE === 'true',
          CALL: process.env?.PUSHER_EVENTS_CALL === 'true',
          TYPEBOT_START: process.env?.PUSHER_EVENTS_TYPEBOT_START === 'true',
          TYPEBOT_CHANGE_STATUS: process.env?.PUSHER_EVENTS_TYPEBOT_CHANGE_STATUS === 'true',
        },
      },
      WA_BUSINESS: {
        TOKEN_WEBHOOK: process.env.WA_BUSINESS_TOKEN_WEBHOOK || 'evolution',
        URL: process.env.WA_BUSINESS_URL || 'https://graph.facebook.com',
        VERSION: process.env.WA_BUSINESS_VERSION || 'v18.0',
        LANGUAGE: process.env.WA_BUSINESS_LANGUAGE || 'en',
      },
      LOG: {
        LEVEL:
          (process.env?.LOG_LEVEL?.split(',') as LogLevel[]) ||
          (['ERROR', 'WARN', 'DEBUG', 'INFO', 'LOG', 'VERBOSE', 'DARK', 'WEBHOOKS', 'WEBSOCKET'] as LogLevel[]),
        COLOR: process.env?.LOG_COLOR === 'true',
        BAILEYS: (process.env?.LOG_BAILEYS as LogBaileys) || 'error',
      },
      DEL_INSTANCE: isBooleanString(process.env?.DEL_INSTANCE)
        ? process.env.DEL_INSTANCE === 'true'
        : Number.parseInt(process.env.DEL_INSTANCE) || false,
      DEL_TEMP_INSTANCES: isBooleanString(process.env?.DEL_TEMP_INSTANCES)
        ? process.env.DEL_TEMP_INSTANCES === 'true'
        : true,
      LANGUAGE: process.env?.LANGUAGE || 'en',
      WEBHOOK: {
        GLOBAL: {
          URL: process.env?.WEBHOOK_GLOBAL_URL || '',
          ENABLED: process.env?.WEBHOOK_GLOBAL_ENABLED === 'true',
          WEBHOOK_BY_EVENTS: process.env?.WEBHOOK_GLOBAL_WEBHOOK_BY_EVENTS === 'true',
        },
        EVENTS: {
          APPLICATION_STARTUP: process.env?.WEBHOOK_EVENTS_APPLICATION_STARTUP === 'true',
          INSTANCE_CREATE: process.env?.WEBHOOK_EVENTS_INSTANCE_CREATE === 'true',
          INSTANCE_DELETE: process.env?.WEBHOOK_EVENTS_INSTANCE_DELETE === 'true',
          QRCODE_UPDATED: process.env?.WEBHOOK_EVENTS_QRCODE_UPDATED === 'true',
          MESSAGES_SET: process.env?.WEBHOOK_EVENTS_MESSAGES_SET === 'true',
          MESSAGES_UPSERT: process.env?.WEBHOOK_EVENTS_MESSAGES_UPSERT === 'true',
          MESSAGES_EDITED: process.env?.WEBHOOK_EVENTS_MESSAGES_EDITED === 'true',
          MESSAGES_UPDATE: process.env?.WEBHOOK_EVENTS_MESSAGES_UPDATE === 'true',
          MESSAGES_DELETE: process.env?.WEBHOOK_EVENTS_MESSAGES_DELETE === 'true',
          SEND_MESSAGE: process.env?.WEBHOOK_EVENTS_SEND_MESSAGE === 'true',
          CONTACTS_SET: process.env?.WEBHOOK_EVENTS_CONTACTS_SET === 'true',
          CONTACTS_UPDATE: process.env?.WEBHOOK_EVENTS_CONTACTS_UPDATE === 'true',
          CONTACTS_UPSERT: process.env?.WEBHOOK_EVENTS_CONTACTS_UPSERT === 'true',
          PRESENCE_UPDATE: process.env?.WEBHOOK_EVENTS_PRESENCE_UPDATE === 'true',
          CHATS_SET: process.env?.WEBHOOK_EVENTS_CHATS_SET === 'true',
          CHATS_UPDATE: process.env?.WEBHOOK_EVENTS_CHATS_UPDATE === 'true',
          CHATS_UPSERT: process.env?.WEBHOOK_EVENTS_CHATS_UPSERT === 'true',
          CHATS_DELETE: process.env?.WEBHOOK_EVENTS_CHATS_DELETE === 'true',
          CONNECTION_UPDATE: process.env?.WEBHOOK_EVENTS_CONNECTION_UPDATE === 'true',
          LABELS_EDIT: process.env?.WEBHOOK_EVENTS_LABELS_EDIT === 'true',
          LABELS_ASSOCIATION: process.env?.WEBHOOK_EVENTS_LABELS_ASSOCIATION === 'true',
          GROUPS_UPSERT: process.env?.WEBHOOK_EVENTS_GROUPS_UPSERT === 'true',
          GROUP_UPDATE: process.env?.WEBHOOK_EVENTS_GROUPS_UPDATE === 'true',
          GROUP_PARTICIPANTS_UPDATE: process.env?.WEBHOOK_EVENTS_GROUP_PARTICIPANTS_UPDATE === 'true',
          CALL: process.env?.WEBHOOK_EVENTS_CALL === 'true',
          TYPEBOT_START: process.env?.WEBHOOK_EVENTS_TYPEBOT_START === 'true',
          TYPEBOT_CHANGE_STATUS: process.env?.WEBHOOK_EVENTS_TYPEBOT_CHANGE_STATUS === 'true',
          ERRORS: process.env?.WEBHOOK_EVENTS_ERRORS === 'true',
          ERRORS_WEBHOOK: process.env?.WEBHOOK_EVENTS_ERRORS_WEBHOOK || '',
        },
      },
      CONFIG_SESSION_PHONE: {
        CLIENT: process.env?.CONFIG_SESSION_PHONE_CLIENT || 'Evolution API',
        NAME: process.env?.CONFIG_SESSION_PHONE_NAME || 'Chrome',
        VERSION: process.env?.CONFIG_SESSION_PHONE_VERSION || null,
      },
      QRCODE: {
        LIMIT: Number.parseInt(process.env.QRCODE_LIMIT) || 30,
        COLOR: process.env.QRCODE_COLOR || '#198754',
      },
      TYPEBOT: {
        ENABLED: process.env?.TYPEBOT_ENABLED === 'true',
        API_VERSION: process.env?.TYPEBOT_API_VERSION || 'old',
        SEND_MEDIA_BASE64: process.env?.TYPEBOT_SEND_MEDIA_BASE64 === 'true',
      },
      CHATWOOT: {
        ENABLED: process.env?.CHATWOOT_ENABLED === 'true',
        MESSAGE_DELETE: process.env.CHATWOOT_MESSAGE_DELETE === 'true',
        MESSAGE_READ: process.env.CHATWOOT_MESSAGE_READ === 'true',
        BOT_CONTACT: !process.env.CHATWOOT_BOT_CONTACT || process.env.CHATWOOT_BOT_CONTACT === 'true',
        IMPORT: {
          DATABASE: {
            CONNECTION: {
              URI: process.env.CHATWOOT_IMPORT_DATABASE_CONNECTION_URI || '',
            },
          },
          PLACEHOLDER_MEDIA_MESSAGE: process.env?.CHATWOOT_IMPORT_PLACEHOLDER_MEDIA_MESSAGE === 'true',
        },
      },
      OPENAI: {
        ENABLED: process.env?.OPENAI_ENABLED === 'true',
        API_KEY_GLOBAL: process.env?.OPENAI_API_KEY_GLOBAL || null,
      },
      DIFY: {
        ENABLED: process.env?.DIFY_ENABLED === 'true',
      },
      CACHE: {
        REDIS: {
          ENABLED: process.env?.CACHE_REDIS_ENABLED === 'true',
          URI: process.env?.CACHE_REDIS_URI || '',
          PREFIX_KEY: process.env?.CACHE_REDIS_PREFIX_KEY || 'evolution-cache',
          TTL: Number.parseInt(process.env?.CACHE_REDIS_TTL) || 604800,
          SAVE_INSTANCES: process.env?.CACHE_REDIS_SAVE_INSTANCES === 'true',
        },
        LOCAL: {
          ENABLED: process.env?.CACHE_LOCAL_ENABLED === 'true',
          TTL: Number.parseInt(process.env?.CACHE_REDIS_TTL) || 86400,
        },
      },
      S3: {
        ACCESS_KEY: process.env?.S3_ACCESS_KEY,
        SECRET_KEY: process.env?.S3_SECRET_KEY,
        ENDPOINT: process.env?.S3_ENDPOINT,
        BUCKET_NAME: process.env?.S3_BUCKET,
        ENABLE: process.env?.S3_ENABLED === 'true',
        PORT: Number.parseInt(process.env?.S3_PORT || '9000'),
        USE_SSL: process.env?.S3_USE_SSL === 'true',
        REGION: process.env?.S3_REGION,
      },
      AUTHENTICATION: {
        API_KEY: {
          KEY: process.env.AUTHENTICATION_API_KEY || 'BQYHJGJHJ',
        },
        EXPOSE_IN_FETCH_INSTANCES: process.env?.AUTHENTICATION_EXPOSE_IN_FETCH_INSTANCES === 'true',
      },
    };
  }
}

export const configService = new ConfigService();



================================================
FILE: src/config/error.config.ts
================================================
import { Logger } from './logger.config';

export function onUnexpectedError() {
  process.on('uncaughtException', (error, origin) => {
    const logger = new Logger('uncaughtException');
    logger.error({
      origin,
      stderr: process.stderr.fd,
      error,
    });
  });

  process.on('unhandledRejection', (error, origin) => {
    const logger = new Logger('unhandledRejection');
    logger.error({
      origin,
      stderr: process.stderr.fd,
    });
    logger.error(error);
  });
}



================================================
FILE: src/config/event.config.ts
================================================
import EventEmitter2 from 'eventemitter2';

const maxListeners = parseInt(process.env.EVENT_EMITTER_MAX_LISTENERS, 10) || 50;

export const eventEmitter = new EventEmitter2({
  delimiter: '.',
  newListener: false,
  ignoreErrors: false,
  maxListeners: maxListeners,
});



================================================
FILE: src/config/logger.config.ts
================================================
import dayjs from 'dayjs';
import fs from 'fs';

import { configService, Log } from './env.config';
const packageJson = JSON.parse(fs.readFileSync('./package.json', 'utf8'));

const formatDateLog = (timestamp: number) =>
  dayjs(timestamp)
    .toDate()
    .toString()
    .replace(/\sGMT.+/, '');

enum Color {
  LOG = '\x1b[32m',
  INFO = '\x1b[34m',
  WARN = '\x1b[33m',
  ERROR = '\x1b[31m',
  DEBUG = '\x1b[36m',
  VERBOSE = '\x1b[37m',
  DARK = '\x1b[30m',
}

enum Command {
  RESET = '\x1b[0m',
  BRIGHT = '\x1b[1m',
  UNDERSCORE = '\x1b[4m',
}

enum Level {
  LOG = Color.LOG + '%s' + Command.RESET,
  DARK = Color.DARK + '%s' + Command.RESET,
  INFO = Color.INFO + '%s' + Command.RESET,
  WARN = Color.WARN + '%s' + Command.RESET,
  ERROR = Color.ERROR + '%s' + Command.RESET,
  DEBUG = Color.DEBUG + '%s' + Command.RESET,
  VERBOSE = Color.VERBOSE + '%s' + Command.RESET,
}

enum Type {
  LOG = 'LOG',
  WARN = 'WARN',
  INFO = 'INFO',
  DARK = 'DARK',
  ERROR = 'ERROR',
  DEBUG = 'DEBUG',
  VERBOSE = 'VERBOSE',
}

enum Background {
  LOG = '\x1b[42m',
  INFO = '\x1b[44m',
  WARN = '\x1b[43m',
  DARK = '\x1b[40m',
  ERROR = '\x1b[41m',
  DEBUG = '\x1b[46m',
  VERBOSE = '\x1b[47m',
}

export class Logger {
  private readonly configService = configService;
  private context: string;

  constructor(context = 'Logger') {
    this.context = context;
  }

  private instance = null;

  public setContext(value: string) {
    this.context = value;
  }

  public setInstance(value: string) {
    this.instance = value;
  }

  private console(value: any, type: Type) {
    const types: Type[] = [];

    this.configService.get<Log>('LOG').LEVEL.forEach((level) => types.push(Type[level]));

    const typeValue = typeof value;
    if (types.includes(type)) {
      if (configService.get<Log>('LOG').COLOR) {
        console.log(
          /*Command.UNDERSCORE +*/ Command.BRIGHT + Level[type],
          '[Evolution API]',
          Command.BRIGHT + Color[type],
          this.instance ? `[${this.instance}]` : '',
          Command.BRIGHT + Color[type],
          `v${packageJson.version}`,
          Command.BRIGHT + Color[type],
          process.pid.toString(),
          Command.RESET,
          Command.BRIGHT + Color[type],
          '-',
          Command.BRIGHT + Color.VERBOSE,
          `${formatDateLog(Date.now())}  `,
          Command.RESET,
          Color[type] + Background[type] + Command.BRIGHT,
          `${type} ` + Command.RESET,
          Color.WARN + Command.BRIGHT,
          `[${this.context}]` + Command.RESET,
          Color[type] + Command.BRIGHT,
          `[${typeValue}]` + Command.RESET,
          Color[type],
          typeValue !== 'object' ? value : '',
          Command.RESET,
        );
        typeValue === 'object' ? console.log(/*Level.DARK,*/ value, '\n') : '';
      } else {
        console.log(
          '[Evolution API]',
          this.instance ? `[${this.instance}]` : '',
          process.pid.toString(),
          '-',
          `${formatDateLog(Date.now())}  `,
          `${type} `,
          `[${this.context}]`,
          `[${typeValue}]`,
          value,
        );
      }
    }
  }

  public log(value: any) {
    this.console(value, Type.LOG);
  }

  public info(value: any) {
    this.console(value, Type.INFO);
  }

  public warn(value: any) {
    this.console(value, Type.WARN);
  }

  public error(value: any) {
    this.console(value, Type.ERROR);
  }

  public verbose(value: any) {
    this.console(value, Type.VERBOSE);
  }

  public debug(value: any) {
    this.console(value, Type.DEBUG);
  }

  public dark(value: any) {
    this.console(value, Type.DARK);
  }
}



================================================
FILE: src/config/path.config.ts
================================================
import { join } from 'path';

export const ROOT_DIR = process.cwd();
export const INSTANCE_DIR = join(ROOT_DIR, 'instances');
export const SRC_DIR = join(ROOT_DIR, 'src');
export const AUTH_DIR = join(ROOT_DIR, 'store', 'auth');
export const STORE_DIR = join(ROOT_DIR, 'store');



================================================
FILE: src/exceptions/400.exception.ts
================================================
import { HttpStatus } from '@api/routes/index.router';

export class BadRequestException {
  constructor(...objectError: any[]) {
    throw {
      status: HttpStatus.BAD_REQUEST,
      error: 'Bad Request',
      message: objectError.length > 0 ? objectError : undefined,
    };
  }
}



================================================
FILE: src/exceptions/401.exception.ts
================================================
import { HttpStatus } from '@api/routes/index.router';

export class UnauthorizedException {
  constructor(...objectError: any[]) {
    throw {
      status: HttpStatus.UNAUTHORIZED,
      error: 'Unauthorized',
      message: objectError.length > 0 ? objectError : 'Unauthorized',
    };
  }
}



================================================
FILE: src/exceptions/403.exception.ts
================================================
import { HttpStatus } from '@api/routes/index.router';

export class ForbiddenException {
  constructor(...objectError: any[]) {
    throw {
      status: HttpStatus.FORBIDDEN,
      error: 'Forbidden',
      message: objectError.length > 0 ? objectError : undefined,
    };
  }
}



================================================
FILE: src/exceptions/404.exception.ts
================================================
import { HttpStatus } from '@api/routes/index.router';

export class NotFoundException {
  constructor(...objectError: any[]) {
    throw {
      status: HttpStatus.NOT_FOUND,
      error: 'Not Found',
      message: objectError.length > 0 ? objectError : undefined,
    };
  }
}



================================================
FILE: src/exceptions/500.exception.ts
================================================
import { HttpStatus } from '@api/routes/index.router';

export class InternalServerErrorException {
  constructor(...objectError: any[]) {
    throw {
      status: HttpStatus.INTERNAL_SERVER_ERROR,
      error: 'Internal Server Error',
      message: objectError.length > 0 ? objectError : undefined,
    };
  }
}



================================================
FILE: src/exceptions/index.ts
================================================
export * from './400.exception';
export * from './401.exception';
export * from './403.exception';
export * from './404.exception';
export * from './500.exception';



================================================
FILE: src/utils/advancedOperatorsSearch.ts
================================================
function normalizeString(str: string): string {
  return str
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase();
}

export function advancedOperatorsSearch(data: string, query: string): boolean {
  const filters = query.split(' ').reduce((acc: Record<string, string[]>, filter) => {
    const [operator, ...values] = filter.split(':');
    const value = values.join(':');

    if (!acc[operator]) {
      acc[operator] = [];
    }
    acc[operator].push(value);
    return acc;
  }, {});

  const normalizedItem = normalizeString(data);

  return Object.entries(filters).every(([operator, values]) => {
    return values.some((val) => {
      const subValues = val.split(',');
      return subValues.every((subVal) => {
        const normalizedSubVal = normalizeString(subVal);

        switch (operator.toLowerCase()) {
          case 'contains':
            return normalizedItem.includes(normalizedSubVal);
          case 'notcontains':
            return !normalizedItem.includes(normalizedSubVal);
          case 'startswith':
            return normalizedItem.startsWith(normalizedSubVal);
          case 'endswith':
            return normalizedItem.endsWith(normalizedSubVal);
          case 'exact':
            return normalizedItem === normalizedSubVal;
          default:
            return false;
        }
      });
    });
  });
}



================================================
FILE: src/utils/createJid.ts
================================================
// Check if the number is MX or AR
function formatMXOrARNumber(jid: string): string {
  const countryCode = jid.substring(0, 2);

  if (Number(countryCode) === 52 || Number(countryCode) === 54) {
    if (jid.length === 13) {
      const number = countryCode + jid.substring(3);
      return number;
    }

    return jid;
  }
  return jid;
}

// Check if the number is br
function formatBRNumber(jid: string) {
  const regexp = new RegExp(/^(\d{2})(\d{2})\d{1}(\d{8})$/);
  if (regexp.test(jid)) {
    const match = regexp.exec(jid);
    if (match && match[1] === '55') {
      const joker = Number.parseInt(match[3][0]);
      const ddd = Number.parseInt(match[2]);
      if (joker < 7 || ddd < 31) {
        return match[0];
      }
      return match[1] + match[2] + match[3];
    }
    return jid;
  } else {
    return jid;
  }
}

export function createJid(number: string): string {
  number = number.replace(/:\d+/, '');

  if (number.includes('@g.us') || number.includes('@s.whatsapp.net') || number.includes('@lid')) {
    return number;
  }

  if (number.includes('@broadcast')) {
    return number;
  }

  number = number
    ?.replace(/\s/g, '')
    .replace(/\+/g, '')
    .replace(/\(/g, '')
    .replace(/\)/g, '')
    .split(':')[0]
    .split('@')[0];

  if (number.includes('-') && number.length >= 24) {
    number = number.replace(/[^\d-]/g, '');
    return `${number}@g.us`;
  }

  number = number.replace(/\D/g, '');

  if (number.length >= 18) {
    number = number.replace(/[^\d-]/g, '');
    return `${number}@g.us`;
  }

  number = formatMXOrARNumber(number);

  number = formatBRNumber(number);

  return `${number}@s.whatsapp.net`;
}



================================================
FILE: src/utils/findBotByTrigger.ts
================================================
import { advancedOperatorsSearch } from './advancedOperatorsSearch';

export const findBotByTrigger = async (botRepository: any, content: string, instanceId: string) => {
  // Check for triggerType 'all'
  const findTriggerAll = await botRepository.findFirst({
    where: {
      enabled: true,
      triggerType: 'all',
      instanceId: instanceId,
    },
  });

  if (findTriggerAll) return findTriggerAll;

  const findTriggerAdvanced = await botRepository.findMany({
    where: {
      enabled: true,
      triggerType: 'advanced',
      instanceId: instanceId,
    },
  });
  for (const advanced of findTriggerAdvanced) {
    if (advancedOperatorsSearch(content, advanced.triggerValue)) {
      return advanced;
    }
  }

  // Check for exact match
  const findTriggerEquals = await botRepository.findFirst({
    where: {
      enabled: true,
      triggerType: 'keyword',
      triggerOperator: 'equals',
      triggerValue: content,
      instanceId: instanceId,
    },
  });

  if (findTriggerEquals) return findTriggerEquals;

  // Check for regex match
  const findRegex = await botRepository.findMany({
    where: {
      enabled: true,
      triggerType: 'keyword',
      triggerOperator: 'regex',
      instanceId: instanceId,
    },
  });

  let findTriggerRegex = null;

  for (const regex of findRegex) {
    const regexValue = new RegExp(regex.triggerValue);

    if (regexValue.test(content)) {
      findTriggerRegex = regex;
      break;
    }
  }

  if (findTriggerRegex) return findTriggerRegex;

  // Check for startsWith match
  const findStartsWith = await botRepository.findMany({
    where: {
      enabled: true,
      triggerType: 'keyword',
      triggerOperator: 'startsWith',
      instanceId: instanceId,
    },
  });

  let findTriggerStartsWith = null;

  for (const startsWith of findStartsWith) {
    if (content.startsWith(startsWith.triggerValue)) {
      findTriggerStartsWith = startsWith;
      break;
    }
  }

  if (findTriggerStartsWith) return findTriggerStartsWith;

  // Check for endsWith match
  const findEndsWith = await botRepository.findMany({
    where: {
      enabled: true,
      triggerType: 'keyword',
      triggerOperator: 'endsWith',
      instanceId: instanceId,
    },
  });

  let findTriggerEndsWith = null;

  for (const endsWith of findEndsWith) {
    if (content.endsWith(endsWith.triggerValue)) {
      findTriggerEndsWith = endsWith;
      break;
    }
  }

  if (findTriggerEndsWith) return findTriggerEndsWith;

  // Check for contains match
  const findContains = await botRepository.findMany({
    where: {
      enabled: true,
      triggerType: 'keyword',
      triggerOperator: 'contains',
      instanceId: instanceId,
    },
  });

  let findTriggerContains = null;

  for (const contains of findContains) {
    if (content.includes(contains.triggerValue)) {
      findTriggerContains = contains;
      break;
    }
  }

  if (findTriggerContains) return findTriggerContains;

  return null;
};



================================================
FILE: src/utils/getConversationMessage.ts
================================================
import { configService, S3 } from '@config/env.config';

const getTypeMessage = (msg: any) => {
  let mediaId: string;

  if (configService.get<S3>('S3').ENABLE) mediaId = msg.message.mediaUrl;
  else mediaId = msg.key.id;

  const types = {
    conversation: msg?.message?.conversation,
    extendedTextMessage: msg?.message?.extendedTextMessage?.text,
    contactMessage: msg?.message?.contactMessage?.displayName,
    locationMessage: msg?.message?.locationMessage?.degreesLatitude,
    viewOnceMessageV2:
      msg?.message?.viewOnceMessageV2?.message?.imageMessage?.url ||
      msg?.message?.viewOnceMessageV2?.message?.videoMessage?.url ||
      msg?.message?.viewOnceMessageV2?.message?.audioMessage?.url,
    listResponseMessage: msg?.message?.listResponseMessage?.title,
    responseRowId: msg?.message?.listResponseMessage?.singleSelectReply?.selectedRowId,
    templateButtonReplyMessage:
      msg?.message?.templateButtonReplyMessage?.selectedId || msg?.message?.buttonsResponseMessage?.selectedButtonId,
    // Medias
    audioMessage: msg?.message?.speechToText
      ? msg?.message?.speechToText
      : msg?.message?.audioMessage
        ? `audioMessage|${mediaId}`
        : undefined,
    imageMessage: msg?.message?.imageMessage
      ? `imageMessage|${mediaId}${msg?.message?.imageMessage?.caption ? `|${msg?.message?.imageMessage?.caption}` : ''}`
      : undefined,
    videoMessage: msg?.message?.videoMessage
      ? `videoMessage|${mediaId}${msg?.message?.videoMessage?.caption ? `|${msg?.message?.videoMessage?.caption}` : ''}`
      : undefined,
    documentMessage: msg?.message?.documentMessage
      ? `documentMessage|${mediaId}${
          msg?.message?.documentMessage?.caption ? `|${msg?.message?.documentMessage?.caption}` : ''
        }`
      : undefined,
    documentWithCaptionMessage: msg?.message?.documentWithCaptionMessage?.message?.documentMessage
      ? `documentWithCaptionMessage|${mediaId}${
          msg?.message?.documentWithCaptionMessage?.message?.documentMessage?.caption
            ? `|${msg?.message?.documentWithCaptionMessage?.message?.documentMessage?.caption}`
            : ''
        }`
      : undefined,
    externalAdReplyBody: msg?.contextInfo?.externalAdReply?.body
      ? `externalAdReplyBody|${msg.contextInfo.externalAdReply.body}`
      : undefined,
  };

  const messageType = Object.keys(types).find((key) => types[key] !== undefined) || 'unknown';

  return { ...types, messageType };
};

const getMessageContent = (types: any) => {
  const typeKey = Object.keys(types).find((key) => key !== 'externalAdReplyBody' && types[key] !== undefined);

  let result = typeKey ? types[typeKey] : undefined;

  if (types.externalAdReplyBody) {
    result = result ? `${result}\n${types.externalAdReplyBody}` : types.externalAdReplyBody;
  }

  return result;
};

export const getConversationMessage = (msg: any) => {
  const types = getTypeMessage(msg);

  const messageContent = getMessageContent(types);

  return messageContent;
};



================================================
FILE: src/utils/i18n.ts
================================================
import { ConfigService, Language } from '@config/env.config';
import fs from 'fs';
import i18next from 'i18next';
import path from 'path';

const languages = ['en', 'pt-BR', 'es'];
const translationsPath = path.join(__dirname, 'translations');
const configService: ConfigService = new ConfigService();

const resources: any = {};

languages.forEach((language) => {
  const languagePath = path.join(translationsPath, `${language}.json`);
  if (fs.existsSync(languagePath)) {
    resources[language] = {
      translation: require(languagePath),
    };
  }
});

i18next.init({
  resources,
  fallbackLng: 'en',
  lng: configService.get<Language>('LANGUAGE'),
  debug: false,

  interpolation: {
    escapeValue: false,
  },
});
export default i18next;



================================================
FILE: src/utils/instrumentSentry.ts
================================================
import * as Sentry from '@sentry/node';

const dsn = process.env.SENTRY_DSN;

if (dsn) {
  Sentry.init({
    dsn: dsn,
    environment: process.env.NODE_ENV || 'development',
    tracesSampleRate: 1.0,
    profilesSampleRate: 1.0,
  });
}



================================================
FILE: src/utils/makeProxyAgent.ts
================================================
import { HttpsProxyAgent } from 'https-proxy-agent';

type Proxy = {
  host: string;
  password?: string;
  port: string;
  protocol: string;
  username?: string;
};

export function makeProxyAgent(proxy: Proxy | string) {
  if (typeof proxy === 'string') {
    return new HttpsProxyAgent(proxy);
  }

  const { host, password, port, protocol, username } = proxy;
  let proxyUrl = `${protocol}://${host}:${port}`;

  if (username && password) {
    proxyUrl = `${protocol}://${username}:${password}@${host}:${port}`;
  }
  return new HttpsProxyAgent(proxyUrl);
}



================================================
FILE: src/utils/onWhatsappCache.ts
================================================
import { prismaRepository } from '@api/server.module';
import { configService, Database } from '@config/env.config';
import dayjs from 'dayjs';

function getAvailableNumbers(remoteJid: string) {
  const numbersAvailable: string[] = [];

  if (remoteJid.startsWith('+')) {
    remoteJid = remoteJid.slice(1);
  }

  const [number, domain] = remoteJid.split('@');

  // Brazilian numbers
  if (remoteJid.startsWith('55')) {
    const numberWithDigit =
      number.slice(4, 5) === '9' && number.length === 13 ? number : `${number.slice(0, 4)}9${number.slice(4)}`;
    const numberWithoutDigit = number.length === 12 ? number : number.slice(0, 4) + number.slice(5);

    numbersAvailable.push(numberWithDigit);
    numbersAvailable.push(numberWithoutDigit);
  }

  // Mexican/Argentina numbers
  // Ref: https://faq.whatsapp.com/1294841057948784
  else if (number.startsWith('52') || number.startsWith('54')) {
    let prefix = '';
    if (number.startsWith('52')) {
      prefix = '1';
    }
    if (number.startsWith('54')) {
      prefix = '9';
    }

    const numberWithDigit =
      number.slice(2, 3) === prefix && number.length === 13
        ? number
        : `${number.slice(0, 2)}${prefix}${number.slice(2)}`;
    const numberWithoutDigit = number.length === 12 ? number : number.slice(0, 2) + number.slice(3);

    numbersAvailable.push(numberWithDigit);
    numbersAvailable.push(numberWithoutDigit);
  }

  // Other countries
  else {
    numbersAvailable.push(remoteJid);
  }

  return numbersAvailable.map((number) => `${number}@${domain}`);
}

interface ISaveOnWhatsappCacheParams {
  remoteJid: string;
}
export async function saveOnWhatsappCache(data: ISaveOnWhatsappCacheParams[]) {
  if (configService.get<Database>('DATABASE').SAVE_DATA.IS_ON_WHATSAPP) {
    const upsertsQuery = data.map((item) => {
      const remoteJid = item.remoteJid.startsWith('+') ? item.remoteJid.slice(1) : item.remoteJid;
      const numbersAvailable = getAvailableNumbers(remoteJid);

      return prismaRepository.isOnWhatsapp.upsert({
        create: { remoteJid: remoteJid, jidOptions: numbersAvailable.join(',') },
        update: { jidOptions: numbersAvailable.join(',') },
        where: { remoteJid: remoteJid },
      });
    });

    await prismaRepository.$transaction(upsertsQuery);
  }
}

export async function getOnWhatsappCache(remoteJids: string[]) {
  let results: {
    remoteJid: string;
    number: string;
    jidOptions: string[];
  }[] = [];

  if (configService.get<Database>('DATABASE').SAVE_DATA.IS_ON_WHATSAPP) {
    const remoteJidsWithoutPlus = remoteJids.map((remoteJid) => getAvailableNumbers(remoteJid)).flat();

    const onWhatsappCache = await prismaRepository.isOnWhatsapp.findMany({
      where: {
        OR: remoteJidsWithoutPlus.map((remoteJid) => ({ jidOptions: { contains: remoteJid } })),
        updatedAt: {
          gte: dayjs().subtract(configService.get<Database>('DATABASE').SAVE_DATA.IS_ON_WHATSAPP_DAYS, 'days').toDate(),
        },
      },
    });

    results = onWhatsappCache.map((item) => ({
      remoteJid: item.remoteJid,
      number: item.remoteJid.split('@')[0],
      jidOptions: item.jidOptions.split(','),
    }));
  }

  return results;
}



================================================
FILE: src/utils/renderStatus.ts
================================================
import { wa } from '@api/types/wa.types';

export const status: Record<number, wa.StatusMessage> = {
  0: 'ERROR',
  1: 'PENDING',
  2: 'SERVER_ACK',
  3: 'DELIVERY_ACK',
  4: 'READ',
  5: 'PLAYED',
};



================================================
FILE: src/utils/sendTelemetry.ts
================================================
import axios from 'axios';
import fs from 'fs';

const packageJson = JSON.parse(fs.readFileSync('./package.json', 'utf8'));

export interface TelemetryData {
  route: string;
  apiVersion: string;
  timestamp: Date;
}

export const sendTelemetry = async (route: string): Promise<void> => {
  const enabled = process.env.TELEMETRY_ENABLED === undefined || process.env.TELEMETRY_ENABLED === 'true';

  if (!enabled) {
    return;
  }

  if (route === '/') {
    return;
  }

  const telemetry: TelemetryData = {
    route,
    apiVersion: `${packageJson.version}`,
    timestamp: new Date(),
  };

  const url =
    process.env.TELEMETRY_URL && process.env.TELEMETRY_URL !== ''
      ? process.env.TELEMETRY_URL
      : 'https://log.evolution-api.com/telemetry';

  axios
    .post(url, telemetry)
    .then(() => {})
    .catch(() => {});
};



================================================
FILE: src/utils/server-up.ts
================================================
import { configService, SslConf } from '@config/env.config';
import { Express } from 'express';
import { readFileSync } from 'fs';
import * as http from 'http';
import * as https from 'https';

export class ServerUP {
  static #app: Express;

  static set app(e: Express) {
    this.#app = e;
  }

  static get https() {
    const { FULLCHAIN, PRIVKEY } = configService.get<SslConf>('SSL_CONF');
    return https.createServer(
      {
        cert: readFileSync(FULLCHAIN),
        key: readFileSync(PRIVKEY),
      },
      ServerUP.#app,
    );
  }

  static get http() {
    return http.createServer(ServerUP.#app);
  }
}



================================================
FILE: src/utils/use-multi-file-auth-state-prisma.ts
================================================
import { prismaRepository } from '@api/server.module';
import { CacheService } from '@api/services/cache.service';
import { INSTANCE_DIR } from '@config/path.config';
import { AuthenticationState, BufferJSON, initAuthCreds, WAProto as proto } from 'baileys';
import fs from 'fs/promises';
import path from 'path';

const fixFileName = (file: string): string | undefined => {
  if (!file) {
    return undefined;
  }
  const replacedSlash = file.replace(/\//g, '__');
  const replacedColon = replacedSlash.replace(/:/g, '-');
  return replacedColon;
};

export async function keyExists(sessionId: string): Promise<any> {
  try {
    const key = await prismaRepository.session.findUnique({ where: { sessionId: sessionId } });
    return !!key;
  } catch (error) {
    return false;
  }
}

export async function saveKey(sessionId: string, keyJson: any): Promise<any> {
  const exists = await keyExists(sessionId);
  try {
    if (!exists)
      return await prismaRepository.session.create({
        data: {
          sessionId: sessionId,
          creds: JSON.stringify(keyJson),
        },
      });
    await prismaRepository.session.update({
      where: { sessionId: sessionId },
      data: { creds: JSON.stringify(keyJson) },
    });
  } catch (error) {
    return null;
  }
}

export async function getAuthKey(sessionId: string): Promise<any> {
  try {
    const register = await keyExists(sessionId);
    if (!register) return null;
    const auth = await prismaRepository.session.findUnique({ where: { sessionId: sessionId } });
    return JSON.parse(auth?.creds);
  } catch (error) {
    return null;
  }
}

async function deleteAuthKey(sessionId: string): Promise<any> {
  try {
    const register = await keyExists(sessionId);
    if (!register) return;
    await prismaRepository.session.delete({ where: { sessionId: sessionId } });
  } catch (error) {
    return;
  }
}

async function fileExists(file: string): Promise<any> {
  try {
    const stat = await fs.stat(file);
    if (stat.isFile()) return true;
  } catch (error) {
    return;
  }
}

export default async function useMultiFileAuthStatePrisma(
  sessionId: string,
  cache: CacheService,
): Promise<{
  state: AuthenticationState;
  saveCreds: () => Promise<void>;
}> {
  const localFolder = path.join(INSTANCE_DIR, sessionId);
  const localFile = (key: string) => path.join(localFolder, fixFileName(key) + '.json');
  await fs.mkdir(localFolder, { recursive: true });

  async function writeData(data: any, key: string): Promise<any> {
    const dataString = JSON.stringify(data, BufferJSON.replacer);

    if (key != 'creds') {
      if (process.env.CACHE_REDIS_ENABLED === 'true') {
        return await cache.hSet(sessionId, key, data);
      } else {
        await fs.writeFile(localFile(key), dataString);
        return;
      }
    }
    await saveKey(sessionId, dataString);
    return;
  }

  async function readData(key: string): Promise<any> {
    try {
      let rawData;

      if (key != 'creds') {
        if (process.env.CACHE_REDIS_ENABLED === 'true') {
          return await cache.hGet(sessionId, key);
        } else {
          if (!(await fileExists(localFile(key)))) return null;
          rawData = await fs.readFile(localFile(key), { encoding: 'utf-8' });
          return JSON.parse(rawData, BufferJSON.reviver);
        }
      } else {
        rawData = await getAuthKey(sessionId);
      }

      const parsedData = JSON.parse(rawData, BufferJSON.reviver);
      return parsedData;
    } catch (error) {
      return null;
    }
  }

  async function removeData(key: string): Promise<any> {
    try {
      if (key != 'creds') {
        if (process.env.CACHE_REDIS_ENABLED === 'true') {
          return await cache.hDelete(sessionId, key);
        } else {
          await fs.unlink(localFile(key));
        }
      } else {
        await deleteAuthKey(sessionId);
      }
    } catch (error) {
      return;
    }
  }

  let creds = await readData('creds');
  if (!creds) {
    creds = initAuthCreds();
    await writeData(creds, 'creds');
  }

  return {
    state: {
      creds,
      keys: {
        get: async (type, ids) => {
          const data = {};
          await Promise.all(
            ids.map(async (id) => {
              let value = await readData(`${type}-${id}`);
              if (type === 'app-state-sync-key' && value) {
                value = proto.Message.AppStateSyncKeyData.fromObject(value);
              }

              data[id] = value;
            }),
          );
          return data;
        },
        set: async (data) => {
          const tasks = [];
          for (const category in data) {
            for (const id in data[category]) {
              const value = data[category][id];
              const key = `${category}-${id}`;

              tasks.push(value ? writeData(value, key) : removeData(key));
            }
          }
          await Promise.all(tasks);
        },
      },
    },
    saveCreds: () => {
      return writeData(creds, 'creds');
    },
  };
}



================================================
FILE: src/utils/use-multi-file-auth-state-provider-files.ts
================================================
/**
 * ┌──────────────────────────────────────────────────────────────────────────────┐
 * │ @author jrCleber                                                             │
 * │ @filename use-multi-file-auth-state-provider-files.ts                              │
 * │ Developed by: Cleber Wilson                                                  │
 * │ Creation date: May 31, 2024                                                 │
 * │ Contact: contato@codechat.dev                                                │
 * ├──────────────────────────────────────────────────────────────────────────────┤
 * │ @copyright © Cleber Wilson 2023. All rights reserved.                        │
 * │ Licensed under the Apache License, Version 2.0                               │
 * │                                                                              │
 * │  @license "https://github.com/code-chat-br/whatsapp-api/blob/main/LICENSE"   │
 * │                                                                              │
 * │ You may not use this file except in compliance with the License.             │
 * │ You may obtain a copy of the License at                                      │
 * │                                                                              │
 * │    http://www.apache.org/licenses/LICENSE-2.0                                │
 * │                                                                              │
 * │ Unless required by applicable law or agreed to in writing, software          │
 * │ distributed under the License is distributed on an "AS IS" BASIS,            │
 * │ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.     │
 * │                                                                              │
 * │ See the License for the specific language governing permissions and          │
 * │ limitations under the License.                                               │
 * │                                                                              │
 * │ @type {AuthState}                                                            │
 * │ @function useMultiFileAuthStateRedisDb                                       │
 * │ @returns {Promise<AuthState>}                                                │
 * ├──────────────────────────────────────────────────────────────────────────────┤
 * │ @important                                                                   │
 * │ For any future changes to the code in this file, it is recommended to        │
 * │ contain, together with the modification, the information of the developer    │
 * │ who changed it and the date of modification.                                 │
 * └──────────────────────────────────────────────────────────────────────────────┘
 */

import { ProviderFiles } from '@api/provider/sessions';
import { Logger } from '@config/logger.config';
import { AuthenticationCreds, AuthenticationState, BufferJSON, initAuthCreds, proto, SignalDataTypeMap } from 'baileys';
import { isNotEmpty } from 'class-validator';

export type AuthState = { state: AuthenticationState; saveCreds: () => Promise<void> };

export class AuthStateProvider {
  constructor(private readonly providerFiles: ProviderFiles) {}

  private readonly logger = new Logger('AuthStateProvider');

  public async authStateProvider(instance: string): Promise<AuthState> {
    const [, error] = await this.providerFiles.create(instance);
    if (error) {
      this.logger.error(['Failed to create folder on file server', error?.message, error?.stack]);
      return;
    }

    const writeData = async (data: any, key: string): Promise<any> => {
      const json = JSON.stringify(data, BufferJSON.replacer);
      const [response, error] = await this.providerFiles.write(instance, key, {
        data: json,
      });
      if (error) {
        // this.logger.error(['writeData', error?.message, error?.stack]);
        return;
      }
      return response;
    };

    const readData = async (key: string): Promise<any> => {
      const [response, error] = await this.providerFiles.read(instance, key);
      if (error) {
        // this.logger.error(['readData', error?.message, error?.stack]);
        return;
      }
      if (isNotEmpty(response?.data)) {
        return JSON.parse(JSON.stringify(response.data), BufferJSON.reviver);
      }
    };

    const removeData = async (key: string) => {
      const [response, error] = await this.providerFiles.delete(instance, key);
      if (error) {
        // this.logger.error(['removeData', error?.message, error?.stack]);
        return;
      }

      return response;
    };

    const creds: AuthenticationCreds = (await readData('creds')) || initAuthCreds();

    return {
      state: {
        creds,
        keys: {
          get: async (type, ids: string[]) => {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const data: { [_: string]: SignalDataTypeMap[type] } = {};
            await Promise.all(
              ids.map(async (id) => {
                let value = await readData(`${type}-${id}`);
                if (type === 'app-state-sync-key' && value) {
                  value = proto.Message.AppStateSyncKeyData.fromObject(value);
                }

                data[id] = value;
              }),
            );

            return data;
          },
          set: async (data: any) => {
            const tasks: Promise<void>[] = [];
            for (const category in data) {
              for (const id in data[category]) {
                const value = data[category][id];
                const key = `${category}-${id}`;
                tasks.push(value ? await writeData(value, key) : await removeData(key));
              }
            }

            await Promise.all(tasks);
          },
        },
      },
      saveCreds: async () => {
        return await writeData(creds, 'creds');
      },
    };
  }
}



================================================
FILE: src/utils/use-multi-file-auth-state-redis-db.ts
================================================
import { CacheService } from '@api/services/cache.service';
import { Logger } from '@config/logger.config';
import { AuthenticationCreds, AuthenticationState, initAuthCreds, proto, SignalDataTypeMap } from 'baileys';

export async function useMultiFileAuthStateRedisDb(
  instanceName: string,
  cache: CacheService,
): Promise<{
  state: AuthenticationState;
  saveCreds: () => Promise<void>;
}> {
  const logger = new Logger('useMultiFileAuthStateRedisDb');

  const writeData = async (data: any, key: string): Promise<any> => {
    try {
      return await cache.hSet(instanceName, key, data);
    } catch (error) {
      return logger.error({ localError: 'writeData', error });
    }
  };

  const readData = async (key: string): Promise<any> => {
    try {
      return await cache.hGet(instanceName, key);
    } catch (error) {
      logger.error({ localError: 'readData', error });
      return;
    }
  };

  const removeData = async (key: string) => {
    try {
      return await cache.hDelete(instanceName, key);
    } catch (error) {
      logger.error({ readData: 'removeData', error });
    }
  };

  const creds: AuthenticationCreds = (await readData('creds')) || initAuthCreds();

  return {
    state: {
      creds,
      keys: {
        get: async (type, ids: string[]) => {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          const data: { [_: string]: SignalDataTypeMap[type] } = {};
          await Promise.all(
            ids.map(async (id) => {
              let value = await readData(`${type}-${id}`);
              if (type === 'app-state-sync-key' && value) {
                value = proto.Message.AppStateSyncKeyData.fromObject(value);
              }

              data[id] = value;
            }),
          );

          return data;
        },
        set: async (data: any) => {
          const tasks: Promise<void>[] = [];
          for (const category in data) {
            for (const id in data[category]) {
              const value = data[category][id];
              const key = `${category}-${id}`;
              tasks.push(value ? await writeData(value, key) : await removeData(key));
            }
          }

          await Promise.all(tasks);
        },
      },
    },
    saveCreds: async () => {
      return await writeData(creds, 'creds');
    },
  };
}



================================================
FILE: src/utils/translations/en.json
================================================
{
  "qrgeneratedsuccesfully": "QRCode successfully generated!",
  "scanqr": "Scan this QR code within the next 40 seconds.",
  "qrlimitreached": "QRCode generation limit reached, to generate a new QRCode, send the 'init' message again.",
  "cw.inbox.connected": "🚀 Connection successfully established!",
  "cw.inbox.disconnect": "🚨 Disconnecting WhatsApp from inbox *{{inboxName}}*.",
  "cw.inbox.alreadyConnected": "🚨 {{inboxName}} instance is connected.",
  "cw.inbox.clearCache": "✅ {{inboxName}} instance cache cleared.",
  "cw.inbox.notFound": "⚠️ {{inboxName}} instance not found.",
  "cw.inbox.status": "⚠️ {{inboxName}} instance status: *{{state}}*.",
  "cw.import.startImport": "💬 Starting to import messages. Please wait...",
  "cw.import.importingMessages": "💬 Importing messages. More one moment...",
  "cw.import.messagesImported": "💬 {{totalMessagesImported}} messages imported. Refresh page to see the new messages.",
  "cw.import.messagesException": "💬 Something went wrong in importing messages.",
  "cw.locationMessage.location": "Location",
  "cw.locationMessage.latitude": "Latitude",
  "cw.locationMessage.longitude": "Longitude",
  "cw.locationMessage.locationName": "Name",
  "cw.locationMessage.locationAddress": "Address",
  "cw.locationMessage.locationUrl": "URL",
  "cw.contactMessage.contact": "Contact",
  "cw.contactMessage.name": "Name",
  "cw.contactMessage.number": "Number",
  "cw.message.notsent": "🚨 The message could not be sent. Please check your connection. {{error}}",
  "cw.message.numbernotinwhatsapp": "🚨 The message was not sent as the contact is not a valid Whatsapp number.",
  "cw.message.edited": "Edited Message"
}


================================================
FILE: src/utils/translations/es.json
================================================
{
  "qrgeneratedsuccesfully": "Código QR generado exitosamente!",
  "scanqr": "Escanea este código QR en los próximos 40 segundos.",
  "qrlimitreached": "🚨 Se alcanzó el límite de generación de QRCode. Para generar un nuevo QRCode, envíe el mensaje 'init' nuevamente.",
  "cw.inbox.connected": "🚀 ¡Conexión establecida exitosamente!",
  "cw.inbox.disconnect": "🚨 Instancia *{{inboxName}}* desconectado de Whatsapp.",
  "cw.inbox.alreadyConnected": "🚨 La instancia {{inboxName}} está conectada.",
  "cw.inbox.clearCache": "✅ Caché de la instancia {{inboxName}} borrada.",
  "cw.inbox.notFound": "⚠️ Instancia {{inboxName}} no encontrada.",
  "cw.inbox.status": "⚠️ Estado de la instancia {{inboxName}}: *{{state}}*.",
  "cw.import.startImport": "💬 Empezando a importar mensajes. Espere por favor...",
  "cw.import.importingMessages": "💬 Importando mensajes. mas un momento...",
  "cw.import.messagesImported": "💬 {{totalMessagesImported}} mensajes importados. Actualiza la página para ver los nuevos mensajes..",
  "cw.import.messagesException": "⚠️ Algo salió mal al importar mensajes..",
  "cw.locationMessage.location": "Ubicación",
  "cw.locationMessage.latitude": "Latitude",
  "cw.locationMessage.longitude": "Longitude",
  "cw.locationMessage.locationName": "Nombre",
  "cw.locationMessage.locationAddress": "Direccion",
  "cw.locationMessage.locationUrl": "URL",
  "cw.contactMessage.contact": "Contacto",
  "cw.contactMessage.name": "Nombre",
  "cw.contactMessage.number": "Numero",
  "cw.message.notsent": "🚨 El mensaje no se pudo enviar. Comprueba tu conexión. {{error}}",
  "cw.message.numbernotinwhatsapp": "🚨 El mensaje no fue enviado porque el contacto no es un número de Whatsapp válido.",
  "cw.message.edited": "Mensaje editado"
}


================================================
FILE: src/utils/translations/pt-BR.json
================================================
{
  "qrgeneratedsuccesfully": "QRCode gerado com sucesso!",
  "scanqr": "Escaneie o QRCode com o WhatsApp nos próximos 40 segundos.",
  "qrlimitreached": "Limite de geração de QRCode atingido! Para gerar um novo QRCode, envie o texto 'init' nesta conversa.",
  "cw.inbox.connected": "🚀 Conectado com sucesso!",
  "cw.inbox.disconnect": "🚨 Instância *{{inboxName}}* desconectada do WhatsApp.",
  "cw.inbox.alreadyConnected": "🚨 Instância *{{inboxName}}* já está conectada.",
  "cw.inbox.clearCache": "✅ Instância *{{inboxName}}* cache removido.",
  "cw.inbox.notFound": "⚠️ Instância *{{inboxName}}* não encontrada.",
  "cw.inbox.status": "⚠️ Status da instância {{inboxName}}: *{{state}}*.",
  "cw.import.startImport": "💬 Iniciando importação de mensagens. Por favor, aguarde...",
  "cw.import.importingMessages": "💬 Importando mensagens. Mais um momento...",
  "cw.import.messagesImported": "💬 {{totalMessagesImported}} mensagens importadas. Atualize a página para ver as novas mensagens.",
  "cw.import.messagesException": "💬 Não foi possível importar as mensagens.",
  "cw.locationMessage.location": "Localização",
  "cw.locationMessage.latitude": "Latitude",
  "cw.locationMessage.longitude": "Longitude",
  "cw.locationMessage.locationName": "Nome",
  "cw.locationMessage.locationAddress": "Endereço",
  "cw.locationMessage.locationUrl": "URL",
  "cw.contactMessage.contact": "Contato",
  "cw.contactMessage.name": "Nome",
  "cw.contactMessage.number": "Número",
  "cw.message.notsent": "🚨 Não foi possível enviar a mensagem. Verifique sua conexão. {{error}}",
  "cw.message.numbernotinwhatsapp": "🚨 A mensagem não foi enviada, pois o contato não é um número válido do WhatsApp.",
  "cw.message.edited": "Mensagem editada"
}


================================================
FILE: src/validate/chat.schema.ts
================================================
import { JSONSchema7, JSONSchema7Definition } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

const numberDefinition: JSONSchema7Definition = {
  type: 'string',
  description: 'Invalid format',
};

export const whatsappNumberSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    numbers: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        description: '"numbers" must be an array of numeric strings',
      },
    },
  },
};

export const readMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    readMessages: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        properties: {
          id: { type: 'string' },
          fromMe: { type: 'boolean', enum: [true, false] },
          remoteJid: { type: 'string' },
        },
        required: ['id', 'fromMe', 'remoteJid'],
        ...isNotEmpty('id', 'remoteJid'),
      },
    },
  },
  required: ['readMessages'],
};

export const archiveChatSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    chat: { type: 'string' },
    lastMessage: {
      type: 'object',
      properties: {
        key: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            remoteJid: { type: 'string' },
            fromMe: { type: 'boolean', enum: [true, false] },
          },
          required: ['id', 'fromMe', 'remoteJid'],
          ...isNotEmpty('id', 'remoteJid'),
        },
        messageTimestamp: { type: 'integer', minLength: 1 },
      },
      required: ['key'],
      ...isNotEmpty('messageTimestamp'),
    },
    archive: { type: 'boolean', enum: [true, false] },
  },
  required: ['archive'],
};

export const markChatUnreadSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    chat: { type: 'string' },
    lastMessage: {
      type: 'object',
      properties: {
        key: {
          type: 'object',
          properties: {
            id: { type: 'string' },
            remoteJid: { type: 'string' },
            fromMe: { type: 'boolean', enum: [true, false] },
          },
          required: ['id', 'fromMe', 'remoteJid'],
          ...isNotEmpty('id', 'remoteJid'),
        },
        messageTimestamp: { type: 'integer', minLength: 1 },
      },
      required: ['key'],
      ...isNotEmpty('messageTimestamp'),
    },
  },
  required: ['lastMessage'],
};

export const deleteMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    id: { type: 'string' },
    fromMe: { type: 'boolean', enum: [true, false] },
    remoteJid: { type: 'string' },
    participant: { type: 'string' },
  },
  required: ['id', 'fromMe', 'remoteJid'],
  ...isNotEmpty('id', 'remoteJid', 'participant'),
};

export const profilePictureSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { type: 'string' },
    picture: { type: 'string' },
  },
};

export const updateMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { type: 'string' },
    text: { type: 'string' },
    key: {
      type: 'object',
      properties: {
        id: { type: 'string' },
        remoteJid: { type: 'string' },
        fromMe: { type: 'boolean', enum: [true, false] },
      },
      required: ['id', 'fromMe', 'remoteJid'],
      ...isNotEmpty('id', 'remoteJid'),
    },
  },
  ...isNotEmpty('number', 'text', 'key'),
};

export const presenceSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    delay: { type: 'number' },
    presence: {
      type: 'string',
      enum: ['unavailable', 'available', 'composing', 'recording', 'paused'],
    },
  },
  required: ['number', 'presence', 'delay'],
};

export const blockUserSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { type: 'string' },
    status: { type: 'string', enum: ['block', 'unblock'] },
  },
  required: ['number', 'status'],
  ...isNotEmpty('number', 'status'),
};

export const contactValidateSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    where: {
      type: 'object',
      properties: {
        _id: { type: 'string', minLength: 1 },
        pushName: { type: 'string', minLength: 1 },
        id: { type: 'string', minLength: 1 },
      },
      ...isNotEmpty('_id', 'id', 'pushName'),
    },
  },
};

export const messageValidateSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    where: {
      type: 'object',
      properties: {
        _id: { type: 'string', minLength: 1 },
        key: {
          type: 'object',
          if: {
            propertyNames: {
              enum: ['fromMe', 'remoteJid', 'id'],
            },
          },
          then: {
            properties: {
              remoteJid: {
                type: 'string',
                minLength: 1,
                description: 'The property cannot be empty',
              },
              id: {
                type: 'string',
                minLength: 1,
                description: 'The property cannot be empty',
              },
              fromMe: { type: 'boolean', enum: [true, false] },
            },
          },
        },
        message: { type: 'object' },
      },
      ...isNotEmpty('_id'),
    },
    limit: { type: 'integer' },
  },
};

export const messageUpSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    where: {
      type: 'object',
      properties: {
        _id: { type: 'string' },
        remoteJid: { type: 'string' },
        id: { type: 'string' },
        fromMe: { type: 'boolean', enum: [true, false] },
        participant: { type: 'string' },
        status: {
          type: 'string',
          enum: ['ERROR', 'PENDING', 'SERVER_ACK', 'DELIVERY_ACK', 'READ', 'PLAYED'],
        },
      },
      ...isNotEmpty('_id', 'remoteJid', 'id', 'status'),
    },
    limit: { type: 'integer' },
  },
};

export const privacySettingsSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    readreceipts: { type: 'string', enum: ['all', 'none'] },
    profile: {
      type: 'string',
      enum: ['all', 'contacts', 'contact_blacklist', 'none'],
    },
    status: {
      type: 'string',
      enum: ['all', 'contacts', 'contact_blacklist', 'none'],
    },
    online: { type: 'string', enum: ['all', 'match_last_seen'] },
    last: { type: 'string', enum: ['all', 'contacts', 'contact_blacklist', 'none'] },
    groupadd: {
      type: 'string',
      enum: ['all', 'contacts', 'contact_blacklist', 'none'],
    },
  },
  required: ['readreceipts', 'profile', 'status', 'online', 'last', 'groupadd'],
  ...isNotEmpty('readreceipts', 'profile', 'status', 'online', 'last', 'groupadd'),
};

export const profileNameSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    name: { type: 'string' },
  },
  ...isNotEmpty('name'),
};

export const profileStatusSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    status: { type: 'string' },
  },
  ...isNotEmpty('status'),
};

export const profileSchema: JSONSchema7 = {
  type: 'object',
  properties: {
    wuid: { type: 'string' },
    name: { type: 'string' },
    picture: { type: 'string' },
    status: { type: 'string' },
    isBusiness: { type: 'boolean' },
  },
};



================================================
FILE: src/validate/group.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const createGroupSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    subject: { type: 'string' },
    description: { type: 'string' },
    profilePicture: { type: 'string' },
    promoteParticipants: { type: 'boolean', enum: [true, false] },
    participants: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        minLength: 10,
        pattern: '\\d+',
        description: '"participants" must be an array of numeric strings',
      },
    },
  },
  required: ['subject', 'participants'],
  ...isNotEmpty('subject', 'description', 'profilePicture'),
};

export const groupJidSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    groupJid: { type: 'string', pattern: '^[\\d-]+@g.us$' },
  },
  required: ['groupJid'],
  ...isNotEmpty('groupJid'),
};

export const getParticipantsSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    getParticipants: { type: 'string', enum: ['true', 'false'] },
  },
  required: ['getParticipants'],
  ...isNotEmpty('getParticipants'),
};

export const groupSendInviteSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    groupJid: { type: 'string' },
    description: { type: 'string' },
    numbers: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        minLength: 10,
        pattern: '\\d+',
        description: '"numbers" must be an array of numeric strings',
      },
    },
  },
  required: ['groupJid', 'description', 'numbers'],
  ...isNotEmpty('groupJid', 'description', 'numbers'),
};

export const groupInviteSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    inviteCode: { type: 'string', pattern: '^[a-zA-Z0-9]{22}$' },
  },
  required: ['inviteCode'],
  ...isNotEmpty('inviteCode'),
};

export const AcceptGroupInviteSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    inviteCode: { type: 'string', pattern: '^[a-zA-Z0-9]{22}$' },
  },
  required: ['inviteCode'],
  ...isNotEmpty('inviteCode'),
};

export const updateParticipantsSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    groupJid: { type: 'string' },
    action: {
      type: 'string',
      enum: ['add', 'remove', 'promote', 'demote'],
    },
    participants: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        minLength: 10,
        pattern: '\\d+',
        description: '"participants" must be an array of numeric strings',
      },
    },
  },
  required: ['groupJid', 'action', 'participants'],
  ...isNotEmpty('groupJid', 'action'),
};

export const updateSettingsSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    groupJid: { type: 'string' },
    action: {
      type: 'string',
      enum: ['announcement', 'not_announcement', 'locked', 'unlocked'],
    },
  },
  required: ['groupJid', 'action'],
  ...isNotEmpty('groupJid', 'action'),
};

export const toggleEphemeralSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    groupJid: { type: 'string' },
    expiration: {
      type: 'number',
      enum: [0, 86400, 604800, 7776000],
    },
  },
  required: ['groupJid', 'expiration'],
  ...isNotEmpty('groupJid', 'expiration'),
};

export const updateGroupPictureSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    groupJid: { type: 'string' },
    image: { type: 'string' },
  },
  required: ['groupJid', 'image'],
  ...isNotEmpty('groupJid', 'image'),
};

export const updateGroupSubjectSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    groupJid: { type: 'string' },
    subject: { type: 'string' },
  },
  required: ['groupJid', 'subject'],
  ...isNotEmpty('groupJid', 'subject'),
};

export const updateGroupDescriptionSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    groupJid: { type: 'string' },
    description: { type: 'string' },
  },
  required: ['groupJid', 'description'],
  ...isNotEmpty('groupJid', 'description'),
};



================================================
FILE: src/validate/instance.schema.ts
================================================
import { Integration } from '@api/types/wa.types';
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const instanceSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    // Instance
    instanceName: { type: 'string' },
    token: { type: 'string' },
    number: { type: 'string', pattern: '^\\d+[\\.@\\w-]+' },
    businessId: { type: 'string' },
    qrcode: { type: 'boolean' },
    Integration: {
      type: 'string',
      enum: Object.values(Integration),
    },
    // Settings
    rejectCall: { type: 'boolean' },
    msgCall: { type: 'string' },
    groupsIgnore: { type: 'boolean' },
    alwaysOnline: { type: 'boolean' },
    readMessages: { type: 'boolean' },
    readStatus: { type: 'boolean' },
    syncFullHistory: { type: 'boolean' },
    wavoipToken: { type: 'string' },
    // Proxy
    proxyHost: { type: 'string' },
    proxyPort: { type: 'string' },
    proxyProtocol: { type: 'string' },
    proxyUsername: { type: 'string' },
    proxyPassword: { type: 'string' },
    // Webhook
    webhookUrl: { type: 'string' },
    webhookByEvents: { type: 'boolean' },
    webhookBase64: { type: 'boolean' },
    webhookEvents: {
      type: 'array',
      minItems: 0,
      items: {
        type: 'string',
        enum: [
          'APPLICATION_STARTUP',
          'QRCODE_UPDATED',
          'MESSAGES_SET',
          'MESSAGES_UPSERT',
          'MESSAGES_EDITED',
          'MESSAGES_UPDATE',
          'MESSAGES_DELETE',
          'SEND_MESSAGE',
          'CONTACTS_SET',
          'CONTACTS_UPSERT',
          'CONTACTS_UPDATE',
          'PRESENCE_UPDATE',
          'CHATS_SET',
          'CHATS_UPSERT',
          'CHATS_UPDATE',
          'CHATS_DELETE',
          'GROUPS_UPSERT',
          'GROUP_UPDATE',
          'GROUP_PARTICIPANTS_UPDATE',
          'CONNECTION_UPDATE',
          'LABELS_EDIT',
          'LABELS_ASSOCIATION',
          'CALL',
          'TYPEBOT_START',
          'TYPEBOT_CHANGE_STATUS',
        ],
      },
    },
    // RabbitMQ
    rabbitmqEnabled: { type: 'boolean' },
    rabbitmqEvents: {
      type: 'array',
      minItems: 0,
      items: {
        type: 'string',
        enum: [
          'APPLICATION_STARTUP',
          'QRCODE_UPDATED',
          'MESSAGES_SET',
          'MESSAGES_UPSERT',
          'MESSAGES_EDITED',
          'MESSAGES_UPDATE',
          'MESSAGES_DELETE',
          'SEND_MESSAGE',
          'CONTACTS_SET',
          'CONTACTS_UPSERT',
          'CONTACTS_UPDATE',
          'PRESENCE_UPDATE',
          'CHATS_SET',
          'CHATS_UPSERT',
          'CHATS_UPDATE',
          'CHATS_DELETE',
          'GROUPS_UPSERT',
          'GROUP_UPDATE',
          'GROUP_PARTICIPANTS_UPDATE',
          'CONNECTION_UPDATE',
          'LABELS_EDIT',
          'LABELS_ASSOCIATION',
          'CALL',
          'TYPEBOT_START',
          'TYPEBOT_CHANGE_STATUS',
        ],
      },
    },
    // SQS
    sqsEnabled: { type: 'boolean' },
    sqsEvents: {
      type: 'array',
      minItems: 0,
      items: {
        type: 'string',
        enum: [
          'APPLICATION_STARTUP',
          'QRCODE_UPDATED',
          'MESSAGES_SET',
          'MESSAGES_UPSERT',
          'MESSAGES_EDITED',
          'MESSAGES_UPDATE',
          'MESSAGES_DELETE',
          'SEND_MESSAGE',
          'CONTACTS_SET',
          'CONTACTS_UPSERT',
          'CONTACTS_UPDATE',
          'PRESENCE_UPDATE',
          'CHATS_SET',
          'CHATS_UPSERT',
          'CHATS_UPDATE',
          'CHATS_DELETE',
          'GROUPS_UPSERT',
          'GROUP_UPDATE',
          'GROUP_PARTICIPANTS_UPDATE',
          'CONNECTION_UPDATE',
          'LABELS_EDIT',
          'LABELS_ASSOCIATION',
          'CALL',
          'TYPEBOT_START',
          'TYPEBOT_CHANGE_STATUS',
        ],
      },
    },
    // Chatwoot
    chatwootAccountId: { type: 'string' },
    chatwootToken: { type: 'string' },
    chatwootUrl: { type: 'string' },
    chatwootSignMsg: { type: 'boolean' },
    chatwootReopenConversation: { type: 'boolean' },
    chatwootConversationPending: { type: 'boolean' },
    chatwootImportContacts: { type: 'boolean' },
    chatwootNameInbox: { type: 'string' },
    chatwootMergeBrazilContacts: { type: 'boolean' },
    chatwootImportMessages: { type: 'boolean' },
    chatwootDaysLimitImportMessages: { type: 'number' },
  },
  ...isNotEmpty('instanceName'),
};

export const presenceOnlySchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    presence: {
      type: 'string',
      enum: ['unavailable', 'available', 'composing', 'recording', 'paused'],
    },
  },
  required: ['presence'],
};



================================================
FILE: src/validate/label.schema.ts
================================================
import { JSONSchema7, JSONSchema7Definition } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

const numberDefinition: JSONSchema7Definition = {
  type: 'string',
  description: 'Invalid format',
};

export const handleLabelSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    labelId: { type: 'string' },
    action: { type: 'string', enum: ['add', 'remove'] },
  },
  required: ['number', 'labelId', 'action'],
  ...isNotEmpty('number', 'labelId', 'action'),
};



================================================
FILE: src/validate/message.schema.ts
================================================
import { JSONSchema7, JSONSchema7Definition } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

const numberDefinition: JSONSchema7Definition = {
  type: 'string',
  description: 'Invalid format',
};

export const templateMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    name: { type: 'string' },
    language: { type: 'string' },
    components: { type: 'array' },
    webhookUrl: { type: 'string' },
  },
  required: ['name', 'language'],
};

const quotedOptionsSchema: JSONSchema7 = {
  properties: {
    key: {
      type: 'object',
      properties: {
        id: { type: 'string' },
        remoteJid: { type: 'string' },
        fromMe: { type: 'boolean', enum: [true, false] },
      },
      required: ['id'],
      ...isNotEmpty('id'),
    },
    message: { type: 'object' },
  },
};

export const offerCallSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    isVideo: { type: 'boolean', enum: [true, false] },
    callDuration: { type: 'integer', minimum: 1, maximum: 15 },
  },
  required: ['number', 'callDuration'],
};

export const textMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    text: { type: 'string' },
    linkPreview: { type: 'boolean' },
    delay: {
      type: 'integer',
      description: 'Enter a value in milliseconds',
    },
    quoted: { ...quotedOptionsSchema },
    everyOne: { type: 'boolean', enum: [true, false] },
    mentioned: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"mentioned" must be an array of numeric strings',
      },
    },
  },
  required: ['number', 'text'],
};

export const mediaMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    mediatype: { type: 'string', enum: ['image', 'document', 'video', 'audio'] },
    mimetype: { type: 'string' },
    media: { type: 'string' },
    fileName: { type: 'string' },
    caption: { type: 'string' },
    delay: {
      type: 'integer',
      description: 'Enter a value in milliseconds',
    },
    quoted: { ...quotedOptionsSchema },
    everyOne: { type: 'boolean', enum: [true, false] },
    mentioned: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"mentioned" must be an array of numeric strings',
      },
    },
  },
  required: ['number', 'mediatype'],
};

export const ptvMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    video: { type: 'string' },
    delay: {
      type: 'integer',
      description: 'Enter a value in milliseconds',
    },
    quoted: { ...quotedOptionsSchema },
    everyOne: { type: 'boolean', enum: [true, false] },
    mentioned: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"mentioned" must be an array of numeric strings',
      },
    },
  },
  required: ['number'],
};

export const audioMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    audio: { type: 'string' },
    delay: {
      type: 'integer',
      description: 'Enter a value in milliseconds',
    },
    quoted: { ...quotedOptionsSchema },
    everyOne: { type: 'boolean', enum: [true, false] },
    mentioned: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"mentioned" must be an array of numeric strings',
      },
    },
  },
  required: ['number'],
};

export const statusMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    type: { type: 'string', enum: ['text', 'image', 'audio', 'video'] },
    content: { type: 'string' },
    caption: { type: 'string' },
    backgroundColor: { type: 'string' },
    font: { type: 'integer', minimum: 0, maximum: 5 },
    statusJidList: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"statusJidList" must be an array of numeric strings',
      },
    },
    allContacts: { type: 'boolean', enum: [true, false] },
  },
  required: ['type'],
};

export const stickerMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    sticker: { type: 'string' },
    delay: {
      type: 'integer',
      description: 'Enter a value in milliseconds',
    },
    quoted: { ...quotedOptionsSchema },
    everyOne: { type: 'boolean', enum: [true, false] },
    mentioned: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"mentioned" must be an array of numeric strings',
      },
    },
  },
  required: ['number'],
};

export const locationMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    latitude: { type: 'number' },
    longitude: { type: 'number' },
    name: { type: 'string' },
    address: { type: 'string' },
    delay: {
      type: 'integer',
      description: 'Enter a value in milliseconds',
    },
    quoted: { ...quotedOptionsSchema },
    everyOne: { type: 'boolean', enum: [true, false] },
    mentioned: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"mentioned" must be an array of numeric strings',
      },
    },
  },
  required: ['number', 'latitude', 'longitude', 'name', 'address'],
};

export const contactMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    contact: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          fullName: { type: 'string' },
          wuid: {
            type: 'string',
            minLength: 10,
            pattern: '\\d+',
            description: '"wuid" must be a numeric string',
          },
          phoneNumber: { type: 'string', minLength: 10 },
          organization: { type: 'string' },
          email: { type: 'string' },
          url: { type: 'string' },
        },
        required: ['fullName', 'phoneNumber'],
        ...isNotEmpty('fullName'),
      },
      minItems: 1,
      uniqueItems: true,
    },
  },
  required: ['number', 'contact'],
};

export const reactionMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    key: {
      type: 'object',
      properties: {
        id: { type: 'string' },
        remoteJid: { type: 'string' },
        fromMe: { type: 'boolean', enum: [true, false] },
      },
      required: ['id', 'remoteJid', 'fromMe'],
      ...isNotEmpty('id', 'remoteJid'),
    },
    reaction: { type: 'string' },
  },
  required: ['key', 'reaction'],
};

export const pollMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    name: { type: 'string' },
    selectableCount: { type: 'integer', minimum: 0, maximum: 10 },
    values: {
      type: 'array',
      minItems: 2,
      maxItems: 10,
      uniqueItems: true,
      items: {
        type: 'string',
      },
    },
    delay: {
      type: 'integer',
      description: 'Enter a value in milliseconds',
    },
    quoted: { ...quotedOptionsSchema },
    everyOne: { type: 'boolean', enum: [true, false] },
    mentioned: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"mentioned" must be an array of numeric strings',
      },
    },
  },
  required: ['number', 'name', 'selectableCount', 'values'],
};

export const listMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    title: { type: 'string' },
    description: { type: 'string' },
    footerText: { type: 'string' },
    buttonText: { type: 'string' },
    sections: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'object',
        properties: {
          title: { type: 'string' },
          rows: {
            type: 'array',
            minItems: 1,
            uniqueItems: true,
            items: {
              type: 'object',
              properties: {
                title: { type: 'string' },
                description: { type: 'string' },
                rowId: { type: 'string' },
              },
              required: ['title', 'rowId'],
              ...isNotEmpty('title', 'description', 'rowId'),
            },
          },
        },
        required: ['title', 'rows'],
        ...isNotEmpty('title'),
      },
    },
    delay: {
      type: 'integer',
      description: 'Enter a value in milliseconds',
    },
    quoted: { ...quotedOptionsSchema },
    everyOne: { type: 'boolean', enum: [true, false] },
    mentioned: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"mentioned" must be an array of numeric strings',
      },
    },
  },
  required: ['number', 'title', 'footerText', 'buttonText', 'sections'],
};

export const buttonsMessageSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    number: { ...numberDefinition },
    thumbnailUrl: { type: 'string' },
    title: { type: 'string' },
    description: { type: 'string' },
    footer: { type: 'string' },
    buttons: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          type: {
            type: 'string',
            enum: ['reply', 'copy', 'url', 'call', 'pix'],
          },
          displayText: { type: 'string' },
          id: { type: 'string' },
          url: { type: 'string' },
          phoneNumber: { type: 'string' },
          currency: { type: 'string' },
          name: { type: 'string' },
          keyType: { type: 'string', enum: ['phone', 'email', 'cpf', 'cnpj', 'random'] },
          key: { type: 'string' },
        },
        required: ['type'],
        ...isNotEmpty('id', 'url', 'phoneNumber'),
      },
    },
    delay: {
      type: 'integer',
      description: 'Enter a value in milliseconds',
    },
    quoted: { ...quotedOptionsSchema },
    everyOne: { type: 'boolean', enum: [true, false] },
    mentioned: {
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        type: 'string',
        pattern: '^\\d+',
        description: '"mentioned" must be an array of numeric strings',
      },
    },
  },
  required: ['number'],
};



================================================
FILE: src/validate/proxy.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const proxySchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    enabled: { type: 'boolean', enum: [true, false] },
    host: { type: 'string' },
    port: { type: 'string' },
    protocol: { type: 'string' },
    username: { type: 'string' },
    password: { type: 'string' },
  },
  required: ['enabled', 'host', 'port', 'protocol'],
  ...isNotEmpty('enabled', 'host', 'port', 'protocol'),
};



================================================
FILE: src/validate/settings.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const settingsSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    rejectCall: { type: 'boolean' },
    msgCall: { type: 'string' },
    groupsIgnore: { type: 'boolean' },
    alwaysOnline: { type: 'boolean' },
    readMessages: { type: 'boolean' },
    readStatus: { type: 'boolean' },
    syncFullHistory: { type: 'boolean' },
    wavoipToken: { type: 'string' },
  },
  required: ['rejectCall', 'groupsIgnore', 'alwaysOnline', 'readMessages', 'readStatus', 'syncFullHistory'],
  ...isNotEmpty('rejectCall', 'groupsIgnore', 'alwaysOnline', 'readMessages', 'readStatus', 'syncFullHistory'),
};



================================================
FILE: src/validate/template.schema.ts
================================================
import { JSONSchema7 } from 'json-schema';
import { v4 } from 'uuid';

const isNotEmpty = (...propertyNames: string[]): JSONSchema7 => {
  const properties = {};
  propertyNames.forEach(
    (property) =>
      (properties[property] = {
        minLength: 1,
        description: `The "${property}" cannot be empty`,
      }),
  );
  return {
    if: {
      propertyNames: {
        enum: [...propertyNames],
      },
    },
    then: { properties },
  };
};

export const templateSchema: JSONSchema7 = {
  $id: v4(),
  type: 'object',
  properties: {
    name: { type: 'string' },
    category: { type: 'string', enum: ['AUTHENTICATION', 'MARKETING', 'UTILITY'] },
    allowCategoryChange: { type: 'boolean' },
    language: { type: 'string' },
    components: { type: 'array' },
    webhookUrl: { type: 'string' },
  },
  required: ['name', 'category', 'language', 'components'],
  ...isNotEmpty('name', 'category', 'language', 'components'),
};



================================================
FILE: src/validate/validate.schema.ts
================================================
// Integrations Schema
export * from './chat.schema';
export * from './group.schema';
export * from './instance.schema';
export * from './label.schema';
export * from './message.schema';
export * from './proxy.schema';
export * from './settings.schema';
export * from './template.schema';
export * from '@api/integrations/chatbot/chatbot.schema';
export * from '@api/integrations/event/event.schema';



================================================
FILE: .github/ISSUE_TEMPLATE/-en--bug-report.yaml
================================================
name: Bug Report
description: Create a report to help us improve.
labels:
  - bug
  - en
  # - help wanted
# Automatically assign the issue to:
# assignees: DavidsonGomes
body:
  - type: checkboxes
    id: terms
    attributes:
      label: Welcome!
      description: |
        The issue tracker is only for reporting bugs and feature requests.
        For user-related support questions, please visit:
          - [Discord](https://evolution-api.com/discord)
          - [WhatsApp Group](https://evolution-api.com/whatsapp)
          <br/>

        **DO NOT OPEN AN ISSUE FOR GENERAL SUPPORT QUESTIONS.**

      options:
        - label: Yes, I have searched for similar issues on [GitHub](https://github.com/EvolutionAPI/evolution-api/issues) and found none.
          required: true

  - type: textarea
    attributes:
      label: What did you do?
      description: |
        How to write a good bug report?

        - Respect the issue template as much as possible.
        - The title should be short and descriptive.
        - Explain the conditions that led you to report this issue: the context.
        - The context should lead to something, an idea or problem you are facing.
        - Be clear and concise.
        - Format your messages to help the reader focus on what matters and understand the structure of your message, use [Markdown syntax](https://help.github.com/articles/github-flavored-markdown)
      placeholder: Describe the problem you encountered in detail.
    validations:
      required: true

  - type: textarea
    attributes:
      label: What did you expect?
      placeholder: Describe what you expected to happen.
    validations:
      required: true

  - type: textarea
    attributes:
      label: What did you observe instead of what you expected?
      placeholder: Explain what actually happens when you follow the steps above.
    validations:
      required: true

  - type: textarea
    attributes:
      label: Screenshots/Videos
      placeholder: |
        If possible, add screenshots or videos that illustrate the problem. This can be extremely helpful in understanding the issue better.

  - type: textarea
    attributes:
      label: Which version of the API are you using?
      description: |
        Enter the version number found in the `version` property of the **package.json**.
      placeholder: Paste the version here.
    validations:
      required: true

  - type: dropdown
    id: select
    attributes:
      label: What is your environment?
      options:
        - Windows
        - Linux
        - Mac
        - Docker
        - Other
    validations:
      required: true
  
  - type: textarea
    attributes:
      label: Other environment specifications
      placeholder: 'Hardware/Software: [e.g., CPU, GPU]'
    validations:
      required: false

  - type: textarea
    attributes:
      label: If applicable, paste the log output
      description: |
        Please attach any logs that might be related to the issue.
        If the logs contain sensitive information, consider sending them privately to one of the project maintainers.
      placeholder: Paste the application log here.
    validations:
      required: false

  - type: textarea
    attributes:
      label: Additional Notes
      description: Include any other information you think might be useful to understand or resolve the bug.
    validations:
      required: false



================================================
FILE: .github/ISSUE_TEMPLATE/-en--feature-request.yaml
================================================
name: Feature Request
description: Suggest ideas for the project.
labels:
  - enhancement
  - en
# Automatically assign the issue to:
# assignees: DavidsonGomes
body:
  - type: checkboxes
    id: terms
    attributes:
      label: Welcome!
      description: '**DO NOT OPEN FOR GENERAL SUPPORT QUESTIONS.**'

      options:
        - label: Yes, I have searched for similar requests on [GitHub](https://github.com/code-chat-br/whatsapp-api/issues) and found none.
          required: true

  - type: dropdown
    attributes:
      label: What type of feature?
      description: |
        How to write a good feature request?

        - Respect the issue template as much as possible.
        - The title should be short and descriptive.
        - Explain the conditions that led you to suggest this feature: the context.
        - The context should lead to something, an idea or problem you are facing.
        - Be clear and concise.
        - Format your messages to help the reader focus on what matters and understand the structure of your message, use [Markdown syntax](https://help.github.com/articles/github-flavored-markdown)
      options:
        - Integration
        - Functionality
        - Endpoint
        - Database adjustment
        - Other
    validations:
      required: true

  - type: textarea
    attributes:
      label: What is the motivation for the request?
      description: |
        What problem does the feature seek to solve?
        Clearly and in detail describe the functionality you want to be implemented.
        Explain how it fits into the context of the project.
      placeholder: Detailed description
    validations:
      required: true
  
  - type: textarea
    attributes:
      label: Usage Examples
      description: |
        Provide specific examples of how this functionality could be used.
        This can include scenarios or use cases where the feature would be particularly beneficial.
      placeholder: text - image - video - flowcharts
    validations:
      required: false

  - type: textarea
    attributes:
      label: How should the feature be developed?
      description: |
        Should it be inserted directly into the code?
        Should it be built as a different application that acts as an extension of the API? 
        For example: a `worker`?
        
        Discuss how this new functionality could impact other parts of the project, if applicable.

        ---

        If you have ideas on how this functionality could be implemented, please share them here.
        This is not mandatory, but it can be helpful for the development team.

      placeholder: Insert feature ideas here
    validations:
      required: false

  - type: textarea
    attributes:
      label: Additional Notes
      description: Any other information you believe is relevant to your request.
      placeholder: Insert your observations here.
    validations:
      required: false



================================================
FILE: .github/ISSUE_TEMPLATE/-pt--reportar-bug.yaml
================================================
name: Relatório de bug
description: Crie um relatório para nos ajudar a melhorar.
labels:
  - bug
  - pt-br
  # - help wanted
# Atrubuir automaticamente a issue a:
# assignees: DavidsonGomes
body:
  - type: checkboxes
    id: termos
    attributes:
      label: Bem-vido!
      description: |
        O rastreador de problemas é apenas para relatar bugs e solicitações de recursos.
        Para perguntas de suporte relacionadas ao usuário final, acesse:
          - [Discord](https://evolution-api.com/discord)
          - [Grupo do WhatsApp](https://evolution-api.com/whatsapp)
          <br/>

        **NÃO ABRA UM PROBLEMA PARA PERGUNTAS GERAIS DE SUPORTE.**

      options:
        - label: Sim, pesquisei problemas semelhantes no [GitHub](https://github.com/EvolutionAPI/evolution-api/issues) e não encontrei nenhum.
          required: true

  - type: textarea
    attributes:
      label: O que você fez?
      description: |
        Como escrever um bom relatório de bug?

        - Respeite o modelo de problema tanto quanto possível.
        - O título deve ser curto e descritivo.
        - Explique as condições que o levaram a reportar este problema: o contexto.
        - O contexto deve levar a algo, ideia ou problema que você está enfrentando.
        - Seja claro e conciso.
        - Formate suas mensagens para ajudar o leitor a se concentrar no que importa e entender a estrutura da sua mensagem, use [sintaxe Markdown](https://help.github.com/articles/github-flavored-markdown)
      placeholder: Descreva detalhadamente o problema que você encontrou.
    validations:
      required: true

  - type: textarea
    attributes:
      label: O que você esperava?
      placeholder: Descreva o que você esperava que acontecesse.
    validations:
      required: true

  - type: textarea
    attributes:
      label: O que vc observou ao invés do que esperava?
      placeholder: Explique o que realmente acontece quando você segue os passos acima.
    validations:
      required: true

  - type: textarea
    attributes:
      label: Capturas de Tela/Vídeos
      placeholder: |
        Se possível, adicione capturas de tela ou vídeos que ilustrem o problema. Isso pode ser extremamente útil para entender melhor o problema.

  - type: textarea
    attributes:
      label: Qual versão da API você está usando?
      description: |
        Insira o número da sua versão que está na propriedade `version` do **package.json**.
      placeholder: Cole aqui a versão.
    validations:
      required: true

  - type: dropdown
    id: select
    attributes:
      label: Qual é o seu ambiente?
      options:
        - Windows
        - Linux
        - Mac
        - Docker
        - Outro
    validations:
      required: true
  
  - type: textarea
    attributes:
      label: Outras expecificações do ambiente
      placeholder: 'Hardware/Software: [ex: CPU, GPU]'
    validations:
      required: false

  - type: textarea
    attributes:
      label: Se aplicável, cole a saída do log
      description: |
        Por favor, anexe os logs que possam estar relacionados ao problema.
        Se os logs contiverem informações sensíveis, considere enviá-los de forma privada para um dos mantenedores do projeto.
      placeholder: Cole aqui o log da aplicação
    validations:
      required: false

  - type: textarea
    attributes:
      label: Notas Adicionais
      description: Inclua aqui qualquer outra informação que você ache que possa ser útil para entender ou resolver o bug.
    validations:
      required: false
    



================================================
FILE: .github/ISSUE_TEMPLATE/-pt--solicitar-recurso.yaml
================================================
name: Solicitação de recursos
description: Sugira ideias para o projeto.
labels:
  - enhancement
  - pt-br
# Automatically assign the issue to:
# assignees: DavidsonGomes
body:
  - type: checkboxes
    id: termos
    attributes:
      label: Bem-vindo!
      description: '**NÃO ABRA PARA PERGUNTAS GERAIS DE SUPORTE.**'

      options:
        - label: Sim, pesquisei solicitações semelhantes no [GitHub](https://github.com/code-chat-br/whatsapp-api/issues) e não encontrei nenhum.
          required: true

  - type: dropdown
    attributes:
      label: Qual tipo de recurso?
      description: |
        Como escrever uma boa solicitação de bug?

        - Respeite o modelo de problema tanto quanto possível.
        - O título deve ser curto e descritivo.
        - Explique as condições que o levaram a reportar este problema: o contexto.
        - O contexto deve levar a algo, ideia ou problema que você está enfrentando.
        - Seja claro e conciso.
        - Formate suas mensagens para ajudar o leitor a se concentrar no que importa e entender a estrutura da sua mensagem, use [sintaxe Markdown](https://help.github.com/articles/github-flavored-markdown)
      options:
        - Integração
        - Funcionalidade
        - Endpoint
        - Ajuste de banco de dados
        - Outro
    validations:
      required: true

  - type: textarea
    attributes:
      label: Qual a motivação para a solicitação?
      description: |
        Qual problema o recurso busca resolver?
        Descreva claramente e em detalhes a funcionalidade que você deseja que seja implementada.
        Explique como isso se encaixa no contexto do projeto.
      placeholder: Descrição detalhada
    validations:
      required: true
  
  - type: textarea
    attributes:
      label: Exemplos de Uso
      description: |
        Forneça exemplos específicos de como essa funcionalidade poderia ser utilizada.
        Isso pode incluir cenários ou casos de uso onde a funcionalidade seria particularmente benéfica.
      placeholder: texto - imagem - video - fluxogramas
    validations:
      required: false

  - type: textarea
    attributes:
      label: Como o recurso deve ser desenvolvido?
      description: |
        Deve ser inserido diretamente no código?
        Deve ser construído uma aplicação diferente que atuará como uma extenção da api? 
        Por exemplo: um `worker`?
        
        Discuta como essa nova funcionalidade poderia impactar outras partes do projeto, se aplicável.

        ---

        Se você tem ideias sobre como essa funcionalidade pode ser implementada, por favor, compartilhe-as aqui.
        Isso não é obrigatório, mas pode ser útil para a equipe de desenvolvimento.

      placeholder: Insira ideias para o recurso
    validations:
      required: false

  - type: textarea
    attributes:
      label: Notas Adicionais
      description: Qualquer outra informação que você acredita ser relevante para a sua solicitação.
      placeholder: Insira aqui as sua observções.
    validations:
      required: false



================================================
FILE: .github/workflows/check_code_quality.yml
================================================
name: Check Code Quality

on: [pull_request]

jobs:
  check-lint-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
    - uses: actions/checkout@v2

    - name: Install Node
      uses: actions/setup-node@v1
      with:
        node-version: 20.x

    - name: Install packages
      run: npm install
    
    - name: Check linting
      run: npm run lint:check

    - name: Check build
      run: npm run db:generate

    - name: Check build
      run: npm run build


================================================
FILE: .github/workflows/publish_docker_image.yml
================================================
name: Build Docker image

on:
  push:
    tags:
      - "*.*.*"

jobs:
  build_deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: atendai/evolution-api
          tags: type=semver,pattern=v{{version}}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Image digest
        run: echo ${{ steps.docker_build.outputs.digest }}


================================================
FILE: .github/workflows/publish_docker_image_homolog.yml
================================================
name: Build Docker image

on:
  push:
    branches:
      - develop

jobs:
  build_deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: atendai/evolution-api
          tags: homolog

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Image digest
        run: echo ${{ steps.docker_build.outputs.digest }}



================================================
FILE: .github/workflows/publish_docker_image_latest.yml
================================================
name: Build Docker image

on:
  push:
    branches:
      - main

jobs:
  build_deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: atendai/evolution-api
          tags: latest

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        id: docker_build
        uses: docker/build-push-action@v5
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Image digest
        run: echo ${{ steps.docker_build.outputs.digest }}


